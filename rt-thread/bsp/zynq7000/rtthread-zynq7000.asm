
rtthread-zynq7000.elf:     file format elf32-littlearm


Disassembly of section .text:

10000000 <__text_start>:
.section .vectors, "ax"
.code 32

.globl system_vectors
system_vectors:
    ldr pc, _vector_reset
10000000:	e59ff018 	ldr	pc, [pc, #24]	; 10000020 <_vector_reset>
    ldr pc, _vector_undef
10000004:	e59ff018 	ldr	pc, [pc, #24]	; 10000024 <_vector_undef>
    ldr pc, _vector_swi
10000008:	e59ff018 	ldr	pc, [pc, #24]	; 10000028 <_vector_swi>
    ldr pc, _vector_pabt
1000000c:	e59ff018 	ldr	pc, [pc, #24]	; 1000002c <_vector_pabt>
    ldr pc, _vector_dabt
10000010:	e59ff018 	ldr	pc, [pc, #24]	; 10000030 <_vector_dabt>
    ldr pc, _vector_resv
10000014:	e59ff018 	ldr	pc, [pc, #24]	; 10000034 <_vector_resv>
    ldr pc, _vector_irq
10000018:	e59ff018 	ldr	pc, [pc, #24]	; 10000038 <_vector_irq>
    ldr pc, _vector_fiq
1000001c:	e59ff018 	ldr	pc, [pc, #24]	; 1000003c <_vector_fiq>

10000020 <_vector_reset>:
10000020:	1000b688 	.word	0x1000b688

10000024 <_vector_undef>:
10000024:	10000120 	.word	0x10000120

10000028 <_vector_swi>:
10000028:	100000e0 	.word	0x100000e0

1000002c <_vector_pabt>:
1000002c:	10000160 	.word	0x10000160

10000030 <_vector_dabt>:
10000030:	100001a0 	.word	0x100001a0

10000034 <_vector_resv>:
10000034:	100001e0 	.word	0x100001e0

10000038 <_vector_irq>:
10000038:	10000060 	.word	0x10000060

1000003c <_vector_fiq>:
1000003c:	10000040 	.word	0x10000040

10000040 <vector_fiq>:
.section .text.isr, "ax"
/* exception handlers: undef, swi, padt, dabt, resv, irq, fiq          */
    .align  5
.globl vector_fiq
vector_fiq:
    stmfd   sp!,{r0-r7,lr}
10000040:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    bl      rt_hw_trap_fiq
10000044:	eb002cf5 	bl	1000b420 <rt_hw_trap_fiq>
    ldmfd   sp!,{r0-r7,lr}
10000048:	e8bd40ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
    subs    pc,lr,#4
1000004c:	e25ef004 	subs	pc, lr, #4
10000050:	e320f000 	nop	{0}
10000054:	e320f000 	nop	{0}
10000058:	e320f000 	nop	{0}
1000005c:	e320f000 	nop	{0}

10000060 <vector_irq>:
.globl      rt_interrupt_to_thread

    .align  5
.globl vector_irq
vector_irq:
    stmfd   sp!, {r0-r12,lr}
10000060:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    bl      rt_interrupt_enter
10000064:	eb001231 	bl	10004930 <rt_interrupt_enter>
    bl      rt_hw_trap_irq
10000068:	eb002cc2 	bl	1000b378 <rt_hw_trap_irq>
    bl      rt_interrupt_leave
1000006c:	eb001241 	bl	10004978 <rt_interrupt_leave>

    @ if rt_thread_switch_interrupt_flag set, jump to
    @ rt_hw_context_switch_interrupt_do and don't return
    ldr     r0, =rt_thread_switch_interrupt_flag
10000070:	e59f0194 	ldr	r0, [pc, #404]	; 1000020c <vector_resv+0x2c>
    ldr     r1, [r0]
10000074:	e5901000 	ldr	r1, [r0]
    cmp     r1, #1
10000078:	e3510001 	cmp	r1, #1
    beq rt_hw_context_switch_interrupt_do
1000007c:	0a000001 	beq	10000088 <rt_hw_context_switch_interrupt_do>

    ldmfd   sp!, {r0-r12,lr}
10000080:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    subs    pc, lr, #4
10000084:	e25ef004 	subs	pc, lr, #4

10000088 <rt_hw_context_switch_interrupt_do>:

rt_hw_context_switch_interrupt_do:
    mov     r1,  #0         @ clear flag
10000088:	e3a01000 	mov	r1, #0
    str     r1,  [r0]
1000008c:	e5801000 	str	r1, [r0]

    mov     r1, sp          @ r1 point to {r0-r3} in stack
10000090:	e1a0100d 	mov	r1, sp
    add     sp, sp, #4*4
10000094:	e28dd010 	add	sp, sp, #16
    ldmfd   sp!, {r4-r12,lr}@ reload saved registers
10000098:	e8bd5ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    mrs     r0,  spsr       @ get cpsr of interrupt thread
1000009c:	e14f0000 	mrs	r0, SPSR
    sub     r2,  lr, #4     @ save old task's pc to r2
100000a0:	e24e2004 	sub	r2, lr, #4

    @ Switch to SVC mode with no interrupt.
    msr     cpsr_c, #I_Bit|F_Bit|Mode_SVC
100000a4:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

    stmfd   sp!, {r2}       @ push old task's pc
100000a8:	e92d0004 	stmfd	sp!, {r2}
    stmfd   sp!, {r4-r12,lr}@ push old task's lr,r12-r4
100000ac:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    ldmfd   r1,  {r1-r4}    @ restore r0-r3 of the interrupt thread
100000b0:	e891001e 	ldm	r1, {r1, r2, r3, r4}
    stmfd   sp!, {r1-r4}    @ push old task's r0-r3
100000b4:	e92d001e 	push	{r1, r2, r3, r4}
    stmfd   sp!, {r0}       @ push old task's cpsr
100000b8:	e92d0001 	stmfd	sp!, {r0}

    ldr     r4,  =rt_interrupt_from_thread
100000bc:	e59f414c 	ldr	r4, [pc, #332]	; 10000210 <vector_resv+0x30>
    ldr     r5,  [r4]
100000c0:	e5945000 	ldr	r5, [r4]
    str     sp,  [r5]       @ store sp in preempted tasks's TCB
100000c4:	e585d000 	str	sp, [r5]

    ldr     r6,  =rt_interrupt_to_thread
100000c8:	e59f6144 	ldr	r6, [pc, #324]	; 10000214 <vector_resv+0x34>
    ldr     r7,  [r6]
100000cc:	e5967000 	ldr	r7, [r6]
    ldr     sp,  [r7]       @ get new task's stack pointer
100000d0:	e597d000 	ldr	sp, [r7]

    ldmfd   sp!, {r4}       @ pop new task's cpsr to spsr
100000d4:	e8bd0010 	ldmfd	sp!, {r4}
    msr     spsr_cxsf, r4
100000d8:	e16ff004 	msr	SPSR_fsxc, r4

    ldmfd   sp!, {r0-r12,lr,pc}^ @ pop new task's r0-r12,lr & pc, copy spsr to cpsr
100000dc:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

100000e0 <vector_swi>:
.endm

    .align  5
    .globl	vector_swi
vector_swi:
    push_svc_reg
100000e0:	e24dd044 	sub	sp, sp, #68	; 0x44
100000e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
100000e8:	e1a0000d 	mov	r0, sp
100000ec:	e14f6000 	mrs	r6, SPSR
100000f0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
100000f4:	e5806040 	str	r6, [r0, #64]	; 0x40
100000f8:	f1020013 	cps	#19
100000fc:	e580d034 	str	sp, [r0, #52]	; 0x34
10000100:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_swi
10000104:	eb002c67 	bl	1000b2a8 <rt_hw_trap_swi>
    b       .
10000108:	eafffffe 	b	10000108 <vector_swi+0x28>
1000010c:	e320f000 	nop	{0}
10000110:	e320f000 	nop	{0}
10000114:	e320f000 	nop	{0}
10000118:	e320f000 	nop	{0}
1000011c:	e320f000 	nop	{0}

10000120 <vector_undef>:

    .align  5
    .globl	vector_undef
vector_undef:
    push_svc_reg
10000120:	e24dd044 	sub	sp, sp, #68	; 0x44
10000124:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
10000128:	e1a0000d 	mov	r0, sp
1000012c:	e14f6000 	mrs	r6, SPSR
10000130:	e580e03c 	str	lr, [r0, #60]	; 0x3c
10000134:	e5806040 	str	r6, [r0, #64]	; 0x40
10000138:	f1020013 	cps	#19
1000013c:	e580d034 	str	sp, [r0, #52]	; 0x34
10000140:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_undef
10000144:	eb002c4a 	bl	1000b274 <rt_hw_trap_undef>
    b       .
10000148:	eafffffe 	b	10000148 <vector_undef+0x28>
1000014c:	e320f000 	nop	{0}
10000150:	e320f000 	nop	{0}
10000154:	e320f000 	nop	{0}
10000158:	e320f000 	nop	{0}
1000015c:	e320f000 	nop	{0}

10000160 <vector_pabt>:

    .align  5
    .globl	vector_pabt
vector_pabt:
    push_svc_reg
10000160:	e24dd044 	sub	sp, sp, #68	; 0x44
10000164:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
10000168:	e1a0000d 	mov	r0, sp
1000016c:	e14f6000 	mrs	r6, SPSR
10000170:	e580e03c 	str	lr, [r0, #60]	; 0x3c
10000174:	e5806040 	str	r6, [r0, #64]	; 0x40
10000178:	f1020013 	cps	#19
1000017c:	e580d034 	str	sp, [r0, #52]	; 0x34
10000180:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_pabt
10000184:	eb002c54 	bl	1000b2dc <rt_hw_trap_pabt>
    b       .
10000188:	eafffffe 	b	10000188 <vector_pabt+0x28>
1000018c:	e320f000 	nop	{0}
10000190:	e320f000 	nop	{0}
10000194:	e320f000 	nop	{0}
10000198:	e320f000 	nop	{0}
1000019c:	e320f000 	nop	{0}

100001a0 <vector_dabt>:

    .align  5
    .globl	vector_dabt
vector_dabt:
    push_svc_reg
100001a0:	e24dd044 	sub	sp, sp, #68	; 0x44
100001a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
100001a8:	e1a0000d 	mov	r0, sp
100001ac:	e14f6000 	mrs	r6, SPSR
100001b0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
100001b4:	e5806040 	str	r6, [r0, #64]	; 0x40
100001b8:	f1020013 	cps	#19
100001bc:	e580d034 	str	sp, [r0, #52]	; 0x34
100001c0:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_dabt
100001c4:	eb002c51 	bl	1000b310 <rt_hw_trap_dabt>
    b       .
100001c8:	eafffffe 	b	100001c8 <vector_dabt+0x28>
100001cc:	e320f000 	nop	{0}
100001d0:	e320f000 	nop	{0}
100001d4:	e320f000 	nop	{0}
100001d8:	e320f000 	nop	{0}
100001dc:	e320f000 	nop	{0}

100001e0 <vector_resv>:

    .align  5
    .globl	vector_resv
vector_resv:
    push_svc_reg
100001e0:	e24dd044 	sub	sp, sp, #68	; 0x44
100001e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
100001e8:	e1a0000d 	mov	r0, sp
100001ec:	e14f6000 	mrs	r6, SPSR
100001f0:	e580e03c 	str	lr, [r0, #60]	; 0x3c
100001f4:	e5806040 	str	r6, [r0, #64]	; 0x40
100001f8:	f1020013 	cps	#19
100001fc:	e580d034 	str	sp, [r0, #52]	; 0x34
10000200:	e580e038 	str	lr, [r0, #56]	; 0x38
    bl      rt_hw_trap_resv
10000204:	eb002c4e 	bl	1000b344 <rt_hw_trap_resv>
    b       .
10000208:	eafffffe 	b	10000208 <vector_resv+0x28>
    bl      rt_hw_trap_irq
    bl      rt_interrupt_leave

    @ if rt_thread_switch_interrupt_flag set, jump to
    @ rt_hw_context_switch_interrupt_do and don't return
    ldr     r0, =rt_thread_switch_interrupt_flag
1000020c:	10029eb0 	.word	0x10029eb0
    stmfd   sp!, {r4-r12,lr}@ push old task's lr,r12-r4
    ldmfd   r1,  {r1-r4}    @ restore r0-r3 of the interrupt thread
    stmfd   sp!, {r1-r4}    @ push old task's r0-r3
    stmfd   sp!, {r0}       @ push old task's cpsr

    ldr     r4,  =rt_interrupt_from_thread
10000210:	10029eac 	.word	0x10029eac
    ldr     r5,  [r4]
    str     sp,  [r5]       @ store sp in preempted tasks's TCB

    ldr     r6,  =rt_interrupt_to_thread
10000214:	10029ea8 	.word	0x10029ea8

10000218 <rt_hw_timer_isr>:

#define PRIVATE_TIMER_BASE            0xF8F00600
#define PRIVATE_TIMER                ((ptimer_reg_t*)PRIVATE_TIMER_BASE)

static void rt_hw_timer_isr(int vector, void *param)
{
10000218:	e92d4800 	push	{fp, lr}
1000021c:	e28db004 	add	fp, sp, #4
10000220:	e24dd008 	sub	sp, sp, #8
10000224:	e50b0008 	str	r0, [fp, #-8]
10000228:	e50b100c 	str	r1, [fp, #-12]
    rt_tick_increase();
1000022c:	eb00028b 	bl	10000c60 <rt_tick_increase>
    /* clear interrupt */
    PRIVATE_TIMER->ISR = PRIVATE_TIMER_ISR_EVENT_FLAG_MASK;
10000230:	e3a03c06 	mov	r3, #1536	; 0x600
10000234:	e34f38f0 	movt	r3, #63728	; 0xf8f0
10000238:	e3a02001 	mov	r2, #1
1000023c:	e583200c 	str	r2, [r3, #12]
}
10000240:	e24bd004 	sub	sp, fp, #4
10000244:	e8bd8800 	pop	{fp, pc}

10000248 <rt_hw_timer_init>:

int rt_hw_timer_init(void)
{
10000248:	e92d4800 	push	{fp, lr}
1000024c:	e28db004 	add	fp, sp, #4
10000250:	e24dd008 	sub	sp, sp, #8
    PRIVATE_TIMER->CONTROL &= ~PRIVATE_TIMER_CONTROL_ENABLE_MASK;
10000254:	e3a03c06 	mov	r3, #1536	; 0x600
10000258:	e34f38f0 	movt	r3, #63728	; 0xf8f0
1000025c:	e3a02c06 	mov	r2, #1536	; 0x600
10000260:	e34f28f0 	movt	r2, #63728	; 0xf8f0
10000264:	e5922008 	ldr	r2, [r2, #8]
10000268:	e3c22001 	bic	r2, r2, #1
1000026c:	e5832008 	str	r2, [r3, #8]
    {
        /* Clear the prescaler. */
        rt_uint32_t ctrl = PRIVATE_TIMER->CONTROL;
10000270:	e3a03c06 	mov	r3, #1536	; 0x600
10000274:	e34f38f0 	movt	r3, #63728	; 0xf8f0
10000278:	e5933008 	ldr	r3, [r3, #8]
1000027c:	e50b3008 	str	r3, [fp, #-8]
        ctrl &= ~PRIVATE_TIMER_CONTROL_PRESCALER_MASK;
10000280:	e51b3008 	ldr	r3, [fp, #-8]
10000284:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
10000288:	e50b3008 	str	r3, [fp, #-8]
        PRIVATE_TIMER->CONTROL = ctrl;
1000028c:	e3a03c06 	mov	r3, #1536	; 0x600
10000290:	e34f38f0 	movt	r3, #63728	; 0xf8f0
10000294:	e51b2008 	ldr	r2, [fp, #-8]
10000298:	e5832008 	str	r2, [r3, #8]
    }
    /* The processor timer is always clocked at 1/2 CPU frequency(CPU_3x2x). */
    PRIVATE_TIMER->COUNTER = APU_FREQ/2/RT_TICK_PER_SECOND;
1000029c:	e3a03c06 	mov	r3, #1536	; 0x600
100002a0:	e34f38f0 	movt	r3, #63728	; 0xf8f0
100002a4:	e3012615 	movw	r2, #5653	; 0x1615
100002a8:	e3402005 	movt	r2, #5
100002ac:	e5832004 	str	r2, [r3, #4]
    /* Set reload value. */
    PRIVATE_TIMER->LOAD = APU_FREQ/2/RT_TICK_PER_SECOND;
100002b0:	e3a03c06 	mov	r3, #1536	; 0x600
100002b4:	e34f38f0 	movt	r3, #63728	; 0xf8f0
100002b8:	e3012615 	movw	r2, #5653	; 0x1615
100002bc:	e3402005 	movt	r2, #5
100002c0:	e5832000 	str	r2, [r3]
    PRIVATE_TIMER->CONTROL |= PRIVATE_TIMER_CONTROL_AUTO_RELOAD_MASK;
100002c4:	e3a03c06 	mov	r3, #1536	; 0x600
100002c8:	e34f38f0 	movt	r3, #63728	; 0xf8f0
100002cc:	e3a02c06 	mov	r2, #1536	; 0x600
100002d0:	e34f28f0 	movt	r2, #63728	; 0xf8f0
100002d4:	e5922008 	ldr	r2, [r2, #8]
100002d8:	e3822002 	orr	r2, r2, #2
100002dc:	e5832008 	str	r2, [r3, #8]

    PRIVATE_TIMER->CONTROL |= PRIVATE_TIMER_CONTROL_IRQ_ENABLE_MASK;
100002e0:	e3a03c06 	mov	r3, #1536	; 0x600
100002e4:	e34f38f0 	movt	r3, #63728	; 0xf8f0
100002e8:	e3a02c06 	mov	r2, #1536	; 0x600
100002ec:	e34f28f0 	movt	r2, #63728	; 0xf8f0
100002f0:	e5922008 	ldr	r2, [r2, #8]
100002f4:	e3822004 	orr	r2, r2, #4
100002f8:	e5832008 	str	r2, [r3, #8]
    PRIVATE_TIMER->ISR = PRIVATE_TIMER_ISR_EVENT_FLAG_MASK;
100002fc:	e3a03c06 	mov	r3, #1536	; 0x600
10000300:	e34f38f0 	movt	r3, #63728	; 0xf8f0
10000304:	e3a02001 	mov	r2, #1
10000308:	e583200c 	str	r2, [r3, #12]

    rt_hw_interrupt_install(IRQ_Zynq7000_PTIMER, rt_hw_timer_isr, RT_NULL, "tick");
1000030c:	e3a0001d 	mov	r0, #29
10000310:	e3001218 	movw	r1, #536	; 0x218
10000314:	e3411000 	movt	r1, #4096	; 0x1000
10000318:	e3a02000 	mov	r2, #0
1000031c:	e30e3148 	movw	r3, #57672	; 0xe148
10000320:	e3413001 	movt	r3, #4097	; 0x1001
10000324:	eb0029d9 	bl	1000aa90 <rt_hw_interrupt_install>
    rt_hw_interrupt_umask(IRQ_Zynq7000_PTIMER);
10000328:	e3a0001d 	mov	r0, #29
1000032c:	eb0029ce 	bl	1000aa6c <rt_hw_interrupt_umask>

    PRIVATE_TIMER->CONTROL |= PRIVATE_TIMER_CONTROL_ENABLE_MASK;
10000330:	e3a03c06 	mov	r3, #1536	; 0x600
10000334:	e34f38f0 	movt	r3, #63728	; 0xf8f0
10000338:	e3a02c06 	mov	r2, #1536	; 0x600
1000033c:	e34f28f0 	movt	r2, #63728	; 0xf8f0
10000340:	e5922008 	ldr	r2, [r2, #8]
10000344:	e3822001 	orr	r2, r2, #1
10000348:	e5832008 	str	r2, [r3, #8]

    return 0;
1000034c:	e3a03000 	mov	r3, #0
}
10000350:	e1a00003 	mov	r0, r3
10000354:	e24bd004 	sub	sp, fp, #4
10000358:	e8bd8800 	pop	{fp, pc}

1000035c <rt_hw_board_init>:
INIT_BOARD_EXPORT(rt_hw_timer_init);

void rt_hw_board_init()
{
1000035c:	e92d4800 	push	{fp, lr}
10000360:	e28db004 	add	fp, sp, #4
    rt_components_board_init();
10000364:	eb000285 	bl	10000d80 <rt_components_board_init>
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
10000368:	e30e0150 	movw	r0, #57680	; 0xe150
1000036c:	e3410001 	movt	r0, #4097	; 0x1001
10000370:	eb0017ad 	bl	1000622c <rt_console_set_device>
}
10000374:	e8bd8800 	pop	{fp, pc}

10000378 <UartEnable>:
            UART->ISR = (UART_IXR_RXOVR | UART_IXR_RXFULL); \
        }                                                   \
    } while(0)

static void UartEnable(UART_Registers* uart)
{
10000378:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000037c:	e28db000 	add	fp, sp, #0
10000380:	e24dd014 	sub	sp, sp, #20
10000384:	e50b0010 	str	r0, [fp, #-16]
	uint32_t tmp = uart->CR;
10000388:	e51b3010 	ldr	r3, [fp, #-16]
1000038c:	e5933000 	ldr	r3, [r3]
10000390:	e50b3008 	str	r3, [fp, #-8]
	tmp &= ~UART_CR_EN_DIS_MASK;
10000394:	e51b3008 	ldr	r3, [fp, #-8]
10000398:	e3c3303c 	bic	r3, r3, #60	; 0x3c
1000039c:	e50b3008 	str	r3, [fp, #-8]
	tmp |= (UART_CR_TX_EN | UART_CR_RX_EN);
100003a0:	e51b3008 	ldr	r3, [fp, #-8]
100003a4:	e3833014 	orr	r3, r3, #20
100003a8:	e50b3008 	str	r3, [fp, #-8]

	uart->CR = tmp;
100003ac:	e51b3010 	ldr	r3, [fp, #-16]
100003b0:	e51b2008 	ldr	r2, [fp, #-8]
100003b4:	e5832000 	str	r2, [r3]
}
100003b8:	e24bd000 	sub	sp, fp, #0
100003bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100003c0:	e12fff1e 	bx	lr

100003c4 <UartDisable>:

static void UartDisable(UART_Registers* uart)
{
100003c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100003c8:	e28db000 	add	fp, sp, #0
100003cc:	e24dd014 	sub	sp, sp, #20
100003d0:	e50b0010 	str	r0, [fp, #-16]
	uint32_t tmp = uart->CR;
100003d4:	e51b3010 	ldr	r3, [fp, #-16]
100003d8:	e5933000 	ldr	r3, [r3]
100003dc:	e50b3008 	str	r3, [fp, #-8]
	tmp &= ~UART_CR_EN_DIS_MASK;
100003e0:	e51b3008 	ldr	r3, [fp, #-8]
100003e4:	e3c3303c 	bic	r3, r3, #60	; 0x3c
100003e8:	e50b3008 	str	r3, [fp, #-8]
	tmp |= (UART_CR_TX_DIS | UART_CR_RX_DIS);
100003ec:	e51b3008 	ldr	r3, [fp, #-8]
100003f0:	e3833028 	orr	r3, r3, #40	; 0x28
100003f4:	e50b3008 	str	r3, [fp, #-8]
	uart->CR = tmp;
100003f8:	e51b3010 	ldr	r3, [fp, #-16]
100003fc:	e51b2008 	ldr	r2, [fp, #-8]
10000400:	e5832000 	str	r2, [r3]
}
10000404:	e24bd000 	sub	sp, fp, #0
10000408:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000040c:	e12fff1e 	bx	lr

10000410 <UartResetTXRXLogic>:

static void UartResetTXRXLogic(UART_Registers* uart)
{
10000410:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000414:	e28db000 	add	fp, sp, #0
10000418:	e24dd00c 	sub	sp, sp, #12
1000041c:	e50b0008 	str	r0, [fp, #-8]
	uart->CR |= 0x03;
10000420:	e51b3008 	ldr	r3, [fp, #-8]
10000424:	e5933000 	ldr	r3, [r3]
10000428:	e3832003 	orr	r2, r3, #3
1000042c:	e51b3008 	ldr	r3, [fp, #-8]
10000430:	e5832000 	str	r2, [r3]
    while (uart->CR & 0x03)
10000434:	e1a00000 	nop			; (mov r0, r0)
10000438:	e51b3008 	ldr	r3, [fp, #-8]
1000043c:	e5933000 	ldr	r3, [r3]
10000440:	e2033003 	and	r3, r3, #3
10000444:	e3530000 	cmp	r3, #0
10000448:	1afffffa 	bne	10000438 <UartResetTXRXLogic+0x28>
        ;
}
1000044c:	e24bd000 	sub	sp, fp, #0
10000450:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000454:	e12fff1e 	bx	lr

10000458 <rt_hw_uart_isr>:
};

/* RT-Thread UART interface */

static void rt_hw_uart_isr(int irqno, void *param)
{
10000458:	e92d4800 	push	{fp, lr}
1000045c:	e28db004 	add	fp, sp, #4
10000460:	e24dd010 	sub	sp, sp, #16
10000464:	e50b0010 	str	r0, [fp, #-16]
10000468:	e50b1014 	str	r1, [fp, #-20]
    struct rt_serial_device *serial = (struct rt_serial_device *)param;
1000046c:	e51b3014 	ldr	r3, [fp, #-20]
10000470:	e50b3008 	str	r3, [fp, #-8]

    rt_hw_serial_isr(serial, RT_SERIAL_EVENT_RX_IND);
10000474:	e51b0008 	ldr	r0, [fp, #-8]
10000478:	e3a01001 	mov	r1, #1
1000047c:	eb0040c2 	bl	1001078c <rt_hw_serial_isr>
}
10000480:	e24bd004 	sub	sp, fp, #4
10000484:	e8bd8800 	pop	{fp, pc}

10000488 <uart_configure>:

static rt_err_t uart_configure(struct rt_serial_device *serial, struct serial_configure *cfg)
{
10000488:	e92d4800 	push	{fp, lr}
1000048c:	e28db004 	add	fp, sp, #4
10000490:	e24dd018 	sub	sp, sp, #24
10000494:	e50b0018 	str	r0, [fp, #-24]
10000498:	e50b101c 	str	r1, [fp, #-28]
    uint32_t mr;
    struct hw_uart_device *pdev = serial->parent.user_data;
1000049c:	e51b3018 	ldr	r3, [fp, #-24]
100004a0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
100004a4:	e50b300c 	str	r3, [fp, #-12]
    UART_Registers *uart = pdev->uart;
100004a8:	e51b300c 	ldr	r3, [fp, #-12]
100004ac:	e5933000 	ldr	r3, [r3]
100004b0:	e50b3010 	str	r3, [fp, #-16]

    /* unlock SLCR */
    __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UNLOCK) = 0xDF0D;
100004b4:	e3a03008 	mov	r3, #8
100004b8:	e34f3800 	movt	r3, #63488	; 0xf800
100004bc:	e30d2f0d 	movw	r2, #57101	; 0xdf0d
100004c0:	e5832000 	str	r2, [r3]

    /* no loopback */
    __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_MIO_LOOPBACK) &= ~(1 << 1);
100004c4:	e3003804 	movw	r3, #2052	; 0x804
100004c8:	e34f3800 	movt	r3, #63488	; 0xf800
100004cc:	e3002804 	movw	r2, #2052	; 0x804
100004d0:	e34f2800 	movt	r2, #63488	; 0xf800
100004d4:	e5922000 	ldr	r2, [r2]
100004d8:	e3c22002 	bic	r2, r2, #2
100004dc:	e5832000 	str	r2, [r3]

    if (uart == (void*)Zynq7000_UART0_BASE)
100004e0:	e51b3010 	ldr	r3, [fp, #-16]
100004e4:	e353020e 	cmp	r3, #-536870912	; 0xe0000000
100004e8:	1a000016 	bne	10000548 <uart_configure+0xc0>
    {
        /* enable the coresponding AMBA Peripheral Clock */
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_APER_CLK_CTRL) |= 1 << 20;
100004ec:	e3a03f4b 	mov	r3, #300	; 0x12c
100004f0:	e34f3800 	movt	r3, #63488	; 0xf800
100004f4:	e3a02f4b 	mov	r2, #300	; 0x12c
100004f8:	e34f2800 	movt	r2, #63488	; 0xf800
100004fc:	e5922000 	ldr	r2, [r2]
10000500:	e3822601 	orr	r2, r2, #1048576	; 0x100000
10000504:	e5832000 	str	r2, [r3]
        /* enable uart clock. Divider 0x14 gives 50MHZ ref clock on IO PLL input. */
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_CLK_CTRL) |= (0x14 << 8) | 0x01;
10000508:	e3a02f55 	mov	r2, #340	; 0x154
1000050c:	e34f2800 	movt	r2, #63488	; 0xf800
10000510:	e3a03f55 	mov	r3, #340	; 0x154
10000514:	e34f3800 	movt	r3, #63488	; 0xf800
10000518:	e5933000 	ldr	r3, [r3]
1000051c:	e3833b05 	orr	r3, r3, #5120	; 0x1400
10000520:	e3833001 	orr	r3, r3, #1
10000524:	e5823000 	str	r3, [r2]
        /* deassert the AMBA clock and software reset */
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_RST_CTRL) &= ~((0x01 << 2)|(0x01 << 0));
10000528:	e3a03f8a 	mov	r3, #552	; 0x228
1000052c:	e34f3800 	movt	r3, #63488	; 0xf800
10000530:	e3a02f8a 	mov	r2, #552	; 0x228
10000534:	e34f2800 	movt	r2, #63488	; 0xf800
10000538:	e5922000 	ldr	r2, [r2]
1000053c:	e3c22005 	bic	r2, r2, #5
10000540:	e5832000 	str	r2, [r3]
10000544:	ea00001d 	b	100005c0 <uart_configure+0x138>
    }
    else if (uart == (void*)Zynq7000_UART1_BASE)
10000548:	e51b2010 	ldr	r2, [fp, #-16]
1000054c:	e3a03a01 	mov	r3, #4096	; 0x1000
10000550:	e34e3000 	movt	r3, #57344	; 0xe000
10000554:	e1520003 	cmp	r2, r3
10000558:	1a000016 	bne	100005b8 <uart_configure+0x130>
    {
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_APER_CLK_CTRL) |= 1 << 21;
1000055c:	e3a03f4b 	mov	r3, #300	; 0x12c
10000560:	e34f3800 	movt	r3, #63488	; 0xf800
10000564:	e3a02f4b 	mov	r2, #300	; 0x12c
10000568:	e34f2800 	movt	r2, #63488	; 0xf800
1000056c:	e5922000 	ldr	r2, [r2]
10000570:	e3822602 	orr	r2, r2, #2097152	; 0x200000
10000574:	e5832000 	str	r2, [r3]
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_CLK_CTRL) |= (0x14 << 8) | 0x02;
10000578:	e3a02f55 	mov	r2, #340	; 0x154
1000057c:	e34f2800 	movt	r2, #63488	; 0xf800
10000580:	e3a03f55 	mov	r3, #340	; 0x154
10000584:	e34f3800 	movt	r3, #63488	; 0xf800
10000588:	e5933000 	ldr	r3, [r3]
1000058c:	e3833b05 	orr	r3, r3, #5120	; 0x1400
10000590:	e3833002 	orr	r3, r3, #2
10000594:	e5823000 	str	r3, [r2]
        __REG32(Zynq7000_SLCR_BASE+Zynq7000_SLCR_UART_RST_CTRL) &= ~((0x01 << 3)|(0x01 << 1));
10000598:	e3a03f8a 	mov	r3, #552	; 0x228
1000059c:	e34f3800 	movt	r3, #63488	; 0xf800
100005a0:	e3a02f8a 	mov	r2, #552	; 0x228
100005a4:	e34f2800 	movt	r2, #63488	; 0xf800
100005a8:	e5922000 	ldr	r2, [r2]
100005ac:	e3c2200a 	bic	r2, r2, #10
100005b0:	e5832000 	str	r2, [r3]
100005b4:	ea000001 	b	100005c0 <uart_configure+0x138>
    }
    else
        return -RT_ERROR;
100005b8:	e3e03000 	mvn	r3, #0
100005bc:	ea00007b 	b	100007b0 <uart_configure+0x328>

    UartDisable(uart);
100005c0:	e51b0010 	ldr	r0, [fp, #-16]
100005c4:	ebffff7e 	bl	100003c4 <UartDisable>
    UartResetTXRXLogic(uart);
100005c8:	e51b0010 	ldr	r0, [fp, #-16]
100005cc:	ebffff8f 	bl	10000410 <UartResetTXRXLogic>
    UartEnable(uart);
100005d0:	e51b0010 	ldr	r0, [fp, #-16]
100005d4:	ebffff67 	bl	10000378 <UartEnable>

    mr = uart->MR & ~(UART_MR_CHARLEN_MASK |
100005d8:	e51b3010 	ldr	r3, [fp, #-16]
100005dc:	e5933004 	ldr	r3, [r3, #4]
100005e0:	e3c330be 	bic	r3, r3, #190	; 0xbe
100005e4:	e50b3008 	str	r3, [fp, #-8]
                      UART_MR_STOPMODE_MASK |
                      UART_MR_PARITY_MASK);

    if (cfg->stop_bits == STOP_BITS_2)
100005e8:	e51b301c 	ldr	r3, [fp, #-28]
100005ec:	e5d33004 	ldrb	r3, [r3, #4]
100005f0:	e2033030 	and	r3, r3, #48	; 0x30
100005f4:	e6ef3073 	uxtb	r3, r3
100005f8:	e3530010 	cmp	r3, #16
100005fc:	1a000003 	bne	10000610 <uart_configure+0x188>
        mr |= UART_MR_STOPMODE_2_BIT;
10000600:	e51b3008 	ldr	r3, [fp, #-8]
10000604:	e3833080 	orr	r3, r3, #128	; 0x80
10000608:	e50b3008 	str	r3, [fp, #-8]
1000060c:	ea000007 	b	10000630 <uart_configure+0x1a8>
    else if (cfg->stop_bits == STOP_BITS_1)
10000610:	e51b301c 	ldr	r3, [fp, #-28]
10000614:	e5d33004 	ldrb	r3, [r3, #4]
10000618:	e2033030 	and	r3, r3, #48	; 0x30
1000061c:	e6ef3073 	uxtb	r3, r3
10000620:	e3530000 	cmp	r3, #0
10000624:	0a000001 	beq	10000630 <uart_configure+0x1a8>
        mr |= UART_MR_STOPMODE_1_BIT;
    else
        return -RT_ERROR;
10000628:	e3e03000 	mvn	r3, #0
1000062c:	ea00005f 	b	100007b0 <uart_configure+0x328>

    if (cfg->parity == PARITY_EVEN)
10000630:	e51b301c 	ldr	r3, [fp, #-28]
10000634:	e5d33004 	ldrb	r3, [r3, #4]
10000638:	e3c3303f 	bic	r3, r3, #63	; 0x3f
1000063c:	e6ef3073 	uxtb	r3, r3
10000640:	e3530080 	cmp	r3, #128	; 0x80
10000644:	0a000015 	beq	100006a0 <uart_configure+0x218>
        mr |= UART_MR_PARITY_EVEN;
    else if (cfg->parity == PARITY_ODD)
10000648:	e51b301c 	ldr	r3, [fp, #-28]
1000064c:	e5d33004 	ldrb	r3, [r3, #4]
10000650:	e3c3303f 	bic	r3, r3, #63	; 0x3f
10000654:	e6ef3073 	uxtb	r3, r3
10000658:	e3530040 	cmp	r3, #64	; 0x40
1000065c:	1a000003 	bne	10000670 <uart_configure+0x1e8>
        mr |= UART_MR_PARITY_ODD;
10000660:	e51b3008 	ldr	r3, [fp, #-8]
10000664:	e3833008 	orr	r3, r3, #8
10000668:	e50b3008 	str	r3, [fp, #-8]
1000066c:	ea00000b 	b	100006a0 <uart_configure+0x218>
    else if (cfg->parity == PARITY_NONE)
10000670:	e51b301c 	ldr	r3, [fp, #-28]
10000674:	e5d33004 	ldrb	r3, [r3, #4]
10000678:	e3c3303f 	bic	r3, r3, #63	; 0x3f
1000067c:	e6ef3073 	uxtb	r3, r3
10000680:	e3530000 	cmp	r3, #0
10000684:	1a000003 	bne	10000698 <uart_configure+0x210>
        mr |= UART_MR_PARITY_NONE;
10000688:	e51b3008 	ldr	r3, [fp, #-8]
1000068c:	e3833020 	orr	r3, r3, #32
10000690:	e50b3008 	str	r3, [fp, #-8]
10000694:	ea000001 	b	100006a0 <uart_configure+0x218>
    else
        return -1;
10000698:	e3e03000 	mvn	r3, #0
1000069c:	ea000043 	b	100007b0 <uart_configure+0x328>

    if (cfg->data_bits == DATA_BITS_8)
100006a0:	e51b301c 	ldr	r3, [fp, #-28]
100006a4:	e5d33004 	ldrb	r3, [r3, #4]
100006a8:	e203300f 	and	r3, r3, #15
100006ac:	e6ef3073 	uxtb	r3, r3
100006b0:	e3530008 	cmp	r3, #8
100006b4:	0a000015 	beq	10000710 <uart_configure+0x288>
        mr |= UART_MR_CHARLEN_8_BIT;
    else if (cfg->data_bits == DATA_BITS_7)
100006b8:	e51b301c 	ldr	r3, [fp, #-28]
100006bc:	e5d33004 	ldrb	r3, [r3, #4]
100006c0:	e203300f 	and	r3, r3, #15
100006c4:	e6ef3073 	uxtb	r3, r3
100006c8:	e3530007 	cmp	r3, #7
100006cc:	1a000003 	bne	100006e0 <uart_configure+0x258>
        mr |= UART_MR_CHARLEN_7_BIT;
100006d0:	e51b3008 	ldr	r3, [fp, #-8]
100006d4:	e3833004 	orr	r3, r3, #4
100006d8:	e50b3008 	str	r3, [fp, #-8]
100006dc:	ea00000b 	b	10000710 <uart_configure+0x288>
    else if (cfg->data_bits == DATA_BITS_6)
100006e0:	e51b301c 	ldr	r3, [fp, #-28]
100006e4:	e5d33004 	ldrb	r3, [r3, #4]
100006e8:	e203300f 	and	r3, r3, #15
100006ec:	e6ef3073 	uxtb	r3, r3
100006f0:	e3530006 	cmp	r3, #6
100006f4:	1a000003 	bne	10000708 <uart_configure+0x280>
        mr |= UART_MR_CHARLEN_6_BIT;
100006f8:	e51b3008 	ldr	r3, [fp, #-8]
100006fc:	e3833006 	orr	r3, r3, #6
10000700:	e50b3008 	str	r3, [fp, #-8]
10000704:	ea000001 	b	10000710 <uart_configure+0x288>
    else
        return -RT_ERROR;
10000708:	e3e03000 	mvn	r3, #0
1000070c:	ea000027 	b	100007b0 <uart_configure+0x328>

	uart->MR = mr;
10000710:	e51b3010 	ldr	r3, [fp, #-16]
10000714:	e51b2008 	ldr	r2, [fp, #-8]
10000718:	e5832004 	str	r2, [r3, #4]

    uart->TXWM = 8;
1000071c:	e51b3010 	ldr	r3, [fp, #-16]
10000720:	e3a02008 	mov	r2, #8
10000724:	e5832044 	str	r2, [r3, #68]	; 0x44
    uart->RXWM = 1;
10000728:	e51b3010 	ldr	r3, [fp, #-16]
1000072c:	e3a02001 	mov	r2, #1
10000730:	e5832020 	str	r2, [r3, #32]

    if (cfg->baud_rate == BAUD_RATE_115200)
10000734:	e51b301c 	ldr	r3, [fp, #-28]
10000738:	e5932000 	ldr	r2, [r3]
1000073c:	e3a03cc2 	mov	r3, #49664	; 0xc200
10000740:	e3403001 	movt	r3, #1
10000744:	e1520003 	cmp	r2, r3
10000748:	1a000006 	bne	10000768 <uart_configure+0x2e0>
    {
        uart->BAUDGEN = UART_BAUDGEN_115200;
1000074c:	e51b3010 	ldr	r3, [fp, #-16]
10000750:	e3a0203e 	mov	r2, #62	; 0x3e
10000754:	e5832018 	str	r2, [r3, #24]
        uart->BAUDDIV = UART_BAUDDIV_115200;
10000758:	e51b3010 	ldr	r3, [fp, #-16]
1000075c:	e3a02006 	mov	r2, #6
10000760:	e5832034 	str	r2, [r3, #52]	; 0x34
10000764:	ea000005 	b	10000780 <uart_configure+0x2f8>
    }
    else
    {
        rt_kprintf("baudrate %d not implemented yet\n", cfg->baud_rate);
10000768:	e51b301c 	ldr	r3, [fp, #-28]
1000076c:	e5933000 	ldr	r3, [r3]
10000770:	e30e0158 	movw	r0, #57688	; 0xe158
10000774:	e3410001 	movt	r0, #4097	; 0x1001
10000778:	e1a01003 	mov	r1, r3
1000077c:	eb0016d4 	bl	100062d4 <rt_kprintf>
    }

    /* disable all interrupts */
    uart->IDR = UART_IXR_MASK;
10000780:	e51b3010 	ldr	r3, [fp, #-16]
10000784:	e30023ff 	movw	r2, #1023	; 0x3ff
10000788:	e583200c 	str	r2, [r3, #12]

    /* configure the pin */
    *(pdev->txmio) = TX_MIO_PIN_MODE;
1000078c:	e51b300c 	ldr	r3, [fp, #-12]
10000790:	e593300c 	ldr	r3, [r3, #12]
10000794:	e3a02e3e 	mov	r2, #992	; 0x3e0
10000798:	e5832000 	str	r2, [r3]
    *(pdev->rxmio) = RX_MIO_PIN_MODE;
1000079c:	e51b300c 	ldr	r3, [fp, #-12]
100007a0:	e5933008 	ldr	r3, [r3, #8]
100007a4:	e30123e0 	movw	r2, #5088	; 0x13e0
100007a8:	e5832000 	str	r2, [r3]

    return RT_EOK;
100007ac:	e3a03000 	mov	r3, #0
}
100007b0:	e1a00003 	mov	r0, r3
100007b4:	e24bd004 	sub	sp, fp, #4
100007b8:	e8bd8800 	pop	{fp, pc}

100007bc <uart_control>:

static rt_err_t uart_control(struct rt_serial_device *serial, int cmd, void *arg)
{
100007bc:	e92d4810 	push	{r4, fp, lr}
100007c0:	e28db008 	add	fp, sp, #8
100007c4:	e24dd01c 	sub	sp, sp, #28
100007c8:	e50b0018 	str	r0, [fp, #-24]
100007cc:	e50b101c 	str	r1, [fp, #-28]
100007d0:	e50b2020 	str	r2, [fp, #-32]
    struct hw_uart_device *pdev;

    RT_ASSERT(serial != RT_NULL);
100007d4:	e51b3018 	ldr	r3, [fp, #-24]
100007d8:	e3530000 	cmp	r3, #0
100007dc:	1a000005 	bne	100007f8 <uart_control+0x3c>
100007e0:	e30e017c 	movw	r0, #57724	; 0xe17c
100007e4:	e3410001 	movt	r0, #4097	; 0x1001
100007e8:	e30e11bc 	movw	r1, #57788	; 0xe1bc
100007ec:	e3411001 	movt	r1, #4097	; 0x1001
100007f0:	e3a020c4 	mov	r2, #196	; 0xc4
100007f4:	eb001773 	bl	100065c8 <rt_assert_handler>

    pdev = serial->parent.user_data;
100007f8:	e51b3018 	ldr	r3, [fp, #-24]
100007fc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10000800:	e50b3010 	str	r3, [fp, #-16]

    switch (cmd)
10000804:	e51b301c 	ldr	r3, [fp, #-28]
10000808:	e3530010 	cmp	r3, #16
1000080c:	0a000009 	beq	10000838 <uart_control+0x7c>
10000810:	e3530011 	cmp	r3, #17
10000814:	1a000028 	bne	100008bc <uart_control+0x100>
    {
    case RT_DEVICE_CTRL_CLR_INT:
        /* disable rx irq */
        Zynq7000_UART_INT_DISABLE(pdev->uart);
10000818:	e51b3010 	ldr	r3, [fp, #-16]
1000081c:	e5933000 	ldr	r3, [r3]
10000820:	e51b2010 	ldr	r2, [fp, #-16]
10000824:	e5922000 	ldr	r2, [r2]
10000828:	e5922008 	ldr	r2, [r2, #8]
1000082c:	e3c22005 	bic	r2, r2, #5
10000830:	e5832008 	str	r2, [r3, #8]
        break;
10000834:	ea000020 	b	100008bc <uart_control+0x100>

    case RT_DEVICE_CTRL_SET_INT:
        /* enable rx irq */
        Zynq7000_UART_INT_ENABLE(pdev->uart);
10000838:	e51b3010 	ldr	r3, [fp, #-16]
1000083c:	e5933000 	ldr	r3, [r3]
10000840:	e51b2010 	ldr	r2, [fp, #-16]
10000844:	e5922000 	ldr	r2, [r2]
10000848:	e5922008 	ldr	r2, [r2, #8]
1000084c:	e3822005 	orr	r2, r2, #5
10000850:	e5832008 	str	r2, [r3, #8]
        rt_hw_interrupt_install(pdev->irqno, rt_hw_uart_isr, serial, "uart");
10000854:	e51b3010 	ldr	r3, [fp, #-16]
10000858:	e5933004 	ldr	r3, [r3, #4]
1000085c:	e1a00003 	mov	r0, r3
10000860:	e3001458 	movw	r1, #1112	; 0x458
10000864:	e3411000 	movt	r1, #4096	; 0x1000
10000868:	e51b2018 	ldr	r2, [fp, #-24]
1000086c:	e30e3190 	movw	r3, #57744	; 0xe190
10000870:	e3413001 	movt	r3, #4097	; 0x1001
10000874:	eb002885 	bl	1000aa90 <rt_hw_interrupt_install>
        /* set the interrupt to this cpu */
        arm_gic_set_cpu(0, pdev->irqno, 1 << rt_cpu_get_smp_id());
10000878:	e51b3010 	ldr	r3, [fp, #-16]
1000087c:	e5933004 	ldr	r3, [r3, #4]
10000880:	e1a04003 	mov	r4, r3
10000884:	eb002b32 	bl	1000b554 <rt_cpu_get_smp_id>
10000888:	e1a03000 	mov	r3, r0
1000088c:	e1a02003 	mov	r2, r3
10000890:	e3a03001 	mov	r3, #1
10000894:	e1a03213 	lsl	r3, r3, r2
10000898:	e3a00000 	mov	r0, #0
1000089c:	e1a01004 	mov	r1, r4
100008a0:	e1a02003 	mov	r2, r3
100008a4:	eb00256f 	bl	10009e68 <arm_gic_set_cpu>
        rt_hw_interrupt_umask(pdev->irqno);
100008a8:	e51b3010 	ldr	r3, [fp, #-16]
100008ac:	e5933004 	ldr	r3, [r3, #4]
100008b0:	e1a00003 	mov	r0, r3
100008b4:	eb00286c 	bl	1000aa6c <rt_hw_interrupt_umask>
        break;
100008b8:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
100008bc:	e3a03000 	mov	r3, #0
}
100008c0:	e1a00003 	mov	r0, r3
100008c4:	e24bd008 	sub	sp, fp, #8
100008c8:	e8bd8810 	pop	{r4, fp, pc}

100008cc <uart_putc>:

static int uart_putc(struct rt_serial_device *serial, char c)
{
100008cc:	e92d4800 	push	{fp, lr}
100008d0:	e28db004 	add	fp, sp, #4
100008d4:	e24dd010 	sub	sp, sp, #16
100008d8:	e50b0010 	str	r0, [fp, #-16]
100008dc:	e1a03001 	mov	r3, r1
100008e0:	e54b3011 	strb	r3, [fp, #-17]
    struct hw_uart_device *dev;

    RT_ASSERT(serial != RT_NULL);
100008e4:	e51b3010 	ldr	r3, [fp, #-16]
100008e8:	e3530000 	cmp	r3, #0
100008ec:	1a000005 	bne	10000908 <uart_putc+0x3c>
100008f0:	e30e017c 	movw	r0, #57724	; 0xe17c
100008f4:	e3410001 	movt	r0, #4097	; 0x1001
100008f8:	e30e11cc 	movw	r1, #57804	; 0xe1cc
100008fc:	e3411001 	movt	r1, #4097	; 0x1001
10000900:	e3a020e0 	mov	r2, #224	; 0xe0
10000904:	eb00172f 	bl	100065c8 <rt_assert_handler>
    dev = (struct hw_uart_device *)serial->parent.user_data;
10000908:	e51b3010 	ldr	r3, [fp, #-16]
1000090c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10000910:	e50b3008 	str	r3, [fp, #-8]

    Zynq7000_UART_SENDCHAR(dev->uart, c);
10000914:	e1a00000 	nop			; (mov r0, r0)
10000918:	e51b3008 	ldr	r3, [fp, #-8]
1000091c:	e5933000 	ldr	r3, [r3]
10000920:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10000924:	e2033010 	and	r3, r3, #16
10000928:	e3530000 	cmp	r3, #0
1000092c:	1afffff9 	bne	10000918 <uart_putc+0x4c>
10000930:	e51b3008 	ldr	r3, [fp, #-8]
10000934:	e5933000 	ldr	r3, [r3]
10000938:	e55b2011 	ldrb	r2, [fp, #-17]
1000093c:	e5832030 	str	r2, [r3, #48]	; 0x30

    return 1;
10000940:	e3a03001 	mov	r3, #1
}
10000944:	e1a00003 	mov	r0, r3
10000948:	e24bd004 	sub	sp, fp, #4
1000094c:	e8bd8800 	pop	{fp, pc}

10000950 <uart_getc>:

static int uart_getc(struct rt_serial_device *serial)
{
10000950:	e92d4800 	push	{fp, lr}
10000954:	e28db004 	add	fp, sp, #4
10000958:	e24dd010 	sub	sp, sp, #16
1000095c:	e50b0010 	str	r0, [fp, #-16]
    int ch;
    struct hw_uart_device *dev;

    RT_ASSERT(serial != RT_NULL);
10000960:	e51b3010 	ldr	r3, [fp, #-16]
10000964:	e3530000 	cmp	r3, #0
10000968:	1a000005 	bne	10000984 <uart_getc+0x34>
1000096c:	e30e017c 	movw	r0, #57724	; 0xe17c
10000970:	e3410001 	movt	r0, #4097	; 0x1001
10000974:	e30e11d8 	movw	r1, #57816	; 0xe1d8
10000978:	e3411001 	movt	r1, #4097	; 0x1001
1000097c:	e3a020ed 	mov	r2, #237	; 0xed
10000980:	eb001710 	bl	100065c8 <rt_assert_handler>
    dev = (struct hw_uart_device *)serial->parent.user_data;
10000984:	e51b3010 	ldr	r3, [fp, #-16]
10000988:	e5933038 	ldr	r3, [r3, #56]	; 0x38
1000098c:	e50b300c 	str	r3, [fp, #-12]

    ch = -1;
10000990:	e3e03000 	mvn	r3, #0
10000994:	e50b3008 	str	r3, [fp, #-8]
    Zynq7000_UART_GETCHAR(dev->uart, ch);
10000998:	e51b300c 	ldr	r3, [fp, #-12]
1000099c:	e5933000 	ldr	r3, [r3]
100009a0:	e5933014 	ldr	r3, [r3, #20]
100009a4:	e2033001 	and	r3, r3, #1
100009a8:	e3530000 	cmp	r3, #0
100009ac:	0a000008 	beq	100009d4 <uart_getc+0x84>
100009b0:	e51b300c 	ldr	r3, [fp, #-12]
100009b4:	e5933000 	ldr	r3, [r3]
100009b8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
100009bc:	e6ef3073 	uxtb	r3, r3
100009c0:	e50b3008 	str	r3, [fp, #-8]
100009c4:	e51b300c 	ldr	r3, [fp, #-12]
100009c8:	e5933000 	ldr	r3, [r3]
100009cc:	e3a02005 	mov	r2, #5
100009d0:	e5832014 	str	r2, [r3, #20]

    return ch;
100009d4:	e51b3008 	ldr	r3, [fp, #-8]
}
100009d8:	e1a00003 	mov	r0, r3
100009dc:	e24bd004 	sub	sp, fp, #4
100009e0:	e8bd8800 	pop	{fp, pc}

100009e4 <rt_hw_uart_init>:

static struct rt_serial_device _serial0;
static struct rt_serial_device _serial1;

int rt_hw_uart_init(void)
{
100009e4:	e92d4800 	push	{fp, lr}
100009e8:	e28db004 	add	fp, sp, #4
100009ec:	e24dd008 	sub	sp, sp, #8
    struct serial_configure config;

    config.baud_rate = BAUD_RATE_115200;
100009f0:	e3a03cc2 	mov	r3, #49664	; 0xc200
100009f4:	e3403001 	movt	r3, #1
100009f8:	e50b300c 	str	r3, [fp, #-12]
    config.bit_order = BIT_ORDER_LSB;
100009fc:	e55b3007 	ldrb	r3, [fp, #-7]
10000a00:	e7c0301f 	bfc	r3, #0, #1
10000a04:	e54b3007 	strb	r3, [fp, #-7]
    config.data_bits = DATA_BITS_8;
10000a08:	e55b3008 	ldrb	r3, [fp, #-8]
10000a0c:	e3a02008 	mov	r2, #8
10000a10:	e7c33012 	bfi	r3, r2, #0, #4
10000a14:	e54b3008 	strb	r3, [fp, #-8]
    config.parity    = PARITY_NONE;
10000a18:	e55b3008 	ldrb	r3, [fp, #-8]
10000a1c:	e7c7331f 	bfc	r3, #6, #2
10000a20:	e54b3008 	strb	r3, [fp, #-8]
    config.stop_bits = STOP_BITS_1;
10000a24:	e55b3008 	ldrb	r3, [fp, #-8]
10000a28:	e7c5321f 	bfc	r3, #4, #2
10000a2c:	e54b3008 	strb	r3, [fp, #-8]
    config.invert    = NRZ_NORMAL;
10000a30:	e55b3007 	ldrb	r3, [fp, #-7]
10000a34:	e7c1309f 	bfc	r3, #1, #1
10000a38:	e54b3007 	strb	r3, [fp, #-7]
	config.bufsz     = RT_SERIAL_RB_BUFSZ;
10000a3c:	e51b3008 	ldr	r3, [fp, #-8]
10000a40:	e3a02040 	mov	r2, #64	; 0x40
10000a44:	e7d93512 	bfi	r3, r2, #10, #16
10000a48:	e50b3008 	str	r3, [fp, #-8]

    _serial0.ops    = &_uart_ops;
10000a4c:	e3083000 	movw	r3, #32768	; 0x8000
10000a50:	e3413002 	movt	r3, #4098	; 0x1002
10000a54:	e30e2198 	movw	r2, #57752	; 0xe198
10000a58:	e3412001 	movt	r2, #4097	; 0x1001
10000a5c:	e583203c 	str	r2, [r3, #60]	; 0x3c
    _serial0.config = config;
10000a60:	e3083000 	movw	r3, #32768	; 0x8000
10000a64:	e3413002 	movt	r3, #4098	; 0x1002
10000a68:	e2833040 	add	r3, r3, #64	; 0x40
10000a6c:	e24b200c 	sub	r2, fp, #12
10000a70:	e8920003 	ldm	r2, {r0, r1}
10000a74:	e8830003 	stm	r3, {r0, r1}

    _serial1.ops    = &_uart_ops;
10000a78:	e3083050 	movw	r3, #32848	; 0x8050
10000a7c:	e3413002 	movt	r3, #4098	; 0x1002
10000a80:	e30e2198 	movw	r2, #57752	; 0xe198
10000a84:	e3412001 	movt	r2, #4097	; 0x1001
10000a88:	e583203c 	str	r2, [r3, #60]	; 0x3c
    _serial1.config = config;
10000a8c:	e3083050 	movw	r3, #32848	; 0x8050
10000a90:	e3413002 	movt	r3, #4098	; 0x1002
10000a94:	e2833040 	add	r3, r3, #64	; 0x40
10000a98:	e24b200c 	sub	r2, fp, #12
10000a9c:	e8920003 	ldm	r2, {r0, r1}
10000aa0:	e8830003 	stm	r3, {r0, r1}

    /* register uart device */
    rt_hw_serial_register(&_serial0, "uart0",
10000aa4:	e3080000 	movw	r0, #32768	; 0x8000
10000aa8:	e3410002 	movt	r0, #4098	; 0x1002
10000aac:	e30e11ac 	movw	r1, #57772	; 0xe1ac
10000ab0:	e3411001 	movt	r1, #4097	; 0x1001
10000ab4:	e3002103 	movw	r2, #259	; 0x103
10000ab8:	e3003998 	movw	r3, #2456	; 0x998
10000abc:	e3413002 	movt	r3, #4098	; 0x1002
10000ac0:	eb003ef1 	bl	1001068c <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          &_uart_device0);
    rt_hw_serial_register(&_serial1, "uart1",
10000ac4:	e3080050 	movw	r0, #32848	; 0x8050
10000ac8:	e3410002 	movt	r0, #4098	; 0x1002
10000acc:	e30e11b4 	movw	r1, #57780	; 0xe1b4
10000ad0:	e3411001 	movt	r1, #4097	; 0x1001
10000ad4:	e3002103 	movw	r2, #259	; 0x103
10000ad8:	e30039a8 	movw	r3, #2472	; 0x9a8
10000adc:	e3413002 	movt	r3, #4098	; 0x1002
10000ae0:	eb003ee9 	bl	1001068c <rt_hw_serial_register>
                          RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
                          &_uart_device1);
    return 0;
10000ae4:	e3a03000 	mov	r3, #0
}
10000ae8:	e1a00003 	mov	r0, r3
10000aec:	e24bd004 	sub	sp, fp, #4
10000af0:	e8bd8800 	pop	{fp, pc}

10000af4 <rt_init_thread_entry>:
#endif
#include <cp15.h>

/* thread phase init */
static void rt_init_thread_entry(void *parameter)
{
10000af4:	e92d4800 	push	{fp, lr}
10000af8:	e28db004 	add	fp, sp, #4
10000afc:	e24dd008 	sub	sp, sp, #8
10000b00:	e50b0008 	str	r0, [fp, #-8]
    /* do component initialization */
    rt_components_init();
10000b04:	eb0000b1 	bl	10000dd0 <rt_components_init>
    rt_kprintf("running on cpu %d\n",
               rt_cpu_get_smp_id() & 0x0f);
10000b08:	eb002a91 	bl	1000b554 <rt_cpu_get_smp_id>
10000b0c:	e1a03000 	mov	r3, r0
/* thread phase init */
static void rt_init_thread_entry(void *parameter)
{
    /* do component initialization */
    rt_components_init();
    rt_kprintf("running on cpu %d\n",
10000b10:	e203300f 	and	r3, r3, #15
10000b14:	e30e01e4 	movw	r0, #57828	; 0xe1e4
10000b18:	e3410001 	movt	r0, #4097	; 0x1001
10000b1c:	e1a01003 	mov	r1, r3
10000b20:	eb0015eb 	bl	100062d4 <rt_kprintf>
               rt_cpu_get_smp_id() & 0x0f);

    /* add your initialization here */
}
10000b24:	e24bd004 	sub	sp, fp, #4
10000b28:	e8bd8800 	pop	{fp, pc}

10000b2c <rt_application_init>:

int rt_application_init()
{
10000b2c:	e92d4800 	push	{fp, lr}
10000b30:	e28db004 	add	fp, sp, #4
10000b34:	e24dd010 	sub	sp, sp, #16
    rt_thread_t tid;

    tid = rt_thread_create("init", rt_init_thread_entry, RT_NULL, 2048,
10000b38:	e3a0300a 	mov	r3, #10
10000b3c:	e58d3000 	str	r3, [sp]
10000b40:	e3a03014 	mov	r3, #20
10000b44:	e58d3004 	str	r3, [sp, #4]
10000b48:	e30e01f8 	movw	r0, #57848	; 0xe1f8
10000b4c:	e3410001 	movt	r0, #4097	; 0x1001
10000b50:	e3001af4 	movw	r1, #2804	; 0xaf4
10000b54:	e3411000 	movt	r1, #4096	; 0x1000
10000b58:	e3a02000 	mov	r2, #0
10000b5c:	e3a03b02 	mov	r3, #2048	; 0x800
10000b60:	eb001f7c 	bl	10008958 <rt_thread_create>
10000b64:	e50b0008 	str	r0, [fp, #-8]
                            RT_THREAD_PRIORITY_MAX/3, 20);
    if (tid != RT_NULL)
10000b68:	e51b3008 	ldr	r3, [fp, #-8]
10000b6c:	e3530000 	cmp	r3, #0
10000b70:	0a000001 	beq	10000b7c <rt_application_init+0x50>
        rt_thread_startup(tid);
10000b74:	e51b0008 	ldr	r0, [fp, #-8]
10000b78:	eb001f1b 	bl	100087ec <rt_thread_startup>

    return 0;
10000b7c:	e3a03000 	mov	r3, #0
}
10000b80:	e1a00003 	mov	r0, r3
10000b84:	e24bd004 	sub	sp, fp, #4
10000b88:	e8bd8800 	pop	{fp, pc}

10000b8c <rtthread_startup>:

/**
 * This function will startup RT-Thread RTOS.
 */
void rtthread_startup(void)
{
10000b8c:	e92d4800 	push	{fp, lr}
10000b90:	e28db004 	add	fp, sp, #4
    rt_hw_mmu_init();
10000b94:	eb0028d5 	bl	1000aef0 <rt_hw_mmu_init>

    /* initialzie hardware interrupt */
    rt_hw_interrupt_init();
10000b98:	eb002779 	bl	1000a984 <rt_hw_interrupt_init>

    /* initialize board */
    rt_hw_board_init();
10000b9c:	ebfffdee 	bl	1000035c <rt_hw_board_init>

    /* show RT-Thread version */
    rt_show_version();
10000ba0:	eb0011ff 	bl	100053a4 <rt_show_version>

    /* initialize memory system */
#ifdef RT_USING_HEAP
    rt_system_heap_init(HEAP_BEGIN, HEAP_END);
10000ba4:	e30a0a70 	movw	r0, #43632	; 0xaa70
10000ba8:	e3410002 	movt	r0, #4098	; 0x1002
10000bac:	e3a01202 	mov	r1, #536870912	; 0x20000000
10000bb0:	eb00173c 	bl	100068a8 <rt_system_heap_init>
#endif

    /* initialize scheduler system */
    rt_system_scheduler_init();
10000bb4:	eb001cde 	bl	10007f34 <rt_system_scheduler_init>

    /* initialize system timer */
    rt_system_timer_init();
10000bb8:	eb00239b 	bl	10009a2c <rt_system_timer_init>

    /* initialize soft timer thread */
    rt_system_timer_thread_init();
10000bbc:	eb0023af 	bl	10009a80 <rt_system_timer_thread_init>

    /* initialize application */
    rt_application_init();
10000bc0:	ebffffd9 	bl	10000b2c <rt_application_init>

    /* initialize idle thread */
    rt_thread_idle_init();
10000bc4:	eb0002fe 	bl	100017c4 <rt_thread_idle_init>

    /* start scheduler */
    rt_system_scheduler_start();
10000bc8:	eb001cfa 	bl	10007fb8 <rt_system_scheduler_start>

    /* never reach here */
    return ;
10000bcc:	e1a00000 	nop			; (mov r0, r0)
}
10000bd0:	e8bd8800 	pop	{fp, pc}

10000bd4 <main>:

int main(void)
{
10000bd4:	e92d4800 	push	{fp, lr}
10000bd8:	e28db004 	add	fp, sp, #4
    /* disable interrupt first */
    rt_hw_interrupt_disable();
10000bdc:	eb002a36 	bl	1000b4bc <rt_hw_interrupt_disable>

    /* invoke rtthread_startup */
    rtthread_startup();
10000be0:	ebffffe9 	bl	10000b8c <rtthread_startup>

    return 0;
10000be4:	e3a03000 	mov	r3, #0
}
10000be8:	e1a00003 	mov	r0, r3
10000bec:	e8bd8800 	pop	{fp, pc}

10000bf0 <rt_system_tick_init>:
 *
 * @deprecated since 1.1.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_tick_init(void)
{
10000bf0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000bf4:	e28db000 	add	fp, sp, #0
}
10000bf8:	e24bd000 	sub	sp, fp, #0
10000bfc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000c00:	e12fff1e 	bx	lr

10000c04 <rt_tick_get>:
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
{
10000c04:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000c08:	e28db000 	add	fp, sp, #0
    /* return the global tick */
    return rt_tick;
10000c0c:	e30830a0 	movw	r3, #32928	; 0x80a0
10000c10:	e3413002 	movt	r3, #4098	; 0x1002
10000c14:	e5933000 	ldr	r3, [r3]
}
10000c18:	e1a00003 	mov	r0, r3
10000c1c:	e24bd000 	sub	sp, fp, #0
10000c20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000c24:	e12fff1e 	bx	lr

10000c28 <rt_tick_set>:

/**
 * This function will set current tick
 */
void rt_tick_set(rt_tick_t tick)
{
10000c28:	e92d4800 	push	{fp, lr}
10000c2c:	e28db004 	add	fp, sp, #4
10000c30:	e24dd010 	sub	sp, sp, #16
10000c34:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;

    level = rt_hw_interrupt_disable();
10000c38:	eb002a1f 	bl	1000b4bc <rt_hw_interrupt_disable>
10000c3c:	e50b0008 	str	r0, [fp, #-8]
    rt_tick = tick;
10000c40:	e30830a0 	movw	r3, #32928	; 0x80a0
10000c44:	e3413002 	movt	r3, #4098	; 0x1002
10000c48:	e51b2010 	ldr	r2, [fp, #-16]
10000c4c:	e5832000 	str	r2, [r3]
    rt_hw_interrupt_enable(level);
10000c50:	e51b0008 	ldr	r0, [fp, #-8]
10000c54:	eb002a1c 	bl	1000b4cc <rt_hw_interrupt_enable>
}
10000c58:	e24bd004 	sub	sp, fp, #4
10000c5c:	e8bd8800 	pop	{fp, pc}

10000c60 <rt_tick_increase>:
/**
 * This function will notify kernel there is one tick passed. Normally,
 * this function is invoked by clock ISR.
 */
void rt_tick_increase(void)
{
10000c60:	e92d4800 	push	{fp, lr}
10000c64:	e28db004 	add	fp, sp, #4
10000c68:	e24dd008 	sub	sp, sp, #8
    struct rt_thread *thread;

    /* increase the global tick */
    ++ rt_tick;
10000c6c:	e30830a0 	movw	r3, #32928	; 0x80a0
10000c70:	e3413002 	movt	r3, #4098	; 0x1002
10000c74:	e5933000 	ldr	r3, [r3]
10000c78:	e2832001 	add	r2, r3, #1
10000c7c:	e30830a0 	movw	r3, #32928	; 0x80a0
10000c80:	e3413002 	movt	r3, #4098	; 0x1002
10000c84:	e5832000 	str	r2, [r3]

    /* check time slice */
    thread = rt_thread_self();
10000c88:	eb001ece 	bl	100087c8 <rt_thread_self>
10000c8c:	e50b0008 	str	r0, [fp, #-8]

    -- thread->remaining_tick;
10000c90:	e51b3008 	ldr	r3, [fp, #-8]
10000c94:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10000c98:	e2432001 	sub	r2, r3, #1
10000c9c:	e51b3008 	ldr	r3, [fp, #-8]
10000ca0:	e5832044 	str	r2, [r3, #68]	; 0x44
    if (thread->remaining_tick == 0)
10000ca4:	e51b3008 	ldr	r3, [fp, #-8]
10000ca8:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10000cac:	e3530000 	cmp	r3, #0
10000cb0:	1a000004 	bne	10000cc8 <rt_tick_increase+0x68>
    {
        /* change to initialized tick */
        thread->remaining_tick = thread->init_tick;
10000cb4:	e51b3008 	ldr	r3, [fp, #-8]
10000cb8:	e5932040 	ldr	r2, [r3, #64]	; 0x40
10000cbc:	e51b3008 	ldr	r3, [fp, #-8]
10000cc0:	e5832044 	str	r2, [r3, #68]	; 0x44

        /* yield */
        rt_thread_yield();
10000cc4:	eb001f72 	bl	10008a94 <rt_thread_yield>
    }

    /* check timer */
    rt_timer_check();
10000cc8:	eb002303 	bl	100098dc <rt_timer_check>
}
10000ccc:	e24bd004 	sub	sp, fp, #4
10000cd0:	e8bd8800 	pop	{fp, pc}

10000cd4 <rt_tick_from_millisecond>:
 * @param ms the specified millisecond
 *
 * @return the calculated tick
 */
rt_tick_t rt_tick_from_millisecond(rt_uint32_t ms)
{
10000cd4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000cd8:	e28db000 	add	fp, sp, #0
10000cdc:	e24dd00c 	sub	sp, sp, #12
10000ce0:	e50b0008 	str	r0, [fp, #-8]
    /* return the calculated tick */
    return (RT_TICK_PER_SECOND * ms + 999) / 1000;
10000ce4:	e51b1008 	ldr	r1, [fp, #-8]
10000ce8:	e1a02001 	mov	r2, r1
10000cec:	e1a03102 	lsl	r3, r2, #2
10000cf0:	e1a02003 	mov	r2, r3
10000cf4:	e1a03282 	lsl	r3, r2, #5
10000cf8:	e0623003 	rsb	r3, r2, r3
10000cfc:	e0833001 	add	r3, r3, r1
10000d00:	e1a03183 	lsl	r3, r3, #3
10000d04:	e2833ff9 	add	r3, r3, #996	; 0x3e4
10000d08:	e2833003 	add	r3, r3, #3
10000d0c:	e3042dd3 	movw	r2, #19923	; 0x4dd3
10000d10:	e3412062 	movt	r2, #4194	; 0x1062
10000d14:	e0832293 	umull	r2, r3, r3, r2
10000d18:	e1a03323 	lsr	r3, r3, #6
}
10000d1c:	e1a00003 	mov	r0, r3
10000d20:	e24bd000 	sub	sp, fp, #0
10000d24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000d28:	e12fff1e 	bx	lr

10000d2c <rti_start>:
 * ...
 * INIT_APP_EXPORT(fn);
 * etc. 
 */
static int rti_start(void)
{
10000d2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000d30:	e28db000 	add	fp, sp, #0
    return 0;
10000d34:	e3a03000 	mov	r3, #0
}
10000d38:	e1a00003 	mov	r0, r3
10000d3c:	e24bd000 	sub	sp, fp, #0
10000d40:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000d44:	e12fff1e 	bx	lr

10000d48 <rti_board_end>:
INIT_EXPORT(rti_start, "0");

static int rti_board_end(void)
{
10000d48:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000d4c:	e28db000 	add	fp, sp, #0
    return 0;
10000d50:	e3a03000 	mov	r3, #0
}
10000d54:	e1a00003 	mov	r0, r3
10000d58:	e24bd000 	sub	sp, fp, #0
10000d5c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000d60:	e12fff1e 	bx	lr

10000d64 <rti_end>:
INIT_EXPORT(rti_board_end, "1.end");

static int rti_end(void)
{
10000d64:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000d68:	e28db000 	add	fp, sp, #0
	return 0;
10000d6c:	e3a03000 	mov	r3, #0
}
10000d70:	e1a00003 	mov	r0, r3
10000d74:	e24bd000 	sub	sp, fp, #0
10000d78:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000d7c:	e12fff1e 	bx	lr

10000d80 <rt_components_board_init>:

/**
 * RT-Thread Components Initialization for board
 */
void rt_components_board_init(void)
{
10000d80:	e92d4800 	push	{fp, lr}
10000d84:	e28db004 	add	fp, sp, #4
10000d88:	e24dd008 	sub	sp, sp, #8
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
10000d8c:	e30e312c 	movw	r3, #57644	; 0xe12c
10000d90:	e3413001 	movt	r3, #4097	; 0x1001
10000d94:	e50b3008 	str	r3, [fp, #-8]
10000d98:	ea000005 	b	10000db4 <rt_components_board_init+0x34>
    {
        (*fn_ptr)();
10000d9c:	e51b3008 	ldr	r3, [fp, #-8]
10000da0:	e5933000 	ldr	r3, [r3]
10000da4:	e12fff33 	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++)
10000da8:	e51b3008 	ldr	r3, [fp, #-8]
10000dac:	e2833004 	add	r3, r3, #4
10000db0:	e50b3008 	str	r3, [fp, #-8]
10000db4:	e51b2008 	ldr	r2, [fp, #-8]
10000db8:	e30e3138 	movw	r3, #57656	; 0xe138
10000dbc:	e3413001 	movt	r3, #4097	; 0x1001
10000dc0:	e1520003 	cmp	r2, r3
10000dc4:	3afffff4 	bcc	10000d9c <rt_components_board_init+0x1c>
    {
        (*fn_ptr)();
    }
#endif
}
10000dc8:	e24bd004 	sub	sp, fp, #4
10000dcc:	e8bd8800 	pop	{fp, pc}

10000dd0 <rt_components_init>:

/**
 * RT-Thread Components Initialization
 */
void rt_components_init(void)
{
10000dd0:	e92d4800 	push	{fp, lr}
10000dd4:	e28db004 	add	fp, sp, #4
10000dd8:	e24dd008 	sub	sp, sp, #8
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
10000ddc:	e30e3138 	movw	r3, #57656	; 0xe138
10000de0:	e3413001 	movt	r3, #4097	; 0x1001
10000de4:	e50b3008 	str	r3, [fp, #-8]
10000de8:	ea000005 	b	10000e04 <rt_components_init+0x34>
    {
        (*fn_ptr)();
10000dec:	e51b3008 	ldr	r3, [fp, #-8]
10000df0:	e5933000 	ldr	r3, [r3]
10000df4:	e12fff33 	blx	r3
        rt_kprintf(":%d done\n", result);
    }
#else
    const init_fn_t *fn_ptr;

    for (fn_ptr = &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++)
10000df8:	e51b3008 	ldr	r3, [fp, #-8]
10000dfc:	e2833004 	add	r3, r3, #4
10000e00:	e50b3008 	str	r3, [fp, #-8]
10000e04:	e51b2008 	ldr	r2, [fp, #-8]
10000e08:	e30e3144 	movw	r3, #57668	; 0xe144
10000e0c:	e3413001 	movt	r3, #4097	; 0x1001
10000e10:	e1520003 	cmp	r2, r3
10000e14:	3afffff4 	bcc	10000dec <rt_components_init+0x1c>
			}
		}
	}
#endif

}
10000e18:	e24bd004 	sub	sp, fp, #4
10000e1c:	e8bd8800 	pop	{fp, pc}

10000e20 <rt_device_register>:
 * @return the error code, RT_EOK on initialization successfully.
 */
rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags)
{
10000e20:	e92d4800 	push	{fp, lr}
10000e24:	e28db004 	add	fp, sp, #4
10000e28:	e24dd010 	sub	sp, sp, #16
10000e2c:	e50b0008 	str	r0, [fp, #-8]
10000e30:	e50b100c 	str	r1, [fp, #-12]
10000e34:	e1a03002 	mov	r3, r2
10000e38:	e14b30be 	strh	r3, [fp, #-14]
    if (dev == RT_NULL)
10000e3c:	e51b3008 	ldr	r3, [fp, #-8]
10000e40:	e3530000 	cmp	r3, #0
10000e44:	1a000001 	bne	10000e50 <rt_device_register+0x30>
        return -RT_ERROR;
10000e48:	e3e03000 	mvn	r3, #0
10000e4c:	ea000012 	b	10000e9c <rt_device_register+0x7c>

    if (rt_device_find(name) != RT_NULL)
10000e50:	e51b000c 	ldr	r0, [fp, #-12]
10000e54:	eb00002e 	bl	10000f14 <rt_device_find>
10000e58:	e1a03000 	mov	r3, r0
10000e5c:	e3530000 	cmp	r3, #0
10000e60:	0a000001 	beq	10000e6c <rt_device_register+0x4c>
        return -RT_ERROR;
10000e64:	e3e03000 	mvn	r3, #0
10000e68:	ea00000b 	b	10000e9c <rt_device_register+0x7c>

    rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
10000e6c:	e51b3008 	ldr	r3, [fp, #-8]
10000e70:	e1a00003 	mov	r0, r3
10000e74:	e3a01007 	mov	r1, #7
10000e78:	e51b200c 	ldr	r2, [fp, #-12]
10000e7c:	eb001a66 	bl	1000781c <rt_object_init>
    dev->flag = flags;
10000e80:	e51b3008 	ldr	r3, [fp, #-8]
10000e84:	e15b20be 	ldrh	r2, [fp, #-14]
10000e88:	e1c321b2 	strh	r2, [r3, #18]
    dev->ref_count = 0;
10000e8c:	e51b3008 	ldr	r3, [fp, #-8]
10000e90:	e3a02000 	mov	r2, #0
10000e94:	e5c32016 	strb	r2, [r3, #22]

    return RT_EOK;
10000e98:	e3a03000 	mov	r3, #0
}
10000e9c:	e1a00003 	mov	r0, r3
10000ea0:	e24bd004 	sub	sp, fp, #4
10000ea4:	e8bd8800 	pop	{fp, pc}

10000ea8 <rt_device_unregister>:
 * @param dev the pointer of device driver structure
 *
 * @return the error code, RT_EOK on successfully.
 */
rt_err_t rt_device_unregister(rt_device_t dev)
{
10000ea8:	e92d4800 	push	{fp, lr}
10000eac:	e28db004 	add	fp, sp, #4
10000eb0:	e24dd008 	sub	sp, sp, #8
10000eb4:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(dev != RT_NULL);
10000eb8:	e51b3008 	ldr	r3, [fp, #-8]
10000ebc:	e3530000 	cmp	r3, #0
10000ec0:	1a000005 	bne	10000edc <rt_device_unregister+0x34>
10000ec4:	e30e0200 	movw	r0, #57856	; 0xe200
10000ec8:	e3410001 	movt	r0, #4097	; 0x1001
10000ecc:	e30e125c 	movw	r1, #57948	; 0xe25c
10000ed0:	e3411001 	movt	r1, #4097	; 0x1001
10000ed4:	e3a02046 	mov	r2, #70	; 0x46
10000ed8:	eb0015ba 	bl	100065c8 <rt_assert_handler>

    rt_object_detach(&(dev->parent));
10000edc:	e51b3008 	ldr	r3, [fp, #-8]
10000ee0:	e1a00003 	mov	r0, r3
10000ee4:	eb001a7b 	bl	100078d8 <rt_object_detach>

    return RT_EOK;
10000ee8:	e3a03000 	mov	r3, #0
}
10000eec:	e1a00003 	mov	r0, r3
10000ef0:	e24bd004 	sub	sp, fp, #4
10000ef4:	e8bd8800 	pop	{fp, pc}

10000ef8 <rt_device_init_all>:
 *
 * @deprecated since 1.2.x, this function is not needed because the initialization 
 *             of a device is performed when applicaiton opens it.
 */
rt_err_t rt_device_init_all(void)
{
10000ef8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10000efc:	e28db000 	add	fp, sp, #0
    return RT_EOK;
10000f00:	e3a03000 	mov	r3, #0
}
10000f04:	e1a00003 	mov	r0, r3
10000f08:	e24bd000 	sub	sp, fp, #0
10000f0c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10000f10:	e12fff1e 	bx	lr

10000f14 <rt_device_find>:
 * @param name the device driver's name
 *
 * @return the registered device driver on successful, or RT_NULL on failure.
 */
rt_device_t rt_device_find(const char *name)
{
10000f14:	e92d4800 	push	{fp, lr}
10000f18:	e28db004 	add	fp, sp, #4
10000f1c:	e24dd018 	sub	sp, sp, #24
10000f20:	e50b0018 	str	r0, [fp, #-24]
    struct rt_object_information *information;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
10000f24:	eb001e27 	bl	100087c8 <rt_thread_self>
10000f28:	e1a03000 	mov	r3, r0
10000f2c:	e3530000 	cmp	r3, #0
10000f30:	0a000000 	beq	10000f38 <rt_device_find+0x24>
        rt_enter_critical();
10000f34:	eb001cdb 	bl	100082a8 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
10000f38:	e59f309c 	ldr	r3, [pc, #156]	; 10000fdc <rt_device_find+0xc8>
10000f3c:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
10000f40:	e51b300c 	ldr	r3, [fp, #-12]
10000f44:	e5933004 	ldr	r3, [r3, #4]
10000f48:	e50b3008 	str	r3, [fp, #-8]
10000f4c:	ea000014 	b	10000fa4 <rt_device_find+0x90>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
10000f50:	e51b3008 	ldr	r3, [fp, #-8]
10000f54:	e2433008 	sub	r3, r3, #8
10000f58:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
10000f5c:	e51b3010 	ldr	r3, [fp, #-16]
10000f60:	e1a00003 	mov	r0, r3
10000f64:	e51b1018 	ldr	r1, [fp, #-24]
10000f68:	e3a02006 	mov	r2, #6
10000f6c:	eb00109a 	bl	100051dc <rt_strncmp>
10000f70:	e1a03000 	mov	r3, r0
10000f74:	e3530000 	cmp	r3, #0
10000f78:	1a000006 	bne	10000f98 <rt_device_find+0x84>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
10000f7c:	eb001e11 	bl	100087c8 <rt_thread_self>
10000f80:	e1a03000 	mov	r3, r0
10000f84:	e3530000 	cmp	r3, #0
10000f88:	0a000000 	beq	10000f90 <rt_device_find+0x7c>
                rt_exit_critical();
10000f8c:	eb001cd7 	bl	100082f0 <rt_exit_critical>

            return (rt_device_t)object;
10000f90:	e51b3010 	ldr	r3, [fp, #-16]
10000f94:	ea00000d 	b	10000fd0 <rt_device_find+0xbc>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
10000f98:	e51b3008 	ldr	r3, [fp, #-8]
10000f9c:	e5933000 	ldr	r3, [r3]
10000fa0:	e50b3008 	str	r3, [fp, #-8]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
         node != &(information->object_list);
10000fa4:	e51b300c 	ldr	r3, [fp, #-12]
10000fa8:	e2832004 	add	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Device];
    for (node  = information->object_list.next;
10000fac:	e51b3008 	ldr	r3, [fp, #-8]
10000fb0:	e1520003 	cmp	r2, r3
10000fb4:	1affffe5 	bne	10000f50 <rt_device_find+0x3c>
            return (rt_device_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
10000fb8:	eb001e02 	bl	100087c8 <rt_thread_self>
10000fbc:	e1a03000 	mov	r3, r0
10000fc0:	e3530000 	cmp	r3, #0
10000fc4:	0a000000 	beq	10000fcc <rt_device_find+0xb8>
        rt_exit_critical();
10000fc8:	eb001cc8 	bl	100082f0 <rt_exit_critical>

    /* not found */
    return RT_NULL;
10000fcc:	e3a03000 	mov	r3, #0
}
10000fd0:	e1a00003 	mov	r0, r3
10000fd4:	e24bd004 	sub	sp, fp, #4
10000fd8:	e8bd8800 	pop	{fp, pc}
10000fdc:	10020a28 	.word	0x10020a28

10000fe0 <rt_device_init>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_init(rt_device_t dev)
{
10000fe0:	e92d4800 	push	{fp, lr}
10000fe4:	e28db004 	add	fp, sp, #4
10000fe8:	e24dd010 	sub	sp, sp, #16
10000fec:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
10000ff0:	e3a03000 	mov	r3, #0
10000ff4:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
10000ff8:	e51b3010 	ldr	r3, [fp, #-16]
10000ffc:	e3530000 	cmp	r3, #0
10001000:	1a000005 	bne	1000101c <rt_device_init+0x3c>
10001004:	e30e0200 	movw	r0, #57856	; 0xe200
10001008:	e3410001 	movt	r0, #4097	; 0x1001
1000100c:	e30e1274 	movw	r1, #57972	; 0xe274
10001010:	e3411001 	movt	r1, #4097	; 0x1001
10001014:	e3a02093 	mov	r2, #147	; 0x93
10001018:	eb00156a 	bl	100065c8 <rt_assert_handler>

    /* get device init handler */
    if (dev->init != RT_NULL)
1000101c:	e51b3010 	ldr	r3, [fp, #-16]
10001020:	e5933020 	ldr	r3, [r3, #32]
10001024:	e3530000 	cmp	r3, #0
10001028:	0a000019 	beq	10001094 <rt_device_init+0xb4>
    {
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
1000102c:	e51b3010 	ldr	r3, [fp, #-16]
10001030:	e1d331b2 	ldrh	r3, [r3, #18]
10001034:	e2033010 	and	r3, r3, #16
10001038:	e3530000 	cmp	r3, #0
1000103c:	1a000014 	bne	10001094 <rt_device_init+0xb4>
        {
            result = dev->init(dev);
10001040:	e51b3010 	ldr	r3, [fp, #-16]
10001044:	e5933020 	ldr	r3, [r3, #32]
10001048:	e51b0010 	ldr	r0, [fp, #-16]
1000104c:	e12fff33 	blx	r3
10001050:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
10001054:	e51b3008 	ldr	r3, [fp, #-8]
10001058:	e3530000 	cmp	r3, #0
1000105c:	0a000006 	beq	1000107c <rt_device_init+0x9c>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
10001060:	e51b3010 	ldr	r3, [fp, #-16]
        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
10001064:	e30e0210 	movw	r0, #57872	; 0xe210
10001068:	e3410001 	movt	r0, #4097	; 0x1001
1000106c:	e1a01003 	mov	r1, r3
10001070:	e51b2008 	ldr	r2, [fp, #-8]
10001074:	eb001496 	bl	100062d4 <rt_kprintf>
10001078:	ea000005 	b	10001094 <rt_device_init+0xb4>
                           dev->parent.name, result);
            }
            else
            {
                dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
1000107c:	e51b3010 	ldr	r3, [fp, #-16]
10001080:	e1d331b2 	ldrh	r3, [r3, #18]
10001084:	e3833010 	orr	r3, r3, #16
10001088:	e6ff2073 	uxth	r2, r3
1000108c:	e51b3010 	ldr	r3, [fp, #-16]
10001090:	e1c321b2 	strh	r2, [r3, #18]
            }
        }
    }

    return result;
10001094:	e51b3008 	ldr	r3, [fp, #-8]
}
10001098:	e1a00003 	mov	r0, r3
1000109c:	e24bd004 	sub	sp, fp, #4
100010a0:	e8bd8800 	pop	{fp, pc}

100010a4 <rt_device_open>:
 * @param oflag the flags for device open
 *
 * @return the result
 */
rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
{
100010a4:	e92d4800 	push	{fp, lr}
100010a8:	e28db004 	add	fp, sp, #4
100010ac:	e24dd010 	sub	sp, sp, #16
100010b0:	e50b0010 	str	r0, [fp, #-16]
100010b4:	e1a03001 	mov	r3, r1
100010b8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
    rt_err_t result = RT_EOK;
100010bc:	e3a03000 	mov	r3, #0
100010c0:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
100010c4:	e51b3010 	ldr	r3, [fp, #-16]
100010c8:	e3530000 	cmp	r3, #0
100010cc:	1a000005 	bne	100010e8 <rt_device_open+0x44>
100010d0:	e30e0200 	movw	r0, #57856	; 0xe200
100010d4:	e3410001 	movt	r0, #4097	; 0x1001
100010d8:	e30e1284 	movw	r1, #57988	; 0xe284
100010dc:	e3411001 	movt	r1, #4097	; 0x1001
100010e0:	e3a020b6 	mov	r2, #182	; 0xb6
100010e4:	eb001537 	bl	100065c8 <rt_assert_handler>

    /* if device is not initialized, initialize it. */
    if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
100010e8:	e51b3010 	ldr	r3, [fp, #-16]
100010ec:	e1d331b2 	ldrh	r3, [r3, #18]
100010f0:	e2033010 	and	r3, r3, #16
100010f4:	e3530000 	cmp	r3, #0
100010f8:	1a000019 	bne	10001164 <rt_device_open+0xc0>
    {
        if (dev->init != RT_NULL)
100010fc:	e51b3010 	ldr	r3, [fp, #-16]
10001100:	e5933020 	ldr	r3, [r3, #32]
10001104:	e3530000 	cmp	r3, #0
10001108:	0a00000f 	beq	1000114c <rt_device_open+0xa8>
        {
            result = dev->init(dev);
1000110c:	e51b3010 	ldr	r3, [fp, #-16]
10001110:	e5933020 	ldr	r3, [r3, #32]
10001114:	e51b0010 	ldr	r0, [fp, #-16]
10001118:	e12fff33 	blx	r3
1000111c:	e50b0008 	str	r0, [fp, #-8]
            if (result != RT_EOK)
10001120:	e51b3008 	ldr	r3, [fp, #-8]
10001124:	e3530000 	cmp	r3, #0
10001128:	0a000007 	beq	1000114c <rt_device_open+0xa8>
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
                           dev->parent.name, result);
1000112c:	e51b3010 	ldr	r3, [fp, #-16]
        if (dev->init != RT_NULL)
        {
            result = dev->init(dev);
            if (result != RT_EOK)
            {
                rt_kprintf("To initialize device:%s failed. The error code is %d\n",
10001130:	e30e0210 	movw	r0, #57872	; 0xe210
10001134:	e3410001 	movt	r0, #4097	; 0x1001
10001138:	e1a01003 	mov	r1, r3
1000113c:	e51b2008 	ldr	r2, [fp, #-8]
10001140:	eb001463 	bl	100062d4 <rt_kprintf>
                           dev->parent.name, result);

                return result;
10001144:	e51b3008 	ldr	r3, [fp, #-8]
10001148:	ea000038 	b	10001230 <rt_device_open+0x18c>
            }
        }

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
1000114c:	e51b3010 	ldr	r3, [fp, #-16]
10001150:	e1d331b2 	ldrh	r3, [r3, #18]
10001154:	e3833010 	orr	r3, r3, #16
10001158:	e6ff2073 	uxth	r2, r3
1000115c:	e51b3010 	ldr	r3, [fp, #-16]
10001160:	e1c321b2 	strh	r2, [r3, #18]
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
10001164:	e51b3010 	ldr	r3, [fp, #-16]
10001168:	e1d331b2 	ldrh	r3, [r3, #18]
1000116c:	e2033008 	and	r3, r3, #8
10001170:	e3530000 	cmp	r3, #0
10001174:	0a000006 	beq	10001194 <rt_device_open+0xf0>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
10001178:	e51b3010 	ldr	r3, [fp, #-16]
1000117c:	e1d331b4 	ldrh	r3, [r3, #20]
10001180:	e2033008 	and	r3, r3, #8

        dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
    }

    /* device is a stand alone device and opened */
    if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
10001184:	e3530000 	cmp	r3, #0
10001188:	0a000001 	beq	10001194 <rt_device_open+0xf0>
        (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
    {
        return -RT_EBUSY;
1000118c:	e3e03006 	mvn	r3, #6
10001190:	ea000026 	b	10001230 <rt_device_open+0x18c>
    }

    /* call device open interface */
    if (dev->open != RT_NULL)
10001194:	e51b3010 	ldr	r3, [fp, #-16]
10001198:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000119c:	e3530000 	cmp	r3, #0
100011a0:	0a000006 	beq	100011c0 <rt_device_open+0x11c>
    {
        result = dev->open(dev, oflag);
100011a4:	e51b3010 	ldr	r3, [fp, #-16]
100011a8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
100011ac:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
100011b0:	e51b0010 	ldr	r0, [fp, #-16]
100011b4:	e1a01002 	mov	r1, r2
100011b8:	e12fff33 	blx	r3
100011bc:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
100011c0:	e51b3008 	ldr	r3, [fp, #-8]
100011c4:	e3530000 	cmp	r3, #0
100011c8:	0a000002 	beq	100011d8 <rt_device_open+0x134>
100011cc:	e51b3008 	ldr	r3, [fp, #-8]
100011d0:	e3730006 	cmn	r3, #6
100011d4:	1a000014 	bne	1000122c <rt_device_open+0x188>
    {
        dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
100011d8:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
100011dc:	e3833008 	orr	r3, r3, #8
100011e0:	e6ff2073 	uxth	r2, r3
100011e4:	e51b3010 	ldr	r3, [fp, #-16]
100011e8:	e1c321b4 	strh	r2, [r3, #20]

        dev->ref_count++;
100011ec:	e51b3010 	ldr	r3, [fp, #-16]
100011f0:	e5d33016 	ldrb	r3, [r3, #22]
100011f4:	e2833001 	add	r3, r3, #1
100011f8:	e6ef2073 	uxtb	r2, r3
100011fc:	e51b3010 	ldr	r3, [fp, #-16]
10001200:	e5c32016 	strb	r2, [r3, #22]
        /* don't let bad things happen silently. If you are bitten by this assert,
         * please set the ref_count to a bigger type. */
        RT_ASSERT(dev->ref_count != 0);
10001204:	e51b3010 	ldr	r3, [fp, #-16]
10001208:	e5d33016 	ldrb	r3, [r3, #22]
1000120c:	e3530000 	cmp	r3, #0
10001210:	1a000005 	bne	1000122c <rt_device_open+0x188>
10001214:	e30e0248 	movw	r0, #57928	; 0xe248
10001218:	e3410001 	movt	r0, #4097	; 0x1001
1000121c:	e30e1284 	movw	r1, #57988	; 0xe284
10001220:	e3411001 	movt	r1, #4097	; 0x1001
10001224:	e3a020df 	mov	r2, #223	; 0xdf
10001228:	eb0014e6 	bl	100065c8 <rt_assert_handler>
    }

    return result;
1000122c:	e51b3008 	ldr	r3, [fp, #-8]
}
10001230:	e1a00003 	mov	r0, r3
10001234:	e24bd004 	sub	sp, fp, #4
10001238:	e8bd8800 	pop	{fp, pc}

1000123c <rt_device_close>:
 * @param dev the pointer of device driver structure
 *
 * @return the result
 */
rt_err_t rt_device_close(rt_device_t dev)
{
1000123c:	e92d4800 	push	{fp, lr}
10001240:	e28db004 	add	fp, sp, #4
10001244:	e24dd010 	sub	sp, sp, #16
10001248:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000124c:	e3a03000 	mov	r3, #0
10001250:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(dev != RT_NULL);
10001254:	e51b3010 	ldr	r3, [fp, #-16]
10001258:	e3530000 	cmp	r3, #0
1000125c:	1a000005 	bne	10001278 <rt_device_close+0x3c>
10001260:	e30e0200 	movw	r0, #57856	; 0xe200
10001264:	e3410001 	movt	r0, #4097	; 0x1001
10001268:	e30e1294 	movw	r1, #58004	; 0xe294
1000126c:	e3411001 	movt	r1, #4097	; 0x1001
10001270:	e3a020f1 	mov	r2, #241	; 0xf1
10001274:	eb0014d3 	bl	100065c8 <rt_assert_handler>

    if (dev->ref_count == 0)
10001278:	e51b3010 	ldr	r3, [fp, #-16]
1000127c:	e5d33016 	ldrb	r3, [r3, #22]
10001280:	e3530000 	cmp	r3, #0
10001284:	1a000001 	bne	10001290 <rt_device_close+0x54>
        return -RT_ERROR;
10001288:	e3e03000 	mvn	r3, #0
1000128c:	ea00001e 	b	1000130c <rt_device_close+0xd0>

    dev->ref_count--;
10001290:	e51b3010 	ldr	r3, [fp, #-16]
10001294:	e5d33016 	ldrb	r3, [r3, #22]
10001298:	e2433001 	sub	r3, r3, #1
1000129c:	e6ef2073 	uxtb	r2, r3
100012a0:	e51b3010 	ldr	r3, [fp, #-16]
100012a4:	e5c32016 	strb	r2, [r3, #22]

    if (dev->ref_count != 0)
100012a8:	e51b3010 	ldr	r3, [fp, #-16]
100012ac:	e5d33016 	ldrb	r3, [r3, #22]
100012b0:	e3530000 	cmp	r3, #0
100012b4:	0a000001 	beq	100012c0 <rt_device_close+0x84>
        return RT_EOK;
100012b8:	e3a03000 	mov	r3, #0
100012bc:	ea000012 	b	1000130c <rt_device_close+0xd0>

    /* call device close interface */
    if (dev->close != RT_NULL)
100012c0:	e51b3010 	ldr	r3, [fp, #-16]
100012c4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
100012c8:	e3530000 	cmp	r3, #0
100012cc:	0a000004 	beq	100012e4 <rt_device_close+0xa8>
    {
        result = dev->close(dev);
100012d0:	e51b3010 	ldr	r3, [fp, #-16]
100012d4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
100012d8:	e51b0010 	ldr	r0, [fp, #-16]
100012dc:	e12fff33 	blx	r3
100012e0:	e50b0008 	str	r0, [fp, #-8]
    }

    /* set open flag */
    if (result == RT_EOK || result == -RT_ENOSYS)
100012e4:	e51b3008 	ldr	r3, [fp, #-8]
100012e8:	e3530000 	cmp	r3, #0
100012ec:	0a000002 	beq	100012fc <rt_device_close+0xc0>
100012f0:	e51b3008 	ldr	r3, [fp, #-8]
100012f4:	e3730006 	cmn	r3, #6
100012f8:	1a000002 	bne	10001308 <rt_device_close+0xcc>
        dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
100012fc:	e51b3010 	ldr	r3, [fp, #-16]
10001300:	e3a02000 	mov	r2, #0
10001304:	e1c321b4 	strh	r2, [r3, #20]

    return result;
10001308:	e51b3008 	ldr	r3, [fp, #-8]
}
1000130c:	e1a00003 	mov	r0, r3
10001310:	e24bd004 	sub	sp, fp, #4
10001314:	e8bd8800 	pop	{fp, pc}

10001318 <rt_device_read>:
 */
rt_size_t rt_device_read(rt_device_t dev,
                         rt_off_t    pos,
                         void       *buffer,
                         rt_size_t   size)
{
10001318:	e92d4800 	push	{fp, lr}
1000131c:	e28db004 	add	fp, sp, #4
10001320:	e24dd010 	sub	sp, sp, #16
10001324:	e50b0008 	str	r0, [fp, #-8]
10001328:	e50b100c 	str	r1, [fp, #-12]
1000132c:	e50b2010 	str	r2, [fp, #-16]
10001330:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(dev != RT_NULL);
10001334:	e51b3008 	ldr	r3, [fp, #-8]
10001338:	e3530000 	cmp	r3, #0
1000133c:	1a000005 	bne	10001358 <rt_device_read+0x40>
10001340:	e30e0200 	movw	r0, #57856	; 0xe200
10001344:	e3410001 	movt	r0, #4097	; 0x1001
10001348:	e30e12a4 	movw	r1, #58020	; 0xe2a4
1000134c:	e3411001 	movt	r1, #4097	; 0x1001
10001350:	e300211a 	movw	r2, #282	; 0x11a
10001354:	eb00149b 	bl	100065c8 <rt_assert_handler>

    if (dev->ref_count == 0)
10001358:	e51b3008 	ldr	r3, [fp, #-8]
1000135c:	e5d33016 	ldrb	r3, [r3, #22]
10001360:	e3530000 	cmp	r3, #0
10001364:	1a000003 	bne	10001378 <rt_device_read+0x60>
    {
        rt_set_errno(-RT_ERROR);
10001368:	e3e00000 	mvn	r0, #0
1000136c:	eb000db6 	bl	10004a4c <rt_set_errno>
        return 0;
10001370:	e3a03000 	mov	r3, #0
10001374:	ea00000f 	b	100013b8 <rt_device_read+0xa0>
    }

    /* call device read interface */
    if (dev->read != RT_NULL)
10001378:	e51b3008 	ldr	r3, [fp, #-8]
1000137c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10001380:	e3530000 	cmp	r3, #0
10001384:	0a000008 	beq	100013ac <rt_device_read+0x94>
    {
        return dev->read(dev, pos, buffer, size);
10001388:	e51b3008 	ldr	r3, [fp, #-8]
1000138c:	e593c02c 	ldr	ip, [r3, #44]	; 0x2c
10001390:	e51b0008 	ldr	r0, [fp, #-8]
10001394:	e51b100c 	ldr	r1, [fp, #-12]
10001398:	e51b2010 	ldr	r2, [fp, #-16]
1000139c:	e51b3014 	ldr	r3, [fp, #-20]
100013a0:	e12fff3c 	blx	ip
100013a4:	e1a03000 	mov	r3, r0
100013a8:	ea000002 	b	100013b8 <rt_device_read+0xa0>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
100013ac:	e3e00005 	mvn	r0, #5
100013b0:	eb000da5 	bl	10004a4c <rt_set_errno>

    return 0;
100013b4:	e3a03000 	mov	r3, #0
}
100013b8:	e1a00003 	mov	r0, r3
100013bc:	e24bd004 	sub	sp, fp, #4
100013c0:	e8bd8800 	pop	{fp, pc}

100013c4 <rt_device_write>:
 */
rt_size_t rt_device_write(rt_device_t dev,
                          rt_off_t    pos,
                          const void *buffer,
                          rt_size_t   size)
{
100013c4:	e92d4800 	push	{fp, lr}
100013c8:	e28db004 	add	fp, sp, #4
100013cc:	e24dd010 	sub	sp, sp, #16
100013d0:	e50b0008 	str	r0, [fp, #-8]
100013d4:	e50b100c 	str	r1, [fp, #-12]
100013d8:	e50b2010 	str	r2, [fp, #-16]
100013dc:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(dev != RT_NULL);
100013e0:	e51b3008 	ldr	r3, [fp, #-8]
100013e4:	e3530000 	cmp	r3, #0
100013e8:	1a000005 	bne	10001404 <rt_device_write+0x40>
100013ec:	e30e0200 	movw	r0, #57856	; 0xe200
100013f0:	e3410001 	movt	r0, #4097	; 0x1001
100013f4:	e30e12b4 	movw	r1, #58036	; 0xe2b4
100013f8:	e3411001 	movt	r1, #4097	; 0x1001
100013fc:	e3a02d05 	mov	r2, #320	; 0x140
10001400:	eb001470 	bl	100065c8 <rt_assert_handler>

    if (dev->ref_count == 0)
10001404:	e51b3008 	ldr	r3, [fp, #-8]
10001408:	e5d33016 	ldrb	r3, [r3, #22]
1000140c:	e3530000 	cmp	r3, #0
10001410:	1a000003 	bne	10001424 <rt_device_write+0x60>
    {
        rt_set_errno(-RT_ERROR);
10001414:	e3e00000 	mvn	r0, #0
10001418:	eb000d8b 	bl	10004a4c <rt_set_errno>
        return 0;
1000141c:	e3a03000 	mov	r3, #0
10001420:	ea00000f 	b	10001464 <rt_device_write+0xa0>
    }

    /* call device write interface */
    if (dev->write != RT_NULL)
10001424:	e51b3008 	ldr	r3, [fp, #-8]
10001428:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1000142c:	e3530000 	cmp	r3, #0
10001430:	0a000008 	beq	10001458 <rt_device_write+0x94>
    {
        return dev->write(dev, pos, buffer, size);
10001434:	e51b3008 	ldr	r3, [fp, #-8]
10001438:	e593c030 	ldr	ip, [r3, #48]	; 0x30
1000143c:	e51b0008 	ldr	r0, [fp, #-8]
10001440:	e51b100c 	ldr	r1, [fp, #-12]
10001444:	e51b2010 	ldr	r2, [fp, #-16]
10001448:	e51b3014 	ldr	r3, [fp, #-20]
1000144c:	e12fff3c 	blx	ip
10001450:	e1a03000 	mov	r3, r0
10001454:	ea000002 	b	10001464 <rt_device_write+0xa0>
    }

    /* set error code */
    rt_set_errno(-RT_ENOSYS);
10001458:	e3e00005 	mvn	r0, #5
1000145c:	eb000d7a 	bl	10004a4c <rt_set_errno>

    return 0;
10001460:	e3a03000 	mov	r3, #0
}
10001464:	e1a00003 	mov	r0, r3
10001468:	e24bd004 	sub	sp, fp, #4
1000146c:	e8bd8800 	pop	{fp, pc}

10001470 <rt_device_control>:
 * @param arg the argument of command
 *
 * @return the result
 */
rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
{
10001470:	e92d4800 	push	{fp, lr}
10001474:	e28db004 	add	fp, sp, #4
10001478:	e24dd010 	sub	sp, sp, #16
1000147c:	e50b0008 	str	r0, [fp, #-8]
10001480:	e1a03001 	mov	r3, r1
10001484:	e50b2010 	str	r2, [fp, #-16]
10001488:	e54b3009 	strb	r3, [fp, #-9]
    RT_ASSERT(dev != RT_NULL);
1000148c:	e51b3008 	ldr	r3, [fp, #-8]
10001490:	e3530000 	cmp	r3, #0
10001494:	1a000005 	bne	100014b0 <rt_device_control+0x40>
10001498:	e30e0200 	movw	r0, #57856	; 0xe200
1000149c:	e3410001 	movt	r0, #4097	; 0x1001
100014a0:	e30e12c4 	movw	r1, #58052	; 0xe2c4
100014a4:	e3411001 	movt	r1, #4097	; 0x1001
100014a8:	e3a02e16 	mov	r2, #352	; 0x160
100014ac:	eb001445 	bl	100065c8 <rt_assert_handler>

    /* call device write interface */
    if (dev->control != RT_NULL)
100014b0:	e51b3008 	ldr	r3, [fp, #-8]
100014b4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
100014b8:	e3530000 	cmp	r3, #0
100014bc:	0a000008 	beq	100014e4 <rt_device_control+0x74>
    {
        return dev->control(dev, cmd, arg);
100014c0:	e51b3008 	ldr	r3, [fp, #-8]
100014c4:	e5933034 	ldr	r3, [r3, #52]	; 0x34
100014c8:	e55b2009 	ldrb	r2, [fp, #-9]
100014cc:	e51b0008 	ldr	r0, [fp, #-8]
100014d0:	e1a01002 	mov	r1, r2
100014d4:	e51b2010 	ldr	r2, [fp, #-16]
100014d8:	e12fff33 	blx	r3
100014dc:	e1a03000 	mov	r3, r0
100014e0:	ea000000 	b	100014e8 <rt_device_control+0x78>
    }

    return RT_EOK;
100014e4:	e3a03000 	mov	r3, #0
}
100014e8:	e1a00003 	mov	r0, r3
100014ec:	e24bd004 	sub	sp, fp, #4
100014f0:	e8bd8800 	pop	{fp, pc}

100014f4 <rt_device_set_rx_indicate>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
{
100014f4:	e92d4800 	push	{fp, lr}
100014f8:	e28db004 	add	fp, sp, #4
100014fc:	e24dd008 	sub	sp, sp, #8
10001500:	e50b0008 	str	r0, [fp, #-8]
10001504:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(dev != RT_NULL);
10001508:	e51b3008 	ldr	r3, [fp, #-8]
1000150c:	e3530000 	cmp	r3, #0
10001510:	1a000005 	bne	1000152c <rt_device_set_rx_indicate+0x38>
10001514:	e30e0200 	movw	r0, #57856	; 0xe200
10001518:	e3410001 	movt	r0, #4097	; 0x1001
1000151c:	e30e12d8 	movw	r1, #58072	; 0xe2d8
10001520:	e3411001 	movt	r1, #4097	; 0x1001
10001524:	e3002179 	movw	r2, #377	; 0x179
10001528:	eb001426 	bl	100065c8 <rt_assert_handler>

    dev->rx_indicate = rx_ind;
1000152c:	e51b3008 	ldr	r3, [fp, #-8]
10001530:	e51b200c 	ldr	r2, [fp, #-12]
10001534:	e5832018 	str	r2, [r3, #24]

    return RT_EOK;
10001538:	e3a03000 	mov	r3, #0
}
1000153c:	e1a00003 	mov	r0, r3
10001540:	e24bd004 	sub	sp, fp, #4
10001544:	e8bd8800 	pop	{fp, pc}

10001548 <rt_device_set_tx_complete>:
 * @return RT_EOK
 */
rt_err_t
rt_device_set_tx_complete(rt_device_t dev,
                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
{
10001548:	e92d4800 	push	{fp, lr}
1000154c:	e28db004 	add	fp, sp, #4
10001550:	e24dd008 	sub	sp, sp, #8
10001554:	e50b0008 	str	r0, [fp, #-8]
10001558:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(dev != RT_NULL);
1000155c:	e51b3008 	ldr	r3, [fp, #-8]
10001560:	e3530000 	cmp	r3, #0
10001564:	1a000005 	bne	10001580 <rt_device_set_tx_complete+0x38>
10001568:	e30e0200 	movw	r0, #57856	; 0xe200
1000156c:	e3410001 	movt	r0, #4097	; 0x1001
10001570:	e30e12f4 	movw	r1, #58100	; 0xe2f4
10001574:	e3411001 	movt	r1, #4097	; 0x1001
10001578:	e300218e 	movw	r2, #398	; 0x18e
1000157c:	eb001411 	bl	100065c8 <rt_assert_handler>

    dev->tx_complete = tx_done;
10001580:	e51b3008 	ldr	r3, [fp, #-8]
10001584:	e51b200c 	ldr	r2, [fp, #-12]
10001588:	e583201c 	str	r2, [r3, #28]

    return RT_EOK;
1000158c:	e3a03000 	mov	r3, #0
}
10001590:	e1a00003 	mov	r0, r3
10001594:	e24bd004 	sub	sp, fp, #4
10001598:	e8bd8800 	pop	{fp, pc}

1000159c <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
1000159c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100015a0:	e28db000 	add	fp, sp, #0
100015a4:	e24dd00c 	sub	sp, sp, #12
100015a8:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
100015ac:	e51b3008 	ldr	r3, [fp, #-8]
100015b0:	e5933000 	ldr	r3, [r3]
100015b4:	e51b2008 	ldr	r2, [fp, #-8]
100015b8:	e5922004 	ldr	r2, [r2, #4]
100015bc:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
100015c0:	e51b3008 	ldr	r3, [fp, #-8]
100015c4:	e5933004 	ldr	r3, [r3, #4]
100015c8:	e51b2008 	ldr	r2, [fp, #-8]
100015cc:	e5922000 	ldr	r2, [r2]
100015d0:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
100015d4:	e51b3008 	ldr	r3, [fp, #-8]
100015d8:	e51b2008 	ldr	r2, [fp, #-8]
100015dc:	e5832004 	str	r2, [r3, #4]
100015e0:	e51b3008 	ldr	r3, [fp, #-8]
100015e4:	e5932004 	ldr	r2, [r3, #4]
100015e8:	e51b3008 	ldr	r3, [fp, #-8]
100015ec:	e5832000 	str	r2, [r3]
}
100015f0:	e24bd000 	sub	sp, fp, #0
100015f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100015f8:	e12fff1e 	bx	lr

100015fc <rt_thread_idle_sethook>:
 * @param hook the specified hook function
 *
 * @note the hook function must be simple and never be blocked or suspend.
 */
void rt_thread_idle_sethook(void (*hook)(void))
{
100015fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001600:	e28db000 	add	fp, sp, #0
10001604:	e24dd00c 	sub	sp, sp, #12
10001608:	e50b0008 	str	r0, [fp, #-8]
    rt_thread_idle_hook = hook;
1000160c:	e308331c 	movw	r3, #33564	; 0x831c
10001610:	e3413002 	movt	r3, #4098	; 0x1002
10001614:	e51b2008 	ldr	r2, [fp, #-8]
10001618:	e5832000 	str	r2, [r3]
}
1000161c:	e24bd000 	sub	sp, fp, #0
10001620:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001624:	e12fff1e 	bx	lr

10001628 <_has_defunct_thread>:
#endif

/* Return whether there is defunctional thread to be deleted. */
rt_inline int _has_defunct_thread(void)
{
10001628:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000162c:	e28db000 	add	fp, sp, #0
10001630:	e24dd00c 	sub	sp, sp, #12
     * So the compiler has a good reason that the rt_thread_defunct list does
     * not change within rt_thread_idle_excute thus optimize the "while" loop
     * into a "if".
     *
     * So add the volatile qualifier here. */
    const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
10001634:	e3093ea0 	movw	r3, #40608	; 0x9ea0
10001638:	e3413002 	movt	r3, #4098	; 0x1002
1000163c:	e50b3008 	str	r3, [fp, #-8]

    return l->next != l;
10001640:	e51b3008 	ldr	r3, [fp, #-8]
10001644:	e5932000 	ldr	r2, [r3]
10001648:	e51b3008 	ldr	r3, [fp, #-8]
1000164c:	e1520003 	cmp	r2, r3
10001650:	13a03001 	movne	r3, #1
10001654:	03a03000 	moveq	r3, #0
10001658:	e6ef3073 	uxtb	r3, r3
}
1000165c:	e1a00003 	mov	r0, r3
10001660:	e24bd000 	sub	sp, fp, #0
10001664:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10001668:	e12fff1e 	bx	lr

1000166c <rt_thread_idle_excute>:
 * @ingroup Thread
 *
 * This function will perform system background job when system idle.
 */
void rt_thread_idle_excute(void)
{
1000166c:	e92d4800 	push	{fp, lr}
10001670:	e28db004 	add	fp, sp, #4
10001674:	e24dd010 	sub	sp, sp, #16
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
10001678:	ea00003c 	b	10001770 <rt_thread_idle_excute+0x104>
        rt_base_t lock;
        rt_thread_t thread;
#ifdef RT_USING_MODULE
        rt_module_t module = RT_NULL;
#endif
        RT_DEBUG_NOT_IN_INTERRUPT;
1000167c:	eb00278e 	bl	1000b4bc <rt_hw_interrupt_disable>
10001680:	e50b0008 	str	r0, [fp, #-8]
10001684:	eb000ccd 	bl	100049c0 <rt_interrupt_get_nest>
10001688:	e1a03000 	mov	r3, r0
1000168c:	e3530000 	cmp	r3, #0
10001690:	0a00000a 	beq	100016c0 <rt_thread_idle_excute+0x54>
10001694:	e30e0310 	movw	r0, #58128	; 0xe310
10001698:	e3410001 	movt	r0, #4097	; 0x1001
1000169c:	e30e1340 	movw	r1, #58176	; 0xe340
100016a0:	e3411001 	movt	r1, #4097	; 0x1001
100016a4:	eb00130a 	bl	100062d4 <rt_kprintf>
100016a8:	e30e0334 	movw	r0, #58164	; 0xe334
100016ac:	e3410001 	movt	r0, #4097	; 0x1001
100016b0:	e30e1340 	movw	r1, #58176	; 0xe340
100016b4:	e3411001 	movt	r1, #4097	; 0x1001
100016b8:	e3a0205e 	mov	r2, #94	; 0x5e
100016bc:	eb0013c1 	bl	100065c8 <rt_assert_handler>
100016c0:	e51b0008 	ldr	r0, [fp, #-8]
100016c4:	eb002780 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
100016c8:	eb00277b 	bl	1000b4bc <rt_hw_interrupt_disable>
100016cc:	e50b000c 	str	r0, [fp, #-12]

        /* re-check whether list is empty */
        if (_has_defunct_thread())
100016d0:	ebffffd4 	bl	10001628 <_has_defunct_thread>
100016d4:	e1a03000 	mov	r3, r0
100016d8:	e3530000 	cmp	r3, #0
100016dc:	0a000018 	beq	10001744 <rt_thread_idle_excute+0xd8>
        {
            /* get defunct thread */
            thread = rt_list_entry(rt_thread_defunct.next,
100016e0:	e3093ea0 	movw	r3, #40608	; 0x9ea0
100016e4:	e3413002 	movt	r3, #4098	; 0x1002
100016e8:	e5933000 	ldr	r3, [r3]
100016ec:	e2433010 	sub	r3, r3, #16
100016f0:	e50b3010 	str	r3, [fp, #-16]
                /* detach module's main thread */
                module->module_thread = RT_NULL;
            }
#endif
            /* remove defunct thread */
            rt_list_remove(&(thread->tlist));
100016f4:	e51b3010 	ldr	r3, [fp, #-16]
100016f8:	e2833010 	add	r3, r3, #16
100016fc:	e1a00003 	mov	r0, r3
10001700:	ebffffa5 	bl	1000159c <rt_list_remove>
            /* invoke thread cleanup */
            if (thread->cleanup != RT_NULL)
10001704:	e51b3010 	ldr	r3, [fp, #-16]
10001708:	e5933070 	ldr	r3, [r3, #112]	; 0x70
1000170c:	e3530000 	cmp	r3, #0
10001710:	0a000003 	beq	10001724 <rt_thread_idle_excute+0xb8>
                thread->cleanup(thread);
10001714:	e51b3010 	ldr	r3, [fp, #-16]
10001718:	e5933070 	ldr	r3, [r3, #112]	; 0x70
1000171c:	e51b0010 	ldr	r0, [fp, #-16]
10001720:	e12fff33 	blx	r3

            /* if it's a system object, not delete it */
            if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
10001724:	e51b0010 	ldr	r0, [fp, #-16]
10001728:	eb001907 	bl	10007b4c <rt_object_is_systemobject>
1000172c:	e1a03000 	mov	r3, r0
10001730:	e3530001 	cmp	r3, #1
10001734:	1a000005 	bne	10001750 <rt_thread_idle_excute+0xe4>
            {
                /* enable interrupt */
                rt_hw_interrupt_enable(lock);
10001738:	e51b000c 	ldr	r0, [fp, #-12]
1000173c:	eb002762 	bl	1000b4cc <rt_hw_interrupt_enable>

                return;
10001740:	ea00000e 	b	10001780 <rt_thread_idle_excute+0x114>
            }
        }
        else
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(lock);
10001744:	e51b000c 	ldr	r0, [fp, #-12]
10001748:	eb00275f 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* may the defunct thread list is removed by others, just return */
            return;
1000174c:	ea00000b 	b	10001780 <rt_thread_idle_excute+0x114>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
10001750:	e51b000c 	ldr	r0, [fp, #-12]
10001754:	eb00275c 	bl	1000b4cc <rt_hw_interrupt_enable>
        if (thread->flags & RT_OBJECT_FLAG_MODULE)
            rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
        else
#endif
        /* release thread's stack */
        RT_KERNEL_FREE(thread->stack_addr);
10001758:	e51b3010 	ldr	r3, [fp, #-16]
1000175c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10001760:	e1a00003 	mov	r0, r3
10001764:	eb0016ea 	bl	10007314 <rt_free>
        /* delete thread object */
        rt_object_delete((rt_object_t)thread);
10001768:	e51b0010 	ldr	r0, [fp, #-16]
1000176c:	eb0018c7 	bl	10007a90 <rt_object_delete>
 */
void rt_thread_idle_excute(void)
{
    /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
     * will do all the cleanups. */
    while (_has_defunct_thread())
10001770:	ebffffac 	bl	10001628 <_has_defunct_thread>
10001774:	e1a03000 	mov	r3, r0
10001778:	e3530000 	cmp	r3, #0
1000177c:	1affffbe 	bne	1000167c <rt_thread_idle_excute+0x10>
            if (module->nref == 0)
                rt_module_destroy(module);
        }
#endif
    }
}
10001780:	e24bd004 	sub	sp, fp, #4
10001784:	e8bd8800 	pop	{fp, pc}

10001788 <rt_thread_idle_entry>:

static void rt_thread_idle_entry(void *parameter)
{
10001788:	e92d4800 	push	{fp, lr}
1000178c:	e28db004 	add	fp, sp, #4
10001790:	e24dd008 	sub	sp, sp, #8
10001794:	e50b0008 	str	r0, [fp, #-8]
    while (1)
    {
        #ifdef RT_USING_HOOK
        if (rt_thread_idle_hook != RT_NULL)
10001798:	e308331c 	movw	r3, #33564	; 0x831c
1000179c:	e3413002 	movt	r3, #4098	; 0x1002
100017a0:	e5933000 	ldr	r3, [r3]
100017a4:	e3530000 	cmp	r3, #0
100017a8:	0a000003 	beq	100017bc <rt_thread_idle_entry+0x34>
            rt_thread_idle_hook();
100017ac:	e308331c 	movw	r3, #33564	; 0x831c
100017b0:	e3413002 	movt	r3, #4098	; 0x1002
100017b4:	e5933000 	ldr	r3, [r3]
100017b8:	e12fff33 	blx	r3
        #endif

        rt_thread_idle_excute();
100017bc:	ebffffaa 	bl	1000166c <rt_thread_idle_excute>
    }
100017c0:	eafffff4 	b	10001798 <rt_thread_idle_entry+0x10>

100017c4 <rt_thread_idle_init>:
 * This function will initialize idle thread, then start it.
 *
 * @note this function must be invoked when system init.
 */
void rt_thread_idle_init(void)
{
100017c4:	e92d4800 	push	{fp, lr}
100017c8:	e28db004 	add	fp, sp, #4
100017cc:	e24dd010 	sub	sp, sp, #16
    /* initialize thread */
    rt_thread_init(&idle,
100017d0:	e308311c 	movw	r3, #33052	; 0x811c
100017d4:	e3413002 	movt	r3, #4098	; 0x1002
100017d8:	e58d3000 	str	r3, [sp]
100017dc:	e3a03c02 	mov	r3, #512	; 0x200
100017e0:	e58d3004 	str	r3, [sp, #4]
100017e4:	e3a0301f 	mov	r3, #31
100017e8:	e58d3008 	str	r3, [sp, #8]
100017ec:	e3a03020 	mov	r3, #32
100017f0:	e58d300c 	str	r3, [sp, #12]
100017f4:	e30800a4 	movw	r0, #32932	; 0x80a4
100017f8:	e3410002 	movt	r0, #4098	; 0x1002
100017fc:	e30e1338 	movw	r1, #58168	; 0xe338
10001800:	e3411001 	movt	r1, #4097	; 0x1001
10001804:	e3012788 	movw	r2, #6024	; 0x1788
10001808:	e3412000 	movt	r2, #4096	; 0x1000
1000180c:	e3a03000 	mov	r3, #0
10001810:	eb001bbe 	bl	10008710 <rt_thread_init>
                   sizeof(rt_thread_stack),
                   RT_THREAD_PRIORITY_MAX - 1,
                   32);

    /* startup */
    rt_thread_startup(&idle);
10001814:	e30800a4 	movw	r0, #32932	; 0x80a4
10001818:	e3410002 	movt	r0, #4098	; 0x1002
1000181c:	eb001bf2 	bl	100087ec <rt_thread_startup>
}
10001820:	e24bd004 	sub	sp, fp, #4
10001824:	e8bd8800 	pop	{fp, pc}

10001828 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10001828:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000182c:	e28db000 	add	fp, sp, #0
10001830:	e24dd00c 	sub	sp, sp, #12
10001834:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10001838:	e51b3008 	ldr	r3, [fp, #-8]
1000183c:	e51b2008 	ldr	r2, [fp, #-8]
10001840:	e5832004 	str	r2, [r3, #4]
10001844:	e51b3008 	ldr	r3, [fp, #-8]
10001848:	e5932004 	ldr	r2, [r3, #4]
1000184c:	e51b3008 	ldr	r3, [fp, #-8]
10001850:	e5832000 	str	r2, [r3]
}
10001854:	e24bd000 	sub	sp, fp, #0
10001858:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000185c:	e12fff1e 	bx	lr

10001860 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
10001860:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10001864:	e28db000 	add	fp, sp, #0
10001868:	e24dd00c 	sub	sp, sp, #12
1000186c:	e50b0008 	str	r0, [fp, #-8]
10001870:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
10001874:	e51b3008 	ldr	r3, [fp, #-8]
10001878:	e5933004 	ldr	r3, [r3, #4]
1000187c:	e51b200c 	ldr	r2, [fp, #-12]
10001880:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
10001884:	e51b3008 	ldr	r3, [fp, #-8]
10001888:	e5932004 	ldr	r2, [r3, #4]
1000188c:	e51b300c 	ldr	r3, [fp, #-12]
10001890:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
10001894:	e51b3008 	ldr	r3, [fp, #-8]
10001898:	e51b200c 	ldr	r2, [fp, #-12]
1000189c:	e5832004 	str	r2, [r3, #4]
    n->next = l;
100018a0:	e51b300c 	ldr	r3, [fp, #-12]
100018a4:	e51b2008 	ldr	r2, [fp, #-8]
100018a8:	e5832000 	str	r2, [r3]
}
100018ac:	e24bd000 	sub	sp, fp, #0
100018b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100018b4:	e12fff1e 	bx	lr

100018b8 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
100018b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100018bc:	e28db000 	add	fp, sp, #0
100018c0:	e24dd00c 	sub	sp, sp, #12
100018c4:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
100018c8:	e51b3008 	ldr	r3, [fp, #-8]
100018cc:	e5932000 	ldr	r2, [r3]
100018d0:	e51b3008 	ldr	r3, [fp, #-8]
100018d4:	e1520003 	cmp	r2, r3
100018d8:	03a03001 	moveq	r3, #1
100018dc:	13a03000 	movne	r3, #0
100018e0:	e6ef3073 	uxtb	r3, r3
}
100018e4:	e1a00003 	mov	r0, r3
100018e8:	e24bd000 	sub	sp, fp, #0
100018ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100018f0:	e12fff1e 	bx	lr

100018f4 <rt_ipc_object_init>:
 * @param ipc the IPC object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
{
100018f4:	e92d4800 	push	{fp, lr}
100018f8:	e28db004 	add	fp, sp, #4
100018fc:	e24dd008 	sub	sp, sp, #8
10001900:	e50b0008 	str	r0, [fp, #-8]
    /* init ipc object */
    rt_list_init(&(ipc->suspend_thread));
10001904:	e51b3008 	ldr	r3, [fp, #-8]
10001908:	e2833010 	add	r3, r3, #16
1000190c:	e1a00003 	mov	r0, r3
10001910:	ebffffc4 	bl	10001828 <rt_list_init>

    return RT_EOK;
10001914:	e3a03000 	mov	r3, #0
}
10001918:	e1a00003 	mov	r0, r3
1000191c:	e24bd004 	sub	sp, fp, #4
10001920:	e8bd8800 	pop	{fp, pc}

10001924 <rt_ipc_list_suspend>:
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
                                       struct rt_thread *thread,
                                       rt_uint8_t        flag)
{
10001924:	e92d4800 	push	{fp, lr}
10001928:	e28db004 	add	fp, sp, #4
1000192c:	e24dd018 	sub	sp, sp, #24
10001930:	e50b0010 	str	r0, [fp, #-16]
10001934:	e50b1014 	str	r1, [fp, #-20]
10001938:	e1a03002 	mov	r3, r2
1000193c:	e54b3015 	strb	r3, [fp, #-21]
    /* suspend thread */
    rt_thread_suspend(thread);
10001940:	e51b0014 	ldr	r0, [fp, #-20]
10001944:	eb001d01 	bl	10008d50 <rt_thread_suspend>

    switch (flag)
10001948:	e55b3015 	ldrb	r3, [fp, #-21]
1000194c:	e3530000 	cmp	r3, #0
10001950:	0a000002 	beq	10001960 <rt_ipc_list_suspend+0x3c>
10001954:	e3530001 	cmp	r3, #1
10001958:	0a000006 	beq	10001978 <rt_ipc_list_suspend+0x54>
1000195c:	ea00002c 	b	10001a14 <rt_ipc_list_suspend+0xf0>
    {
    case RT_IPC_FLAG_FIFO:
        rt_list_insert_before(list, &(thread->tlist));
10001960:	e51b3014 	ldr	r3, [fp, #-20]
10001964:	e2833010 	add	r3, r3, #16
10001968:	e51b0010 	ldr	r0, [fp, #-16]
1000196c:	e1a01003 	mov	r1, r3
10001970:	ebffffba 	bl	10001860 <rt_list_insert_before>
        break;
10001974:	ea000026 	b	10001a14 <rt_ipc_list_suspend+0xf0>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
10001978:	e51b3010 	ldr	r3, [fp, #-16]
1000197c:	e5933000 	ldr	r3, [r3]
10001980:	e50b3008 	str	r3, [fp, #-8]
10001984:	ea000013 	b	100019d8 <rt_ipc_list_suspend+0xb4>
            {
                sthread = rt_list_entry(n, struct rt_thread, tlist);
10001988:	e51b3008 	ldr	r3, [fp, #-8]
1000198c:	e2433010 	sub	r3, r3, #16
10001990:	e50b300c 	str	r3, [fp, #-12]

                /* find out */
                if (thread->current_priority < sthread->current_priority)
10001994:	e51b3014 	ldr	r3, [fp, #-20]
10001998:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000199c:	e51b300c 	ldr	r3, [fp, #-12]
100019a0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
100019a4:	e1520003 	cmp	r2, r3
100019a8:	2a000007 	bcs	100019cc <rt_ipc_list_suspend+0xa8>
                {
                    /* insert this thread before the sthread */
                    rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
100019ac:	e51b300c 	ldr	r3, [fp, #-12]
100019b0:	e2832010 	add	r2, r3, #16
100019b4:	e51b3014 	ldr	r3, [fp, #-20]
100019b8:	e2833010 	add	r3, r3, #16
100019bc:	e1a00002 	mov	r0, r2
100019c0:	e1a01003 	mov	r1, r3
100019c4:	ebffffa5 	bl	10001860 <rt_list_insert_before>
                    break;
100019c8:	ea000006 	b	100019e8 <rt_ipc_list_suspend+0xc4>
        {
            struct rt_list_node *n;
            struct rt_thread *sthread;

            /* find a suitable position */
            for (n = list->next; n != list; n = n->next)
100019cc:	e51b3008 	ldr	r3, [fp, #-8]
100019d0:	e5933000 	ldr	r3, [r3]
100019d4:	e50b3008 	str	r3, [fp, #-8]
100019d8:	e51b2008 	ldr	r2, [fp, #-8]
100019dc:	e51b3010 	ldr	r3, [fp, #-16]
100019e0:	e1520003 	cmp	r2, r3
100019e4:	1affffe7 	bne	10001988 <rt_ipc_list_suspend+0x64>

            /*
             * not found a suitable position,
             * append to the end of suspend_thread list
             */
            if (n == list)
100019e8:	e51b2008 	ldr	r2, [fp, #-8]
100019ec:	e51b3010 	ldr	r3, [fp, #-16]
100019f0:	e1520003 	cmp	r2, r3
100019f4:	1a000005 	bne	10001a10 <rt_ipc_list_suspend+0xec>
                rt_list_insert_before(list, &(thread->tlist));
100019f8:	e51b3014 	ldr	r3, [fp, #-20]
100019fc:	e2833010 	add	r3, r3, #16
10001a00:	e51b0010 	ldr	r0, [fp, #-16]
10001a04:	e1a01003 	mov	r1, r3
10001a08:	ebffff94 	bl	10001860 <rt_list_insert_before>
        }
        break;
10001a0c:	eaffffff 	b	10001a10 <rt_ipc_list_suspend+0xec>
10001a10:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
10001a14:	e3a03000 	mov	r3, #0
}
10001a18:	e1a00003 	mov	r0, r3
10001a1c:	e24bd004 	sub	sp, fp, #4
10001a20:	e8bd8800 	pop	{fp, pc}

10001a24 <rt_ipc_list_resume>:
 * @param list the thread list
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
{
10001a24:	e92d4800 	push	{fp, lr}
10001a28:	e28db004 	add	fp, sp, #4
10001a2c:	e24dd010 	sub	sp, sp, #16
10001a30:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;

    /* get thread entry */
    thread = rt_list_entry(list->next, struct rt_thread, tlist);
10001a34:	e51b3010 	ldr	r3, [fp, #-16]
10001a38:	e5933000 	ldr	r3, [r3]
10001a3c:	e2433010 	sub	r3, r3, #16
10001a40:	e50b3008 	str	r3, [fp, #-8]

    RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));

    /* resume it */
    rt_thread_resume(thread);
10001a44:	e51b0008 	ldr	r0, [fp, #-8]
10001a48:	eb001ce4 	bl	10008de0 <rt_thread_resume>

    return RT_EOK;
10001a4c:	e3a03000 	mov	r3, #0
}
10001a50:	e1a00003 	mov	r0, r3
10001a54:	e24bd004 	sub	sp, fp, #4
10001a58:	e8bd8800 	pop	{fp, pc}

10001a5c <rt_ipc_list_resume_all>:
 * @param list of the threads to resume
 *
 * @return the operation status, RT_EOK on successful
 */
rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
{
10001a5c:	e92d4810 	push	{r4, fp, lr}
10001a60:	e28db008 	add	fp, sp, #8
10001a64:	e24dd014 	sub	sp, sp, #20
10001a68:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
10001a6c:	ea00000e 	b	10001aac <rt_ipc_list_resume_all+0x50>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10001a70:	eb002691 	bl	1000b4bc <rt_hw_interrupt_disable>
10001a74:	e1a03000 	mov	r3, r0
10001a78:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(list->next, struct rt_thread, tlist);
10001a7c:	e51b3018 	ldr	r3, [fp, #-24]
10001a80:	e5933000 	ldr	r3, [r3]
10001a84:	e2433010 	sub	r3, r3, #16
10001a88:	e50b3010 	str	r3, [fp, #-16]
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
10001a8c:	e51b3010 	ldr	r3, [fp, #-16]
10001a90:	e3e02000 	mvn	r2, #0
10001a94:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
10001a98:	e51b0010 	ldr	r0, [fp, #-16]
10001a9c:	eb001ccf 	bl	10008de0 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10001aa0:	e1a03004 	mov	r3, r4
10001aa4:	e1a00003 	mov	r0, r3
10001aa8:	eb002687 	bl	1000b4cc <rt_hw_interrupt_enable>
{
    struct rt_thread *thread;
    register rt_ubase_t temp;

    /* wakeup all suspend threads */
    while (!rt_list_isempty(list))
10001aac:	e51b0018 	ldr	r0, [fp, #-24]
10001ab0:	ebffff80 	bl	100018b8 <rt_list_isempty>
10001ab4:	e1a03000 	mov	r3, r0
10001ab8:	e3530000 	cmp	r3, #0
10001abc:	0affffeb 	beq	10001a70 <rt_ipc_list_resume_all+0x14>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    return RT_EOK;
10001ac0:	e3a03000 	mov	r3, #0
}
10001ac4:	e1a00003 	mov	r0, r3
10001ac8:	e24bd008 	sub	sp, fp, #8
10001acc:	e8bd8810 	pop	{r4, fp, pc}

10001ad0 <rt_sem_init>:
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
{
10001ad0:	e92d4800 	push	{fp, lr}
10001ad4:	e28db004 	add	fp, sp, #4
10001ad8:	e24dd010 	sub	sp, sp, #16
10001adc:	e50b0008 	str	r0, [fp, #-8]
10001ae0:	e50b100c 	str	r1, [fp, #-12]
10001ae4:	e50b2010 	str	r2, [fp, #-16]
10001ae8:	e54b3011 	strb	r3, [fp, #-17]
    RT_ASSERT(sem != RT_NULL);
10001aec:	e51b3008 	ldr	r3, [fp, #-8]
10001af0:	e3530000 	cmp	r3, #0
10001af4:	1a000005 	bne	10001b10 <rt_sem_init+0x40>
10001af8:	e30e0358 	movw	r0, #58200	; 0xe358
10001afc:	e3410001 	movt	r0, #4097	; 0x1001
10001b00:	e30e1430 	movw	r1, #58416	; 0xe430
10001b04:	e3411001 	movt	r1, #4097	; 0x1001
10001b08:	e3a020d8 	mov	r2, #216	; 0xd8
10001b0c:	eb0012ad 	bl	100065c8 <rt_assert_handler>

    /* init object */
    rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
10001b10:	e51b3008 	ldr	r3, [fp, #-8]
10001b14:	e1a00003 	mov	r0, r3
10001b18:	e3a01001 	mov	r1, #1
10001b1c:	e51b200c 	ldr	r2, [fp, #-12]
10001b20:	eb00173d 	bl	1000781c <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
10001b24:	e51b3008 	ldr	r3, [fp, #-8]
10001b28:	e1a00003 	mov	r0, r3
10001b2c:	ebffff70 	bl	100018f4 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
10001b30:	e51b3010 	ldr	r3, [fp, #-16]
10001b34:	e6ff2073 	uxth	r2, r3
10001b38:	e51b3008 	ldr	r3, [fp, #-8]
10001b3c:	e1c321b8 	strh	r2, [r3, #24]

    /* set parent */
    sem->parent.parent.flag = flag;
10001b40:	e51b3008 	ldr	r3, [fp, #-8]
10001b44:	e55b2011 	ldrb	r2, [fp, #-17]
10001b48:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
10001b4c:	e3a03000 	mov	r3, #0
}
10001b50:	e1a00003 	mov	r0, r3
10001b54:	e24bd004 	sub	sp, fp, #4
10001b58:	e8bd8800 	pop	{fp, pc}

10001b5c <rt_sem_detach>:
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_sem_delete
 */
rt_err_t rt_sem_detach(rt_sem_t sem)
{
10001b5c:	e92d4800 	push	{fp, lr}
10001b60:	e28db004 	add	fp, sp, #4
10001b64:	e24dd008 	sub	sp, sp, #8
10001b68:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(sem != RT_NULL);
10001b6c:	e51b3008 	ldr	r3, [fp, #-8]
10001b70:	e3530000 	cmp	r3, #0
10001b74:	1a000005 	bne	10001b90 <rt_sem_detach+0x34>
10001b78:	e30e0358 	movw	r0, #58200	; 0xe358
10001b7c:	e3410001 	movt	r0, #4097	; 0x1001
10001b80:	e30e143c 	movw	r1, #58428	; 0xe43c
10001b84:	e3411001 	movt	r1, #4097	; 0x1001
10001b88:	e3a020f5 	mov	r2, #245	; 0xf5
10001b8c:	eb00128d 	bl	100065c8 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
10001b90:	e51b3008 	ldr	r3, [fp, #-8]
10001b94:	e2833010 	add	r3, r3, #16
10001b98:	e1a00003 	mov	r0, r3
10001b9c:	ebffffae 	bl	10001a5c <rt_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(sem->parent.parent));
10001ba0:	e51b3008 	ldr	r3, [fp, #-8]
10001ba4:	e1a00003 	mov	r0, r3
10001ba8:	eb00174a 	bl	100078d8 <rt_object_detach>

    return RT_EOK;
10001bac:	e3a03000 	mov	r3, #0
}
10001bb0:	e1a00003 	mov	r0, r3
10001bb4:	e24bd004 	sub	sp, fp, #4
10001bb8:	e8bd8800 	pop	{fp, pc}

10001bbc <rt_sem_create>:
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
{
10001bbc:	e92d4800 	push	{fp, lr}
10001bc0:	e28db004 	add	fp, sp, #4
10001bc4:	e24dd018 	sub	sp, sp, #24
10001bc8:	e50b0010 	str	r0, [fp, #-16]
10001bcc:	e50b1014 	str	r1, [fp, #-20]
10001bd0:	e1a03002 	mov	r3, r2
10001bd4:	e54b3015 	strb	r3, [fp, #-21]
    rt_sem_t sem;

    RT_DEBUG_NOT_IN_INTERRUPT;
10001bd8:	eb002637 	bl	1000b4bc <rt_hw_interrupt_disable>
10001bdc:	e50b0008 	str	r0, [fp, #-8]
10001be0:	eb000b76 	bl	100049c0 <rt_interrupt_get_nest>
10001be4:	e1a03000 	mov	r3, r0
10001be8:	e3530000 	cmp	r3, #0
10001bec:	0a00000a 	beq	10001c1c <rt_sem_create+0x60>
10001bf0:	e30e0368 	movw	r0, #58216	; 0xe368
10001bf4:	e3410001 	movt	r0, #4097	; 0x1001
10001bf8:	e30e144c 	movw	r1, #58444	; 0xe44c
10001bfc:	e3411001 	movt	r1, #4097	; 0x1001
10001c00:	eb0011b3 	bl	100062d4 <rt_kprintf>
10001c04:	e30e038c 	movw	r0, #58252	; 0xe38c
10001c08:	e3410001 	movt	r0, #4097	; 0x1001
10001c0c:	e30e144c 	movw	r1, #58444	; 0xe44c
10001c10:	e3411001 	movt	r1, #4097	; 0x1001
10001c14:	e3002111 	movw	r2, #273	; 0x111
10001c18:	eb00126a 	bl	100065c8 <rt_assert_handler>
10001c1c:	e51b0008 	ldr	r0, [fp, #-8]
10001c20:	eb002629 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* allocate object */
    sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
10001c24:	e3a00001 	mov	r0, #1
10001c28:	e51b1010 	ldr	r1, [fp, #-16]
10001c2c:	eb00174a 	bl	1000795c <rt_object_allocate>
10001c30:	e50b000c 	str	r0, [fp, #-12]
    if (sem == RT_NULL)
10001c34:	e51b300c 	ldr	r3, [fp, #-12]
10001c38:	e3530000 	cmp	r3, #0
10001c3c:	1a000001 	bne	10001c48 <rt_sem_create+0x8c>
        return sem;
10001c40:	e51b300c 	ldr	r3, [fp, #-12]
10001c44:	ea00000a 	b	10001c74 <rt_sem_create+0xb8>

    /* init ipc object */
    rt_ipc_object_init(&(sem->parent));
10001c48:	e51b300c 	ldr	r3, [fp, #-12]
10001c4c:	e1a00003 	mov	r0, r3
10001c50:	ebffff27 	bl	100018f4 <rt_ipc_object_init>

    /* set init value */
    sem->value = value;
10001c54:	e51b3014 	ldr	r3, [fp, #-20]
10001c58:	e6ff2073 	uxth	r2, r3
10001c5c:	e51b300c 	ldr	r3, [fp, #-12]
10001c60:	e1c321b8 	strh	r2, [r3, #24]

    /* set parent */
    sem->parent.parent.flag = flag;
10001c64:	e51b300c 	ldr	r3, [fp, #-12]
10001c68:	e55b2015 	ldrb	r2, [fp, #-21]
10001c6c:	e5c32007 	strb	r2, [r3, #7]

    return sem;
10001c70:	e51b300c 	ldr	r3, [fp, #-12]
}
10001c74:	e1a00003 	mov	r0, r3
10001c78:	e24bd004 	sub	sp, fp, #4
10001c7c:	e8bd8800 	pop	{fp, pc}

10001c80 <rt_sem_delete>:
 * @return the error code
 *
 * @see rt_sem_detach
 */
rt_err_t rt_sem_delete(rt_sem_t sem)
{
10001c80:	e92d4800 	push	{fp, lr}
10001c84:	e28db004 	add	fp, sp, #4
10001c88:	e24dd010 	sub	sp, sp, #16
10001c8c:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
10001c90:	eb002609 	bl	1000b4bc <rt_hw_interrupt_disable>
10001c94:	e50b0008 	str	r0, [fp, #-8]
10001c98:	eb000b48 	bl	100049c0 <rt_interrupt_get_nest>
10001c9c:	e1a03000 	mov	r3, r0
10001ca0:	e3530000 	cmp	r3, #0
10001ca4:	0a00000a 	beq	10001cd4 <rt_sem_delete+0x54>
10001ca8:	e30e0368 	movw	r0, #58216	; 0xe368
10001cac:	e3410001 	movt	r0, #4097	; 0x1001
10001cb0:	e30e145c 	movw	r1, #58460	; 0xe45c
10001cb4:	e3411001 	movt	r1, #4097	; 0x1001
10001cb8:	eb001185 	bl	100062d4 <rt_kprintf>
10001cbc:	e30e038c 	movw	r0, #58252	; 0xe38c
10001cc0:	e3410001 	movt	r0, #4097	; 0x1001
10001cc4:	e30e145c 	movw	r1, #58460	; 0xe45c
10001cc8:	e3411001 	movt	r1, #4097	; 0x1001
10001ccc:	e3a02e13 	mov	r2, #304	; 0x130
10001cd0:	eb00123c 	bl	100065c8 <rt_assert_handler>
10001cd4:	e51b0008 	ldr	r0, [fp, #-8]
10001cd8:	eb0025fb 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_ASSERT(sem != RT_NULL);
10001cdc:	e51b3010 	ldr	r3, [fp, #-16]
10001ce0:	e3530000 	cmp	r3, #0
10001ce4:	1a000005 	bne	10001d00 <rt_sem_delete+0x80>
10001ce8:	e30e0358 	movw	r0, #58200	; 0xe358
10001cec:	e3410001 	movt	r0, #4097	; 0x1001
10001cf0:	e30e145c 	movw	r1, #58460	; 0xe45c
10001cf4:	e3411001 	movt	r1, #4097	; 0x1001
10001cf8:	e3002132 	movw	r2, #306	; 0x132
10001cfc:	eb001231 	bl	100065c8 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
10001d00:	e51b3010 	ldr	r3, [fp, #-16]
10001d04:	e2833010 	add	r3, r3, #16
10001d08:	e1a00003 	mov	r0, r3
10001d0c:	ebffff52 	bl	10001a5c <rt_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(sem->parent.parent));
10001d10:	e51b3010 	ldr	r3, [fp, #-16]
10001d14:	e1a00003 	mov	r0, r3
10001d18:	eb00175c 	bl	10007a90 <rt_object_delete>

    return RT_EOK;
10001d1c:	e3a03000 	mov	r3, #0
}
10001d20:	e1a00003 	mov	r0, r3
10001d24:	e24bd004 	sub	sp, fp, #4
10001d28:	e8bd8800 	pop	{fp, pc}

10001d2c <rt_sem_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
{
10001d2c:	e92d4810 	push	{r4, fp, lr}
10001d30:	e28db008 	add	fp, sp, #8
10001d34:	e24dd01c 	sub	sp, sp, #28
10001d38:	e50b0020 	str	r0, [fp, #-32]
10001d3c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_base_t temp;
    struct rt_thread *thread;

    RT_ASSERT(sem != RT_NULL);
10001d40:	e51b3020 	ldr	r3, [fp, #-32]
10001d44:	e3530000 	cmp	r3, #0
10001d48:	1a000005 	bne	10001d64 <rt_sem_take+0x38>
10001d4c:	e30e0358 	movw	r0, #58200	; 0xe358
10001d50:	e3410001 	movt	r0, #4097	; 0x1001
10001d54:	e30e146c 	movw	r1, #58476	; 0xe46c
10001d58:	e3411001 	movt	r1, #4097	; 0x1001
10001d5c:	e300214d 	movw	r2, #333	; 0x14d
10001d60:	eb001218 	bl	100065c8 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
10001d64:	e3093d90 	movw	r3, #40336	; 0x9d90
10001d68:	e3413002 	movt	r3, #4098	; 0x1002
10001d6c:	e5933000 	ldr	r3, [r3]
10001d70:	e3530000 	cmp	r3, #0
10001d74:	0a000005 	beq	10001d90 <rt_sem_take+0x64>
10001d78:	e3093d90 	movw	r3, #40336	; 0x9d90
10001d7c:	e3413002 	movt	r3, #4098	; 0x1002
10001d80:	e5933000 	ldr	r3, [r3]
10001d84:	e51b2020 	ldr	r2, [fp, #-32]
10001d88:	e1a00002 	mov	r0, r2
10001d8c:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10001d90:	eb0025c9 	bl	1000b4bc <rt_hw_interrupt_disable>
10001d94:	e1a04000 	mov	r4, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (sem->value > 0)
10001d98:	e51b3020 	ldr	r3, [fp, #-32]
10001d9c:	e1d331b8 	ldrh	r3, [r3, #24]
10001da0:	e3530000 	cmp	r3, #0
10001da4:	0a000008 	beq	10001dcc <rt_sem_take+0xa0>
    {
        /* semaphore is available */
        sem->value --;
10001da8:	e51b3020 	ldr	r3, [fp, #-32]
10001dac:	e1d331b8 	ldrh	r3, [r3, #24]
10001db0:	e2433001 	sub	r3, r3, #1
10001db4:	e6ff2073 	uxth	r2, r3
10001db8:	e51b3020 	ldr	r3, [fp, #-32]
10001dbc:	e1c321b8 	strh	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10001dc0:	e1a00004 	mov	r0, r4
10001dc4:	eb0025c0 	bl	1000b4cc <rt_hw_interrupt_enable>
10001dc8:	ea000051 	b	10001f14 <rt_sem_take+0x1e8>
    }
    else
    {
        /* no waiting, return with timeout */
        if (time == 0)
10001dcc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10001dd0:	e3530000 	cmp	r3, #0
10001dd4:	1a000003 	bne	10001de8 <rt_sem_take+0xbc>
        {
            rt_hw_interrupt_enable(temp);
10001dd8:	e1a00004 	mov	r0, r4
10001ddc:	eb0025ba 	bl	1000b4cc <rt_hw_interrupt_enable>

            return -RT_ETIMEOUT;
10001de0:	e3e03001 	mvn	r3, #1
10001de4:	ea000056 	b	10001f44 <rt_sem_take+0x218>
        }
        else
        {
            /* current context checking */
            RT_DEBUG_IN_THREAD_CONTEXT;
10001de8:	eb0025b3 	bl	1000b4bc <rt_hw_interrupt_disable>
10001dec:	e50b0010 	str	r0, [fp, #-16]
10001df0:	eb001a74 	bl	100087c8 <rt_thread_self>
10001df4:	e1a03000 	mov	r3, r0
10001df8:	e3530000 	cmp	r3, #0
10001dfc:	1a00000a 	bne	10001e2c <rt_sem_take+0x100>
10001e00:	e30e0390 	movw	r0, #58256	; 0xe390
10001e04:	e3410001 	movt	r0, #4097	; 0x1001
10001e08:	e30e146c 	movw	r1, #58476	; 0xe46c
10001e0c:	e3411001 	movt	r1, #4097	; 0x1001
10001e10:	eb00112f 	bl	100062d4 <rt_kprintf>
10001e14:	e30e038c 	movw	r0, #58252	; 0xe38c
10001e18:	e3410001 	movt	r0, #4097	; 0x1001
10001e1c:	e30e146c 	movw	r1, #58476	; 0xe46c
10001e20:	e3411001 	movt	r1, #4097	; 0x1001
10001e24:	e300216d 	movw	r2, #365	; 0x16d
10001e28:	eb0011e6 	bl	100065c8 <rt_assert_handler>
10001e2c:	eb0025a2 	bl	1000b4bc <rt_hw_interrupt_disable>
10001e30:	e50b0014 	str	r0, [fp, #-20]
10001e34:	eb000ae1 	bl	100049c0 <rt_interrupt_get_nest>
10001e38:	e1a03000 	mov	r3, r0
10001e3c:	e3530000 	cmp	r3, #0
10001e40:	0a00000a 	beq	10001e70 <rt_sem_take+0x144>
10001e44:	e30e0368 	movw	r0, #58216	; 0xe368
10001e48:	e3410001 	movt	r0, #4097	; 0x1001
10001e4c:	e30e146c 	movw	r1, #58476	; 0xe46c
10001e50:	e3411001 	movt	r1, #4097	; 0x1001
10001e54:	eb00111e 	bl	100062d4 <rt_kprintf>
10001e58:	e30e038c 	movw	r0, #58252	; 0xe38c
10001e5c:	e3410001 	movt	r0, #4097	; 0x1001
10001e60:	e30e146c 	movw	r1, #58476	; 0xe46c
10001e64:	e3411001 	movt	r1, #4097	; 0x1001
10001e68:	e300216d 	movw	r2, #365	; 0x16d
10001e6c:	eb0011d5 	bl	100065c8 <rt_assert_handler>
10001e70:	e51b0014 	ldr	r0, [fp, #-20]
10001e74:	eb002594 	bl	1000b4cc <rt_hw_interrupt_enable>
10001e78:	e51b0010 	ldr	r0, [fp, #-16]
10001e7c:	eb002592 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* semaphore is unavailable, push to suspend list */
            /* get current thread */
            thread = rt_thread_self();
10001e80:	eb001a50 	bl	100087c8 <rt_thread_self>
10001e84:	e50b0018 	str	r0, [fp, #-24]

            /* reset thread error number */
            thread->error = RT_EOK;
10001e88:	e51b3018 	ldr	r3, [fp, #-24]
10001e8c:	e3a02000 	mov	r2, #0
10001e90:	e583202c 	str	r2, [r3, #44]	; 0x2c

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
                                        thread->name));

            /* suspend thread */
            rt_ipc_list_suspend(&(sem->parent.suspend_thread),
10001e94:	e51b3020 	ldr	r3, [fp, #-32]
10001e98:	e2832010 	add	r2, r3, #16
10001e9c:	e51b3020 	ldr	r3, [fp, #-32]
10001ea0:	e5d33007 	ldrb	r3, [r3, #7]
10001ea4:	e1a00002 	mov	r0, r2
10001ea8:	e51b1018 	ldr	r1, [fp, #-24]
10001eac:	e1a02003 	mov	r2, r3
10001eb0:	ebfffe9b 	bl	10001924 <rt_ipc_list_suspend>
                                thread,
                                sem->parent.parent.flag);

            /* has waiting time, start thread timer */
            if (time > 0)
10001eb4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10001eb8:	e3530000 	cmp	r3, #0
10001ebc:	da00000a 	ble	10001eec <rt_sem_take+0x1c0>
            {
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                            thread->name));

                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
10001ec0:	e51b3018 	ldr	r3, [fp, #-24]
10001ec4:	e2832048 	add	r2, r3, #72	; 0x48
10001ec8:	e24b3024 	sub	r3, fp, #36	; 0x24
10001ecc:	e1a00002 	mov	r0, r2
10001ed0:	e3a01000 	mov	r1, #0
10001ed4:	e1a02003 	mov	r2, r3
10001ed8:	eb001e4b 	bl	1000980c <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &time);
                rt_timer_start(&(thread->thread_timer));
10001edc:	e51b3018 	ldr	r3, [fp, #-24]
10001ee0:	e2833048 	add	r3, r3, #72	; 0x48
10001ee4:	e1a00003 	mov	r0, r3
10001ee8:	eb001d51 	bl	10009434 <rt_timer_start>
            }

            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
10001eec:	e1a00004 	mov	r0, r4
10001ef0:	eb002575 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
10001ef4:	eb001844 	bl	1000800c <rt_schedule>

            if (thread->error != RT_EOK)
10001ef8:	e51b3018 	ldr	r3, [fp, #-24]
10001efc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10001f00:	e3530000 	cmp	r3, #0
10001f04:	0a000002 	beq	10001f14 <rt_sem_take+0x1e8>
            {
                return thread->error;
10001f08:	e51b3018 	ldr	r3, [fp, #-24]
10001f0c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10001f10:	ea00000b 	b	10001f44 <rt_sem_take+0x218>
            }
        }
    }

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
10001f14:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10001f18:	e3413002 	movt	r3, #4098	; 0x1002
10001f1c:	e5933000 	ldr	r3, [r3]
10001f20:	e3530000 	cmp	r3, #0
10001f24:	0a000005 	beq	10001f40 <rt_sem_take+0x214>
10001f28:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10001f2c:	e3413002 	movt	r3, #4098	; 0x1002
10001f30:	e5933000 	ldr	r3, [r3]
10001f34:	e51b2020 	ldr	r2, [fp, #-32]
10001f38:	e1a00002 	mov	r0, r2
10001f3c:	e12fff33 	blx	r3

    return RT_EOK;
10001f40:	e3a03000 	mov	r3, #0
}
10001f44:	e1a00003 	mov	r0, r3
10001f48:	e24bd008 	sub	sp, fp, #8
10001f4c:	e8bd8810 	pop	{r4, fp, pc}

10001f50 <rt_sem_trytake>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_trytake(rt_sem_t sem)
{
10001f50:	e92d4800 	push	{fp, lr}
10001f54:	e28db004 	add	fp, sp, #4
10001f58:	e24dd008 	sub	sp, sp, #8
10001f5c:	e50b0008 	str	r0, [fp, #-8]
    return rt_sem_take(sem, 0);
10001f60:	e51b0008 	ldr	r0, [fp, #-8]
10001f64:	e3a01000 	mov	r1, #0
10001f68:	ebffff6f 	bl	10001d2c <rt_sem_take>
10001f6c:	e1a03000 	mov	r3, r0
}
10001f70:	e1a00003 	mov	r0, r3
10001f74:	e24bd004 	sub	sp, fp, #4
10001f78:	e8bd8800 	pop	{fp, pc}

10001f7c <rt_sem_release>:
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
{
10001f7c:	e92d4830 	push	{r4, r5, fp, lr}
10001f80:	e28db00c 	add	fp, sp, #12
10001f84:	e24dd008 	sub	sp, sp, #8
10001f88:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;
    register rt_bool_t need_schedule;

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
10001f8c:	e3093d88 	movw	r3, #40328	; 0x9d88
10001f90:	e3413002 	movt	r3, #4098	; 0x1002
10001f94:	e5933000 	ldr	r3, [r3]
10001f98:	e3530000 	cmp	r3, #0
10001f9c:	0a000005 	beq	10001fb8 <rt_sem_release+0x3c>
10001fa0:	e3093d88 	movw	r3, #40328	; 0x9d88
10001fa4:	e3413002 	movt	r3, #4098	; 0x1002
10001fa8:	e5933000 	ldr	r3, [r3]
10001fac:	e51b2010 	ldr	r2, [fp, #-16]
10001fb0:	e1a00002 	mov	r0, r2
10001fb4:	e12fff33 	blx	r3

    need_schedule = RT_FALSE;
10001fb8:	e3a04000 	mov	r4, #0

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10001fbc:	eb00253e 	bl	1000b4bc <rt_hw_interrupt_disable>
10001fc0:	e1a05000 	mov	r5, r0
    RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
                                rt_thread_self()->name,
                                ((struct rt_object *)sem)->name,
                                sem->value));

    if (!rt_list_isempty(&sem->parent.suspend_thread))
10001fc4:	e51b3010 	ldr	r3, [fp, #-16]
10001fc8:	e2833010 	add	r3, r3, #16
10001fcc:	e1a00003 	mov	r0, r3
10001fd0:	ebfffe38 	bl	100018b8 <rt_list_isempty>
10001fd4:	e1a03000 	mov	r3, r0
10001fd8:	e3530000 	cmp	r3, #0
10001fdc:	1a000005 	bne	10001ff8 <rt_sem_release+0x7c>
    {
        /* resume the suspended thread */
        rt_ipc_list_resume(&(sem->parent.suspend_thread));
10001fe0:	e51b3010 	ldr	r3, [fp, #-16]
10001fe4:	e2833010 	add	r3, r3, #16
10001fe8:	e1a00003 	mov	r0, r3
10001fec:	ebfffe8c 	bl	10001a24 <rt_ipc_list_resume>
        need_schedule = RT_TRUE;
10001ff0:	e3a04001 	mov	r4, #1
10001ff4:	ea000005 	b	10002010 <rt_sem_release+0x94>
    }
    else
        sem->value ++; /* increase value */
10001ff8:	e51b3010 	ldr	r3, [fp, #-16]
10001ffc:	e1d331b8 	ldrh	r3, [r3, #24]
10002000:	e2833001 	add	r3, r3, #1
10002004:	e6ff2073 	uxth	r2, r3
10002008:	e51b3010 	ldr	r3, [fp, #-16]
1000200c:	e1c321b8 	strh	r2, [r3, #24]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10002010:	e1a00005 	mov	r0, r5
10002014:	eb00252c 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* resume a thread, re-schedule */
    if (need_schedule == RT_TRUE)
10002018:	e3540001 	cmp	r4, #1
1000201c:	1a000000 	bne	10002024 <rt_sem_release+0xa8>
        rt_schedule();
10002020:	eb0017f9 	bl	1000800c <rt_schedule>

    return RT_EOK;
10002024:	e3a03000 	mov	r3, #0
}
10002028:	e1a00003 	mov	r0, r3
1000202c:	e24bd00c 	sub	sp, fp, #12
10002030:	e8bd8830 	pop	{r4, r5, fp, pc}

10002034 <rt_sem_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
{
10002034:	e92d4800 	push	{fp, lr}
10002038:	e28db004 	add	fp, sp, #4
1000203c:	e24dd018 	sub	sp, sp, #24
10002040:	e50b0010 	str	r0, [fp, #-16]
10002044:	e1a03001 	mov	r3, r1
10002048:	e50b2018 	str	r2, [fp, #-24]
1000204c:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(sem != RT_NULL);
10002050:	e51b3010 	ldr	r3, [fp, #-16]
10002054:	e3530000 	cmp	r3, #0
10002058:	1a000005 	bne	10002074 <rt_sem_control+0x40>
1000205c:	e30e0358 	movw	r0, #58200	; 0xe358
10002060:	e3410001 	movt	r0, #4097	; 0x1001
10002064:	e30e1478 	movw	r1, #58488	; 0xe478
10002068:	e3411001 	movt	r1, #4097	; 0x1001
1000206c:	e3a02f79 	mov	r2, #484	; 0x1e4
10002070:	eb001154 	bl	100065c8 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
10002074:	e55b3011 	ldrb	r3, [fp, #-17]
10002078:	e3530001 	cmp	r3, #1
1000207c:	1a000012 	bne	100020cc <rt_sem_control+0x98>
    {
        rt_uint32_t value;

        /* get value */
        value = (rt_uint32_t)arg;
10002080:	e51b3018 	ldr	r3, [fp, #-24]
10002084:	e50b3008 	str	r3, [fp, #-8]
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
10002088:	eb00250b 	bl	1000b4bc <rt_hw_interrupt_disable>
1000208c:	e1a03000 	mov	r3, r0
10002090:	e50b300c 	str	r3, [fp, #-12]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&sem->parent.suspend_thread);
10002094:	e51b3010 	ldr	r3, [fp, #-16]
10002098:	e2833010 	add	r3, r3, #16
1000209c:	e1a00003 	mov	r0, r3
100020a0:	ebfffe6d 	bl	10001a5c <rt_ipc_list_resume_all>

        /* set new value */
        sem->value = (rt_uint16_t)value;
100020a4:	e51b3008 	ldr	r3, [fp, #-8]
100020a8:	e6ff2073 	uxth	r2, r3
100020ac:	e51b3010 	ldr	r3, [fp, #-16]
100020b0:	e1c321b8 	strh	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100020b4:	e51b300c 	ldr	r3, [fp, #-12]
100020b8:	e1a00003 	mov	r0, r3
100020bc:	eb002502 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
100020c0:	eb0017d1 	bl	1000800c <rt_schedule>

        return RT_EOK;
100020c4:	e3a03000 	mov	r3, #0
100020c8:	ea000000 	b	100020d0 <rt_sem_control+0x9c>
    }

    return -RT_ERROR;
100020cc:	e3e03000 	mvn	r3, #0
}
100020d0:	e1a00003 	mov	r0, r3
100020d4:	e24bd004 	sub	sp, fp, #4
100020d8:	e8bd8800 	pop	{fp, pc}

100020dc <rt_mutex_init>:
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
{
100020dc:	e92d4800 	push	{fp, lr}
100020e0:	e28db004 	add	fp, sp, #4
100020e4:	e24dd010 	sub	sp, sp, #16
100020e8:	e50b0008 	str	r0, [fp, #-8]
100020ec:	e50b100c 	str	r1, [fp, #-12]
100020f0:	e1a03002 	mov	r3, r2
100020f4:	e54b300d 	strb	r3, [fp, #-13]
    RT_ASSERT(mutex != RT_NULL);
100020f8:	e51b3008 	ldr	r3, [fp, #-8]
100020fc:	e3530000 	cmp	r3, #0
10002100:	1a000005 	bne	1000211c <rt_mutex_init+0x40>
10002104:	e30e03c8 	movw	r0, #58312	; 0xe3c8
10002108:	e3410001 	movt	r0, #4097	; 0x1001
1000210c:	e30e1488 	movw	r1, #58504	; 0xe488
10002110:	e3411001 	movt	r1, #4097	; 0x1001
10002114:	e300220f 	movw	r2, #527	; 0x20f
10002118:	eb00112a 	bl	100065c8 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
1000211c:	e51b3008 	ldr	r3, [fp, #-8]
10002120:	e1a00003 	mov	r0, r3
10002124:	e3a01002 	mov	r1, #2
10002128:	e51b200c 	ldr	r2, [fp, #-12]
1000212c:	eb0015ba 	bl	1000781c <rt_object_init>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
10002130:	e51b3008 	ldr	r3, [fp, #-8]
10002134:	e1a00003 	mov	r0, r3
10002138:	ebfffded 	bl	100018f4 <rt_ipc_object_init>

    mutex->value = 1;
1000213c:	e51b3008 	ldr	r3, [fp, #-8]
10002140:	e3a02001 	mov	r2, #1
10002144:	e1c321b8 	strh	r2, [r3, #24]
    mutex->owner = RT_NULL;
10002148:	e51b3008 	ldr	r3, [fp, #-8]
1000214c:	e3a02000 	mov	r2, #0
10002150:	e583201c 	str	r2, [r3, #28]
    mutex->original_priority = 0xFF;
10002154:	e51b3008 	ldr	r3, [fp, #-8]
10002158:	e3e02000 	mvn	r2, #0
1000215c:	e5c3201a 	strb	r2, [r3, #26]
    mutex->hold  = 0;
10002160:	e51b3008 	ldr	r3, [fp, #-8]
10002164:	e3a02000 	mov	r2, #0
10002168:	e5c3201b 	strb	r2, [r3, #27]

    /* set flag */
    mutex->parent.parent.flag = flag;
1000216c:	e51b3008 	ldr	r3, [fp, #-8]
10002170:	e55b200d 	ldrb	r2, [fp, #-13]
10002174:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
10002178:	e3a03000 	mov	r3, #0
}
1000217c:	e1a00003 	mov	r0, r3
10002180:	e24bd004 	sub	sp, fp, #4
10002184:	e8bd8800 	pop	{fp, pc}

10002188 <rt_mutex_detach>:
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_mutex_delete
 */
rt_err_t rt_mutex_detach(rt_mutex_t mutex)
{
10002188:	e92d4800 	push	{fp, lr}
1000218c:	e28db004 	add	fp, sp, #4
10002190:	e24dd008 	sub	sp, sp, #8
10002194:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(mutex != RT_NULL);
10002198:	e51b3008 	ldr	r3, [fp, #-8]
1000219c:	e3530000 	cmp	r3, #0
100021a0:	1a000005 	bne	100021bc <rt_mutex_detach+0x34>
100021a4:	e30e03c8 	movw	r0, #58312	; 0xe3c8
100021a8:	e3410001 	movt	r0, #4097	; 0x1001
100021ac:	e30e1498 	movw	r1, #58520	; 0xe498
100021b0:	e3411001 	movt	r1, #4097	; 0x1001
100021b4:	e300222e 	movw	r2, #558	; 0x22e
100021b8:	eb001102 	bl	100065c8 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
100021bc:	e51b3008 	ldr	r3, [fp, #-8]
100021c0:	e2833010 	add	r3, r3, #16
100021c4:	e1a00003 	mov	r0, r3
100021c8:	ebfffe23 	bl	10001a5c <rt_ipc_list_resume_all>

    /* detach semaphore object */
    rt_object_detach(&(mutex->parent.parent));
100021cc:	e51b3008 	ldr	r3, [fp, #-8]
100021d0:	e1a00003 	mov	r0, r3
100021d4:	eb0015bf 	bl	100078d8 <rt_object_detach>

    return RT_EOK;
100021d8:	e3a03000 	mov	r3, #0
}
100021dc:	e1a00003 	mov	r0, r3
100021e0:	e24bd004 	sub	sp, fp, #4
100021e4:	e8bd8800 	pop	{fp, pc}

100021e8 <rt_mutex_create>:
 * @return the created mutex, RT_NULL on error happen
 *
 * @see rt_mutex_init
 */
rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
{
100021e8:	e92d4800 	push	{fp, lr}
100021ec:	e28db004 	add	fp, sp, #4
100021f0:	e24dd010 	sub	sp, sp, #16
100021f4:	e50b0010 	str	r0, [fp, #-16]
100021f8:	e1a03001 	mov	r3, r1
100021fc:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_mutex *mutex;

    RT_DEBUG_NOT_IN_INTERRUPT;
10002200:	eb0024ad 	bl	1000b4bc <rt_hw_interrupt_disable>
10002204:	e50b0008 	str	r0, [fp, #-8]
10002208:	eb0009ec 	bl	100049c0 <rt_interrupt_get_nest>
1000220c:	e1a03000 	mov	r3, r0
10002210:	e3530000 	cmp	r3, #0
10002214:	0a00000a 	beq	10002244 <rt_mutex_create+0x5c>
10002218:	e30e0368 	movw	r0, #58216	; 0xe368
1000221c:	e3410001 	movt	r0, #4097	; 0x1001
10002220:	e30e14a8 	movw	r1, #58536	; 0xe4a8
10002224:	e3411001 	movt	r1, #4097	; 0x1001
10002228:	eb001029 	bl	100062d4 <rt_kprintf>
1000222c:	e30e038c 	movw	r0, #58252	; 0xe38c
10002230:	e3410001 	movt	r0, #4097	; 0x1001
10002234:	e30e14a8 	movw	r1, #58536	; 0xe4a8
10002238:	e3411001 	movt	r1, #4097	; 0x1001
1000223c:	e3002249 	movw	r2, #585	; 0x249
10002240:	eb0010e0 	bl	100065c8 <rt_assert_handler>
10002244:	e51b0008 	ldr	r0, [fp, #-8]
10002248:	eb00249f 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* allocate object */
    mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
1000224c:	e3a00002 	mov	r0, #2
10002250:	e51b1010 	ldr	r1, [fp, #-16]
10002254:	eb0015c0 	bl	1000795c <rt_object_allocate>
10002258:	e50b000c 	str	r0, [fp, #-12]
    if (mutex == RT_NULL)
1000225c:	e51b300c 	ldr	r3, [fp, #-12]
10002260:	e3530000 	cmp	r3, #0
10002264:	1a000001 	bne	10002270 <rt_mutex_create+0x88>
        return mutex;
10002268:	e51b300c 	ldr	r3, [fp, #-12]
1000226c:	ea000012 	b	100022bc <rt_mutex_create+0xd4>

    /* init ipc object */
    rt_ipc_object_init(&(mutex->parent));
10002270:	e51b300c 	ldr	r3, [fp, #-12]
10002274:	e1a00003 	mov	r0, r3
10002278:	ebfffd9d 	bl	100018f4 <rt_ipc_object_init>

    mutex->value              = 1;
1000227c:	e51b300c 	ldr	r3, [fp, #-12]
10002280:	e3a02001 	mov	r2, #1
10002284:	e1c321b8 	strh	r2, [r3, #24]
    mutex->owner              = RT_NULL;
10002288:	e51b300c 	ldr	r3, [fp, #-12]
1000228c:	e3a02000 	mov	r2, #0
10002290:	e583201c 	str	r2, [r3, #28]
    mutex->original_priority  = 0xFF;
10002294:	e51b300c 	ldr	r3, [fp, #-12]
10002298:	e3e02000 	mvn	r2, #0
1000229c:	e5c3201a 	strb	r2, [r3, #26]
    mutex->hold               = 0;
100022a0:	e51b300c 	ldr	r3, [fp, #-12]
100022a4:	e3a02000 	mov	r2, #0
100022a8:	e5c3201b 	strb	r2, [r3, #27]

    /* set flag */
    mutex->parent.parent.flag = flag;
100022ac:	e51b300c 	ldr	r3, [fp, #-12]
100022b0:	e55b2011 	ldrb	r2, [fp, #-17]
100022b4:	e5c32007 	strb	r2, [r3, #7]

    return mutex;
100022b8:	e51b300c 	ldr	r3, [fp, #-12]
}
100022bc:	e1a00003 	mov	r0, r3
100022c0:	e24bd004 	sub	sp, fp, #4
100022c4:	e8bd8800 	pop	{fp, pc}

100022c8 <rt_mutex_delete>:
 * @return the error code
 *
 * @see rt_mutex_detach
 */
rt_err_t rt_mutex_delete(rt_mutex_t mutex)
{
100022c8:	e92d4800 	push	{fp, lr}
100022cc:	e28db004 	add	fp, sp, #4
100022d0:	e24dd010 	sub	sp, sp, #16
100022d4:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
100022d8:	eb002477 	bl	1000b4bc <rt_hw_interrupt_disable>
100022dc:	e50b0008 	str	r0, [fp, #-8]
100022e0:	eb0009b6 	bl	100049c0 <rt_interrupt_get_nest>
100022e4:	e1a03000 	mov	r3, r0
100022e8:	e3530000 	cmp	r3, #0
100022ec:	0a00000a 	beq	1000231c <rt_mutex_delete+0x54>
100022f0:	e30e0368 	movw	r0, #58216	; 0xe368
100022f4:	e3410001 	movt	r0, #4097	; 0x1001
100022f8:	e30e14b8 	movw	r1, #58552	; 0xe4b8
100022fc:	e3411001 	movt	r1, #4097	; 0x1001
10002300:	eb000ff3 	bl	100062d4 <rt_kprintf>
10002304:	e30e038c 	movw	r0, #58252	; 0xe38c
10002308:	e3410001 	movt	r0, #4097	; 0x1001
1000230c:	e30e14b8 	movw	r1, #58552	; 0xe4b8
10002310:	e3411001 	movt	r1, #4097	; 0x1001
10002314:	e300226a 	movw	r2, #618	; 0x26a
10002318:	eb0010aa 	bl	100065c8 <rt_assert_handler>
1000231c:	e51b0008 	ldr	r0, [fp, #-8]
10002320:	eb002469 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
10002324:	e51b3010 	ldr	r3, [fp, #-16]
10002328:	e3530000 	cmp	r3, #0
1000232c:	1a000005 	bne	10002348 <rt_mutex_delete+0x80>
10002330:	e30e03c8 	movw	r0, #58312	; 0xe3c8
10002334:	e3410001 	movt	r0, #4097	; 0x1001
10002338:	e30e14b8 	movw	r1, #58552	; 0xe4b8
1000233c:	e3411001 	movt	r1, #4097	; 0x1001
10002340:	e3a02f9b 	mov	r2, #620	; 0x26c
10002344:	eb00109f 	bl	100065c8 <rt_assert_handler>

    /* wakeup all suspend threads */
    rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
10002348:	e51b3010 	ldr	r3, [fp, #-16]
1000234c:	e2833010 	add	r3, r3, #16
10002350:	e1a00003 	mov	r0, r3
10002354:	ebfffdc0 	bl	10001a5c <rt_ipc_list_resume_all>

    /* delete semaphore object */
    rt_object_delete(&(mutex->parent.parent));
10002358:	e51b3010 	ldr	r3, [fp, #-16]
1000235c:	e1a00003 	mov	r0, r3
10002360:	eb0015ca 	bl	10007a90 <rt_object_delete>

    return RT_EOK;
10002364:	e3a03000 	mov	r3, #0
}
10002368:	e1a00003 	mov	r0, r3
1000236c:	e24bd004 	sub	sp, fp, #4
10002370:	e8bd8800 	pop	{fp, pc}

10002374 <rt_mutex_take>:
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
{
10002374:	e92d4810 	push	{r4, fp, lr}
10002378:	e28db008 	add	fp, sp, #8
1000237c:	e24dd01c 	sub	sp, sp, #28
10002380:	e50b0020 	str	r0, [fp, #-32]
10002384:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_base_t temp;
    struct rt_thread *thread;

    /* this function must not be used in interrupt even if time = 0 */
    RT_DEBUG_IN_THREAD_CONTEXT;
10002388:	eb00244b 	bl	1000b4bc <rt_hw_interrupt_disable>
1000238c:	e50b0010 	str	r0, [fp, #-16]
10002390:	eb00190c 	bl	100087c8 <rt_thread_self>
10002394:	e1a03000 	mov	r3, r0
10002398:	e3530000 	cmp	r3, #0
1000239c:	1a00000a 	bne	100023cc <rt_mutex_take+0x58>
100023a0:	e30e0390 	movw	r0, #58256	; 0xe390
100023a4:	e3410001 	movt	r0, #4097	; 0x1001
100023a8:	e30e14c8 	movw	r1, #58568	; 0xe4c8
100023ac:	e3411001 	movt	r1, #4097	; 0x1001
100023b0:	eb000fc7 	bl	100062d4 <rt_kprintf>
100023b4:	e30e038c 	movw	r0, #58252	; 0xe38c
100023b8:	e3410001 	movt	r0, #4097	; 0x1001
100023bc:	e30e14c8 	movw	r1, #58568	; 0xe4c8
100023c0:	e3411001 	movt	r1, #4097	; 0x1001
100023c4:	e3a02fa2 	mov	r2, #648	; 0x288
100023c8:	eb00107e 	bl	100065c8 <rt_assert_handler>
100023cc:	eb00243a 	bl	1000b4bc <rt_hw_interrupt_disable>
100023d0:	e50b0014 	str	r0, [fp, #-20]
100023d4:	eb000979 	bl	100049c0 <rt_interrupt_get_nest>
100023d8:	e1a03000 	mov	r3, r0
100023dc:	e3530000 	cmp	r3, #0
100023e0:	0a00000a 	beq	10002410 <rt_mutex_take+0x9c>
100023e4:	e30e0368 	movw	r0, #58216	; 0xe368
100023e8:	e3410001 	movt	r0, #4097	; 0x1001
100023ec:	e30e14c8 	movw	r1, #58568	; 0xe4c8
100023f0:	e3411001 	movt	r1, #4097	; 0x1001
100023f4:	eb000fb6 	bl	100062d4 <rt_kprintf>
100023f8:	e30e038c 	movw	r0, #58252	; 0xe38c
100023fc:	e3410001 	movt	r0, #4097	; 0x1001
10002400:	e30e14c8 	movw	r1, #58568	; 0xe4c8
10002404:	e3411001 	movt	r1, #4097	; 0x1001
10002408:	e3a02fa2 	mov	r2, #648	; 0x288
1000240c:	eb00106d 	bl	100065c8 <rt_assert_handler>
10002410:	e51b0014 	ldr	r0, [fp, #-20]
10002414:	eb00242c 	bl	1000b4cc <rt_hw_interrupt_enable>
10002418:	e51b0010 	ldr	r0, [fp, #-16]
1000241c:	eb00242a 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_ASSERT(mutex != RT_NULL);
10002420:	e51b3020 	ldr	r3, [fp, #-32]
10002424:	e3530000 	cmp	r3, #0
10002428:	1a000005 	bne	10002444 <rt_mutex_take+0xd0>
1000242c:	e30e03c8 	movw	r0, #58312	; 0xe3c8
10002430:	e3410001 	movt	r0, #4097	; 0x1001
10002434:	e30e14c8 	movw	r1, #58568	; 0xe4c8
10002438:	e3411001 	movt	r1, #4097	; 0x1001
1000243c:	e300228a 	movw	r2, #650	; 0x28a
10002440:	eb001060 	bl	100065c8 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10002444:	eb00241c 	bl	1000b4bc <rt_hw_interrupt_disable>
10002448:	e1a04000 	mov	r4, r0

    /* get current thread */
    thread = rt_thread_self();
1000244c:	eb0018dd 	bl	100087c8 <rt_thread_self>
10002450:	e50b0018 	str	r0, [fp, #-24]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
10002454:	e3093d90 	movw	r3, #40336	; 0x9d90
10002458:	e3413002 	movt	r3, #4098	; 0x1002
1000245c:	e5933000 	ldr	r3, [r3]
10002460:	e3530000 	cmp	r3, #0
10002464:	0a000005 	beq	10002480 <rt_mutex_take+0x10c>
10002468:	e3093d90 	movw	r3, #40336	; 0x9d90
1000246c:	e3413002 	movt	r3, #4098	; 0x1002
10002470:	e5933000 	ldr	r3, [r3]
10002474:	e51b2020 	ldr	r2, [fp, #-32]
10002478:	e1a00002 	mov	r0, r2
1000247c:	e12fff33 	blx	r3
    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    /* reset thread error */
    thread->error = RT_EOK;
10002480:	e51b3018 	ldr	r3, [fp, #-24]
10002484:	e3a02000 	mov	r2, #0
10002488:	e583202c 	str	r2, [r3, #44]	; 0x2c

    if (mutex->owner == thread)
1000248c:	e51b3020 	ldr	r3, [fp, #-32]
10002490:	e593201c 	ldr	r2, [r3, #28]
10002494:	e51b3018 	ldr	r3, [fp, #-24]
10002498:	e1520003 	cmp	r2, r3
1000249c:	1a000006 	bne	100024bc <rt_mutex_take+0x148>
    {
        /* it's the same thread */
        mutex->hold ++;
100024a0:	e51b3020 	ldr	r3, [fp, #-32]
100024a4:	e5d3301b 	ldrb	r3, [r3, #27]
100024a8:	e2833001 	add	r3, r3, #1
100024ac:	e6ef2073 	uxtb	r2, r3
100024b0:	e51b3020 	ldr	r3, [fp, #-32]
100024b4:	e5c3201b 	strb	r2, [r3, #27]
100024b8:	ea000052 	b	10002608 <rt_mutex_take+0x294>
    else
    {
        /* The value of mutex is 1 in initial status. Therefore, if the
         * value is great than 0, it indicates the mutex is avaible.
         */
        if (mutex->value > 0)
100024bc:	e51b3020 	ldr	r3, [fp, #-32]
100024c0:	e1d331b8 	ldrh	r3, [r3, #24]
100024c4:	e3530000 	cmp	r3, #0
100024c8:	0a000013 	beq	1000251c <rt_mutex_take+0x1a8>
        {
            /* mutex is available */
            mutex->value --;
100024cc:	e51b3020 	ldr	r3, [fp, #-32]
100024d0:	e1d331b8 	ldrh	r3, [r3, #24]
100024d4:	e2433001 	sub	r3, r3, #1
100024d8:	e6ff2073 	uxth	r2, r3
100024dc:	e51b3020 	ldr	r3, [fp, #-32]
100024e0:	e1c321b8 	strh	r2, [r3, #24]

            /* set mutex owner and original priority */
            mutex->owner             = thread;
100024e4:	e51b3020 	ldr	r3, [fp, #-32]
100024e8:	e51b2018 	ldr	r2, [fp, #-24]
100024ec:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = thread->current_priority;
100024f0:	e51b3018 	ldr	r3, [fp, #-24]
100024f4:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
100024f8:	e51b3020 	ldr	r3, [fp, #-32]
100024fc:	e5c3201a 	strb	r2, [r3, #26]
            mutex->hold ++;
10002500:	e51b3020 	ldr	r3, [fp, #-32]
10002504:	e5d3301b 	ldrb	r3, [r3, #27]
10002508:	e2833001 	add	r3, r3, #1
1000250c:	e6ef2073 	uxtb	r2, r3
10002510:	e51b3020 	ldr	r3, [fp, #-32]
10002514:	e5c3201b 	strb	r2, [r3, #27]
10002518:	ea00003a 	b	10002608 <rt_mutex_take+0x294>
        }
        else
        {
            /* no waiting, return with timeout */
            if (time == 0)
1000251c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002520:	e3530000 	cmp	r3, #0
10002524:	1a000006 	bne	10002544 <rt_mutex_take+0x1d0>
            {
                /* set error as timeout */
                thread->error = -RT_ETIMEOUT;
10002528:	e51b3018 	ldr	r3, [fp, #-24]
1000252c:	e3e02001 	mvn	r2, #1
10002530:	e583202c 	str	r2, [r3, #44]	; 0x2c

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
10002534:	e1a00004 	mov	r0, r4
10002538:	eb0023e3 	bl	1000b4cc <rt_hw_interrupt_enable>

                return -RT_ETIMEOUT;
1000253c:	e3e03001 	mvn	r3, #1
10002540:	ea00003e 	b	10002640 <rt_mutex_take+0x2cc>
                /* mutex is unavailable, push to suspend list */
                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
                                            thread->name));

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
10002544:	e51b3018 	ldr	r3, [fp, #-24]
10002548:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000254c:	e51b3020 	ldr	r3, [fp, #-32]
10002550:	e593301c 	ldr	r3, [r3, #28]
10002554:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10002558:	e1520003 	cmp	r2, r3
1000255c:	2a000007 	bcs	10002580 <rt_mutex_take+0x20c>
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
10002560:	e51b3020 	ldr	r3, [fp, #-32]
10002564:	e593201c 	ldr	r2, [r3, #28]
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
10002568:	e51b3018 	ldr	r3, [fp, #-24]
1000256c:	e2833031 	add	r3, r3, #49	; 0x31

                /* change the owner thread priority of mutex */
                if (thread->current_priority < mutex->owner->current_priority)
                {
                    /* change the owner thread priority */
                    rt_thread_control(mutex->owner,
10002570:	e1a00002 	mov	r0, r2
10002574:	e3a01002 	mov	r1, #2
10002578:	e1a02003 	mov	r2, r3
1000257c:	eb0019a9 	bl	10008c28 <rt_thread_control>
                                      RT_THREAD_CTRL_CHANGE_PRIORITY,
                                      &thread->current_priority);
                }

                /* suspend current thread */
                rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
10002580:	e51b3020 	ldr	r3, [fp, #-32]
10002584:	e2832010 	add	r2, r3, #16
10002588:	e51b3020 	ldr	r3, [fp, #-32]
1000258c:	e5d33007 	ldrb	r3, [r3, #7]
10002590:	e1a00002 	mov	r0, r2
10002594:	e51b1018 	ldr	r1, [fp, #-24]
10002598:	e1a02003 	mov	r2, r3
1000259c:	ebfffce0 	bl	10001924 <rt_ipc_list_suspend>
                                    thread,
                                    mutex->parent.parent.flag);

                /* has waiting time, start thread timer */
                if (time > 0)
100025a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
100025a4:	e3530000 	cmp	r3, #0
100025a8:	da00000a 	ble	100025d8 <rt_mutex_take+0x264>
                    RT_DEBUG_LOG(RT_DEBUG_IPC,
                                 ("mutex_take: start the timer of thread:%s\n",
                                  thread->name));

                    /* reset the timeout of thread timer and start it */
                    rt_timer_control(&(thread->thread_timer),
100025ac:	e51b3018 	ldr	r3, [fp, #-24]
100025b0:	e2832048 	add	r2, r3, #72	; 0x48
100025b4:	e24b3024 	sub	r3, fp, #36	; 0x24
100025b8:	e1a00002 	mov	r0, r2
100025bc:	e3a01000 	mov	r1, #0
100025c0:	e1a02003 	mov	r2, r3
100025c4:	eb001c90 	bl	1000980c <rt_timer_control>
                                     RT_TIMER_CTRL_SET_TIME,
                                     &time);
                    rt_timer_start(&(thread->thread_timer));
100025c8:	e51b3018 	ldr	r3, [fp, #-24]
100025cc:	e2833048 	add	r3, r3, #72	; 0x48
100025d0:	e1a00003 	mov	r0, r3
100025d4:	eb001b96 	bl	10009434 <rt_timer_start>
                }

                /* enable interrupt */
                rt_hw_interrupt_enable(temp);
100025d8:	e1a00004 	mov	r0, r4
100025dc:	eb0023ba 	bl	1000b4cc <rt_hw_interrupt_enable>

                /* do schedule */
                rt_schedule();
100025e0:	eb001689 	bl	1000800c <rt_schedule>

                if (thread->error != RT_EOK)
100025e4:	e51b3018 	ldr	r3, [fp, #-24]
100025e8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100025ec:	e3530000 	cmp	r3, #0
100025f0:	0a000002 	beq	10002600 <rt_mutex_take+0x28c>
                {
                    /* return error */
                    return thread->error;
100025f4:	e51b3018 	ldr	r3, [fp, #-24]
100025f8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100025fc:	ea00000f 	b	10002640 <rt_mutex_take+0x2cc>
                }
                else
                {
                    /* the mutex is taken successfully. */
                    /* disable interrupt */
                    temp = rt_hw_interrupt_disable();
10002600:	eb0023ad 	bl	1000b4bc <rt_hw_interrupt_disable>
10002604:	e1a04000 	mov	r4, r0
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10002608:	e1a00004 	mov	r0, r4
1000260c:	eb0023ae 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
10002610:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10002614:	e3413002 	movt	r3, #4098	; 0x1002
10002618:	e5933000 	ldr	r3, [r3]
1000261c:	e3530000 	cmp	r3, #0
10002620:	0a000005 	beq	1000263c <rt_mutex_take+0x2c8>
10002624:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10002628:	e3413002 	movt	r3, #4098	; 0x1002
1000262c:	e5933000 	ldr	r3, [r3]
10002630:	e51b2020 	ldr	r2, [fp, #-32]
10002634:	e1a00002 	mov	r0, r2
10002638:	e12fff33 	blx	r3

    return RT_EOK;
1000263c:	e3a03000 	mov	r3, #0
}
10002640:	e1a00003 	mov	r0, r3
10002644:	e24bd008 	sub	sp, fp, #8
10002648:	e8bd8810 	pop	{r4, fp, pc}

1000264c <rt_mutex_release>:
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
{
1000264c:	e92d4810 	push	{r4, fp, lr}
10002650:	e28db008 	add	fp, sp, #8
10002654:	e24dd01c 	sub	sp, sp, #28
10002658:	e50b0020 	str	r0, [fp, #-32]
    register rt_base_t temp;
    struct rt_thread *thread;
    rt_bool_t need_schedule;

    need_schedule = RT_FALSE;
1000265c:	e3a03000 	mov	r3, #0
10002660:	e50b3010 	str	r3, [fp, #-16]

    /* only thread could release mutex because we need test the ownership */
    RT_DEBUG_IN_THREAD_CONTEXT;
10002664:	eb002394 	bl	1000b4bc <rt_hw_interrupt_disable>
10002668:	e50b0014 	str	r0, [fp, #-20]
1000266c:	eb001855 	bl	100087c8 <rt_thread_self>
10002670:	e1a03000 	mov	r3, r0
10002674:	e3530000 	cmp	r3, #0
10002678:	1a00000a 	bne	100026a8 <rt_mutex_release+0x5c>
1000267c:	e30e0390 	movw	r0, #58256	; 0xe390
10002680:	e3410001 	movt	r0, #4097	; 0x1001
10002684:	e30e14d8 	movw	r1, #58584	; 0xe4d8
10002688:	e3411001 	movt	r1, #4097	; 0x1001
1000268c:	eb000f10 	bl	100062d4 <rt_kprintf>
10002690:	e30e038c 	movw	r0, #58252	; 0xe38c
10002694:	e3410001 	movt	r0, #4097	; 0x1001
10002698:	e30e14d8 	movw	r1, #58584	; 0xe4d8
1000269c:	e3411001 	movt	r1, #4097	; 0x1001
100026a0:	e300230d 	movw	r2, #781	; 0x30d
100026a4:	eb000fc7 	bl	100065c8 <rt_assert_handler>
100026a8:	eb002383 	bl	1000b4bc <rt_hw_interrupt_disable>
100026ac:	e50b0018 	str	r0, [fp, #-24]
100026b0:	eb0008c2 	bl	100049c0 <rt_interrupt_get_nest>
100026b4:	e1a03000 	mov	r3, r0
100026b8:	e3530000 	cmp	r3, #0
100026bc:	0a00000a 	beq	100026ec <rt_mutex_release+0xa0>
100026c0:	e30e0368 	movw	r0, #58216	; 0xe368
100026c4:	e3410001 	movt	r0, #4097	; 0x1001
100026c8:	e30e14d8 	movw	r1, #58584	; 0xe4d8
100026cc:	e3411001 	movt	r1, #4097	; 0x1001
100026d0:	eb000eff 	bl	100062d4 <rt_kprintf>
100026d4:	e30e038c 	movw	r0, #58252	; 0xe38c
100026d8:	e3410001 	movt	r0, #4097	; 0x1001
100026dc:	e30e14d8 	movw	r1, #58584	; 0xe4d8
100026e0:	e3411001 	movt	r1, #4097	; 0x1001
100026e4:	e300230d 	movw	r2, #781	; 0x30d
100026e8:	eb000fb6 	bl	100065c8 <rt_assert_handler>
100026ec:	e51b0018 	ldr	r0, [fp, #-24]
100026f0:	eb002375 	bl	1000b4cc <rt_hw_interrupt_enable>
100026f4:	e51b0014 	ldr	r0, [fp, #-20]
100026f8:	eb002373 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* get current thread */
    thread = rt_thread_self();
100026fc:	eb001831 	bl	100087c8 <rt_thread_self>
10002700:	e50b001c 	str	r0, [fp, #-28]

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10002704:	eb00236c 	bl	1000b4bc <rt_hw_interrupt_disable>
10002708:	e1a04000 	mov	r4, r0

    RT_DEBUG_LOG(RT_DEBUG_IPC,
                 ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
                  thread->name, mutex->value, mutex->hold));

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
1000270c:	e3093d88 	movw	r3, #40328	; 0x9d88
10002710:	e3413002 	movt	r3, #4098	; 0x1002
10002714:	e5933000 	ldr	r3, [r3]
10002718:	e3530000 	cmp	r3, #0
1000271c:	0a000005 	beq	10002738 <rt_mutex_release+0xec>
10002720:	e3093d88 	movw	r3, #40328	; 0x9d88
10002724:	e3413002 	movt	r3, #4098	; 0x1002
10002728:	e5933000 	ldr	r3, [r3]
1000272c:	e51b2020 	ldr	r2, [fp, #-32]
10002730:	e1a00002 	mov	r0, r2
10002734:	e12fff33 	blx	r3

    /* mutex only can be released by owner */
    if (thread != mutex->owner)
10002738:	e51b3020 	ldr	r3, [fp, #-32]
1000273c:	e593201c 	ldr	r2, [r3, #28]
10002740:	e51b301c 	ldr	r3, [fp, #-28]
10002744:	e1520003 	cmp	r2, r3
10002748:	0a000006 	beq	10002768 <rt_mutex_release+0x11c>
    {
        thread->error = -RT_ERROR;
1000274c:	e51b301c 	ldr	r3, [fp, #-28]
10002750:	e3e02000 	mvn	r2, #0
10002754:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10002758:	e1a00004 	mov	r0, r4
1000275c:	eb00235a 	bl	1000b4cc <rt_hw_interrupt_enable>

        return -RT_ERROR;
10002760:	e3e03000 	mvn	r3, #0
10002764:	ea00004a 	b	10002894 <rt_mutex_release+0x248>
    }

    /* decrease hold */
    mutex->hold --;
10002768:	e51b3020 	ldr	r3, [fp, #-32]
1000276c:	e5d3301b 	ldrb	r3, [r3, #27]
10002770:	e2433001 	sub	r3, r3, #1
10002774:	e6ef2073 	uxtb	r2, r3
10002778:	e51b3020 	ldr	r3, [fp, #-32]
1000277c:	e5c3201b 	strb	r2, [r3, #27]
    /* if no hold */
    if (mutex->hold == 0)
10002780:	e51b3020 	ldr	r3, [fp, #-32]
10002784:	e5d3301b 	ldrb	r3, [r3, #27]
10002788:	e3530000 	cmp	r3, #0
1000278c:	1a000039 	bne	10002878 <rt_mutex_release+0x22c>
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
10002790:	e51b3020 	ldr	r3, [fp, #-32]
10002794:	e5d3201a 	ldrb	r2, [r3, #26]
10002798:	e51b3020 	ldr	r3, [fp, #-32]
1000279c:	e593301c 	ldr	r3, [r3, #28]
100027a0:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
100027a4:	e1520003 	cmp	r2, r3
100027a8:	0a000007 	beq	100027cc <rt_mutex_release+0x180>
        {
            rt_thread_control(mutex->owner,
100027ac:	e51b3020 	ldr	r3, [fp, #-32]
100027b0:	e593201c 	ldr	r2, [r3, #28]
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
100027b4:	e51b3020 	ldr	r3, [fp, #-32]
100027b8:	e283301a 	add	r3, r3, #26
    if (mutex->hold == 0)
    {
        /* change the owner thread to original priority */
        if (mutex->original_priority != mutex->owner->current_priority)
        {
            rt_thread_control(mutex->owner,
100027bc:	e1a00002 	mov	r0, r2
100027c0:	e3a01002 	mov	r1, #2
100027c4:	e1a02003 	mov	r2, r3
100027c8:	eb001916 	bl	10008c28 <rt_thread_control>
                              RT_THREAD_CTRL_CHANGE_PRIORITY,
                              &(mutex->original_priority));
        }

        /* wakeup suspended thread */
        if (!rt_list_isempty(&mutex->parent.suspend_thread))
100027cc:	e51b3020 	ldr	r3, [fp, #-32]
100027d0:	e2833010 	add	r3, r3, #16
100027d4:	e1a00003 	mov	r0, r3
100027d8:	ebfffc36 	bl	100018b8 <rt_list_isempty>
100027dc:	e1a03000 	mov	r3, r0
100027e0:	e3530000 	cmp	r3, #0
100027e4:	1a000017 	bne	10002848 <rt_mutex_release+0x1fc>
        {
            /* get suspended thread */
            thread = rt_list_entry(mutex->parent.suspend_thread.next,
100027e8:	e51b3020 	ldr	r3, [fp, #-32]
100027ec:	e5933010 	ldr	r3, [r3, #16]
100027f0:	e2433010 	sub	r3, r3, #16
100027f4:	e50b301c 	str	r3, [fp, #-28]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
                                        thread->name));

            /* set new owner and priority */
            mutex->owner             = thread;
100027f8:	e51b3020 	ldr	r3, [fp, #-32]
100027fc:	e51b201c 	ldr	r2, [fp, #-28]
10002800:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = thread->current_priority;
10002804:	e51b301c 	ldr	r3, [fp, #-28]
10002808:	e5d32031 	ldrb	r2, [r3, #49]	; 0x31
1000280c:	e51b3020 	ldr	r3, [fp, #-32]
10002810:	e5c3201a 	strb	r2, [r3, #26]
            mutex->hold ++;
10002814:	e51b3020 	ldr	r3, [fp, #-32]
10002818:	e5d3301b 	ldrb	r3, [r3, #27]
1000281c:	e2833001 	add	r3, r3, #1
10002820:	e6ef2073 	uxtb	r2, r3
10002824:	e51b3020 	ldr	r3, [fp, #-32]
10002828:	e5c3201b 	strb	r2, [r3, #27]

            /* resume thread */
            rt_ipc_list_resume(&(mutex->parent.suspend_thread));
1000282c:	e51b3020 	ldr	r3, [fp, #-32]
10002830:	e2833010 	add	r3, r3, #16
10002834:	e1a00003 	mov	r0, r3
10002838:	ebfffc79 	bl	10001a24 <rt_ipc_list_resume>

            need_schedule = RT_TRUE;
1000283c:	e3a03001 	mov	r3, #1
10002840:	e50b3010 	str	r3, [fp, #-16]
10002844:	ea00000b 	b	10002878 <rt_mutex_release+0x22c>
        }
        else
        {
            /* increase value */
            mutex->value ++;
10002848:	e51b3020 	ldr	r3, [fp, #-32]
1000284c:	e1d331b8 	ldrh	r3, [r3, #24]
10002850:	e2833001 	add	r3, r3, #1
10002854:	e6ff2073 	uxth	r2, r3
10002858:	e51b3020 	ldr	r3, [fp, #-32]
1000285c:	e1c321b8 	strh	r2, [r3, #24]

            /* clear owner */
            mutex->owner             = RT_NULL;
10002860:	e51b3020 	ldr	r3, [fp, #-32]
10002864:	e3a02000 	mov	r2, #0
10002868:	e583201c 	str	r2, [r3, #28]
            mutex->original_priority = 0xff;
1000286c:	e51b3020 	ldr	r3, [fp, #-32]
10002870:	e3e02000 	mvn	r2, #0
10002874:	e5c3201a 	strb	r2, [r3, #26]
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10002878:	e1a00004 	mov	r0, r4
1000287c:	eb002312 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* perform a schedule */
    if (need_schedule == RT_TRUE)
10002880:	e51b3010 	ldr	r3, [fp, #-16]
10002884:	e3530001 	cmp	r3, #1
10002888:	1a000000 	bne	10002890 <rt_mutex_release+0x244>
        rt_schedule();
1000288c:	eb0015de 	bl	1000800c <rt_schedule>

    return RT_EOK;
10002890:	e3a03000 	mov	r3, #0
}
10002894:	e1a00003 	mov	r0, r3
10002898:	e24bd008 	sub	sp, fp, #8
1000289c:	e8bd8810 	pop	{r4, fp, pc}

100028a0 <rt_mutex_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
{
100028a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100028a4:	e28db000 	add	fp, sp, #0
100028a8:	e24dd014 	sub	sp, sp, #20
100028ac:	e50b0008 	str	r0, [fp, #-8]
100028b0:	e1a03001 	mov	r3, r1
100028b4:	e50b2010 	str	r2, [fp, #-16]
100028b8:	e54b3009 	strb	r3, [fp, #-9]
    return -RT_ERROR;
100028bc:	e3e03000 	mvn	r3, #0
}
100028c0:	e1a00003 	mov	r0, r3
100028c4:	e24bd000 	sub	sp, fp, #0
100028c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100028cc:	e12fff1e 	bx	lr

100028d0 <rt_event_init>:
 * @param flag the flag of event
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
{
100028d0:	e92d4800 	push	{fp, lr}
100028d4:	e28db004 	add	fp, sp, #4
100028d8:	e24dd010 	sub	sp, sp, #16
100028dc:	e50b0008 	str	r0, [fp, #-8]
100028e0:	e50b100c 	str	r1, [fp, #-12]
100028e4:	e1a03002 	mov	r3, r2
100028e8:	e54b300d 	strb	r3, [fp, #-13]
    RT_ASSERT(event != RT_NULL);
100028ec:	e51b3008 	ldr	r3, [fp, #-8]
100028f0:	e3530000 	cmp	r3, #0
100028f4:	1a000005 	bne	10002910 <rt_event_init+0x40>
100028f8:	e30e03dc 	movw	r0, #58332	; 0xe3dc
100028fc:	e3410001 	movt	r0, #4097	; 0x1001
10002900:	e30e14ec 	movw	r1, #58604	; 0xe4ec
10002904:	e3411001 	movt	r1, #4097	; 0x1001
10002908:	e300237b 	movw	r2, #891	; 0x37b
1000290c:	eb000f2d 	bl	100065c8 <rt_assert_handler>

    /* init object */
    rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
10002910:	e51b3008 	ldr	r3, [fp, #-8]
10002914:	e1a00003 	mov	r0, r3
10002918:	e3a01003 	mov	r1, #3
1000291c:	e51b200c 	ldr	r2, [fp, #-12]
10002920:	eb0013bd 	bl	1000781c <rt_object_init>

    /* set parent flag */
    event->parent.parent.flag = flag;
10002924:	e51b3008 	ldr	r3, [fp, #-8]
10002928:	e55b200d 	ldrb	r2, [fp, #-13]
1000292c:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(event->parent));
10002930:	e51b3008 	ldr	r3, [fp, #-8]
10002934:	e1a00003 	mov	r0, r3
10002938:	ebfffbed 	bl	100018f4 <rt_ipc_object_init>

    /* init event */
    event->set = 0;
1000293c:	e51b3008 	ldr	r3, [fp, #-8]
10002940:	e3a02000 	mov	r2, #0
10002944:	e5832018 	str	r2, [r3, #24]

    return RT_EOK;
10002948:	e3a03000 	mov	r3, #0
}
1000294c:	e1a00003 	mov	r0, r3
10002950:	e24bd004 	sub	sp, fp, #4
10002954:	e8bd8800 	pop	{fp, pc}

10002958 <rt_event_detach>:
 * @param event the event object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_detach(rt_event_t event)
{
10002958:	e92d4800 	push	{fp, lr}
1000295c:	e28db004 	add	fp, sp, #4
10002960:	e24dd008 	sub	sp, sp, #8
10002964:	e50b0008 	str	r0, [fp, #-8]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
10002968:	e51b3008 	ldr	r3, [fp, #-8]
1000296c:	e3530000 	cmp	r3, #0
10002970:	1a000005 	bne	1000298c <rt_event_detach+0x34>
10002974:	e30e03dc 	movw	r0, #58332	; 0xe3dc
10002978:	e3410001 	movt	r0, #4097	; 0x1001
1000297c:	e30e14fc 	movw	r1, #58620	; 0xe4fc
10002980:	e3411001 	movt	r1, #4097	; 0x1001
10002984:	e3002397 	movw	r2, #919	; 0x397
10002988:	eb000f0e 	bl	100065c8 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(event->parent.suspend_thread));
1000298c:	e51b3008 	ldr	r3, [fp, #-8]
10002990:	e2833010 	add	r3, r3, #16
10002994:	e1a00003 	mov	r0, r3
10002998:	ebfffc2f 	bl	10001a5c <rt_ipc_list_resume_all>

    /* detach event object */
    rt_object_detach(&(event->parent.parent));
1000299c:	e51b3008 	ldr	r3, [fp, #-8]
100029a0:	e1a00003 	mov	r0, r3
100029a4:	eb0013cb 	bl	100078d8 <rt_object_detach>

    return RT_EOK;
100029a8:	e3a03000 	mov	r3, #0
}
100029ac:	e1a00003 	mov	r0, r3
100029b0:	e24bd004 	sub	sp, fp, #4
100029b4:	e8bd8800 	pop	{fp, pc}

100029b8 <rt_event_create>:
 * @param flag the flag of event
 *
 * @return the created event, RT_NULL on error happen
 */
rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
{
100029b8:	e92d4800 	push	{fp, lr}
100029bc:	e28db004 	add	fp, sp, #4
100029c0:	e24dd010 	sub	sp, sp, #16
100029c4:	e50b0010 	str	r0, [fp, #-16]
100029c8:	e1a03001 	mov	r3, r1
100029cc:	e54b3011 	strb	r3, [fp, #-17]
    rt_event_t event;

    RT_DEBUG_NOT_IN_INTERRUPT;
100029d0:	eb0022b9 	bl	1000b4bc <rt_hw_interrupt_disable>
100029d4:	e50b0008 	str	r0, [fp, #-8]
100029d8:	eb0007f8 	bl	100049c0 <rt_interrupt_get_nest>
100029dc:	e1a03000 	mov	r3, r0
100029e0:	e3530000 	cmp	r3, #0
100029e4:	0a00000a 	beq	10002a14 <rt_event_create+0x5c>
100029e8:	e30e0368 	movw	r0, #58216	; 0xe368
100029ec:	e3410001 	movt	r0, #4097	; 0x1001
100029f0:	e30e150c 	movw	r1, #58636	; 0xe50c
100029f4:	e3411001 	movt	r1, #4097	; 0x1001
100029f8:	eb000e35 	bl	100062d4 <rt_kprintf>
100029fc:	e30e038c 	movw	r0, #58252	; 0xe38c
10002a00:	e3410001 	movt	r0, #4097	; 0x1001
10002a04:	e30e150c 	movw	r1, #58636	; 0xe50c
10002a08:	e3411001 	movt	r1, #4097	; 0x1001
10002a0c:	e3a02e3b 	mov	r2, #944	; 0x3b0
10002a10:	eb000eec 	bl	100065c8 <rt_assert_handler>
10002a14:	e51b0008 	ldr	r0, [fp, #-8]
10002a18:	eb0022ab 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* allocate object */
    event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
10002a1c:	e3a00003 	mov	r0, #3
10002a20:	e51b1010 	ldr	r1, [fp, #-16]
10002a24:	eb0013cc 	bl	1000795c <rt_object_allocate>
10002a28:	e50b000c 	str	r0, [fp, #-12]
    if (event == RT_NULL)
10002a2c:	e51b300c 	ldr	r3, [fp, #-12]
10002a30:	e3530000 	cmp	r3, #0
10002a34:	1a000001 	bne	10002a40 <rt_event_create+0x88>
        return event;
10002a38:	e51b300c 	ldr	r3, [fp, #-12]
10002a3c:	ea000009 	b	10002a68 <rt_event_create+0xb0>

    /* set parent */
    event->parent.parent.flag = flag;
10002a40:	e51b300c 	ldr	r3, [fp, #-12]
10002a44:	e55b2011 	ldrb	r2, [fp, #-17]
10002a48:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(event->parent));
10002a4c:	e51b300c 	ldr	r3, [fp, #-12]
10002a50:	e1a00003 	mov	r0, r3
10002a54:	ebfffba6 	bl	100018f4 <rt_ipc_object_init>

    /* init event */
    event->set = 0;
10002a58:	e51b300c 	ldr	r3, [fp, #-12]
10002a5c:	e3a02000 	mov	r2, #0
10002a60:	e5832018 	str	r2, [r3, #24]

    return event;
10002a64:	e51b300c 	ldr	r3, [fp, #-12]
}
10002a68:	e1a00003 	mov	r0, r3
10002a6c:	e24bd004 	sub	sp, fp, #4
10002a70:	e8bd8800 	pop	{fp, pc}

10002a74 <rt_event_delete>:
 * @param event the event object
 *
 * @return the error code
 */
rt_err_t rt_event_delete(rt_event_t event)
{
10002a74:	e92d4800 	push	{fp, lr}
10002a78:	e28db004 	add	fp, sp, #4
10002a7c:	e24dd010 	sub	sp, sp, #16
10002a80:	e50b0010 	str	r0, [fp, #-16]
    /* parameter check */
    RT_ASSERT(event != RT_NULL);
10002a84:	e51b3010 	ldr	r3, [fp, #-16]
10002a88:	e3530000 	cmp	r3, #0
10002a8c:	1a000005 	bne	10002aa8 <rt_event_delete+0x34>
10002a90:	e30e03dc 	movw	r0, #58332	; 0xe3dc
10002a94:	e3410001 	movt	r0, #4097	; 0x1001
10002a98:	e30e151c 	movw	r1, #58652	; 0xe51c
10002a9c:	e3411001 	movt	r1, #4097	; 0x1001
10002aa0:	e30023ce 	movw	r2, #974	; 0x3ce
10002aa4:	eb000ec7 	bl	100065c8 <rt_assert_handler>

    RT_DEBUG_NOT_IN_INTERRUPT;
10002aa8:	eb002283 	bl	1000b4bc <rt_hw_interrupt_disable>
10002aac:	e50b0008 	str	r0, [fp, #-8]
10002ab0:	eb0007c2 	bl	100049c0 <rt_interrupt_get_nest>
10002ab4:	e1a03000 	mov	r3, r0
10002ab8:	e3530000 	cmp	r3, #0
10002abc:	0a00000a 	beq	10002aec <rt_event_delete+0x78>
10002ac0:	e30e0368 	movw	r0, #58216	; 0xe368
10002ac4:	e3410001 	movt	r0, #4097	; 0x1001
10002ac8:	e30e151c 	movw	r1, #58652	; 0xe51c
10002acc:	e3411001 	movt	r1, #4097	; 0x1001
10002ad0:	eb000dff 	bl	100062d4 <rt_kprintf>
10002ad4:	e30e038c 	movw	r0, #58252	; 0xe38c
10002ad8:	e3410001 	movt	r0, #4097	; 0x1001
10002adc:	e30e151c 	movw	r1, #58652	; 0xe51c
10002ae0:	e3411001 	movt	r1, #4097	; 0x1001
10002ae4:	e3a02e3d 	mov	r2, #976	; 0x3d0
10002ae8:	eb000eb6 	bl	100065c8 <rt_assert_handler>
10002aec:	e51b0008 	ldr	r0, [fp, #-8]
10002af0:	eb002275 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(event->parent.suspend_thread));
10002af4:	e51b3010 	ldr	r3, [fp, #-16]
10002af8:	e2833010 	add	r3, r3, #16
10002afc:	e1a00003 	mov	r0, r3
10002b00:	ebfffbd5 	bl	10001a5c <rt_ipc_list_resume_all>

    /* delete event object */
    rt_object_delete(&(event->parent.parent));
10002b04:	e51b3010 	ldr	r3, [fp, #-16]
10002b08:	e1a00003 	mov	r0, r3
10002b0c:	eb0013df 	bl	10007a90 <rt_object_delete>

    return RT_EOK;
10002b10:	e3a03000 	mov	r3, #0
}
10002b14:	e1a00003 	mov	r0, r3
10002b18:	e24bd004 	sub	sp, fp, #4
10002b1c:	e8bd8800 	pop	{fp, pc}

10002b20 <rt_event_send>:
 * @param set the event set
 *
 * @return the error code
 */
rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
{
10002b20:	e92d4830 	push	{r4, r5, fp, lr}
10002b24:	e28db00c 	add	fp, sp, #12
10002b28:	e24dd018 	sub	sp, sp, #24
10002b2c:	e50b0020 	str	r0, [fp, #-32]
10002b30:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    register rt_ubase_t level;
    register rt_base_t status;
    rt_bool_t need_schedule;

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
10002b34:	e51b3020 	ldr	r3, [fp, #-32]
10002b38:	e3530000 	cmp	r3, #0
10002b3c:	1a000005 	bne	10002b58 <rt_event_send+0x38>
10002b40:	e30e03dc 	movw	r0, #58332	; 0xe3dc
10002b44:	e3410001 	movt	r0, #4097	; 0x1001
10002b48:	e30e152c 	movw	r1, #58668	; 0xe52c
10002b4c:	e3411001 	movt	r1, #4097	; 0x1001
10002b50:	e30023ef 	movw	r2, #1007	; 0x3ef
10002b54:	eb000e9b 	bl	100065c8 <rt_assert_handler>
    if (set == 0)
10002b58:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002b5c:	e3530000 	cmp	r3, #0
10002b60:	1a000001 	bne	10002b6c <rt_event_send+0x4c>
        return -RT_ERROR;
10002b64:	e3e03000 	mvn	r3, #0
10002b68:	ea00006b 	b	10002d1c <rt_event_send+0x1fc>

    need_schedule = RT_FALSE;
10002b6c:	e3a03000 	mov	r3, #0
10002b70:	e50b3014 	str	r3, [fp, #-20]
    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
10002b74:	e3093d88 	movw	r3, #40328	; 0x9d88
10002b78:	e3413002 	movt	r3, #4098	; 0x1002
10002b7c:	e5933000 	ldr	r3, [r3]
10002b80:	e3530000 	cmp	r3, #0
10002b84:	0a000005 	beq	10002ba0 <rt_event_send+0x80>
10002b88:	e3093d88 	movw	r3, #40328	; 0x9d88
10002b8c:	e3413002 	movt	r3, #4098	; 0x1002
10002b90:	e5933000 	ldr	r3, [r3]
10002b94:	e51b2020 	ldr	r2, [fp, #-32]
10002b98:	e1a00002 	mov	r0, r2
10002b9c:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10002ba0:	eb002245 	bl	1000b4bc <rt_hw_interrupt_disable>
10002ba4:	e1a03000 	mov	r3, r0
10002ba8:	e1a05003 	mov	r5, r3

    /* set event */
    event->set |= set;
10002bac:	e51b3020 	ldr	r3, [fp, #-32]
10002bb0:	e5932018 	ldr	r2, [r3, #24]
10002bb4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002bb8:	e1822003 	orr	r2, r2, r3
10002bbc:	e51b3020 	ldr	r3, [fp, #-32]
10002bc0:	e5832018 	str	r2, [r3, #24]

    if (!rt_list_isempty(&event->parent.suspend_thread))
10002bc4:	e51b3020 	ldr	r3, [fp, #-32]
10002bc8:	e2833010 	add	r3, r3, #16
10002bcc:	e1a00003 	mov	r0, r3
10002bd0:	ebfffb38 	bl	100018b8 <rt_list_isempty>
10002bd4:	e1a03000 	mov	r3, r0
10002bd8:	e3530000 	cmp	r3, #0
10002bdc:	1a000046 	bne	10002cfc <rt_event_send+0x1dc>
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
10002be0:	e51b3020 	ldr	r3, [fp, #-32]
10002be4:	e5933010 	ldr	r3, [r3, #16]
10002be8:	e50b3010 	str	r3, [fp, #-16]
        while (n != &(event->parent.suspend_thread))
10002bec:	ea00003d 	b	10002ce8 <rt_event_send+0x1c8>
        {
            /* get thread */
            thread = rt_list_entry(n, struct rt_thread, tlist);
10002bf0:	e51b3010 	ldr	r3, [fp, #-16]
10002bf4:	e2433010 	sub	r3, r3, #16
10002bf8:	e50b3018 	str	r3, [fp, #-24]

            status = -RT_ERROR;
10002bfc:	e3e04000 	mvn	r4, #0
            if (thread->event_info & RT_EVENT_FLAG_AND)
10002c00:	e51b3018 	ldr	r3, [fp, #-24]
10002c04:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
10002c08:	e2033001 	and	r3, r3, #1
10002c0c:	e3530000 	cmp	r3, #0
10002c10:	0a00000a 	beq	10002c40 <rt_event_send+0x120>
            {
                if ((thread->event_set & event->set) == thread->event_set)
10002c14:	e51b3018 	ldr	r3, [fp, #-24]
10002c18:	e5932038 	ldr	r2, [r3, #56]	; 0x38
10002c1c:	e51b3020 	ldr	r3, [fp, #-32]
10002c20:	e5933018 	ldr	r3, [r3, #24]
10002c24:	e0022003 	and	r2, r2, r3
10002c28:	e51b3018 	ldr	r3, [fp, #-24]
10002c2c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10002c30:	e1520003 	cmp	r2, r3
10002c34:	1a000015 	bne	10002c90 <rt_event_send+0x170>
                {
                    /* received an AND event */
                    status = RT_EOK;
10002c38:	e3a04000 	mov	r4, #0
10002c3c:	ea000013 	b	10002c90 <rt_event_send+0x170>
                }
            }
            else if (thread->event_info & RT_EVENT_FLAG_OR)
10002c40:	e51b3018 	ldr	r3, [fp, #-24]
10002c44:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
10002c48:	e2033002 	and	r3, r3, #2
10002c4c:	e3530000 	cmp	r3, #0
10002c50:	0a00000e 	beq	10002c90 <rt_event_send+0x170>
            {
                if (thread->event_set & event->set)
10002c54:	e51b3018 	ldr	r3, [fp, #-24]
10002c58:	e5932038 	ldr	r2, [r3, #56]	; 0x38
10002c5c:	e51b3020 	ldr	r3, [fp, #-32]
10002c60:	e5933018 	ldr	r3, [r3, #24]
10002c64:	e0033002 	and	r3, r3, r2
10002c68:	e3530000 	cmp	r3, #0
10002c6c:	0a000007 	beq	10002c90 <rt_event_send+0x170>
                {
                    /* save recieved event set */
                    thread->event_set = thread->event_set & event->set;
10002c70:	e51b3018 	ldr	r3, [fp, #-24]
10002c74:	e5932038 	ldr	r2, [r3, #56]	; 0x38
10002c78:	e51b3020 	ldr	r3, [fp, #-32]
10002c7c:	e5933018 	ldr	r3, [r3, #24]
10002c80:	e0022003 	and	r2, r2, r3
10002c84:	e51b3018 	ldr	r3, [fp, #-24]
10002c88:	e5832038 	str	r2, [r3, #56]	; 0x38

                    /* received an OR event */
                    status = RT_EOK;
10002c8c:	e3a04000 	mov	r4, #0
                }
            }

            /* move node to the next */
            n = n->next;
10002c90:	e51b3010 	ldr	r3, [fp, #-16]
10002c94:	e5933000 	ldr	r3, [r3]
10002c98:	e50b3010 	str	r3, [fp, #-16]

            /* condition is satisfied, resume thread */
            if (status == RT_EOK)
10002c9c:	e3540000 	cmp	r4, #0
10002ca0:	1a000010 	bne	10002ce8 <rt_event_send+0x1c8>
            {
                /* clear event */
                if (thread->event_info & RT_EVENT_FLAG_CLEAR)
10002ca4:	e51b3018 	ldr	r3, [fp, #-24]
10002ca8:	e5d3303c 	ldrb	r3, [r3, #60]	; 0x3c
10002cac:	e2033004 	and	r3, r3, #4
10002cb0:	e3530000 	cmp	r3, #0
10002cb4:	0a000007 	beq	10002cd8 <rt_event_send+0x1b8>
                    event->set &= ~thread->event_set;
10002cb8:	e51b3020 	ldr	r3, [fp, #-32]
10002cbc:	e5932018 	ldr	r2, [r3, #24]
10002cc0:	e51b3018 	ldr	r3, [fp, #-24]
10002cc4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
10002cc8:	e1e03003 	mvn	r3, r3
10002ccc:	e0022003 	and	r2, r2, r3
10002cd0:	e51b3020 	ldr	r3, [fp, #-32]
10002cd4:	e5832018 	str	r2, [r3, #24]

                /* resume thread, and thread list breaks out */
                rt_thread_resume(thread);
10002cd8:	e51b0018 	ldr	r0, [fp, #-24]
10002cdc:	eb00183f 	bl	10008de0 <rt_thread_resume>

                /* need do a scheduling */
                need_schedule = RT_TRUE;
10002ce0:	e3a03001 	mov	r3, #1
10002ce4:	e50b3014 	str	r3, [fp, #-20]

    if (!rt_list_isempty(&event->parent.suspend_thread))
    {
        /* search thread list to resume thread */
        n = event->parent.suspend_thread.next;
        while (n != &(event->parent.suspend_thread))
10002ce8:	e51b3020 	ldr	r3, [fp, #-32]
10002cec:	e2832010 	add	r2, r3, #16
10002cf0:	e51b3010 	ldr	r3, [fp, #-16]
10002cf4:	e1520003 	cmp	r2, r3
10002cf8:	1affffbc 	bne	10002bf0 <rt_event_send+0xd0>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10002cfc:	e1a03005 	mov	r3, r5
10002d00:	e1a00003 	mov	r0, r3
10002d04:	eb0021f0 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* do a schedule */
    if (need_schedule == RT_TRUE)
10002d08:	e51b3014 	ldr	r3, [fp, #-20]
10002d0c:	e3530001 	cmp	r3, #1
10002d10:	1a000000 	bne	10002d18 <rt_event_send+0x1f8>
        rt_schedule();
10002d14:	eb0014bc 	bl	1000800c <rt_schedule>

    return RT_EOK;
10002d18:	e3a03000 	mov	r3, #0
}
10002d1c:	e1a00003 	mov	r0, r3
10002d20:	e24bd00c 	sub	sp, fp, #12
10002d24:	e8bd8830 	pop	{r4, r5, fp, pc}

10002d28 <rt_event_recv>:
rt_err_t rt_event_recv(rt_event_t   event,
                       rt_uint32_t  set,
                       rt_uint8_t   option,
                       rt_int32_t   timeout,
                       rt_uint32_t *recved)
{
10002d28:	e92d4830 	push	{r4, r5, fp, lr}
10002d2c:	e28db00c 	add	fp, sp, #12
10002d30:	e24dd020 	sub	sp, sp, #32
10002d34:	e50b0020 	str	r0, [fp, #-32]
10002d38:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10002d3c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
10002d40:	e1a03002 	mov	r3, r2
10002d44:	e54b3025 	strb	r3, [fp, #-37]	; 0x25
    struct rt_thread *thread;
    register rt_ubase_t level;
    register rt_base_t status;

    RT_DEBUG_IN_THREAD_CONTEXT;
10002d48:	eb0021db 	bl	1000b4bc <rt_hw_interrupt_disable>
10002d4c:	e50b0010 	str	r0, [fp, #-16]
10002d50:	eb00169c 	bl	100087c8 <rt_thread_self>
10002d54:	e1a03000 	mov	r3, r0
10002d58:	e3530000 	cmp	r3, #0
10002d5c:	1a00000a 	bne	10002d8c <rt_event_recv+0x64>
10002d60:	e30e0390 	movw	r0, #58256	; 0xe390
10002d64:	e3410001 	movt	r0, #4097	; 0x1001
10002d68:	e30e153c 	movw	r1, #58684	; 0xe53c
10002d6c:	e3411001 	movt	r1, #4097	; 0x1001
10002d70:	eb000d57 	bl	100062d4 <rt_kprintf>
10002d74:	e30e038c 	movw	r0, #58252	; 0xe38c
10002d78:	e3410001 	movt	r0, #4097	; 0x1001
10002d7c:	e30e153c 	movw	r1, #58684	; 0xe53c
10002d80:	e3411001 	movt	r1, #4097	; 0x1001
10002d84:	e300244f 	movw	r2, #1103	; 0x44f
10002d88:	eb000e0e 	bl	100065c8 <rt_assert_handler>
10002d8c:	eb0021ca 	bl	1000b4bc <rt_hw_interrupt_disable>
10002d90:	e50b0014 	str	r0, [fp, #-20]
10002d94:	eb000709 	bl	100049c0 <rt_interrupt_get_nest>
10002d98:	e1a03000 	mov	r3, r0
10002d9c:	e3530000 	cmp	r3, #0
10002da0:	0a00000a 	beq	10002dd0 <rt_event_recv+0xa8>
10002da4:	e30e0368 	movw	r0, #58216	; 0xe368
10002da8:	e3410001 	movt	r0, #4097	; 0x1001
10002dac:	e30e153c 	movw	r1, #58684	; 0xe53c
10002db0:	e3411001 	movt	r1, #4097	; 0x1001
10002db4:	eb000d46 	bl	100062d4 <rt_kprintf>
10002db8:	e30e038c 	movw	r0, #58252	; 0xe38c
10002dbc:	e3410001 	movt	r0, #4097	; 0x1001
10002dc0:	e30e153c 	movw	r1, #58684	; 0xe53c
10002dc4:	e3411001 	movt	r1, #4097	; 0x1001
10002dc8:	e300244f 	movw	r2, #1103	; 0x44f
10002dcc:	eb000dfd 	bl	100065c8 <rt_assert_handler>
10002dd0:	e51b0014 	ldr	r0, [fp, #-20]
10002dd4:	eb0021bc 	bl	1000b4cc <rt_hw_interrupt_enable>
10002dd8:	e51b0010 	ldr	r0, [fp, #-16]
10002ddc:	eb0021ba 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(event != RT_NULL);
10002de0:	e51b3020 	ldr	r3, [fp, #-32]
10002de4:	e3530000 	cmp	r3, #0
10002de8:	1a000005 	bne	10002e04 <rt_event_recv+0xdc>
10002dec:	e30e03dc 	movw	r0, #58332	; 0xe3dc
10002df0:	e3410001 	movt	r0, #4097	; 0x1001
10002df4:	e30e153c 	movw	r1, #58684	; 0xe53c
10002df8:	e3411001 	movt	r1, #4097	; 0x1001
10002dfc:	e3002452 	movw	r2, #1106	; 0x452
10002e00:	eb000df0 	bl	100065c8 <rt_assert_handler>
    if (set == 0)
10002e04:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002e08:	e3530000 	cmp	r3, #0
10002e0c:	1a000001 	bne	10002e18 <rt_event_recv+0xf0>
        return -RT_ERROR;
10002e10:	e3e03000 	mvn	r3, #0
10002e14:	ea00008b 	b	10003048 <rt_event_recv+0x320>

    /* init status */
    status = -RT_ERROR;
10002e18:	e3e04000 	mvn	r4, #0
    /* get current thread */
    thread = rt_thread_self();
10002e1c:	eb001669 	bl	100087c8 <rt_thread_self>
10002e20:	e50b0018 	str	r0, [fp, #-24]
    /* reset thread error */
    thread->error = RT_EOK;
10002e24:	e51b3018 	ldr	r3, [fp, #-24]
10002e28:	e3a02000 	mov	r2, #0
10002e2c:	e583202c 	str	r2, [r3, #44]	; 0x2c

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
10002e30:	e3093d90 	movw	r3, #40336	; 0x9d90
10002e34:	e3413002 	movt	r3, #4098	; 0x1002
10002e38:	e5933000 	ldr	r3, [r3]
10002e3c:	e3530000 	cmp	r3, #0
10002e40:	0a000005 	beq	10002e5c <rt_event_recv+0x134>
10002e44:	e3093d90 	movw	r3, #40336	; 0x9d90
10002e48:	e3413002 	movt	r3, #4098	; 0x1002
10002e4c:	e5933000 	ldr	r3, [r3]
10002e50:	e51b2020 	ldr	r2, [fp, #-32]
10002e54:	e1a00002 	mov	r0, r2
10002e58:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10002e5c:	eb002196 	bl	1000b4bc <rt_hw_interrupt_disable>
10002e60:	e1a03000 	mov	r3, r0
10002e64:	e1a05003 	mov	r5, r3

    /* check event set */
    if (option & RT_EVENT_FLAG_AND)
10002e68:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
10002e6c:	e2033001 	and	r3, r3, #1
10002e70:	e3530000 	cmp	r3, #0
10002e74:	0a000008 	beq	10002e9c <rt_event_recv+0x174>
    {
        if ((event->set & set) == set)
10002e78:	e51b3020 	ldr	r3, [fp, #-32]
10002e7c:	e5932018 	ldr	r2, [r3, #24]
10002e80:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002e84:	e0022003 	and	r2, r2, r3
10002e88:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002e8c:	e1520003 	cmp	r2, r3
10002e90:	1a000013 	bne	10002ee4 <rt_event_recv+0x1bc>
            status = RT_EOK;
10002e94:	e3a04000 	mov	r4, #0
10002e98:	ea000011 	b	10002ee4 <rt_event_recv+0x1bc>
    }
    else if (option & RT_EVENT_FLAG_OR)
10002e9c:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
10002ea0:	e2033002 	and	r3, r3, #2
10002ea4:	e3530000 	cmp	r3, #0
10002ea8:	0a000007 	beq	10002ecc <rt_event_recv+0x1a4>
    {
        if (event->set & set)
10002eac:	e51b3020 	ldr	r3, [fp, #-32]
10002eb0:	e5932018 	ldr	r2, [r3, #24]
10002eb4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002eb8:	e0033002 	and	r3, r3, r2
10002ebc:	e3530000 	cmp	r3, #0
10002ec0:	0a000007 	beq	10002ee4 <rt_event_recv+0x1bc>
            status = RT_EOK;
10002ec4:	e3a04000 	mov	r4, #0
10002ec8:	ea000005 	b	10002ee4 <rt_event_recv+0x1bc>
    }
    else
    {
        /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
        RT_ASSERT(0);
10002ecc:	e30e038c 	movw	r0, #58252	; 0xe38c
10002ed0:	e3410001 	movt	r0, #4097	; 0x1001
10002ed4:	e30e153c 	movw	r1, #58684	; 0xe53c
10002ed8:	e3411001 	movt	r1, #4097	; 0x1001
10002edc:	e3a02e47 	mov	r2, #1136	; 0x470
10002ee0:	eb000db8 	bl	100065c8 <rt_assert_handler>
    }

    if (status == RT_EOK)
10002ee4:	e3540000 	cmp	r4, #0
10002ee8:	1a000011 	bne	10002f34 <rt_event_recv+0x20c>
    {
        /* set received event */
        *recved = (event->set & set);
10002eec:	e51b3020 	ldr	r3, [fp, #-32]
10002ef0:	e5932018 	ldr	r2, [r3, #24]
10002ef4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002ef8:	e0022003 	and	r2, r2, r3
10002efc:	e59b3004 	ldr	r3, [fp, #4]
10002f00:	e5832000 	str	r2, [r3]

        /* received event */
        if (option & RT_EVENT_FLAG_CLEAR)
10002f04:	e55b3025 	ldrb	r3, [fp, #-37]	; 0x25
10002f08:	e2033004 	and	r3, r3, #4
10002f0c:	e3530000 	cmp	r3, #0
10002f10:	0a00003c 	beq	10003008 <rt_event_recv+0x2e0>
            event->set &= ~set;
10002f14:	e51b3020 	ldr	r3, [fp, #-32]
10002f18:	e5932018 	ldr	r2, [r3, #24]
10002f1c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10002f20:	e1e03003 	mvn	r3, r3
10002f24:	e0022003 	and	r2, r2, r3
10002f28:	e51b3020 	ldr	r3, [fp, #-32]
10002f2c:	e5832018 	str	r2, [r3, #24]
10002f30:	ea000034 	b	10003008 <rt_event_recv+0x2e0>
    }
    else if (timeout == 0)
10002f34:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10002f38:	e3530000 	cmp	r3, #0
10002f3c:	1a000003 	bne	10002f50 <rt_event_recv+0x228>
    {
        /* no waiting */
        thread->error = -RT_ETIMEOUT;
10002f40:	e51b3018 	ldr	r3, [fp, #-24]
10002f44:	e3e02001 	mvn	r2, #1
10002f48:	e583202c 	str	r2, [r3, #44]	; 0x2c
10002f4c:	ea00002d 	b	10003008 <rt_event_recv+0x2e0>
    }
    else
    {
        /* fill thread event info */
        thread->event_set  = set;
10002f50:	e51b3018 	ldr	r3, [fp, #-24]
10002f54:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10002f58:	e5832038 	str	r2, [r3, #56]	; 0x38
        thread->event_info = option;
10002f5c:	e51b3018 	ldr	r3, [fp, #-24]
10002f60:	e55b2025 	ldrb	r2, [fp, #-37]	; 0x25
10002f64:	e5c3203c 	strb	r2, [r3, #60]	; 0x3c

        /* put thread to suspended thread list */
        rt_ipc_list_suspend(&(event->parent.suspend_thread),
10002f68:	e51b3020 	ldr	r3, [fp, #-32]
10002f6c:	e2832010 	add	r2, r3, #16
10002f70:	e51b3020 	ldr	r3, [fp, #-32]
10002f74:	e5d33007 	ldrb	r3, [r3, #7]
10002f78:	e1a00002 	mov	r0, r2
10002f7c:	e51b1018 	ldr	r1, [fp, #-24]
10002f80:	e1a02003 	mov	r2, r3
10002f84:	ebfffa66 	bl	10001924 <rt_ipc_list_suspend>
                            thread,
                            event->parent.parent.flag);

        /* if there is a waiting timeout, active thread timer */
        if (timeout > 0)
10002f88:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10002f8c:	e3530000 	cmp	r3, #0
10002f90:	da00000a 	ble	10002fc0 <rt_event_recv+0x298>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
10002f94:	e51b3018 	ldr	r3, [fp, #-24]
10002f98:	e2832048 	add	r2, r3, #72	; 0x48
10002f9c:	e24b302c 	sub	r3, fp, #44	; 0x2c
10002fa0:	e1a00002 	mov	r0, r2
10002fa4:	e3a01000 	mov	r1, #0
10002fa8:	e1a02003 	mov	r2, r3
10002fac:	eb001a16 	bl	1000980c <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10002fb0:	e51b3018 	ldr	r3, [fp, #-24]
10002fb4:	e2833048 	add	r3, r3, #72	; 0x48
10002fb8:	e1a00003 	mov	r0, r3
10002fbc:	eb00191c 	bl	10009434 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10002fc0:	e1a03005 	mov	r3, r5
10002fc4:	e1a00003 	mov	r0, r3
10002fc8:	eb00213f 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* do a schedule */
        rt_schedule();
10002fcc:	eb00140e 	bl	1000800c <rt_schedule>

        if (thread->error != RT_EOK)
10002fd0:	e51b3018 	ldr	r3, [fp, #-24]
10002fd4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10002fd8:	e3530000 	cmp	r3, #0
10002fdc:	0a000002 	beq	10002fec <rt_event_recv+0x2c4>
        {
            /* return error */
            return thread->error;
10002fe0:	e51b3018 	ldr	r3, [fp, #-24]
10002fe4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10002fe8:	ea000016 	b	10003048 <rt_event_recv+0x320>
        }

        /* received an event, disable interrupt to protect */
        level = rt_hw_interrupt_disable();
10002fec:	eb002132 	bl	1000b4bc <rt_hw_interrupt_disable>
10002ff0:	e1a03000 	mov	r3, r0
10002ff4:	e1a05003 	mov	r5, r3

        /* set received event */
        *recved = thread->event_set;
10002ff8:	e51b3018 	ldr	r3, [fp, #-24]
10002ffc:	e5932038 	ldr	r2, [r3, #56]	; 0x38
10003000:	e59b3004 	ldr	r3, [fp, #4]
10003004:	e5832000 	str	r2, [r3]
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10003008:	e1a03005 	mov	r3, r5
1000300c:	e1a00003 	mov	r0, r3
10003010:	eb00212d 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
10003014:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10003018:	e3413002 	movt	r3, #4098	; 0x1002
1000301c:	e5933000 	ldr	r3, [r3]
10003020:	e3530000 	cmp	r3, #0
10003024:	0a000005 	beq	10003040 <rt_event_recv+0x318>
10003028:	e3093d8c 	movw	r3, #40332	; 0x9d8c
1000302c:	e3413002 	movt	r3, #4098	; 0x1002
10003030:	e5933000 	ldr	r3, [r3]
10003034:	e51b2020 	ldr	r2, [fp, #-32]
10003038:	e1a00002 	mov	r0, r2
1000303c:	e12fff33 	blx	r3

    return thread->error;
10003040:	e51b3018 	ldr	r3, [fp, #-24]
10003044:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
}
10003048:	e1a00003 	mov	r0, r3
1000304c:	e24bd00c 	sub	sp, fp, #12
10003050:	e8bd8830 	pop	{r4, r5, fp, pc}

10003054 <rt_event_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
{
10003054:	e92d4800 	push	{fp, lr}
10003058:	e28db004 	add	fp, sp, #4
1000305c:	e24dd018 	sub	sp, sp, #24
10003060:	e50b0010 	str	r0, [fp, #-16]
10003064:	e1a03001 	mov	r3, r1
10003068:	e50b2018 	str	r2, [fp, #-24]
1000306c:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(event != RT_NULL);
10003070:	e51b3010 	ldr	r3, [fp, #-16]
10003074:	e3530000 	cmp	r3, #0
10003078:	1a000005 	bne	10003094 <rt_event_control+0x40>
1000307c:	e30e03dc 	movw	r0, #58332	; 0xe3dc
10003080:	e3410001 	movt	r0, #4097	; 0x1001
10003084:	e30e154c 	movw	r1, #58700	; 0xe54c
10003088:	e3411001 	movt	r1, #4097	; 0x1001
1000308c:	e30024be 	movw	r2, #1214	; 0x4be
10003090:	eb000d4c 	bl	100065c8 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
10003094:	e55b3011 	ldrb	r3, [fp, #-17]
10003098:	e3530001 	cmp	r3, #1
1000309c:	1a00000f 	bne	100030e0 <rt_event_control+0x8c>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
100030a0:	eb002105 	bl	1000b4bc <rt_hw_interrupt_disable>
100030a4:	e1a03000 	mov	r3, r0
100030a8:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&event->parent.suspend_thread);
100030ac:	e51b3010 	ldr	r3, [fp, #-16]
100030b0:	e2833010 	add	r3, r3, #16
100030b4:	e1a00003 	mov	r0, r3
100030b8:	ebfffa67 	bl	10001a5c <rt_ipc_list_resume_all>

        /* init event set */
        event->set = 0;
100030bc:	e51b3010 	ldr	r3, [fp, #-16]
100030c0:	e3a02000 	mov	r2, #0
100030c4:	e5832018 	str	r2, [r3, #24]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
100030c8:	e51b3008 	ldr	r3, [fp, #-8]
100030cc:	e1a00003 	mov	r0, r3
100030d0:	eb0020fd 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
100030d4:	eb0013cc 	bl	1000800c <rt_schedule>

        return RT_EOK;
100030d8:	e3a03000 	mov	r3, #0
100030dc:	ea000000 	b	100030e4 <rt_event_control+0x90>
    }

    return -RT_ERROR;
100030e0:	e3e03000 	mvn	r3, #0
}
100030e4:	e1a00003 	mov	r0, r3
100030e8:	e24bd004 	sub	sp, fp, #4
100030ec:	e8bd8800 	pop	{fp, pc}

100030f0 <rt_mb_init>:
rt_err_t rt_mb_init(rt_mailbox_t mb,
                    const char  *name,
                    void        *msgpool,
                    rt_size_t    size,
                    rt_uint8_t   flag)
{
100030f0:	e92d4800 	push	{fp, lr}
100030f4:	e28db004 	add	fp, sp, #4
100030f8:	e24dd010 	sub	sp, sp, #16
100030fc:	e50b0008 	str	r0, [fp, #-8]
10003100:	e50b100c 	str	r1, [fp, #-12]
10003104:	e50b2010 	str	r2, [fp, #-16]
10003108:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(mb != RT_NULL);
1000310c:	e51b3008 	ldr	r3, [fp, #-8]
10003110:	e3530000 	cmp	r3, #0
10003114:	1a000005 	bne	10003130 <rt_mb_init+0x40>
10003118:	e30e03f0 	movw	r0, #58352	; 0xe3f0
1000311c:	e3410001 	movt	r0, #4097	; 0x1001
10003120:	e30e1560 	movw	r1, #58720	; 0xe560
10003124:	e3411001 	movt	r1, #4097	; 0x1001
10003128:	e30024eb 	movw	r2, #1259	; 0x4eb
1000312c:	eb000d25 	bl	100065c8 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
10003130:	e51b3008 	ldr	r3, [fp, #-8]
10003134:	e1a00003 	mov	r0, r3
10003138:	e3a01004 	mov	r1, #4
1000313c:	e51b200c 	ldr	r2, [fp, #-12]
10003140:	eb0011b5 	bl	1000781c <rt_object_init>

    /* set parent flag */
    mb->parent.parent.flag = flag;
10003144:	e51b3008 	ldr	r3, [fp, #-8]
10003148:	e5db2004 	ldrb	r2, [fp, #4]
1000314c:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mb->parent));
10003150:	e51b3008 	ldr	r3, [fp, #-8]
10003154:	e1a00003 	mov	r0, r3
10003158:	ebfff9e5 	bl	100018f4 <rt_ipc_object_init>

    /* init mailbox */
    mb->msg_pool   = msgpool;
1000315c:	e51b3008 	ldr	r3, [fp, #-8]
10003160:	e51b2010 	ldr	r2, [fp, #-16]
10003164:	e5832018 	str	r2, [r3, #24]
    mb->size       = size;
10003168:	e51b3014 	ldr	r3, [fp, #-20]
1000316c:	e6ff2073 	uxth	r2, r3
10003170:	e51b3008 	ldr	r3, [fp, #-8]
10003174:	e1c321bc 	strh	r2, [r3, #28]
    mb->entry      = 0;
10003178:	e51b3008 	ldr	r3, [fp, #-8]
1000317c:	e3a02000 	mov	r2, #0
10003180:	e1c321be 	strh	r2, [r3, #30]
    mb->in_offset  = 0;
10003184:	e51b3008 	ldr	r3, [fp, #-8]
10003188:	e3a02000 	mov	r2, #0
1000318c:	e1c322b0 	strh	r2, [r3, #32]
    mb->out_offset = 0;
10003190:	e51b3008 	ldr	r3, [fp, #-8]
10003194:	e3a02000 	mov	r2, #0
10003198:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

    /* init an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
1000319c:	e51b3008 	ldr	r3, [fp, #-8]
100031a0:	e2833024 	add	r3, r3, #36	; 0x24
100031a4:	e1a00003 	mov	r0, r3
100031a8:	ebfff99e 	bl	10001828 <rt_list_init>

    return RT_EOK;
100031ac:	e3a03000 	mov	r3, #0
}
100031b0:	e1a00003 	mov	r0, r3
100031b4:	e24bd004 	sub	sp, fp, #4
100031b8:	e8bd8800 	pop	{fp, pc}

100031bc <rt_mb_detach>:
 * @param mb the mailbox object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mb_detach(rt_mailbox_t mb)
{
100031bc:	e92d4800 	push	{fp, lr}
100031c0:	e28db004 	add	fp, sp, #4
100031c4:	e24dd008 	sub	sp, sp, #8
100031c8:	e50b0008 	str	r0, [fp, #-8]
    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
100031cc:	e51b3008 	ldr	r3, [fp, #-8]
100031d0:	e3530000 	cmp	r3, #0
100031d4:	1a000005 	bne	100031f0 <rt_mb_detach+0x34>
100031d8:	e30e03f0 	movw	r0, #58352	; 0xe3f0
100031dc:	e3410001 	movt	r0, #4097	; 0x1001
100031e0:	e30e156c 	movw	r1, #58732	; 0xe56c
100031e4:	e3411001 	movt	r1, #4097	; 0x1001
100031e8:	e300250e 	movw	r2, #1294	; 0x50e
100031ec:	eb000cf5 	bl	100065c8 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
100031f0:	e51b3008 	ldr	r3, [fp, #-8]
100031f4:	e2833010 	add	r3, r3, #16
100031f8:	e1a00003 	mov	r0, r3
100031fc:	ebfffa16 	bl	10001a5c <rt_ipc_list_resume_all>
    /* also resume all mailbox private suspended thread */
    rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
10003200:	e51b3008 	ldr	r3, [fp, #-8]
10003204:	e2833024 	add	r3, r3, #36	; 0x24
10003208:	e1a00003 	mov	r0, r3
1000320c:	ebfffa12 	bl	10001a5c <rt_ipc_list_resume_all>

    /* detach mailbox object */
    rt_object_detach(&(mb->parent.parent));
10003210:	e51b3008 	ldr	r3, [fp, #-8]
10003214:	e1a00003 	mov	r0, r3
10003218:	eb0011ae 	bl	100078d8 <rt_object_detach>

    return RT_EOK;
1000321c:	e3a03000 	mov	r3, #0
}
10003220:	e1a00003 	mov	r0, r3
10003224:	e24bd004 	sub	sp, fp, #4
10003228:	e8bd8800 	pop	{fp, pc}

1000322c <rt_mb_create>:
 * @param flag the flag of mailbox
 *
 * @return the created mailbox, RT_NULL on error happen
 */
rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
{
1000322c:	e92d4800 	push	{fp, lr}
10003230:	e28db004 	add	fp, sp, #4
10003234:	e24dd018 	sub	sp, sp, #24
10003238:	e50b0010 	str	r0, [fp, #-16]
1000323c:	e50b1014 	str	r1, [fp, #-20]
10003240:	e1a03002 	mov	r3, r2
10003244:	e54b3015 	strb	r3, [fp, #-21]
    rt_mailbox_t mb;

    RT_DEBUG_NOT_IN_INTERRUPT;
10003248:	eb00209b 	bl	1000b4bc <rt_hw_interrupt_disable>
1000324c:	e50b0008 	str	r0, [fp, #-8]
10003250:	eb0005da 	bl	100049c0 <rt_interrupt_get_nest>
10003254:	e1a03000 	mov	r3, r0
10003258:	e3530000 	cmp	r3, #0
1000325c:	0a00000a 	beq	1000328c <rt_mb_create+0x60>
10003260:	e30e0368 	movw	r0, #58216	; 0xe368
10003264:	e3410001 	movt	r0, #4097	; 0x1001
10003268:	e30e157c 	movw	r1, #58748	; 0xe57c
1000326c:	e3411001 	movt	r1, #4097	; 0x1001
10003270:	eb000c17 	bl	100062d4 <rt_kprintf>
10003274:	e30e038c 	movw	r0, #58252	; 0xe38c
10003278:	e3410001 	movt	r0, #4097	; 0x1001
1000327c:	e30e157c 	movw	r1, #58748	; 0xe57c
10003280:	e3411001 	movt	r1, #4097	; 0x1001
10003284:	e300252a 	movw	r2, #1322	; 0x52a
10003288:	eb000cce 	bl	100065c8 <rt_assert_handler>
1000328c:	e51b0008 	ldr	r0, [fp, #-8]
10003290:	eb00208d 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* allocate object */
    mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
10003294:	e3a00004 	mov	r0, #4
10003298:	e51b1010 	ldr	r1, [fp, #-16]
1000329c:	eb0011ae 	bl	1000795c <rt_object_allocate>
100032a0:	e50b000c 	str	r0, [fp, #-12]
    if (mb == RT_NULL)
100032a4:	e51b300c 	ldr	r3, [fp, #-12]
100032a8:	e3530000 	cmp	r3, #0
100032ac:	1a000001 	bne	100032b8 <rt_mb_create+0x8c>
        return mb;
100032b0:	e51b300c 	ldr	r3, [fp, #-12]
100032b4:	ea000028 	b	1000335c <rt_mb_create+0x130>

    /* set parent */
    mb->parent.parent.flag = flag;
100032b8:	e51b300c 	ldr	r3, [fp, #-12]
100032bc:	e55b2015 	ldrb	r2, [fp, #-21]
100032c0:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mb->parent));
100032c4:	e51b300c 	ldr	r3, [fp, #-12]
100032c8:	e1a00003 	mov	r0, r3
100032cc:	ebfff988 	bl	100018f4 <rt_ipc_object_init>

    /* init mailbox */
    mb->size     = size;
100032d0:	e51b3014 	ldr	r3, [fp, #-20]
100032d4:	e6ff2073 	uxth	r2, r3
100032d8:	e51b300c 	ldr	r3, [fp, #-12]
100032dc:	e1c321bc 	strh	r2, [r3, #28]
    mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
100032e0:	e51b300c 	ldr	r3, [fp, #-12]
100032e4:	e1d331bc 	ldrh	r3, [r3, #28]
100032e8:	e1a03103 	lsl	r3, r3, #2
100032ec:	e1a00003 	mov	r0, r3
100032f0:	eb000dec 	bl	10006aa8 <rt_malloc>
100032f4:	e1a02000 	mov	r2, r0
100032f8:	e51b300c 	ldr	r3, [fp, #-12]
100032fc:	e5832018 	str	r2, [r3, #24]
    if (mb->msg_pool == RT_NULL)
10003300:	e51b300c 	ldr	r3, [fp, #-12]
10003304:	e5933018 	ldr	r3, [r3, #24]
10003308:	e3530000 	cmp	r3, #0
1000330c:	1a000004 	bne	10003324 <rt_mb_create+0xf8>
    {
        /* delete mailbox object */
        rt_object_delete(&(mb->parent.parent));
10003310:	e51b300c 	ldr	r3, [fp, #-12]
10003314:	e1a00003 	mov	r0, r3
10003318:	eb0011dc 	bl	10007a90 <rt_object_delete>

        return RT_NULL;
1000331c:	e3a03000 	mov	r3, #0
10003320:	ea00000d 	b	1000335c <rt_mb_create+0x130>
    }
    mb->entry      = 0;
10003324:	e51b300c 	ldr	r3, [fp, #-12]
10003328:	e3a02000 	mov	r2, #0
1000332c:	e1c321be 	strh	r2, [r3, #30]
    mb->in_offset  = 0;
10003330:	e51b300c 	ldr	r3, [fp, #-12]
10003334:	e3a02000 	mov	r2, #0
10003338:	e1c322b0 	strh	r2, [r3, #32]
    mb->out_offset = 0;
1000333c:	e51b300c 	ldr	r3, [fp, #-12]
10003340:	e3a02000 	mov	r2, #0
10003344:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

    /* init an additional list of sender suspend thread */
    rt_list_init(&(mb->suspend_sender_thread));
10003348:	e51b300c 	ldr	r3, [fp, #-12]
1000334c:	e2833024 	add	r3, r3, #36	; 0x24
10003350:	e1a00003 	mov	r0, r3
10003354:	ebfff933 	bl	10001828 <rt_list_init>

    return mb;
10003358:	e51b300c 	ldr	r3, [fp, #-12]
}
1000335c:	e1a00003 	mov	r0, r3
10003360:	e24bd004 	sub	sp, fp, #4
10003364:	e8bd8800 	pop	{fp, pc}

10003368 <rt_mb_delete>:
 * @param mb the mailbox object
 *
 * @return the error code
 */
rt_err_t rt_mb_delete(rt_mailbox_t mb)
{
10003368:	e92d4800 	push	{fp, lr}
1000336c:	e28db004 	add	fp, sp, #4
10003370:	e24dd010 	sub	sp, sp, #16
10003374:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
10003378:	eb00204f 	bl	1000b4bc <rt_hw_interrupt_disable>
1000337c:	e50b0008 	str	r0, [fp, #-8]
10003380:	eb00058e 	bl	100049c0 <rt_interrupt_get_nest>
10003384:	e1a03000 	mov	r3, r0
10003388:	e3530000 	cmp	r3, #0
1000338c:	0a00000a 	beq	100033bc <rt_mb_delete+0x54>
10003390:	e30e0368 	movw	r0, #58216	; 0xe368
10003394:	e3410001 	movt	r0, #4097	; 0x1001
10003398:	e30e158c 	movw	r1, #58764	; 0xe58c
1000339c:	e3411001 	movt	r1, #4097	; 0x1001
100033a0:	eb000bcb 	bl	100062d4 <rt_kprintf>
100033a4:	e30e038c 	movw	r0, #58252	; 0xe38c
100033a8:	e3410001 	movt	r0, #4097	; 0x1001
100033ac:	e30e158c 	movw	r1, #58764	; 0xe58c
100033b0:	e3411001 	movt	r1, #4097	; 0x1001
100033b4:	e3002555 	movw	r2, #1365	; 0x555
100033b8:	eb000c82 	bl	100065c8 <rt_assert_handler>
100033bc:	e51b0008 	ldr	r0, [fp, #-8]
100033c0:	eb002041 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
100033c4:	e51b3010 	ldr	r3, [fp, #-16]
100033c8:	e3530000 	cmp	r3, #0
100033cc:	1a000005 	bne	100033e8 <rt_mb_delete+0x80>
100033d0:	e30e03f0 	movw	r0, #58352	; 0xe3f0
100033d4:	e3410001 	movt	r0, #4097	; 0x1001
100033d8:	e30e158c 	movw	r1, #58764	; 0xe58c
100033dc:	e3411001 	movt	r1, #4097	; 0x1001
100033e0:	e3002558 	movw	r2, #1368	; 0x558
100033e4:	eb000c77 	bl	100065c8 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
100033e8:	e51b3010 	ldr	r3, [fp, #-16]
100033ec:	e2833010 	add	r3, r3, #16
100033f0:	e1a00003 	mov	r0, r3
100033f4:	ebfff998 	bl	10001a5c <rt_ipc_list_resume_all>

    /* also resume all mailbox private suspended thread */
    rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
100033f8:	e51b3010 	ldr	r3, [fp, #-16]
100033fc:	e2833024 	add	r3, r3, #36	; 0x24
10003400:	e1a00003 	mov	r0, r3
10003404:	ebfff994 	bl	10001a5c <rt_ipc_list_resume_all>
        rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
    else
#endif

    /* free mailbox pool */
    RT_KERNEL_FREE(mb->msg_pool);
10003408:	e51b3010 	ldr	r3, [fp, #-16]
1000340c:	e5933018 	ldr	r3, [r3, #24]
10003410:	e1a00003 	mov	r0, r3
10003414:	eb000fbe 	bl	10007314 <rt_free>

    /* delete mailbox object */
    rt_object_delete(&(mb->parent.parent));
10003418:	e51b3010 	ldr	r3, [fp, #-16]
1000341c:	e1a00003 	mov	r0, r3
10003420:	eb00119a 	bl	10007a90 <rt_object_delete>

    return RT_EOK;
10003424:	e3a03000 	mov	r3, #0
}
10003428:	e1a00003 	mov	r0, r3
1000342c:	e24bd004 	sub	sp, fp, #4
10003430:	e8bd8800 	pop	{fp, pc}

10003434 <rt_mb_send_wait>:
 * @return the error code
 */
rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
                         rt_uint32_t  value,
                         rt_int32_t   timeout)
{
10003434:	e92d4810 	push	{r4, fp, lr}
10003438:	e28db008 	add	fp, sp, #8
1000343c:	e24dd024 	sub	sp, sp, #36	; 0x24
10003440:	e50b0020 	str	r0, [fp, #-32]
10003444:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10003448:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
1000344c:	e51b3020 	ldr	r3, [fp, #-32]
10003450:	e3530000 	cmp	r3, #0
10003454:	1a000005 	bne	10003470 <rt_mb_send_wait+0x3c>
10003458:	e30e03f0 	movw	r0, #58352	; 0xe3f0
1000345c:	e3410001 	movt	r0, #4097	; 0x1001
10003460:	e30e159c 	movw	r1, #58780	; 0xe59c
10003464:	e3411001 	movt	r1, #4097	; 0x1001
10003468:	e3002585 	movw	r2, #1413	; 0x585
1000346c:	eb000c55 	bl	100065c8 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
10003470:	e3a03000 	mov	r3, #0
10003474:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
10003478:	eb0014d2 	bl	100087c8 <rt_thread_self>
1000347c:	e50b0014 	str	r0, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
10003480:	e3093d88 	movw	r3, #40328	; 0x9d88
10003484:	e3413002 	movt	r3, #4098	; 0x1002
10003488:	e5933000 	ldr	r3, [r3]
1000348c:	e3530000 	cmp	r3, #0
10003490:	0a000005 	beq	100034ac <rt_mb_send_wait+0x78>
10003494:	e3093d88 	movw	r3, #40328	; 0x9d88
10003498:	e3413002 	movt	r3, #4098	; 0x1002
1000349c:	e5933000 	ldr	r3, [r3]
100034a0:	e51b2020 	ldr	r2, [fp, #-32]
100034a4:	e1a00002 	mov	r0, r2
100034a8:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
100034ac:	eb002002 	bl	1000b4bc <rt_hw_interrupt_disable>
100034b0:	e1a03000 	mov	r3, r0
100034b4:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mb->entry == mb->size && timeout == 0)
100034b8:	e51b3020 	ldr	r3, [fp, #-32]
100034bc:	e1d321be 	ldrh	r2, [r3, #30]
100034c0:	e51b3020 	ldr	r3, [fp, #-32]
100034c4:	e1d331bc 	ldrh	r3, [r3, #28]
100034c8:	e1520003 	cmp	r2, r3
100034cc:	1a000007 	bne	100034f0 <rt_mb_send_wait+0xbc>
100034d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100034d4:	e3530000 	cmp	r3, #0
100034d8:	1a000004 	bne	100034f0 <rt_mb_send_wait+0xbc>
    {
        rt_hw_interrupt_enable(temp);
100034dc:	e1a03004 	mov	r3, r4
100034e0:	e1a00003 	mov	r0, r3
100034e4:	eb001ff8 	bl	1000b4cc <rt_hw_interrupt_enable>

        return -RT_EFULL;
100034e8:	e3e03002 	mvn	r3, #2
100034ec:	ea0000a1 	b	10003778 <rt_mb_send_wait+0x344>
    }

    /* mailbox is full */
    while (mb->entry == mb->size)
100034f0:	ea000068 	b	10003698 <rt_mb_send_wait+0x264>
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
100034f4:	e51b3014 	ldr	r3, [fp, #-20]
100034f8:	e3a02000 	mov	r2, #0
100034fc:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
10003500:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003504:	e3530000 	cmp	r3, #0
10003508:	1a000004 	bne	10003520 <rt_mb_send_wait+0xec>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
1000350c:	e1a03004 	mov	r3, r4
10003510:	e1a00003 	mov	r0, r3
10003514:	eb001fec 	bl	1000b4cc <rt_hw_interrupt_enable>

            return -RT_EFULL;
10003518:	e3e03002 	mvn	r3, #2
1000351c:	ea000095 	b	10003778 <rt_mb_send_wait+0x344>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
10003520:	eb001fe5 	bl	1000b4bc <rt_hw_interrupt_disable>
10003524:	e50b0018 	str	r0, [fp, #-24]
10003528:	eb0014a6 	bl	100087c8 <rt_thread_self>
1000352c:	e1a03000 	mov	r3, r0
10003530:	e3530000 	cmp	r3, #0
10003534:	1a00000a 	bne	10003564 <rt_mb_send_wait+0x130>
10003538:	e30e0390 	movw	r0, #58256	; 0xe390
1000353c:	e3410001 	movt	r0, #4097	; 0x1001
10003540:	e30e159c 	movw	r1, #58780	; 0xe59c
10003544:	e3411001 	movt	r1, #4097	; 0x1001
10003548:	eb000b61 	bl	100062d4 <rt_kprintf>
1000354c:	e30e038c 	movw	r0, #58252	; 0xe38c
10003550:	e3410001 	movt	r0, #4097	; 0x1001
10003554:	e30e159c 	movw	r1, #58780	; 0xe59c
10003558:	e3411001 	movt	r1, #4097	; 0x1001
1000355c:	e30025a8 	movw	r2, #1448	; 0x5a8
10003560:	eb000c18 	bl	100065c8 <rt_assert_handler>
10003564:	eb001fd4 	bl	1000b4bc <rt_hw_interrupt_disable>
10003568:	e50b001c 	str	r0, [fp, #-28]
1000356c:	eb000513 	bl	100049c0 <rt_interrupt_get_nest>
10003570:	e1a03000 	mov	r3, r0
10003574:	e3530000 	cmp	r3, #0
10003578:	0a00000a 	beq	100035a8 <rt_mb_send_wait+0x174>
1000357c:	e30e0368 	movw	r0, #58216	; 0xe368
10003580:	e3410001 	movt	r0, #4097	; 0x1001
10003584:	e30e159c 	movw	r1, #58780	; 0xe59c
10003588:	e3411001 	movt	r1, #4097	; 0x1001
1000358c:	eb000b50 	bl	100062d4 <rt_kprintf>
10003590:	e30e038c 	movw	r0, #58252	; 0xe38c
10003594:	e3410001 	movt	r0, #4097	; 0x1001
10003598:	e30e159c 	movw	r1, #58780	; 0xe59c
1000359c:	e3411001 	movt	r1, #4097	; 0x1001
100035a0:	e30025a8 	movw	r2, #1448	; 0x5a8
100035a4:	eb000c07 	bl	100065c8 <rt_assert_handler>
100035a8:	e51b001c 	ldr	r0, [fp, #-28]
100035ac:	eb001fc6 	bl	1000b4cc <rt_hw_interrupt_enable>
100035b0:	e51b0018 	ldr	r0, [fp, #-24]
100035b4:	eb001fc4 	bl	1000b4cc <rt_hw_interrupt_enable>
        /* suspend current thread */
        rt_ipc_list_suspend(&(mb->suspend_sender_thread),
100035b8:	e51b3020 	ldr	r3, [fp, #-32]
100035bc:	e2832024 	add	r2, r3, #36	; 0x24
100035c0:	e51b3020 	ldr	r3, [fp, #-32]
100035c4:	e5d33007 	ldrb	r3, [r3, #7]
100035c8:	e1a00002 	mov	r0, r2
100035cc:	e51b1014 	ldr	r1, [fp, #-20]
100035d0:	e1a02003 	mov	r2, r3
100035d4:	ebfff8d2 	bl	10001924 <rt_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
100035d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100035dc:	e3530000 	cmp	r3, #0
100035e0:	da00000c 	ble	10003618 <rt_mb_send_wait+0x1e4>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
100035e4:	ebfff586 	bl	10000c04 <rt_tick_get>
100035e8:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
100035ec:	e51b3014 	ldr	r3, [fp, #-20]
100035f0:	e2832048 	add	r2, r3, #72	; 0x48
100035f4:	e24b3028 	sub	r3, fp, #40	; 0x28
100035f8:	e1a00002 	mov	r0, r2
100035fc:	e3a01000 	mov	r1, #0
10003600:	e1a02003 	mov	r2, r3
10003604:	eb001880 	bl	1000980c <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10003608:	e51b3014 	ldr	r3, [fp, #-20]
1000360c:	e2833048 	add	r3, r3, #72	; 0x48
10003610:	e1a00003 	mov	r0, r3
10003614:	eb001786 	bl	10009434 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10003618:	e1a03004 	mov	r3, r4
1000361c:	e1a00003 	mov	r0, r3
10003620:	eb001fa9 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
10003624:	eb001278 	bl	1000800c <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
10003628:	e51b3014 	ldr	r3, [fp, #-20]
1000362c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10003630:	e3530000 	cmp	r3, #0
10003634:	0a000002 	beq	10003644 <rt_mb_send_wait+0x210>
        {
            /* return error */
            return thread->error;
10003638:	e51b3014 	ldr	r3, [fp, #-20]
1000363c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10003640:	ea00004c 	b	10003778 <rt_mb_send_wait+0x344>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10003644:	eb001f9c 	bl	1000b4bc <rt_hw_interrupt_disable>
10003648:	e1a03000 	mov	r3, r0
1000364c:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
10003650:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003654:	e3530000 	cmp	r3, #0
10003658:	da00000e 	ble	10003698 <rt_mb_send_wait+0x264>
        {
            tick_delta = rt_tick_get() - tick_delta;
1000365c:	ebfff568 	bl	10000c04 <rt_tick_get>
10003660:	e1a02000 	mov	r2, r0
10003664:	e51b3010 	ldr	r3, [fp, #-16]
10003668:	e0633002 	rsb	r3, r3, r2
1000366c:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
10003670:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003674:	e1a02003 	mov	r2, r3
10003678:	e51b3010 	ldr	r3, [fp, #-16]
1000367c:	e0633002 	rsb	r3, r3, r2
10003680:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            if (timeout < 0)
10003684:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003688:	e3530000 	cmp	r3, #0
1000368c:	aa000001 	bge	10003698 <rt_mb_send_wait+0x264>
                timeout = 0;
10003690:	e3a03000 	mov	r3, #0
10003694:	e50b3028 	str	r3, [fp, #-40]	; 0x28

        return -RT_EFULL;
    }

    /* mailbox is full */
    while (mb->entry == mb->size)
10003698:	e51b3020 	ldr	r3, [fp, #-32]
1000369c:	e1d321be 	ldrh	r2, [r3, #30]
100036a0:	e51b3020 	ldr	r3, [fp, #-32]
100036a4:	e1d331bc 	ldrh	r3, [r3, #28]
100036a8:	e1520003 	cmp	r2, r3
100036ac:	0affff90 	beq	100034f4 <rt_mb_send_wait+0xc0>
                timeout = 0;
        }
    }

    /* set ptr */
    mb->msg_pool[mb->in_offset] = value;
100036b0:	e51b3020 	ldr	r3, [fp, #-32]
100036b4:	e5932018 	ldr	r2, [r3, #24]
100036b8:	e51b3020 	ldr	r3, [fp, #-32]
100036bc:	e1d332b0 	ldrh	r3, [r3, #32]
100036c0:	e1a03103 	lsl	r3, r3, #2
100036c4:	e0823003 	add	r3, r2, r3
100036c8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100036cc:	e5832000 	str	r2, [r3]
    /* increase input offset */
    ++ mb->in_offset;
100036d0:	e51b3020 	ldr	r3, [fp, #-32]
100036d4:	e1d332b0 	ldrh	r3, [r3, #32]
100036d8:	e2833001 	add	r3, r3, #1
100036dc:	e6ff2073 	uxth	r2, r3
100036e0:	e51b3020 	ldr	r3, [fp, #-32]
100036e4:	e1c322b0 	strh	r2, [r3, #32]
    if (mb->in_offset >= mb->size)
100036e8:	e51b3020 	ldr	r3, [fp, #-32]
100036ec:	e1d322b0 	ldrh	r2, [r3, #32]
100036f0:	e51b3020 	ldr	r3, [fp, #-32]
100036f4:	e1d331bc 	ldrh	r3, [r3, #28]
100036f8:	e1520003 	cmp	r2, r3
100036fc:	3a000002 	bcc	1000370c <rt_mb_send_wait+0x2d8>
        mb->in_offset = 0;
10003700:	e51b3020 	ldr	r3, [fp, #-32]
10003704:	e3a02000 	mov	r2, #0
10003708:	e1c322b0 	strh	r2, [r3, #32]
    /* increase message entry */
    mb->entry ++;
1000370c:	e51b3020 	ldr	r3, [fp, #-32]
10003710:	e1d331be 	ldrh	r3, [r3, #30]
10003714:	e2833001 	add	r3, r3, #1
10003718:	e6ff2073 	uxth	r2, r3
1000371c:	e51b3020 	ldr	r3, [fp, #-32]
10003720:	e1c321be 	strh	r2, [r3, #30]

    /* resume suspended thread */
    if (!rt_list_isempty(&mb->parent.suspend_thread))
10003724:	e51b3020 	ldr	r3, [fp, #-32]
10003728:	e2833010 	add	r3, r3, #16
1000372c:	e1a00003 	mov	r0, r3
10003730:	ebfff860 	bl	100018b8 <rt_list_isempty>
10003734:	e1a03000 	mov	r3, r0
10003738:	e3530000 	cmp	r3, #0
1000373c:	1a000009 	bne	10003768 <rt_mb_send_wait+0x334>
    {
        rt_ipc_list_resume(&(mb->parent.suspend_thread));
10003740:	e51b3020 	ldr	r3, [fp, #-32]
10003744:	e2833010 	add	r3, r3, #16
10003748:	e1a00003 	mov	r0, r3
1000374c:	ebfff8b4 	bl	10001a24 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10003750:	e1a03004 	mov	r3, r4
10003754:	e1a00003 	mov	r0, r3
10003758:	eb001f5b 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
1000375c:	eb00122a 	bl	1000800c <rt_schedule>

        return RT_EOK;
10003760:	e3a03000 	mov	r3, #0
10003764:	ea000003 	b	10003778 <rt_mb_send_wait+0x344>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10003768:	e1a03004 	mov	r3, r4
1000376c:	e1a00003 	mov	r0, r3
10003770:	eb001f55 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
10003774:	e3a03000 	mov	r3, #0
}
10003778:	e1a00003 	mov	r0, r3
1000377c:	e24bd008 	sub	sp, fp, #8
10003780:	e8bd8810 	pop	{r4, fp, pc}

10003784 <rt_mb_send>:
 * @param value the mail
 *
 * @return the error code
 */
rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
{
10003784:	e92d4800 	push	{fp, lr}
10003788:	e28db004 	add	fp, sp, #4
1000378c:	e24dd008 	sub	sp, sp, #8
10003790:	e50b0008 	str	r0, [fp, #-8]
10003794:	e50b100c 	str	r1, [fp, #-12]
    return rt_mb_send_wait(mb, value, 0);
10003798:	e51b0008 	ldr	r0, [fp, #-8]
1000379c:	e51b100c 	ldr	r1, [fp, #-12]
100037a0:	e3a02000 	mov	r2, #0
100037a4:	ebffff22 	bl	10003434 <rt_mb_send_wait>
100037a8:	e1a03000 	mov	r3, r0
}
100037ac:	e1a00003 	mov	r0, r3
100037b0:	e24bd004 	sub	sp, fp, #4
100037b4:	e8bd8800 	pop	{fp, pc}

100037b8 <rt_mb_recv>:
 * @param timeout the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
{
100037b8:	e92d4810 	push	{r4, fp, lr}
100037bc:	e28db008 	add	fp, sp, #8
100037c0:	e24dd024 	sub	sp, sp, #36	; 0x24
100037c4:	e50b0020 	str	r0, [fp, #-32]
100037c8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
100037cc:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    struct rt_thread *thread;
    register rt_ubase_t temp;
    rt_uint32_t tick_delta;

    /* parameter check */
    RT_ASSERT(mb != RT_NULL);
100037d0:	e51b3020 	ldr	r3, [fp, #-32]
100037d4:	e3530000 	cmp	r3, #0
100037d8:	1a000005 	bne	100037f4 <rt_mb_recv+0x3c>
100037dc:	e30e03f0 	movw	r0, #58352	; 0xe3f0
100037e0:	e3410001 	movt	r0, #4097	; 0x1001
100037e4:	e30e15ac 	movw	r1, #58796	; 0xe5ac
100037e8:	e3411001 	movt	r1, #4097	; 0x1001
100037ec:	e3002616 	movw	r2, #1558	; 0x616
100037f0:	eb000b74 	bl	100065c8 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
100037f4:	e3a03000 	mov	r3, #0
100037f8:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
100037fc:	eb0013f1 	bl	100087c8 <rt_thread_self>
10003800:	e50b0014 	str	r0, [fp, #-20]

    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
10003804:	e3093d90 	movw	r3, #40336	; 0x9d90
10003808:	e3413002 	movt	r3, #4098	; 0x1002
1000380c:	e5933000 	ldr	r3, [r3]
10003810:	e3530000 	cmp	r3, #0
10003814:	0a000005 	beq	10003830 <rt_mb_recv+0x78>
10003818:	e3093d90 	movw	r3, #40336	; 0x9d90
1000381c:	e3413002 	movt	r3, #4098	; 0x1002
10003820:	e5933000 	ldr	r3, [r3]
10003824:	e51b2020 	ldr	r2, [fp, #-32]
10003828:	e1a00002 	mov	r0, r2
1000382c:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10003830:	eb001f21 	bl	1000b4bc <rt_hw_interrupt_disable>
10003834:	e1a03000 	mov	r3, r0
10003838:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mb->entry == 0 && timeout == 0)
1000383c:	e51b3020 	ldr	r3, [fp, #-32]
10003840:	e1d331be 	ldrh	r3, [r3, #30]
10003844:	e3530000 	cmp	r3, #0
10003848:	1a000007 	bne	1000386c <rt_mb_recv+0xb4>
1000384c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003850:	e3530000 	cmp	r3, #0
10003854:	1a000004 	bne	1000386c <rt_mb_recv+0xb4>
    {
        rt_hw_interrupt_enable(temp);
10003858:	e1a03004 	mov	r3, r4
1000385c:	e1a00003 	mov	r0, r3
10003860:	eb001f19 	bl	1000b4cc <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
10003864:	e3e03001 	mvn	r3, #1
10003868:	ea0000b9 	b	10003b54 <rt_mb_recv+0x39c>
    }

    /* mailbox is empty */
    while (mb->entry == 0)
1000386c:	ea00006b 	b	10003a20 <rt_mb_recv+0x268>
    {
        /* reset error number in thread */
        thread->error = RT_EOK;
10003870:	e51b3014 	ldr	r3, [fp, #-20]
10003874:	e3a02000 	mov	r2, #0
10003878:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
1000387c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003880:	e3530000 	cmp	r3, #0
10003884:	1a000007 	bne	100038a8 <rt_mb_recv+0xf0>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
10003888:	e1a03004 	mov	r3, r4
1000388c:	e1a00003 	mov	r0, r3
10003890:	eb001f0d 	bl	1000b4cc <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
10003894:	e51b3014 	ldr	r3, [fp, #-20]
10003898:	e3e02001 	mvn	r2, #1
1000389c:	e583202c 	str	r2, [r3, #44]	; 0x2c

            return -RT_ETIMEOUT;
100038a0:	e3e03001 	mvn	r3, #1
100038a4:	ea0000aa 	b	10003b54 <rt_mb_recv+0x39c>
        }

        RT_DEBUG_IN_THREAD_CONTEXT;
100038a8:	eb001f03 	bl	1000b4bc <rt_hw_interrupt_disable>
100038ac:	e50b0018 	str	r0, [fp, #-24]
100038b0:	eb0013c4 	bl	100087c8 <rt_thread_self>
100038b4:	e1a03000 	mov	r3, r0
100038b8:	e3530000 	cmp	r3, #0
100038bc:	1a00000a 	bne	100038ec <rt_mb_recv+0x134>
100038c0:	e30e0390 	movw	r0, #58256	; 0xe390
100038c4:	e3410001 	movt	r0, #4097	; 0x1001
100038c8:	e30e15ac 	movw	r1, #58796	; 0xe5ac
100038cc:	e3411001 	movt	r1, #4097	; 0x1001
100038d0:	eb000a7f 	bl	100062d4 <rt_kprintf>
100038d4:	e30e038c 	movw	r0, #58252	; 0xe38c
100038d8:	e3410001 	movt	r0, #4097	; 0x1001
100038dc:	e30e15ac 	movw	r1, #58796	; 0xe5ac
100038e0:	e3411001 	movt	r1, #4097	; 0x1001
100038e4:	e300263b 	movw	r2, #1595	; 0x63b
100038e8:	eb000b36 	bl	100065c8 <rt_assert_handler>
100038ec:	eb001ef2 	bl	1000b4bc <rt_hw_interrupt_disable>
100038f0:	e50b001c 	str	r0, [fp, #-28]
100038f4:	eb000431 	bl	100049c0 <rt_interrupt_get_nest>
100038f8:	e1a03000 	mov	r3, r0
100038fc:	e3530000 	cmp	r3, #0
10003900:	0a00000a 	beq	10003930 <rt_mb_recv+0x178>
10003904:	e30e0368 	movw	r0, #58216	; 0xe368
10003908:	e3410001 	movt	r0, #4097	; 0x1001
1000390c:	e30e15ac 	movw	r1, #58796	; 0xe5ac
10003910:	e3411001 	movt	r1, #4097	; 0x1001
10003914:	eb000a6e 	bl	100062d4 <rt_kprintf>
10003918:	e30e038c 	movw	r0, #58252	; 0xe38c
1000391c:	e3410001 	movt	r0, #4097	; 0x1001
10003920:	e30e15ac 	movw	r1, #58796	; 0xe5ac
10003924:	e3411001 	movt	r1, #4097	; 0x1001
10003928:	e300263b 	movw	r2, #1595	; 0x63b
1000392c:	eb000b25 	bl	100065c8 <rt_assert_handler>
10003930:	e51b001c 	ldr	r0, [fp, #-28]
10003934:	eb001ee4 	bl	1000b4cc <rt_hw_interrupt_enable>
10003938:	e51b0018 	ldr	r0, [fp, #-24]
1000393c:	eb001ee2 	bl	1000b4cc <rt_hw_interrupt_enable>
        /* suspend current thread */
        rt_ipc_list_suspend(&(mb->parent.suspend_thread),
10003940:	e51b3020 	ldr	r3, [fp, #-32]
10003944:	e2832010 	add	r2, r3, #16
10003948:	e51b3020 	ldr	r3, [fp, #-32]
1000394c:	e5d33007 	ldrb	r3, [r3, #7]
10003950:	e1a00002 	mov	r0, r2
10003954:	e51b1014 	ldr	r1, [fp, #-20]
10003958:	e1a02003 	mov	r2, r3
1000395c:	ebfff7f0 	bl	10001924 <rt_ipc_list_suspend>
                            thread,
                            mb->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
10003960:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003964:	e3530000 	cmp	r3, #0
10003968:	da00000c 	ble	100039a0 <rt_mb_recv+0x1e8>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
1000396c:	ebfff4a4 	bl	10000c04 <rt_tick_get>
10003970:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
10003974:	e51b3014 	ldr	r3, [fp, #-20]
10003978:	e2832048 	add	r2, r3, #72	; 0x48
1000397c:	e24b3028 	sub	r3, fp, #40	; 0x28
10003980:	e1a00002 	mov	r0, r2
10003984:	e3a01000 	mov	r1, #0
10003988:	e1a02003 	mov	r2, r3
1000398c:	eb00179e 	bl	1000980c <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10003990:	e51b3014 	ldr	r3, [fp, #-20]
10003994:	e2833048 	add	r3, r3, #72	; 0x48
10003998:	e1a00003 	mov	r0, r3
1000399c:	eb0016a4 	bl	10009434 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
100039a0:	e1a03004 	mov	r3, r4
100039a4:	e1a00003 	mov	r0, r3
100039a8:	eb001ec7 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
100039ac:	eb001196 	bl	1000800c <rt_schedule>

        /* resume from suspend state */
        if (thread->error != RT_EOK)
100039b0:	e51b3014 	ldr	r3, [fp, #-20]
100039b4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100039b8:	e3530000 	cmp	r3, #0
100039bc:	0a000002 	beq	100039cc <rt_mb_recv+0x214>
        {
            /* return error */
            return thread->error;
100039c0:	e51b3014 	ldr	r3, [fp, #-20]
100039c4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100039c8:	ea000061 	b	10003b54 <rt_mb_recv+0x39c>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
100039cc:	eb001eba 	bl	1000b4bc <rt_hw_interrupt_disable>
100039d0:	e1a03000 	mov	r3, r0
100039d4:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
100039d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100039dc:	e3530000 	cmp	r3, #0
100039e0:	da00000e 	ble	10003a20 <rt_mb_recv+0x268>
        {
            tick_delta = rt_tick_get() - tick_delta;
100039e4:	ebfff486 	bl	10000c04 <rt_tick_get>
100039e8:	e1a02000 	mov	r2, r0
100039ec:	e51b3010 	ldr	r3, [fp, #-16]
100039f0:	e0633002 	rsb	r3, r3, r2
100039f4:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
100039f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100039fc:	e1a02003 	mov	r2, r3
10003a00:	e51b3010 	ldr	r3, [fp, #-16]
10003a04:	e0633002 	rsb	r3, r3, r2
10003a08:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            if (timeout < 0)
10003a0c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003a10:	e3530000 	cmp	r3, #0
10003a14:	aa000001 	bge	10003a20 <rt_mb_recv+0x268>
                timeout = 0;
10003a18:	e3a03000 	mov	r3, #0
10003a1c:	e50b3028 	str	r3, [fp, #-40]	; 0x28

        return -RT_ETIMEOUT;
    }

    /* mailbox is empty */
    while (mb->entry == 0)
10003a20:	e51b3020 	ldr	r3, [fp, #-32]
10003a24:	e1d331be 	ldrh	r3, [r3, #30]
10003a28:	e3530000 	cmp	r3, #0
10003a2c:	0affff8f 	beq	10003870 <rt_mb_recv+0xb8>
                timeout = 0;
        }
    }

    /* fill ptr */
    *value = mb->msg_pool[mb->out_offset];
10003a30:	e51b3020 	ldr	r3, [fp, #-32]
10003a34:	e5932018 	ldr	r2, [r3, #24]
10003a38:	e51b3020 	ldr	r3, [fp, #-32]
10003a3c:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
10003a40:	e1a03103 	lsl	r3, r3, #2
10003a44:	e0823003 	add	r3, r2, r3
10003a48:	e5932000 	ldr	r2, [r3]
10003a4c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10003a50:	e5832000 	str	r2, [r3]

    /* increase output offset */
    ++ mb->out_offset;
10003a54:	e51b3020 	ldr	r3, [fp, #-32]
10003a58:	e1d332b2 	ldrh	r3, [r3, #34]	; 0x22
10003a5c:	e2833001 	add	r3, r3, #1
10003a60:	e6ff2073 	uxth	r2, r3
10003a64:	e51b3020 	ldr	r3, [fp, #-32]
10003a68:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    if (mb->out_offset >= mb->size)
10003a6c:	e51b3020 	ldr	r3, [fp, #-32]
10003a70:	e1d322b2 	ldrh	r2, [r3, #34]	; 0x22
10003a74:	e51b3020 	ldr	r3, [fp, #-32]
10003a78:	e1d331bc 	ldrh	r3, [r3, #28]
10003a7c:	e1520003 	cmp	r2, r3
10003a80:	3a000002 	bcc	10003a90 <rt_mb_recv+0x2d8>
        mb->out_offset = 0;
10003a84:	e51b3020 	ldr	r3, [fp, #-32]
10003a88:	e3a02000 	mov	r2, #0
10003a8c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
    /* decrease message entry */
    mb->entry --;
10003a90:	e51b3020 	ldr	r3, [fp, #-32]
10003a94:	e1d331be 	ldrh	r3, [r3, #30]
10003a98:	e2433001 	sub	r3, r3, #1
10003a9c:	e6ff2073 	uxth	r2, r3
10003aa0:	e51b3020 	ldr	r3, [fp, #-32]
10003aa4:	e1c321be 	strh	r2, [r3, #30]

    /* resume suspended thread */
    if (!rt_list_isempty(&(mb->suspend_sender_thread)))
10003aa8:	e51b3020 	ldr	r3, [fp, #-32]
10003aac:	e2833024 	add	r3, r3, #36	; 0x24
10003ab0:	e1a00003 	mov	r0, r3
10003ab4:	ebfff77f 	bl	100018b8 <rt_list_isempty>
10003ab8:	e1a03000 	mov	r3, r0
10003abc:	e3530000 	cmp	r3, #0
10003ac0:	1a000014 	bne	10003b18 <rt_mb_recv+0x360>
    {
        rt_ipc_list_resume(&(mb->suspend_sender_thread));
10003ac4:	e51b3020 	ldr	r3, [fp, #-32]
10003ac8:	e2833024 	add	r3, r3, #36	; 0x24
10003acc:	e1a00003 	mov	r0, r3
10003ad0:	ebfff7d3 	bl	10001a24 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10003ad4:	e1a03004 	mov	r3, r4
10003ad8:	e1a00003 	mov	r0, r3
10003adc:	eb001e7a 	bl	1000b4cc <rt_hw_interrupt_enable>

        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
10003ae0:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10003ae4:	e3413002 	movt	r3, #4098	; 0x1002
10003ae8:	e5933000 	ldr	r3, [r3]
10003aec:	e3530000 	cmp	r3, #0
10003af0:	0a000005 	beq	10003b0c <rt_mb_recv+0x354>
10003af4:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10003af8:	e3413002 	movt	r3, #4098	; 0x1002
10003afc:	e5933000 	ldr	r3, [r3]
10003b00:	e51b2020 	ldr	r2, [fp, #-32]
10003b04:	e1a00002 	mov	r0, r2
10003b08:	e12fff33 	blx	r3

        rt_schedule();
10003b0c:	eb00113e 	bl	1000800c <rt_schedule>

        return RT_EOK;
10003b10:	e3a03000 	mov	r3, #0
10003b14:	ea00000e 	b	10003b54 <rt_mb_recv+0x39c>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10003b18:	e1a03004 	mov	r3, r4
10003b1c:	e1a00003 	mov	r0, r3
10003b20:	eb001e69 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
10003b24:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10003b28:	e3413002 	movt	r3, #4098	; 0x1002
10003b2c:	e5933000 	ldr	r3, [r3]
10003b30:	e3530000 	cmp	r3, #0
10003b34:	0a000005 	beq	10003b50 <rt_mb_recv+0x398>
10003b38:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10003b3c:	e3413002 	movt	r3, #4098	; 0x1002
10003b40:	e5933000 	ldr	r3, [r3]
10003b44:	e51b2020 	ldr	r2, [fp, #-32]
10003b48:	e1a00002 	mov	r0, r2
10003b4c:	e12fff33 	blx	r3

    return RT_EOK;
10003b50:	e3a03000 	mov	r3, #0
}
10003b54:	e1a00003 	mov	r0, r3
10003b58:	e24bd008 	sub	sp, fp, #8
10003b5c:	e8bd8810 	pop	{r4, fp, pc}

10003b60 <rt_mb_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
{
10003b60:	e92d4800 	push	{fp, lr}
10003b64:	e28db004 	add	fp, sp, #4
10003b68:	e24dd018 	sub	sp, sp, #24
10003b6c:	e50b0010 	str	r0, [fp, #-16]
10003b70:	e1a03001 	mov	r3, r1
10003b74:	e50b2018 	str	r2, [fp, #-24]
10003b78:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    RT_ASSERT(mb != RT_NULL);
10003b7c:	e51b3010 	ldr	r3, [fp, #-16]
10003b80:	e3530000 	cmp	r3, #0
10003b84:	1a000005 	bne	10003ba0 <rt_mb_control+0x40>
10003b88:	e30e03f0 	movw	r0, #58352	; 0xe3f0
10003b8c:	e3410001 	movt	r0, #4097	; 0x1001
10003b90:	e30e15b8 	movw	r1, #58808	; 0xe5b8
10003b94:	e3411001 	movt	r1, #4097	; 0x1001
10003b98:	e3002699 	movw	r2, #1689	; 0x699
10003b9c:	eb000a89 	bl	100065c8 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
10003ba0:	e55b3011 	ldrb	r3, [fp, #-17]
10003ba4:	e3530001 	cmp	r3, #1
10003ba8:	1a000019 	bne	10003c14 <rt_mb_control+0xb4>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
10003bac:	eb001e42 	bl	1000b4bc <rt_hw_interrupt_disable>
10003bb0:	e1a03000 	mov	r3, r0
10003bb4:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
10003bb8:	e51b3010 	ldr	r3, [fp, #-16]
10003bbc:	e2833010 	add	r3, r3, #16
10003bc0:	e1a00003 	mov	r0, r3
10003bc4:	ebfff7a4 	bl	10001a5c <rt_ipc_list_resume_all>
        /* also resume all mailbox private suspended thread */
        rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
10003bc8:	e51b3010 	ldr	r3, [fp, #-16]
10003bcc:	e2833024 	add	r3, r3, #36	; 0x24
10003bd0:	e1a00003 	mov	r0, r3
10003bd4:	ebfff7a0 	bl	10001a5c <rt_ipc_list_resume_all>

        /* re-init mailbox */
        mb->entry      = 0;
10003bd8:	e51b3010 	ldr	r3, [fp, #-16]
10003bdc:	e3a02000 	mov	r2, #0
10003be0:	e1c321be 	strh	r2, [r3, #30]
        mb->in_offset  = 0;
10003be4:	e51b3010 	ldr	r3, [fp, #-16]
10003be8:	e3a02000 	mov	r2, #0
10003bec:	e1c322b0 	strh	r2, [r3, #32]
        mb->out_offset = 0;
10003bf0:	e51b3010 	ldr	r3, [fp, #-16]
10003bf4:	e3a02000 	mov	r2, #0
10003bf8:	e1c322b2 	strh	r2, [r3, #34]	; 0x22

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10003bfc:	e51b3008 	ldr	r3, [fp, #-8]
10003c00:	e1a00003 	mov	r0, r3
10003c04:	eb001e30 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
10003c08:	eb0010ff 	bl	1000800c <rt_schedule>

        return RT_EOK;
10003c0c:	e3a03000 	mov	r3, #0
10003c10:	ea000000 	b	10003c18 <rt_mb_control+0xb8>
    }

    return -RT_ERROR;
10003c14:	e3e03000 	mvn	r3, #0
}
10003c18:	e1a00003 	mov	r0, r3
10003c1c:	e24bd004 	sub	sp, fp, #4
10003c20:	e8bd8800 	pop	{fp, pc}

10003c24 <rt_mq_init>:
                    const char *name,
                    void       *msgpool,
                    rt_size_t   msg_size,
                    rt_size_t   pool_size,
                    rt_uint8_t  flag)
{
10003c24:	e92d4810 	push	{r4, fp, lr}
10003c28:	e28db008 	add	fp, sp, #8
10003c2c:	e24dd01c 	sub	sp, sp, #28
10003c30:	e50b0018 	str	r0, [fp, #-24]
10003c34:	e50b101c 	str	r1, [fp, #-28]
10003c38:	e50b2020 	str	r2, [fp, #-32]
10003c3c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    struct rt_mq_message *head;
    register rt_base_t temp;

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
10003c40:	e51b3018 	ldr	r3, [fp, #-24]
10003c44:	e3530000 	cmp	r3, #0
10003c48:	1a000005 	bne	10003c64 <rt_mq_init+0x40>
10003c4c:	e30e0400 	movw	r0, #58368	; 0xe400
10003c50:	e3410001 	movt	r0, #4097	; 0x1001
10003c54:	e30e15c8 	movw	r1, #58824	; 0xe5c8
10003c58:	e3411001 	movt	r1, #4097	; 0x1001
10003c5c:	e30026d5 	movw	r2, #1749	; 0x6d5
10003c60:	eb000a58 	bl	100065c8 <rt_assert_handler>

    /* init object */
    rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
10003c64:	e51b3018 	ldr	r3, [fp, #-24]
10003c68:	e1a00003 	mov	r0, r3
10003c6c:	e3a01005 	mov	r1, #5
10003c70:	e51b201c 	ldr	r2, [fp, #-28]
10003c74:	eb000ee8 	bl	1000781c <rt_object_init>

    /* set parent flag */
    mq->parent.parent.flag = flag;
10003c78:	e51b3018 	ldr	r3, [fp, #-24]
10003c7c:	e5db2008 	ldrb	r2, [fp, #8]
10003c80:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
10003c84:	e51b3018 	ldr	r3, [fp, #-24]
10003c88:	e1a00003 	mov	r0, r3
10003c8c:	ebfff718 	bl	100018f4 <rt_ipc_object_init>

    /* set messasge pool */
    mq->msg_pool = msgpool;
10003c90:	e51b3018 	ldr	r3, [fp, #-24]
10003c94:	e51b2020 	ldr	r2, [fp, #-32]
10003c98:	e5832018 	str	r2, [r3, #24]

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
10003c9c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10003ca0:	e6ff3073 	uxth	r3, r3
10003ca4:	e2833003 	add	r3, r3, #3
10003ca8:	e6ff3073 	uxth	r3, r3
10003cac:	e3c33003 	bic	r3, r3, #3
10003cb0:	e6ff2073 	uxth	r2, r3
10003cb4:	e51b3018 	ldr	r3, [fp, #-24]
10003cb8:	e1c321bc 	strh	r2, [r3, #28]
    mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
10003cbc:	e51b3018 	ldr	r3, [fp, #-24]
10003cc0:	e1d331bc 	ldrh	r3, [r3, #28]
10003cc4:	e2833004 	add	r3, r3, #4
10003cc8:	e59b0004 	ldr	r0, [fp, #4]
10003ccc:	e1a01003 	mov	r1, r3
10003cd0:	fa00658a 	blx	1001d300 <__aeabi_uidiv>
10003cd4:	e1a03000 	mov	r3, r0
10003cd8:	e6ff2073 	uxth	r2, r3
10003cdc:	e51b3018 	ldr	r3, [fp, #-24]
10003ce0:	e1c321be 	strh	r2, [r3, #30]

    /* init message list */
    mq->msg_queue_head = RT_NULL;
10003ce4:	e51b3018 	ldr	r3, [fp, #-24]
10003ce8:	e3a02000 	mov	r2, #0
10003cec:	e5832024 	str	r2, [r3, #36]	; 0x24
    mq->msg_queue_tail = RT_NULL;
10003cf0:	e51b3018 	ldr	r3, [fp, #-24]
10003cf4:	e3a02000 	mov	r2, #0
10003cf8:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
10003cfc:	e51b3018 	ldr	r3, [fp, #-24]
10003d00:	e3a02000 	mov	r2, #0
10003d04:	e583202c 	str	r2, [r3, #44]	; 0x2c
    for (temp = 0; temp < mq->max_msgs; temp ++)
10003d08:	e3a04000 	mov	r4, #0
10003d0c:	ea000010 	b	10003d54 <rt_mq_init+0x130>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10003d10:	e51b3018 	ldr	r3, [fp, #-24]
10003d14:	e5932018 	ldr	r2, [r3, #24]
            temp * (mq->msg_size + sizeof(struct rt_mq_message)));
10003d18:	e51b3018 	ldr	r3, [fp, #-24]
10003d1c:	e1d331bc 	ldrh	r3, [r3, #28]
10003d20:	e2833004 	add	r3, r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10003d24:	e1a01004 	mov	r1, r4
10003d28:	e0030391 	mul	r3, r1, r3
10003d2c:	e0823003 	add	r3, r2, r3
10003d30:	e50b3010 	str	r3, [fp, #-16]
            temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
10003d34:	e51b3018 	ldr	r3, [fp, #-24]
10003d38:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
10003d3c:	e51b3010 	ldr	r3, [fp, #-16]
10003d40:	e5832000 	str	r2, [r3]
        mq->msg_queue_free = head;
10003d44:	e51b3018 	ldr	r3, [fp, #-24]
10003d48:	e51b2010 	ldr	r2, [fp, #-16]
10003d4c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
10003d50:	e2844001 	add	r4, r4, #1
10003d54:	e51b3018 	ldr	r3, [fp, #-24]
10003d58:	e1d331be 	ldrh	r3, [r3, #30]
10003d5c:	e1530004 	cmp	r3, r4
10003d60:	caffffea 	bgt	10003d10 <rt_mq_init+0xec>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
10003d64:	e51b3018 	ldr	r3, [fp, #-24]
10003d68:	e3a02000 	mov	r2, #0
10003d6c:	e1c322b0 	strh	r2, [r3, #32]

    return RT_EOK;
10003d70:	e3a03000 	mov	r3, #0
}
10003d74:	e1a00003 	mov	r0, r3
10003d78:	e24bd008 	sub	sp, fp, #8
10003d7c:	e8bd8810 	pop	{r4, fp, pc}

10003d80 <rt_mq_detach>:
 * @param mq the message queue object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mq_detach(rt_mq_t mq)
{
10003d80:	e92d4800 	push	{fp, lr}
10003d84:	e28db004 	add	fp, sp, #4
10003d88:	e24dd008 	sub	sp, sp, #8
10003d8c:	e50b0008 	str	r0, [fp, #-8]
    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
10003d90:	e51b3008 	ldr	r3, [fp, #-8]
10003d94:	e3530000 	cmp	r3, #0
10003d98:	1a000005 	bne	10003db4 <rt_mq_detach+0x34>
10003d9c:	e30e0400 	movw	r0, #58368	; 0xe400
10003da0:	e3410001 	movt	r0, #4097	; 0x1001
10003da4:	e30e15d4 	movw	r1, #58836	; 0xe5d4
10003da8:	e3411001 	movt	r1, #4097	; 0x1001
10003dac:	e3002706 	movw	r2, #1798	; 0x706
10003db0:	eb000a04 	bl	100065c8 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&mq->parent.suspend_thread);
10003db4:	e51b3008 	ldr	r3, [fp, #-8]
10003db8:	e2833010 	add	r3, r3, #16
10003dbc:	e1a00003 	mov	r0, r3
10003dc0:	ebfff725 	bl	10001a5c <rt_ipc_list_resume_all>

    /* detach message queue object */
    rt_object_detach(&(mq->parent.parent));
10003dc4:	e51b3008 	ldr	r3, [fp, #-8]
10003dc8:	e1a00003 	mov	r0, r3
10003dcc:	eb000ec1 	bl	100078d8 <rt_object_detach>

    return RT_EOK;
10003dd0:	e3a03000 	mov	r3, #0
}
10003dd4:	e1a00003 	mov	r0, r3
10003dd8:	e24bd004 	sub	sp, fp, #4
10003ddc:	e8bd8800 	pop	{fp, pc}

10003de0 <rt_mq_create>:
 */
rt_mq_t rt_mq_create(const char *name,
                     rt_size_t   msg_size,
                     rt_size_t   max_msgs,
                     rt_uint8_t  flag)
{
10003de0:	e92d4810 	push	{r4, fp, lr}
10003de4:	e28db008 	add	fp, sp, #8
10003de8:	e24dd024 	sub	sp, sp, #36	; 0x24
10003dec:	e50b0020 	str	r0, [fp, #-32]
10003df0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10003df4:	e50b2028 	str	r2, [fp, #-40]	; 0x28
10003df8:	e54b3029 	strb	r3, [fp, #-41]	; 0x29
    struct rt_messagequeue *mq;
    struct rt_mq_message *head;
    register rt_base_t temp;

    RT_DEBUG_NOT_IN_INTERRUPT;
10003dfc:	eb001dae 	bl	1000b4bc <rt_hw_interrupt_disable>
10003e00:	e50b0010 	str	r0, [fp, #-16]
10003e04:	eb0002ed 	bl	100049c0 <rt_interrupt_get_nest>
10003e08:	e1a03000 	mov	r3, r0
10003e0c:	e3530000 	cmp	r3, #0
10003e10:	0a00000a 	beq	10003e40 <rt_mq_create+0x60>
10003e14:	e30e0368 	movw	r0, #58216	; 0xe368
10003e18:	e3410001 	movt	r0, #4097	; 0x1001
10003e1c:	e30e15e4 	movw	r1, #58852	; 0xe5e4
10003e20:	e3411001 	movt	r1, #4097	; 0x1001
10003e24:	eb00092a 	bl	100062d4 <rt_kprintf>
10003e28:	e30e038c 	movw	r0, #58252	; 0xe38c
10003e2c:	e3410001 	movt	r0, #4097	; 0x1001
10003e30:	e30e15e4 	movw	r1, #58852	; 0xe5e4
10003e34:	e3411001 	movt	r1, #4097	; 0x1001
10003e38:	e3002726 	movw	r2, #1830	; 0x726
10003e3c:	eb0009e1 	bl	100065c8 <rt_assert_handler>
10003e40:	e51b0010 	ldr	r0, [fp, #-16]
10003e44:	eb001da0 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* allocate object */
    mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
10003e48:	e3a00005 	mov	r0, #5
10003e4c:	e51b1020 	ldr	r1, [fp, #-32]
10003e50:	eb000ec1 	bl	1000795c <rt_object_allocate>
10003e54:	e50b0014 	str	r0, [fp, #-20]
    if (mq == RT_NULL)
10003e58:	e51b3014 	ldr	r3, [fp, #-20]
10003e5c:	e3530000 	cmp	r3, #0
10003e60:	1a000001 	bne	10003e6c <rt_mq_create+0x8c>
        return mq;
10003e64:	e51b3014 	ldr	r3, [fp, #-20]
10003e68:	ea000048 	b	10003f90 <rt_mq_create+0x1b0>

    /* set parent */
    mq->parent.parent.flag = flag;
10003e6c:	e51b3014 	ldr	r3, [fp, #-20]
10003e70:	e55b2029 	ldrb	r2, [fp, #-41]	; 0x29
10003e74:	e5c32007 	strb	r2, [r3, #7]

    /* init ipc object */
    rt_ipc_object_init(&(mq->parent));
10003e78:	e51b3014 	ldr	r3, [fp, #-20]
10003e7c:	e1a00003 	mov	r0, r3
10003e80:	ebfff69b 	bl	100018f4 <rt_ipc_object_init>

    /* init message queue */

    /* get correct message size */
    mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
10003e84:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10003e88:	e6ff3073 	uxth	r3, r3
10003e8c:	e2833003 	add	r3, r3, #3
10003e90:	e6ff3073 	uxth	r3, r3
10003e94:	e3c33003 	bic	r3, r3, #3
10003e98:	e6ff2073 	uxth	r2, r3
10003e9c:	e51b3014 	ldr	r3, [fp, #-20]
10003ea0:	e1c321bc 	strh	r2, [r3, #28]
    mq->max_msgs = max_msgs;
10003ea4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10003ea8:	e6ff2073 	uxth	r2, r3
10003eac:	e51b3014 	ldr	r3, [fp, #-20]
10003eb0:	e1c321be 	strh	r2, [r3, #30]

    /* allocate message pool */
    mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
10003eb4:	e51b3014 	ldr	r3, [fp, #-20]
10003eb8:	e1d331bc 	ldrh	r3, [r3, #28]
10003ebc:	e2833004 	add	r3, r3, #4
10003ec0:	e51b2014 	ldr	r2, [fp, #-20]
10003ec4:	e1d221be 	ldrh	r2, [r2, #30]
10003ec8:	e0030392 	mul	r3, r2, r3
10003ecc:	e1a00003 	mov	r0, r3
10003ed0:	eb000af4 	bl	10006aa8 <rt_malloc>
10003ed4:	e1a02000 	mov	r2, r0
10003ed8:	e51b3014 	ldr	r3, [fp, #-20]
10003edc:	e5832018 	str	r2, [r3, #24]
    if (mq->msg_pool == RT_NULL)
10003ee0:	e51b3014 	ldr	r3, [fp, #-20]
10003ee4:	e5933018 	ldr	r3, [r3, #24]
10003ee8:	e3530000 	cmp	r3, #0
10003eec:	1a000003 	bne	10003f00 <rt_mq_create+0x120>
    {
        rt_mq_delete(mq);
10003ef0:	e51b0014 	ldr	r0, [fp, #-20]
10003ef4:	eb000028 	bl	10003f9c <rt_mq_delete>

        return RT_NULL;
10003ef8:	e3a03000 	mov	r3, #0
10003efc:	ea000023 	b	10003f90 <rt_mq_create+0x1b0>
    }

    /* init message list */
    mq->msg_queue_head = RT_NULL;
10003f00:	e51b3014 	ldr	r3, [fp, #-20]
10003f04:	e3a02000 	mov	r2, #0
10003f08:	e5832024 	str	r2, [r3, #36]	; 0x24
    mq->msg_queue_tail = RT_NULL;
10003f0c:	e51b3014 	ldr	r3, [fp, #-20]
10003f10:	e3a02000 	mov	r2, #0
10003f14:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
10003f18:	e51b3014 	ldr	r3, [fp, #-20]
10003f1c:	e3a02000 	mov	r2, #0
10003f20:	e583202c 	str	r2, [r3, #44]	; 0x2c
    for (temp = 0; temp < mq->max_msgs; temp ++)
10003f24:	e3a04000 	mov	r4, #0
10003f28:	ea000010 	b	10003f70 <rt_mq_create+0x190>
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10003f2c:	e51b3014 	ldr	r3, [fp, #-20]
10003f30:	e5932018 	ldr	r2, [r3, #24]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
10003f34:	e51b3014 	ldr	r3, [fp, #-20]
10003f38:	e1d331bc 	ldrh	r3, [r3, #28]
10003f3c:	e2833004 	add	r3, r3, #4

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
    {
        head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
10003f40:	e1a01004 	mov	r1, r4
10003f44:	e0030391 	mul	r3, r1, r3
10003f48:	e0823003 	add	r3, r2, r3
10003f4c:	e50b3018 	str	r3, [fp, #-24]
               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
        head->next = mq->msg_queue_free;
10003f50:	e51b3014 	ldr	r3, [fp, #-20]
10003f54:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
10003f58:	e51b3018 	ldr	r3, [fp, #-24]
10003f5c:	e5832000 	str	r2, [r3]
        mq->msg_queue_free = head;
10003f60:	e51b3014 	ldr	r3, [fp, #-20]
10003f64:	e51b2018 	ldr	r2, [fp, #-24]
10003f68:	e583202c 	str	r2, [r3, #44]	; 0x2c
    mq->msg_queue_head = RT_NULL;
    mq->msg_queue_tail = RT_NULL;

    /* init message empty list */
    mq->msg_queue_free = RT_NULL;
    for (temp = 0; temp < mq->max_msgs; temp ++)
10003f6c:	e2844001 	add	r4, r4, #1
10003f70:	e51b3014 	ldr	r3, [fp, #-20]
10003f74:	e1d331be 	ldrh	r3, [r3, #30]
10003f78:	e1530004 	cmp	r3, r4
10003f7c:	caffffea 	bgt	10003f2c <rt_mq_create+0x14c>
        head->next = mq->msg_queue_free;
        mq->msg_queue_free = head;
    }

    /* the initial entry is zero */
    mq->entry = 0;
10003f80:	e51b3014 	ldr	r3, [fp, #-20]
10003f84:	e3a02000 	mov	r2, #0
10003f88:	e1c322b0 	strh	r2, [r3, #32]

    return mq;
10003f8c:	e51b3014 	ldr	r3, [fp, #-20]
}
10003f90:	e1a00003 	mov	r0, r3
10003f94:	e24bd008 	sub	sp, fp, #8
10003f98:	e8bd8810 	pop	{r4, fp, pc}

10003f9c <rt_mq_delete>:
 * @param mq the message queue object
 *
 * @return the error code
 */
rt_err_t rt_mq_delete(rt_mq_t mq)
{
10003f9c:	e92d4800 	push	{fp, lr}
10003fa0:	e28db004 	add	fp, sp, #4
10003fa4:	e24dd010 	sub	sp, sp, #16
10003fa8:	e50b0010 	str	r0, [fp, #-16]
    RT_DEBUG_NOT_IN_INTERRUPT;
10003fac:	eb001d42 	bl	1000b4bc <rt_hw_interrupt_disable>
10003fb0:	e50b0008 	str	r0, [fp, #-8]
10003fb4:	eb000281 	bl	100049c0 <rt_interrupt_get_nest>
10003fb8:	e1a03000 	mov	r3, r0
10003fbc:	e3530000 	cmp	r3, #0
10003fc0:	0a00000a 	beq	10003ff0 <rt_mq_delete+0x54>
10003fc4:	e30e0368 	movw	r0, #58216	; 0xe368
10003fc8:	e3410001 	movt	r0, #4097	; 0x1001
10003fcc:	e30e15f4 	movw	r1, #58868	; 0xe5f4
10003fd0:	e3411001 	movt	r1, #4097	; 0x1001
10003fd4:	eb0008be 	bl	100062d4 <rt_kprintf>
10003fd8:	e30e038c 	movw	r0, #58252	; 0xe38c
10003fdc:	e3410001 	movt	r0, #4097	; 0x1001
10003fe0:	e30e15f4 	movw	r1, #58868	; 0xe5f4
10003fe4:	e3411001 	movt	r1, #4097	; 0x1001
10003fe8:	e3a02e76 	mov	r2, #1888	; 0x760
10003fec:	eb000975 	bl	100065c8 <rt_assert_handler>
10003ff0:	e51b0008 	ldr	r0, [fp, #-8]
10003ff4:	eb001d34 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* parameter check */
    RT_ASSERT(mq != RT_NULL);
10003ff8:	e51b3010 	ldr	r3, [fp, #-16]
10003ffc:	e3530000 	cmp	r3, #0
10004000:	1a000005 	bne	1000401c <rt_mq_delete+0x80>
10004004:	e30e0400 	movw	r0, #58368	; 0xe400
10004008:	e3410001 	movt	r0, #4097	; 0x1001
1000400c:	e30e15f4 	movw	r1, #58868	; 0xe5f4
10004010:	e3411001 	movt	r1, #4097	; 0x1001
10004014:	e3002763 	movw	r2, #1891	; 0x763
10004018:	eb00096a 	bl	100065c8 <rt_assert_handler>

    /* resume all suspended thread */
    rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
1000401c:	e51b3010 	ldr	r3, [fp, #-16]
10004020:	e2833010 	add	r3, r3, #16
10004024:	e1a00003 	mov	r0, r3
10004028:	ebfff68b 	bl	10001a5c <rt_ipc_list_resume_all>
        rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
    else
#endif

    /* free message queue pool */
    RT_KERNEL_FREE(mq->msg_pool);
1000402c:	e51b3010 	ldr	r3, [fp, #-16]
10004030:	e5933018 	ldr	r3, [r3, #24]
10004034:	e1a00003 	mov	r0, r3
10004038:	eb000cb5 	bl	10007314 <rt_free>

    /* delete message queue object */
    rt_object_delete(&(mq->parent.parent));
1000403c:	e51b3010 	ldr	r3, [fp, #-16]
10004040:	e1a00003 	mov	r0, r3
10004044:	eb000e91 	bl	10007a90 <rt_object_delete>

    return RT_EOK;
10004048:	e3a03000 	mov	r3, #0
}
1000404c:	e1a00003 	mov	r0, r3
10004050:	e24bd004 	sub	sp, fp, #4
10004054:	e8bd8800 	pop	{fp, pc}

10004058 <rt_mq_send>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
{
10004058:	e92d4810 	push	{r4, fp, lr}
1000405c:	e28db008 	add	fp, sp, #8
10004060:	e24dd01c 	sub	sp, sp, #28
10004064:	e50b0018 	str	r0, [fp, #-24]
10004068:	e50b101c 	str	r1, [fp, #-28]
1000406c:	e50b2020 	str	r2, [fp, #-32]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
10004070:	e51b3018 	ldr	r3, [fp, #-24]
10004074:	e3530000 	cmp	r3, #0
10004078:	1a000005 	bne	10004094 <rt_mq_send+0x3c>
1000407c:	e30e0400 	movw	r0, #58368	; 0xe400
10004080:	e3410001 	movt	r0, #4097	; 0x1001
10004084:	e30e1604 	movw	r1, #58884	; 0xe604
10004088:	e3411001 	movt	r1, #4097	; 0x1001
1000408c:	e3002789 	movw	r2, #1929	; 0x789
10004090:	eb00094c 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
10004094:	e51b301c 	ldr	r3, [fp, #-28]
10004098:	e3530000 	cmp	r3, #0
1000409c:	1a000005 	bne	100040b8 <rt_mq_send+0x60>
100040a0:	e30e0410 	movw	r0, #58384	; 0xe410
100040a4:	e3410001 	movt	r0, #4097	; 0x1001
100040a8:	e30e1604 	movw	r1, #58884	; 0xe604
100040ac:	e3411001 	movt	r1, #4097	; 0x1001
100040b0:	e300278a 	movw	r2, #1930	; 0x78a
100040b4:	eb000943 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(size != 0);
100040b8:	e51b3020 	ldr	r3, [fp, #-32]
100040bc:	e3530000 	cmp	r3, #0
100040c0:	1a000005 	bne	100040dc <rt_mq_send+0x84>
100040c4:	e30e0424 	movw	r0, #58404	; 0xe424
100040c8:	e3410001 	movt	r0, #4097	; 0x1001
100040cc:	e30e1604 	movw	r1, #58884	; 0xe604
100040d0:	e3411001 	movt	r1, #4097	; 0x1001
100040d4:	e300278b 	movw	r2, #1931	; 0x78b
100040d8:	eb00093a 	bl	100065c8 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
100040dc:	e51b3018 	ldr	r3, [fp, #-24]
100040e0:	e1d331bc 	ldrh	r3, [r3, #28]
100040e4:	e1a02003 	mov	r2, r3
100040e8:	e51b3020 	ldr	r3, [fp, #-32]
100040ec:	e1520003 	cmp	r2, r3
100040f0:	2a000001 	bcs	100040fc <rt_mq_send+0xa4>
        return -RT_ERROR;
100040f4:	e3e03000 	mvn	r3, #0
100040f8:	ea000058 	b	10004260 <rt_mq_send+0x208>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
100040fc:	e3093d88 	movw	r3, #40328	; 0x9d88
10004100:	e3413002 	movt	r3, #4098	; 0x1002
10004104:	e5933000 	ldr	r3, [r3]
10004108:	e3530000 	cmp	r3, #0
1000410c:	0a000005 	beq	10004128 <rt_mq_send+0xd0>
10004110:	e3093d88 	movw	r3, #40328	; 0x9d88
10004114:	e3413002 	movt	r3, #4098	; 0x1002
10004118:	e5933000 	ldr	r3, [r3]
1000411c:	e51b2018 	ldr	r2, [fp, #-24]
10004120:	e1a00002 	mov	r0, r2
10004124:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10004128:	eb001ce3 	bl	1000b4bc <rt_hw_interrupt_disable>
1000412c:	e1a03000 	mov	r3, r0
10004130:	e1a04003 	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message*)mq->msg_queue_free;
10004134:	e51b3018 	ldr	r3, [fp, #-24]
10004138:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000413c:	e50b3010 	str	r3, [fp, #-16]
    /* message queue is full */
    if (msg == RT_NULL)
10004140:	e51b3010 	ldr	r3, [fp, #-16]
10004144:	e3530000 	cmp	r3, #0
10004148:	1a000004 	bne	10004160 <rt_mq_send+0x108>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1000414c:	e1a03004 	mov	r3, r4
10004150:	e1a00003 	mov	r0, r3
10004154:	eb001cdc 	bl	1000b4cc <rt_hw_interrupt_enable>

        return -RT_EFULL;
10004158:	e3e03002 	mvn	r3, #2
1000415c:	ea00003f 	b	10004260 <rt_mq_send+0x208>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
10004160:	e51b3010 	ldr	r3, [fp, #-16]
10004164:	e5932000 	ldr	r2, [r3]
10004168:	e51b3018 	ldr	r3, [fp, #-24]
1000416c:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10004170:	e1a03004 	mov	r3, r4
10004174:	e1a00003 	mov	r0, r3
10004178:	eb001cd3 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* the msg is the new tailer of list, the next shall be NULL */
    msg->next = RT_NULL;
1000417c:	e51b3010 	ldr	r3, [fp, #-16]
10004180:	e3a02000 	mov	r2, #0
10004184:	e5832000 	str	r2, [r3]
    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
10004188:	e51b3010 	ldr	r3, [fp, #-16]
1000418c:	e2833004 	add	r3, r3, #4
10004190:	e1a00003 	mov	r0, r3
10004194:	e51b101c 	ldr	r1, [fp, #-28]
10004198:	e51b2020 	ldr	r2, [fp, #-32]
1000419c:	eb0002b5 	bl	10004c78 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
100041a0:	eb001cc5 	bl	1000b4bc <rt_hw_interrupt_disable>
100041a4:	e1a03000 	mov	r3, r0
100041a8:	e1a04003 	mov	r4, r3
    /* link msg to message queue */
    if (mq->msg_queue_tail != RT_NULL)
100041ac:	e51b3018 	ldr	r3, [fp, #-24]
100041b0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
100041b4:	e3530000 	cmp	r3, #0
100041b8:	0a000003 	beq	100041cc <rt_mq_send+0x174>
    {
        /* if the tail exists, */
        ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
100041bc:	e51b3018 	ldr	r3, [fp, #-24]
100041c0:	e5933028 	ldr	r3, [r3, #40]	; 0x28
100041c4:	e51b2010 	ldr	r2, [fp, #-16]
100041c8:	e5832000 	str	r2, [r3]
    }

    /* set new tail */
    mq->msg_queue_tail = msg;
100041cc:	e51b3018 	ldr	r3, [fp, #-24]
100041d0:	e51b2010 	ldr	r2, [fp, #-16]
100041d4:	e5832028 	str	r2, [r3, #40]	; 0x28
    /* if the head is empty, set head */
    if (mq->msg_queue_head == RT_NULL)
100041d8:	e51b3018 	ldr	r3, [fp, #-24]
100041dc:	e5933024 	ldr	r3, [r3, #36]	; 0x24
100041e0:	e3530000 	cmp	r3, #0
100041e4:	1a000002 	bne	100041f4 <rt_mq_send+0x19c>
        mq->msg_queue_head = msg;
100041e8:	e51b3018 	ldr	r3, [fp, #-24]
100041ec:	e51b2010 	ldr	r2, [fp, #-16]
100041f0:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* increase message entry */
    mq->entry ++;
100041f4:	e51b3018 	ldr	r3, [fp, #-24]
100041f8:	e1d332b0 	ldrh	r3, [r3, #32]
100041fc:	e2833001 	add	r3, r3, #1
10004200:	e6ff2073 	uxth	r2, r3
10004204:	e51b3018 	ldr	r3, [fp, #-24]
10004208:	e1c322b0 	strh	r2, [r3, #32]

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
1000420c:	e51b3018 	ldr	r3, [fp, #-24]
10004210:	e2833010 	add	r3, r3, #16
10004214:	e1a00003 	mov	r0, r3
10004218:	ebfff5a6 	bl	100018b8 <rt_list_isempty>
1000421c:	e1a03000 	mov	r3, r0
10004220:	e3530000 	cmp	r3, #0
10004224:	1a000009 	bne	10004250 <rt_mq_send+0x1f8>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
10004228:	e51b3018 	ldr	r3, [fp, #-24]
1000422c:	e2833010 	add	r3, r3, #16
10004230:	e1a00003 	mov	r0, r3
10004234:	ebfff5fa 	bl	10001a24 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10004238:	e1a03004 	mov	r3, r4
1000423c:	e1a00003 	mov	r0, r3
10004240:	eb001ca1 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
10004244:	eb000f70 	bl	1000800c <rt_schedule>

        return RT_EOK;
10004248:	e3a03000 	mov	r3, #0
1000424c:	ea000003 	b	10004260 <rt_mq_send+0x208>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10004250:	e1a03004 	mov	r3, r4
10004254:	e1a00003 	mov	r0, r3
10004258:	eb001c9b 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
1000425c:	e3a03000 	mov	r3, #0
}
10004260:	e1a00003 	mov	r0, r3
10004264:	e24bd008 	sub	sp, fp, #8
10004268:	e8bd8810 	pop	{r4, fp, pc}

1000426c <rt_mq_urgent>:
 * @param size the size of buffer
 *
 * @return the error code
 */
rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
{
1000426c:	e92d4810 	push	{r4, fp, lr}
10004270:	e28db008 	add	fp, sp, #8
10004274:	e24dd01c 	sub	sp, sp, #28
10004278:	e50b0018 	str	r0, [fp, #-24]
1000427c:	e50b101c 	str	r1, [fp, #-28]
10004280:	e50b2020 	str	r2, [fp, #-32]
    register rt_ubase_t temp;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
10004284:	e51b3018 	ldr	r3, [fp, #-24]
10004288:	e3530000 	cmp	r3, #0
1000428c:	1a000005 	bne	100042a8 <rt_mq_urgent+0x3c>
10004290:	e30e0400 	movw	r0, #58368	; 0xe400
10004294:	e3410001 	movt	r0, #4097	; 0x1001
10004298:	e30e1610 	movw	r1, #58896	; 0xe610
1000429c:	e3411001 	movt	r1, #4097	; 0x1001
100042a0:	e30027e1 	movw	r2, #2017	; 0x7e1
100042a4:	eb0008c7 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
100042a8:	e51b301c 	ldr	r3, [fp, #-28]
100042ac:	e3530000 	cmp	r3, #0
100042b0:	1a000005 	bne	100042cc <rt_mq_urgent+0x60>
100042b4:	e30e0410 	movw	r0, #58384	; 0xe410
100042b8:	e3410001 	movt	r0, #4097	; 0x1001
100042bc:	e30e1610 	movw	r1, #58896	; 0xe610
100042c0:	e3411001 	movt	r1, #4097	; 0x1001
100042c4:	e30027e2 	movw	r2, #2018	; 0x7e2
100042c8:	eb0008be 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(size != 0);
100042cc:	e51b3020 	ldr	r3, [fp, #-32]
100042d0:	e3530000 	cmp	r3, #0
100042d4:	1a000005 	bne	100042f0 <rt_mq_urgent+0x84>
100042d8:	e30e0424 	movw	r0, #58404	; 0xe424
100042dc:	e3410001 	movt	r0, #4097	; 0x1001
100042e0:	e30e1610 	movw	r1, #58896	; 0xe610
100042e4:	e3411001 	movt	r1, #4097	; 0x1001
100042e8:	e30027e3 	movw	r2, #2019	; 0x7e3
100042ec:	eb0008b5 	bl	100065c8 <rt_assert_handler>

    /* greater than one message size */
    if (size > mq->msg_size)
100042f0:	e51b3018 	ldr	r3, [fp, #-24]
100042f4:	e1d331bc 	ldrh	r3, [r3, #28]
100042f8:	e1a02003 	mov	r2, r3
100042fc:	e51b3020 	ldr	r3, [fp, #-32]
10004300:	e1520003 	cmp	r2, r3
10004304:	2a000001 	bcs	10004310 <rt_mq_urgent+0xa4>
        return -RT_ERROR;
10004308:	e3e03000 	mvn	r3, #0
1000430c:	ea000051 	b	10004458 <rt_mq_urgent+0x1ec>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
10004310:	e3093d88 	movw	r3, #40328	; 0x9d88
10004314:	e3413002 	movt	r3, #4098	; 0x1002
10004318:	e5933000 	ldr	r3, [r3]
1000431c:	e3530000 	cmp	r3, #0
10004320:	0a000005 	beq	1000433c <rt_mq_urgent+0xd0>
10004324:	e3093d88 	movw	r3, #40328	; 0x9d88
10004328:	e3413002 	movt	r3, #4098	; 0x1002
1000432c:	e5933000 	ldr	r3, [r3]
10004330:	e51b2018 	ldr	r2, [fp, #-24]
10004334:	e1a00002 	mov	r0, r2
10004338:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1000433c:	eb001c5e 	bl	1000b4bc <rt_hw_interrupt_disable>
10004340:	e1a03000 	mov	r3, r0
10004344:	e1a04003 	mov	r4, r3

    /* get a free list, there must be an empty item */
    msg = (struct rt_mq_message *)mq->msg_queue_free;
10004348:	e51b3018 	ldr	r3, [fp, #-24]
1000434c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10004350:	e50b3010 	str	r3, [fp, #-16]
    /* message queue is full */
    if (msg == RT_NULL)
10004354:	e51b3010 	ldr	r3, [fp, #-16]
10004358:	e3530000 	cmp	r3, #0
1000435c:	1a000004 	bne	10004374 <rt_mq_urgent+0x108>
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10004360:	e1a03004 	mov	r3, r4
10004364:	e1a00003 	mov	r0, r3
10004368:	eb001c57 	bl	1000b4cc <rt_hw_interrupt_enable>

        return -RT_EFULL;
1000436c:	e3e03002 	mvn	r3, #2
10004370:	ea000038 	b	10004458 <rt_mq_urgent+0x1ec>
    }
    /* move free list pointer */
    mq->msg_queue_free = msg->next;
10004374:	e51b3010 	ldr	r3, [fp, #-16]
10004378:	e5932000 	ldr	r2, [r3]
1000437c:	e51b3018 	ldr	r3, [fp, #-24]
10004380:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10004384:	e1a03004 	mov	r3, r4
10004388:	e1a00003 	mov	r0, r3
1000438c:	eb001c4e 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* copy buffer */
    rt_memcpy(msg + 1, buffer, size);
10004390:	e51b3010 	ldr	r3, [fp, #-16]
10004394:	e2833004 	add	r3, r3, #4
10004398:	e1a00003 	mov	r0, r3
1000439c:	e51b101c 	ldr	r1, [fp, #-28]
100043a0:	e51b2020 	ldr	r2, [fp, #-32]
100043a4:	eb000233 	bl	10004c78 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
100043a8:	eb001c43 	bl	1000b4bc <rt_hw_interrupt_disable>
100043ac:	e1a03000 	mov	r3, r0
100043b0:	e1a04003 	mov	r4, r3

    /* link msg to the beginning of message queue */
    msg->next = mq->msg_queue_head;
100043b4:	e51b3018 	ldr	r3, [fp, #-24]
100043b8:	e5932024 	ldr	r2, [r3, #36]	; 0x24
100043bc:	e51b3010 	ldr	r3, [fp, #-16]
100043c0:	e5832000 	str	r2, [r3]
    mq->msg_queue_head = msg;
100043c4:	e51b3018 	ldr	r3, [fp, #-24]
100043c8:	e51b2010 	ldr	r2, [fp, #-16]
100043cc:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* if there is no tail */
    if (mq->msg_queue_tail == RT_NULL)
100043d0:	e51b3018 	ldr	r3, [fp, #-24]
100043d4:	e5933028 	ldr	r3, [r3, #40]	; 0x28
100043d8:	e3530000 	cmp	r3, #0
100043dc:	1a000002 	bne	100043ec <rt_mq_urgent+0x180>
        mq->msg_queue_tail = msg;
100043e0:	e51b3018 	ldr	r3, [fp, #-24]
100043e4:	e51b2010 	ldr	r2, [fp, #-16]
100043e8:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* increase message entry */
    mq->entry ++;
100043ec:	e51b3018 	ldr	r3, [fp, #-24]
100043f0:	e1d332b0 	ldrh	r3, [r3, #32]
100043f4:	e2833001 	add	r3, r3, #1
100043f8:	e6ff2073 	uxth	r2, r3
100043fc:	e51b3018 	ldr	r3, [fp, #-24]
10004400:	e1c322b0 	strh	r2, [r3, #32]

    /* resume suspended thread */
    if (!rt_list_isempty(&mq->parent.suspend_thread))
10004404:	e51b3018 	ldr	r3, [fp, #-24]
10004408:	e2833010 	add	r3, r3, #16
1000440c:	e1a00003 	mov	r0, r3
10004410:	ebfff528 	bl	100018b8 <rt_list_isempty>
10004414:	e1a03000 	mov	r3, r0
10004418:	e3530000 	cmp	r3, #0
1000441c:	1a000009 	bne	10004448 <rt_mq_urgent+0x1dc>
    {
        rt_ipc_list_resume(&(mq->parent.suspend_thread));
10004420:	e51b3018 	ldr	r3, [fp, #-24]
10004424:	e2833010 	add	r3, r3, #16
10004428:	e1a00003 	mov	r0, r3
1000442c:	ebfff57c 	bl	10001a24 <rt_ipc_list_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10004430:	e1a03004 	mov	r3, r4
10004434:	e1a00003 	mov	r0, r3
10004438:	eb001c23 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
1000443c:	eb000ef2 	bl	1000800c <rt_schedule>

        return RT_EOK;
10004440:	e3a03000 	mov	r3, #0
10004444:	ea000003 	b	10004458 <rt_mq_urgent+0x1ec>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10004448:	e1a03004 	mov	r3, r4
1000444c:	e1a00003 	mov	r0, r3
10004450:	eb001c1d 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
10004454:	e3a03000 	mov	r3, #0
}
10004458:	e1a00003 	mov	r0, r3
1000445c:	e24bd008 	sub	sp, fp, #8
10004460:	e8bd8810 	pop	{r4, fp, pc}

10004464 <rt_mq_recv>:
 */
rt_err_t rt_mq_recv(rt_mq_t    mq,
                    void      *buffer,
                    rt_size_t  size,
                    rt_int32_t timeout)
{
10004464:	e92d4810 	push	{r4, fp, lr}
10004468:	e28db008 	add	fp, sp, #8
1000446c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10004470:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10004474:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
10004478:	e50b2030 	str	r2, [fp, #-48]	; 0x30
1000447c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
    struct rt_thread *thread;
    register rt_ubase_t temp;
    struct rt_mq_message *msg;
    rt_uint32_t tick_delta;

    RT_ASSERT(mq != RT_NULL);
10004480:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004484:	e3530000 	cmp	r3, #0
10004488:	1a000005 	bne	100044a4 <rt_mq_recv+0x40>
1000448c:	e30e0400 	movw	r0, #58368	; 0xe400
10004490:	e3410001 	movt	r0, #4097	; 0x1001
10004494:	e30e1620 	movw	r1, #58912	; 0xe620
10004498:	e3411001 	movt	r1, #4097	; 0x1001
1000449c:	e3002839 	movw	r2, #2105	; 0x839
100044a0:	eb000848 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(buffer != RT_NULL);
100044a4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
100044a8:	e3530000 	cmp	r3, #0
100044ac:	1a000005 	bne	100044c8 <rt_mq_recv+0x64>
100044b0:	e30e0410 	movw	r0, #58384	; 0xe410
100044b4:	e3410001 	movt	r0, #4097	; 0x1001
100044b8:	e30e1620 	movw	r1, #58912	; 0xe620
100044bc:	e3411001 	movt	r1, #4097	; 0x1001
100044c0:	e300283a 	movw	r2, #2106	; 0x83a
100044c4:	eb00083f 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(size != 0);
100044c8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100044cc:	e3530000 	cmp	r3, #0
100044d0:	1a000005 	bne	100044ec <rt_mq_recv+0x88>
100044d4:	e30e0424 	movw	r0, #58404	; 0xe424
100044d8:	e3410001 	movt	r0, #4097	; 0x1001
100044dc:	e30e1620 	movw	r1, #58912	; 0xe620
100044e0:	e3411001 	movt	r1, #4097	; 0x1001
100044e4:	e300283b 	movw	r2, #2107	; 0x83b
100044e8:	eb000836 	bl	100065c8 <rt_assert_handler>

    /* initialize delta tick */
    tick_delta = 0;
100044ec:	e3a03000 	mov	r3, #0
100044f0:	e50b3010 	str	r3, [fp, #-16]
    /* get current thread */
    thread = rt_thread_self();
100044f4:	eb0010b3 	bl	100087c8 <rt_thread_self>
100044f8:	e50b0014 	str	r0, [fp, #-20]
    RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
100044fc:	e3093d90 	movw	r3, #40336	; 0x9d90
10004500:	e3413002 	movt	r3, #4098	; 0x1002
10004504:	e5933000 	ldr	r3, [r3]
10004508:	e3530000 	cmp	r3, #0
1000450c:	0a000005 	beq	10004528 <rt_mq_recv+0xc4>
10004510:	e3093d90 	movw	r3, #40336	; 0x9d90
10004514:	e3413002 	movt	r3, #4098	; 0x1002
10004518:	e5933000 	ldr	r3, [r3]
1000451c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10004520:	e1a00002 	mov	r0, r2
10004524:	e12fff33 	blx	r3

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10004528:	eb001be3 	bl	1000b4bc <rt_hw_interrupt_disable>
1000452c:	e1a03000 	mov	r3, r0
10004530:	e1a04003 	mov	r4, r3

    /* for non-blocking call */
    if (mq->entry == 0 && timeout == 0)
10004534:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004538:	e1d332b0 	ldrh	r3, [r3, #32]
1000453c:	e3530000 	cmp	r3, #0
10004540:	1a000007 	bne	10004564 <rt_mq_recv+0x100>
10004544:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004548:	e3530000 	cmp	r3, #0
1000454c:	1a000004 	bne	10004564 <rt_mq_recv+0x100>
    {
        rt_hw_interrupt_enable(temp);
10004550:	e1a03004 	mov	r3, r4
10004554:	e1a00003 	mov	r0, r3
10004558:	eb001bdb 	bl	1000b4cc <rt_hw_interrupt_enable>

        return -RT_ETIMEOUT;
1000455c:	e3e03001 	mvn	r3, #1
10004560:	ea0000ad 	b	1000481c <rt_mq_recv+0x3b8>
    }

    /* message queue is empty */
    while (mq->entry == 0)
10004564:	ea00006b 	b	10004718 <rt_mq_recv+0x2b4>
    {
        RT_DEBUG_IN_THREAD_CONTEXT;
10004568:	eb001bd3 	bl	1000b4bc <rt_hw_interrupt_disable>
1000456c:	e50b0018 	str	r0, [fp, #-24]
10004570:	eb001094 	bl	100087c8 <rt_thread_self>
10004574:	e1a03000 	mov	r3, r0
10004578:	e3530000 	cmp	r3, #0
1000457c:	1a00000a 	bne	100045ac <rt_mq_recv+0x148>
10004580:	e30e0390 	movw	r0, #58256	; 0xe390
10004584:	e3410001 	movt	r0, #4097	; 0x1001
10004588:	e30e1620 	movw	r1, #58912	; 0xe620
1000458c:	e3411001 	movt	r1, #4097	; 0x1001
10004590:	eb00074f 	bl	100062d4 <rt_kprintf>
10004594:	e30e038c 	movw	r0, #58252	; 0xe38c
10004598:	e3410001 	movt	r0, #4097	; 0x1001
1000459c:	e30e1620 	movw	r1, #58912	; 0xe620
100045a0:	e3411001 	movt	r1, #4097	; 0x1001
100045a4:	e3002851 	movw	r2, #2129	; 0x851
100045a8:	eb000806 	bl	100065c8 <rt_assert_handler>
100045ac:	eb001bc2 	bl	1000b4bc <rt_hw_interrupt_disable>
100045b0:	e50b001c 	str	r0, [fp, #-28]
100045b4:	eb000101 	bl	100049c0 <rt_interrupt_get_nest>
100045b8:	e1a03000 	mov	r3, r0
100045bc:	e3530000 	cmp	r3, #0
100045c0:	0a00000a 	beq	100045f0 <rt_mq_recv+0x18c>
100045c4:	e30e0368 	movw	r0, #58216	; 0xe368
100045c8:	e3410001 	movt	r0, #4097	; 0x1001
100045cc:	e30e1620 	movw	r1, #58912	; 0xe620
100045d0:	e3411001 	movt	r1, #4097	; 0x1001
100045d4:	eb00073e 	bl	100062d4 <rt_kprintf>
100045d8:	e30e038c 	movw	r0, #58252	; 0xe38c
100045dc:	e3410001 	movt	r0, #4097	; 0x1001
100045e0:	e30e1620 	movw	r1, #58912	; 0xe620
100045e4:	e3411001 	movt	r1, #4097	; 0x1001
100045e8:	e3002851 	movw	r2, #2129	; 0x851
100045ec:	eb0007f5 	bl	100065c8 <rt_assert_handler>
100045f0:	e51b001c 	ldr	r0, [fp, #-28]
100045f4:	eb001bb4 	bl	1000b4cc <rt_hw_interrupt_enable>
100045f8:	e51b0018 	ldr	r0, [fp, #-24]
100045fc:	eb001bb2 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* reset error number in thread */
        thread->error = RT_EOK;
10004600:	e51b3014 	ldr	r3, [fp, #-20]
10004604:	e3a02000 	mov	r2, #0
10004608:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* no waiting, return timeout */
        if (timeout == 0)
1000460c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004610:	e3530000 	cmp	r3, #0
10004614:	1a000007 	bne	10004638 <rt_mq_recv+0x1d4>
        {
            /* enable interrupt */
            rt_hw_interrupt_enable(temp);
10004618:	e1a03004 	mov	r3, r4
1000461c:	e1a00003 	mov	r0, r3
10004620:	eb001ba9 	bl	1000b4cc <rt_hw_interrupt_enable>

            thread->error = -RT_ETIMEOUT;
10004624:	e51b3014 	ldr	r3, [fp, #-20]
10004628:	e3e02001 	mvn	r2, #1
1000462c:	e583202c 	str	r2, [r3, #44]	; 0x2c

            return -RT_ETIMEOUT;
10004630:	e3e03001 	mvn	r3, #1
10004634:	ea000078 	b	1000481c <rt_mq_recv+0x3b8>
        }

        /* suspend current thread */
        rt_ipc_list_suspend(&(mq->parent.suspend_thread),
10004638:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000463c:	e2832010 	add	r2, r3, #16
10004640:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004644:	e5d33007 	ldrb	r3, [r3, #7]
10004648:	e1a00002 	mov	r0, r2
1000464c:	e51b1014 	ldr	r1, [fp, #-20]
10004650:	e1a02003 	mov	r2, r3
10004654:	ebfff4b2 	bl	10001924 <rt_ipc_list_suspend>
                            thread,
                            mq->parent.parent.flag);

        /* has waiting time, start thread timer */
        if (timeout > 0)
10004658:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000465c:	e3530000 	cmp	r3, #0
10004660:	da00000c 	ble	10004698 <rt_mq_recv+0x234>
        {
            /* get the start tick of timer */
            tick_delta = rt_tick_get();
10004664:	ebfff166 	bl	10000c04 <rt_tick_get>
10004668:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
                                        thread->name));

            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
1000466c:	e51b3014 	ldr	r3, [fp, #-20]
10004670:	e2832048 	add	r2, r3, #72	; 0x48
10004674:	e24b3034 	sub	r3, fp, #52	; 0x34
10004678:	e1a00002 	mov	r0, r2
1000467c:	e3a01000 	mov	r1, #0
10004680:	e1a02003 	mov	r2, r3
10004684:	eb001460 	bl	1000980c <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
10004688:	e51b3014 	ldr	r3, [fp, #-20]
1000468c:	e2833048 	add	r3, r3, #72	; 0x48
10004690:	e1a00003 	mov	r0, r3
10004694:	eb001366 	bl	10009434 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10004698:	e1a03004 	mov	r3, r4
1000469c:	e1a00003 	mov	r0, r3
100046a0:	eb001b89 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* re-schedule */
        rt_schedule();
100046a4:	eb000e58 	bl	1000800c <rt_schedule>

        /* recv message */
        if (thread->error != RT_EOK)
100046a8:	e51b3014 	ldr	r3, [fp, #-20]
100046ac:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100046b0:	e3530000 	cmp	r3, #0
100046b4:	0a000002 	beq	100046c4 <rt_mq_recv+0x260>
        {
            /* return error */
            return thread->error;
100046b8:	e51b3014 	ldr	r3, [fp, #-20]
100046bc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
100046c0:	ea000055 	b	1000481c <rt_mq_recv+0x3b8>
        }

        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
100046c4:	eb001b7c 	bl	1000b4bc <rt_hw_interrupt_disable>
100046c8:	e1a03000 	mov	r3, r0
100046cc:	e1a04003 	mov	r4, r3

        /* if it's not waiting forever and then re-calculate timeout tick */
        if (timeout > 0)
100046d0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
100046d4:	e3530000 	cmp	r3, #0
100046d8:	da00000e 	ble	10004718 <rt_mq_recv+0x2b4>
        {
            tick_delta = rt_tick_get() - tick_delta;
100046dc:	ebfff148 	bl	10000c04 <rt_tick_get>
100046e0:	e1a02000 	mov	r2, r0
100046e4:	e51b3010 	ldr	r3, [fp, #-16]
100046e8:	e0633002 	rsb	r3, r3, r2
100046ec:	e50b3010 	str	r3, [fp, #-16]
            timeout -= tick_delta;
100046f0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
100046f4:	e1a02003 	mov	r2, r3
100046f8:	e51b3010 	ldr	r3, [fp, #-16]
100046fc:	e0633002 	rsb	r3, r3, r2
10004700:	e50b3034 	str	r3, [fp, #-52]	; 0x34
            if (timeout < 0)
10004704:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10004708:	e3530000 	cmp	r3, #0
1000470c:	aa000001 	bge	10004718 <rt_mq_recv+0x2b4>
                timeout = 0;
10004710:	e3a03000 	mov	r3, #0
10004714:	e50b3034 	str	r3, [fp, #-52]	; 0x34

        return -RT_ETIMEOUT;
    }

    /* message queue is empty */
    while (mq->entry == 0)
10004718:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000471c:	e1d332b0 	ldrh	r3, [r3, #32]
10004720:	e3530000 	cmp	r3, #0
10004724:	0affff8f 	beq	10004568 <rt_mq_recv+0x104>
                timeout = 0;
        }
    }

    /* get message from queue */
    msg = (struct rt_mq_message *)mq->msg_queue_head;
10004728:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000472c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10004730:	e50b3020 	str	r3, [fp, #-32]
	
    /* move message queue head */
    mq->msg_queue_head = msg->next;
10004734:	e51b3020 	ldr	r3, [fp, #-32]
10004738:	e5932000 	ldr	r2, [r3]
1000473c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004740:	e5832024 	str	r2, [r3, #36]	; 0x24
    /* reach queue tail, set to NULL */
    if (mq->msg_queue_tail == msg)
10004744:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004748:	e5932028 	ldr	r2, [r3, #40]	; 0x28
1000474c:	e51b3020 	ldr	r3, [fp, #-32]
10004750:	e1520003 	cmp	r2, r3
10004754:	1a000002 	bne	10004764 <rt_mq_recv+0x300>
        mq->msg_queue_tail = RT_NULL;
10004758:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000475c:	e3a02000 	mov	r2, #0
10004760:	e5832028 	str	r2, [r3, #40]	; 0x28

    /* decrease message entry */
    mq->entry --;
10004764:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004768:	e1d332b0 	ldrh	r3, [r3, #32]
1000476c:	e2433001 	sub	r3, r3, #1
10004770:	e6ff2073 	uxth	r2, r3
10004774:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004778:	e1c322b0 	strh	r2, [r3, #32]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
1000477c:	e1a03004 	mov	r3, r4
10004780:	e1a00003 	mov	r0, r3
10004784:	eb001b50 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* copy message */
    rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
10004788:	e51b3020 	ldr	r3, [fp, #-32]
1000478c:	e2831004 	add	r1, r3, #4
10004790:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004794:	e1d331bc 	ldrh	r3, [r3, #28]
10004798:	e1a02003 	mov	r2, r3
1000479c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100047a0:	e1520003 	cmp	r2, r3
100047a4:	31a03002 	movcc	r3, r2
100047a8:	21a03003 	movcs	r3, r3
100047ac:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
100047b0:	e1a02003 	mov	r2, r3
100047b4:	eb00012f 	bl	10004c78 <rt_memcpy>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
100047b8:	eb001b3f 	bl	1000b4bc <rt_hw_interrupt_disable>
100047bc:	e1a03000 	mov	r3, r0
100047c0:	e1a04003 	mov	r4, r3
    /* put message to free list */
    msg->next = (struct rt_mq_message *)mq->msg_queue_free;
100047c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100047c8:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
100047cc:	e51b3020 	ldr	r3, [fp, #-32]
100047d0:	e5832000 	str	r2, [r3]
    mq->msg_queue_free = msg;
100047d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100047d8:	e51b2020 	ldr	r2, [fp, #-32]
100047dc:	e583202c 	str	r2, [r3, #44]	; 0x2c
    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
100047e0:	e1a03004 	mov	r3, r4
100047e4:	e1a00003 	mov	r0, r3
100047e8:	eb001b37 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
100047ec:	e3093d8c 	movw	r3, #40332	; 0x9d8c
100047f0:	e3413002 	movt	r3, #4098	; 0x1002
100047f4:	e5933000 	ldr	r3, [r3]
100047f8:	e3530000 	cmp	r3, #0
100047fc:	0a000005 	beq	10004818 <rt_mq_recv+0x3b4>
10004800:	e3093d8c 	movw	r3, #40332	; 0x9d8c
10004804:	e3413002 	movt	r3, #4098	; 0x1002
10004808:	e5933000 	ldr	r3, [r3]
1000480c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10004810:	e1a00002 	mov	r0, r2
10004814:	e12fff33 	blx	r3

    return RT_EOK;
10004818:	e3a03000 	mov	r3, #0
}
1000481c:	e1a00003 	mov	r0, r3
10004820:	e24bd008 	sub	sp, fp, #8
10004824:	e8bd8810 	pop	{r4, fp, pc}

10004828 <rt_mq_control>:
 * @param arg the execution argument
 *
 * @return the error code
 */
rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
{
10004828:	e92d4800 	push	{fp, lr}
1000482c:	e28db004 	add	fp, sp, #4
10004830:	e24dd018 	sub	sp, sp, #24
10004834:	e50b0010 	str	r0, [fp, #-16]
10004838:	e1a03001 	mov	r3, r1
1000483c:	e50b2018 	str	r2, [fp, #-24]
10004840:	e54b3011 	strb	r3, [fp, #-17]
    rt_ubase_t level;
    struct rt_mq_message *msg;

    RT_ASSERT(mq != RT_NULL);
10004844:	e51b3010 	ldr	r3, [fp, #-16]
10004848:	e3530000 	cmp	r3, #0
1000484c:	1a000005 	bne	10004868 <rt_mq_control+0x40>
10004850:	e30e0400 	movw	r0, #58368	; 0xe400
10004854:	e3410001 	movt	r0, #4097	; 0x1001
10004858:	e30e162c 	movw	r1, #58924	; 0xe62c
1000485c:	e3411001 	movt	r1, #4097	; 0x1001
10004860:	e30028bf 	movw	r2, #2239	; 0x8bf
10004864:	eb000757 	bl	100065c8 <rt_assert_handler>

    if (cmd == RT_IPC_CMD_RESET)
10004868:	e55b3011 	ldrb	r3, [fp, #-17]
1000486c:	e3530001 	cmp	r3, #1
10004870:	1a00002a 	bne	10004920 <rt_mq_control+0xf8>
    {
        /* disable interrupt */
        level = rt_hw_interrupt_disable();
10004874:	eb001b10 	bl	1000b4bc <rt_hw_interrupt_disable>
10004878:	e1a03000 	mov	r3, r0
1000487c:	e50b3008 	str	r3, [fp, #-8]

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&mq->parent.suspend_thread);
10004880:	e51b3010 	ldr	r3, [fp, #-16]
10004884:	e2833010 	add	r3, r3, #16
10004888:	e1a00003 	mov	r0, r3
1000488c:	ebfff472 	bl	10001a5c <rt_ipc_list_resume_all>

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
10004890:	ea000015 	b	100048ec <rt_mq_control+0xc4>
        {
            /* get message from queue */
            msg = (struct rt_mq_message *)mq->msg_queue_head;
10004894:	e51b3010 	ldr	r3, [fp, #-16]
10004898:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000489c:	e50b300c 	str	r3, [fp, #-12]

            /* move message queue head */
            mq->msg_queue_head = msg->next;
100048a0:	e51b300c 	ldr	r3, [fp, #-12]
100048a4:	e5932000 	ldr	r2, [r3]
100048a8:	e51b3010 	ldr	r3, [fp, #-16]
100048ac:	e5832024 	str	r2, [r3, #36]	; 0x24
            /* reach queue tail, set to NULL */
            if (mq->msg_queue_tail == msg)
100048b0:	e51b3010 	ldr	r3, [fp, #-16]
100048b4:	e5932028 	ldr	r2, [r3, #40]	; 0x28
100048b8:	e51b300c 	ldr	r3, [fp, #-12]
100048bc:	e1520003 	cmp	r2, r3
100048c0:	1a000002 	bne	100048d0 <rt_mq_control+0xa8>
                mq->msg_queue_tail = RT_NULL;
100048c4:	e51b3010 	ldr	r3, [fp, #-16]
100048c8:	e3a02000 	mov	r2, #0
100048cc:	e5832028 	str	r2, [r3, #40]	; 0x28

            /* put message to free list */
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
100048d0:	e51b3010 	ldr	r3, [fp, #-16]
100048d4:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
100048d8:	e51b300c 	ldr	r3, [fp, #-12]
100048dc:	e5832000 	str	r2, [r3]
            mq->msg_queue_free = msg;
100048e0:	e51b3010 	ldr	r3, [fp, #-16]
100048e4:	e51b200c 	ldr	r2, [fp, #-12]
100048e8:	e583202c 	str	r2, [r3, #44]	; 0x2c

        /* resume all waiting thread */
        rt_ipc_list_resume_all(&mq->parent.suspend_thread);

        /* release all message in the queue */
        while (mq->msg_queue_head != RT_NULL)
100048ec:	e51b3010 	ldr	r3, [fp, #-16]
100048f0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
100048f4:	e3530000 	cmp	r3, #0
100048f8:	1affffe5 	bne	10004894 <rt_mq_control+0x6c>
            msg->next = (struct rt_mq_message *)mq->msg_queue_free;
            mq->msg_queue_free = msg;
        }

        /* clean entry */
        mq->entry = 0;
100048fc:	e51b3010 	ldr	r3, [fp, #-16]
10004900:	e3a02000 	mov	r2, #0
10004904:	e1c322b0 	strh	r2, [r3, #32]

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10004908:	e51b3008 	ldr	r3, [fp, #-8]
1000490c:	e1a00003 	mov	r0, r3
10004910:	eb001aed 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
10004914:	eb000dbc 	bl	1000800c <rt_schedule>

        return RT_EOK;
10004918:	e3a03000 	mov	r3, #0
1000491c:	ea000000 	b	10004924 <rt_mq_control+0xfc>
    }

    return -RT_ERROR;
10004920:	e3e03000 	mvn	r3, #0
}
10004924:	e1a00003 	mov	r0, r3
10004928:	e24bd004 	sub	sp, fp, #4
1000492c:	e8bd8800 	pop	{fp, pc}

10004930 <rt_interrupt_enter>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_leave
 */
void rt_interrupt_enter(void)
{
10004930:	e92d4800 	push	{fp, lr}
10004934:	e28db004 	add	fp, sp, #4
10004938:	e24dd008 	sub	sp, sp, #8
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq coming..., irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
1000493c:	eb001ade 	bl	1000b4bc <rt_hw_interrupt_disable>
10004940:	e50b0008 	str	r0, [fp, #-8]
    rt_interrupt_nest ++;
10004944:	e3093d80 	movw	r3, #40320	; 0x9d80
10004948:	e3413002 	movt	r3, #4098	; 0x1002
1000494c:	e5d33000 	ldrb	r3, [r3]
10004950:	e6ef3073 	uxtb	r3, r3
10004954:	e2833001 	add	r3, r3, #1
10004958:	e6ef2073 	uxtb	r2, r3
1000495c:	e3093d80 	movw	r3, #40320	; 0x9d80
10004960:	e3413002 	movt	r3, #4098	; 0x1002
10004964:	e5c32000 	strb	r2, [r3]
    rt_hw_interrupt_enable(level);
10004968:	e51b0008 	ldr	r0, [fp, #-8]
1000496c:	eb001ad6 	bl	1000b4cc <rt_hw_interrupt_enable>
}
10004970:	e24bd004 	sub	sp, fp, #4
10004974:	e8bd8800 	pop	{fp, pc}

10004978 <rt_interrupt_leave>:
 * @note please don't invoke this routine in application
 *
 * @see rt_interrupt_enter
 */
void rt_interrupt_leave(void)
{
10004978:	e92d4800 	push	{fp, lr}
1000497c:	e28db004 	add	fp, sp, #4
10004980:	e24dd008 	sub	sp, sp, #8
    rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_IRQ, ("irq leave, irq nest:%d\n",
                                rt_interrupt_nest));

    level = rt_hw_interrupt_disable();
10004984:	eb001acc 	bl	1000b4bc <rt_hw_interrupt_disable>
10004988:	e50b0008 	str	r0, [fp, #-8]
    rt_interrupt_nest --;
1000498c:	e3093d80 	movw	r3, #40320	; 0x9d80
10004990:	e3413002 	movt	r3, #4098	; 0x1002
10004994:	e5d33000 	ldrb	r3, [r3]
10004998:	e6ef3073 	uxtb	r3, r3
1000499c:	e2433001 	sub	r3, r3, #1
100049a0:	e6ef2073 	uxtb	r2, r3
100049a4:	e3093d80 	movw	r3, #40320	; 0x9d80
100049a8:	e3413002 	movt	r3, #4098	; 0x1002
100049ac:	e5c32000 	strb	r2, [r3]
    rt_hw_interrupt_enable(level);
100049b0:	e51b0008 	ldr	r0, [fp, #-8]
100049b4:	eb001ac4 	bl	1000b4cc <rt_hw_interrupt_enable>
}
100049b8:	e24bd004 	sub	sp, fp, #4
100049bc:	e8bd8800 	pop	{fp, pc}

100049c0 <rt_interrupt_get_nest>:
 * context is interrupt context.
 *
 * @return the number of nested interrupts.
 */
rt_uint8_t rt_interrupt_get_nest(void)
{
100049c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100049c4:	e28db000 	add	fp, sp, #0
    return rt_interrupt_nest;
100049c8:	e3093d80 	movw	r3, #40320	; 0x9d80
100049cc:	e3413002 	movt	r3, #4098	; 0x1002
100049d0:	e5d33000 	ldrb	r3, [r3]
100049d4:	e6ef3073 	uxtb	r3, r3
}
100049d8:	e1a00003 	mov	r0, r3
100049dc:	e24bd000 	sub	sp, fp, #0
100049e0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100049e4:	e12fff1e 	bx	lr

100049e8 <rt_get_errno>:
 * This function will get errno
 *
 * @return errno
 */
rt_err_t rt_get_errno(void)
{
100049e8:	e92d4800 	push	{fp, lr}
100049ec:	e28db004 	add	fp, sp, #4
100049f0:	e24dd008 	sub	sp, sp, #8
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
100049f4:	ebfffff1 	bl	100049c0 <rt_interrupt_get_nest>
100049f8:	e1a03000 	mov	r3, r0
100049fc:	e3530000 	cmp	r3, #0
10004a00:	0a000003 	beq	10004a14 <rt_get_errno+0x2c>
    {
        /* it's in interrupt context */
        return _errno;
10004a04:	e3083320 	movw	r3, #33568	; 0x8320
10004a08:	e3413002 	movt	r3, #4098	; 0x1002
10004a0c:	e5933000 	ldr	r3, [r3]
10004a10:	ea00000a 	b	10004a40 <rt_get_errno+0x58>
    }

    tid = rt_thread_self();
10004a14:	eb000f6b 	bl	100087c8 <rt_thread_self>
10004a18:	e50b0008 	str	r0, [fp, #-8]
    if (tid == RT_NULL)
10004a1c:	e51b3008 	ldr	r3, [fp, #-8]
10004a20:	e3530000 	cmp	r3, #0
10004a24:	1a000003 	bne	10004a38 <rt_get_errno+0x50>
        return _errno;
10004a28:	e3083320 	movw	r3, #33568	; 0x8320
10004a2c:	e3413002 	movt	r3, #4098	; 0x1002
10004a30:	e5933000 	ldr	r3, [r3]
10004a34:	ea000001 	b	10004a40 <rt_get_errno+0x58>

    return tid->error;
10004a38:	e51b3008 	ldr	r3, [fp, #-8]
10004a3c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
}
10004a40:	e1a00003 	mov	r0, r3
10004a44:	e24bd004 	sub	sp, fp, #4
10004a48:	e8bd8800 	pop	{fp, pc}

10004a4c <rt_set_errno>:
 * This function will set errno
 *
 * @param error the errno shall be set
 */
void rt_set_errno(rt_err_t error)
{
10004a4c:	e92d4800 	push	{fp, lr}
10004a50:	e28db004 	add	fp, sp, #4
10004a54:	e24dd010 	sub	sp, sp, #16
10004a58:	e50b0010 	str	r0, [fp, #-16]
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
10004a5c:	ebffffd7 	bl	100049c0 <rt_interrupt_get_nest>
10004a60:	e1a03000 	mov	r3, r0
10004a64:	e3530000 	cmp	r3, #0
10004a68:	0a000004 	beq	10004a80 <rt_set_errno+0x34>
    {
        /* it's in interrupt context */
        _errno = error;
10004a6c:	e3083320 	movw	r3, #33568	; 0x8320
10004a70:	e3413002 	movt	r3, #4098	; 0x1002
10004a74:	e51b2010 	ldr	r2, [fp, #-16]
10004a78:	e5832000 	str	r2, [r3]

        return;
10004a7c:	ea00000c 	b	10004ab4 <rt_set_errno+0x68>
    }

    tid = rt_thread_self();
10004a80:	eb000f50 	bl	100087c8 <rt_thread_self>
10004a84:	e50b0008 	str	r0, [fp, #-8]
    if (tid == RT_NULL)
10004a88:	e51b3008 	ldr	r3, [fp, #-8]
10004a8c:	e3530000 	cmp	r3, #0
10004a90:	1a000004 	bne	10004aa8 <rt_set_errno+0x5c>
    {
        _errno = error;
10004a94:	e3083320 	movw	r3, #33568	; 0x8320
10004a98:	e3413002 	movt	r3, #4098	; 0x1002
10004a9c:	e51b2010 	ldr	r2, [fp, #-16]
10004aa0:	e5832000 	str	r2, [r3]

        return;
10004aa4:	ea000002 	b	10004ab4 <rt_set_errno+0x68>
    }

    tid->error = error;
10004aa8:	e51b3008 	ldr	r3, [fp, #-8]
10004aac:	e51b2010 	ldr	r2, [fp, #-16]
10004ab0:	e583202c 	str	r2, [r3, #44]	; 0x2c
}
10004ab4:	e24bd004 	sub	sp, fp, #4
10004ab8:	e8bd8800 	pop	{fp, pc}

10004abc <_rt_errno>:
 * This function returns errno.
 *
 * @return the errno in the system
 */
int *_rt_errno(void)
{
10004abc:	e92d4800 	push	{fp, lr}
10004ac0:	e28db004 	add	fp, sp, #4
10004ac4:	e24dd008 	sub	sp, sp, #8
    rt_thread_t tid;

    if (rt_interrupt_get_nest() != 0)
10004ac8:	ebffffbc 	bl	100049c0 <rt_interrupt_get_nest>
10004acc:	e1a03000 	mov	r3, r0
10004ad0:	e3530000 	cmp	r3, #0
10004ad4:	0a000002 	beq	10004ae4 <_rt_errno+0x28>
        return (int *)&_errno;
10004ad8:	e3083320 	movw	r3, #33568	; 0x8320
10004adc:	e3413002 	movt	r3, #4098	; 0x1002
10004ae0:	ea000009 	b	10004b0c <_rt_errno+0x50>

    tid = rt_thread_self();
10004ae4:	eb000f37 	bl	100087c8 <rt_thread_self>
10004ae8:	e50b0008 	str	r0, [fp, #-8]
    if (tid != RT_NULL)
10004aec:	e51b3008 	ldr	r3, [fp, #-8]
10004af0:	e3530000 	cmp	r3, #0
10004af4:	0a000002 	beq	10004b04 <_rt_errno+0x48>
        return (int *)&(tid->error);
10004af8:	e51b3008 	ldr	r3, [fp, #-8]
10004afc:	e283302c 	add	r3, r3, #44	; 0x2c
10004b00:	ea000001 	b	10004b0c <_rt_errno+0x50>

    return (int *)&_errno;
10004b04:	e3083320 	movw	r3, #33568	; 0x8320
10004b08:	e3413002 	movt	r3, #4098	; 0x1002
}
10004b0c:	e1a00003 	mov	r0, r3
10004b10:	e24bd004 	sub	sp, fp, #4
10004b14:	e8bd8800 	pop	{fp, pc}

10004b18 <rt_memset>:
 * @param count the copied length
 *
 * @return the address of source memory
 */
void *rt_memset(void *s, int c, rt_ubase_t count)
{
10004b18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004b1c:	e28db000 	add	fp, sp, #0
10004b20:	e24dd024 	sub	sp, sp, #36	; 0x24
10004b24:	e50b0018 	str	r0, [fp, #-24]
10004b28:	e50b101c 	str	r1, [fp, #-28]
10004b2c:	e50b2020 	str	r2, [fp, #-32]
#define LBLOCKSIZE      (sizeof(rt_int32_t))
#define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
#define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)

    int i;
    char *m = (char *)s;
10004b30:	e51b3018 	ldr	r3, [fp, #-24]
10004b34:	e50b3008 	str	r3, [fp, #-8]
    rt_uint32_t buffer;
    rt_uint32_t *aligned_addr;
    rt_uint32_t d = c & 0xff;
10004b38:	e51b301c 	ldr	r3, [fp, #-28]
10004b3c:	e6ef3073 	uxtb	r3, r3
10004b40:	e50b3010 	str	r3, [fp, #-16]

    if (!TOO_SMALL(count) && !UNALIGNED(s))
10004b44:	e51b3020 	ldr	r3, [fp, #-32]
10004b48:	e3530003 	cmp	r3, #3
10004b4c:	9a000038 	bls	10004c34 <rt_memset+0x11c>
10004b50:	e51b3018 	ldr	r3, [fp, #-24]
10004b54:	e2033003 	and	r3, r3, #3
10004b58:	e3530000 	cmp	r3, #0
10004b5c:	1a000034 	bne	10004c34 <rt_memset+0x11c>
    {
        /* If we get this far, we know that n is large and m is word-aligned. */
        aligned_addr = (rt_uint32_t *)s;
10004b60:	e51b3018 	ldr	r3, [fp, #-24]
10004b64:	e50b300c 	str	r3, [fp, #-12]
        /* Store D into each char sized location in BUFFER so that
         * we can set large blocks quickly.
         */
        if (LBLOCKSIZE == 4)
        {
            buffer = (d << 8) | d;
10004b68:	e51b3010 	ldr	r3, [fp, #-16]
10004b6c:	e1a02403 	lsl	r2, r3, #8
10004b70:	e51b3010 	ldr	r3, [fp, #-16]
10004b74:	e1823003 	orr	r3, r2, r3
10004b78:	e50b3014 	str	r3, [fp, #-20]
            buffer |= (buffer << 16);
10004b7c:	e51b3014 	ldr	r3, [fp, #-20]
10004b80:	e1a03803 	lsl	r3, r3, #16
10004b84:	e51b2014 	ldr	r2, [fp, #-20]
10004b88:	e1823003 	orr	r3, r2, r3
10004b8c:	e50b3014 	str	r3, [fp, #-20]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
10004b90:	ea000016 	b	10004bf0 <rt_memset+0xd8>
        {
            *aligned_addr++ = buffer;
10004b94:	e51b300c 	ldr	r3, [fp, #-12]
10004b98:	e2832004 	add	r2, r3, #4
10004b9c:	e50b200c 	str	r2, [fp, #-12]
10004ba0:	e51b2014 	ldr	r2, [fp, #-20]
10004ba4:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
10004ba8:	e51b300c 	ldr	r3, [fp, #-12]
10004bac:	e2832004 	add	r2, r3, #4
10004bb0:	e50b200c 	str	r2, [fp, #-12]
10004bb4:	e51b2014 	ldr	r2, [fp, #-20]
10004bb8:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
10004bbc:	e51b300c 	ldr	r3, [fp, #-12]
10004bc0:	e2832004 	add	r2, r3, #4
10004bc4:	e50b200c 	str	r2, [fp, #-12]
10004bc8:	e51b2014 	ldr	r2, [fp, #-20]
10004bcc:	e5832000 	str	r2, [r3]
            *aligned_addr++ = buffer;
10004bd0:	e51b300c 	ldr	r3, [fp, #-12]
10004bd4:	e2832004 	add	r2, r3, #4
10004bd8:	e50b200c 	str	r2, [fp, #-12]
10004bdc:	e51b2014 	ldr	r2, [fp, #-20]
10004be0:	e5832000 	str	r2, [r3]
            count -= 4 * LBLOCKSIZE;
10004be4:	e51b3020 	ldr	r3, [fp, #-32]
10004be8:	e2433010 	sub	r3, r3, #16
10004bec:	e50b3020 	str	r3, [fp, #-32]
            buffer = 0;
            for (i = 0; i < LBLOCKSIZE; i ++)
                buffer = (buffer << 8) | d;
        }

        while (count >= LBLOCKSIZE * 4)
10004bf0:	e51b3020 	ldr	r3, [fp, #-32]
10004bf4:	e353000f 	cmp	r3, #15
10004bf8:	8affffe5 	bhi	10004b94 <rt_memset+0x7c>
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
10004bfc:	ea000007 	b	10004c20 <rt_memset+0x108>
        {
            *aligned_addr++ = buffer;
10004c00:	e51b300c 	ldr	r3, [fp, #-12]
10004c04:	e2832004 	add	r2, r3, #4
10004c08:	e50b200c 	str	r2, [fp, #-12]
10004c0c:	e51b2014 	ldr	r2, [fp, #-20]
10004c10:	e5832000 	str	r2, [r3]
            count -= LBLOCKSIZE;
10004c14:	e51b3020 	ldr	r3, [fp, #-32]
10004c18:	e2433004 	sub	r3, r3, #4
10004c1c:	e50b3020 	str	r3, [fp, #-32]
            *aligned_addr++ = buffer;
            *aligned_addr++ = buffer;
            count -= 4 * LBLOCKSIZE;
        }

        while (count >= LBLOCKSIZE)
10004c20:	e51b3020 	ldr	r3, [fp, #-32]
10004c24:	e3530003 	cmp	r3, #3
10004c28:	8afffff4 	bhi	10004c00 <rt_memset+0xe8>
            *aligned_addr++ = buffer;
            count -= LBLOCKSIZE;
        }

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
10004c2c:	e51b300c 	ldr	r3, [fp, #-12]
10004c30:	e50b3008 	str	r3, [fp, #-8]
    }

    while (count--)
10004c34:	ea000005 	b	10004c50 <rt_memset+0x138>
    {
        *m++ = (char)d;
10004c38:	e51b3008 	ldr	r3, [fp, #-8]
10004c3c:	e2832001 	add	r2, r3, #1
10004c40:	e50b2008 	str	r2, [fp, #-8]
10004c44:	e51b2010 	ldr	r2, [fp, #-16]
10004c48:	e6ef2072 	uxtb	r2, r2
10004c4c:	e5c32000 	strb	r2, [r3]

        /* Pick up the remainder with a bytewise loop. */
        m = (char *)aligned_addr;
    }

    while (count--)
10004c50:	e51b3020 	ldr	r3, [fp, #-32]
10004c54:	e2432001 	sub	r2, r3, #1
10004c58:	e50b2020 	str	r2, [fp, #-32]
10004c5c:	e3530000 	cmp	r3, #0
10004c60:	1afffff4 	bne	10004c38 <rt_memset+0x120>
    {
        *m++ = (char)d;
    }

    return s;
10004c64:	e51b3018 	ldr	r3, [fp, #-24]

#undef LBLOCKSIZE
#undef UNALIGNED
#undef TOO_SMALL
#endif
}
10004c68:	e1a00003 	mov	r0, r3
10004c6c:	e24bd000 	sub	sp, fp, #0
10004c70:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004c74:	e12fff1e 	bx	lr

10004c78 <rt_memcpy>:
 * @param count the copied length
 *
 * @return the address of destination memory
 */
void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
{
10004c78:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004c7c:	e28db000 	add	fp, sp, #0
10004c80:	e24dd02c 	sub	sp, sp, #44	; 0x2c
10004c84:	e50b0020 	str	r0, [fp, #-32]
10004c88:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10004c8c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
                         ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
#define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
#define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)

    char *dst_ptr = (char *)dst;
10004c90:	e51b3020 	ldr	r3, [fp, #-32]
10004c94:	e50b3008 	str	r3, [fp, #-8]
    char *src_ptr = (char *)src;
10004c98:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10004c9c:	e50b300c 	str	r3, [fp, #-12]
    rt_int32_t *aligned_dst;
    rt_int32_t *aligned_src;
    int len = count;
10004ca0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10004ca4:	e50b3018 	str	r3, [fp, #-24]

    /* If the size is small, or either SRC or DST is unaligned,
    then punt into the byte copy loop.  This should be rare. */
    if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
10004ca8:	e51b3018 	ldr	r3, [fp, #-24]
10004cac:	e353000f 	cmp	r3, #15
10004cb0:	9a000043 	bls	10004dc4 <rt_memcpy+0x14c>
10004cb4:	e51b200c 	ldr	r2, [fp, #-12]
10004cb8:	e51b3008 	ldr	r3, [fp, #-8]
10004cbc:	e1823003 	orr	r3, r2, r3
10004cc0:	e2033003 	and	r3, r3, #3
10004cc4:	e3530000 	cmp	r3, #0
10004cc8:	1a00003d 	bne	10004dc4 <rt_memcpy+0x14c>
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
10004ccc:	e51b3008 	ldr	r3, [fp, #-8]
10004cd0:	e50b3010 	str	r3, [fp, #-16]
        aligned_src = (rt_int32_t *)src_ptr;
10004cd4:	e51b300c 	ldr	r3, [fp, #-12]
10004cd8:	e50b3014 	str	r3, [fp, #-20]

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
10004cdc:	ea000022 	b	10004d6c <rt_memcpy+0xf4>
        {
            *aligned_dst++ = *aligned_src++;
10004ce0:	e51b3010 	ldr	r3, [fp, #-16]
10004ce4:	e2832004 	add	r2, r3, #4
10004ce8:	e50b2010 	str	r2, [fp, #-16]
10004cec:	e51b2014 	ldr	r2, [fp, #-20]
10004cf0:	e2821004 	add	r1, r2, #4
10004cf4:	e50b1014 	str	r1, [fp, #-20]
10004cf8:	e5922000 	ldr	r2, [r2]
10004cfc:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
10004d00:	e51b3010 	ldr	r3, [fp, #-16]
10004d04:	e2832004 	add	r2, r3, #4
10004d08:	e50b2010 	str	r2, [fp, #-16]
10004d0c:	e51b2014 	ldr	r2, [fp, #-20]
10004d10:	e2821004 	add	r1, r2, #4
10004d14:	e50b1014 	str	r1, [fp, #-20]
10004d18:	e5922000 	ldr	r2, [r2]
10004d1c:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
10004d20:	e51b3010 	ldr	r3, [fp, #-16]
10004d24:	e2832004 	add	r2, r3, #4
10004d28:	e50b2010 	str	r2, [fp, #-16]
10004d2c:	e51b2014 	ldr	r2, [fp, #-20]
10004d30:	e2821004 	add	r1, r2, #4
10004d34:	e50b1014 	str	r1, [fp, #-20]
10004d38:	e5922000 	ldr	r2, [r2]
10004d3c:	e5832000 	str	r2, [r3]
            *aligned_dst++ = *aligned_src++;
10004d40:	e51b3010 	ldr	r3, [fp, #-16]
10004d44:	e2832004 	add	r2, r3, #4
10004d48:	e50b2010 	str	r2, [fp, #-16]
10004d4c:	e51b2014 	ldr	r2, [fp, #-20]
10004d50:	e2821004 	add	r1, r2, #4
10004d54:	e50b1014 	str	r1, [fp, #-20]
10004d58:	e5922000 	ldr	r2, [r2]
10004d5c:	e5832000 	str	r2, [r3]
            len -= BIGBLOCKSIZE;
10004d60:	e51b3018 	ldr	r3, [fp, #-24]
10004d64:	e2433010 	sub	r3, r3, #16
10004d68:	e50b3018 	str	r3, [fp, #-24]
    {
        aligned_dst = (rt_int32_t *)dst_ptr;
        aligned_src = (rt_int32_t *)src_ptr;

        /* Copy 4X long words at a time if possible. */
        while (len >= BIGBLOCKSIZE)
10004d6c:	e51b3018 	ldr	r3, [fp, #-24]
10004d70:	e353000f 	cmp	r3, #15
10004d74:	8affffd9 	bhi	10004ce0 <rt_memcpy+0x68>
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
10004d78:	ea00000a 	b	10004da8 <rt_memcpy+0x130>
        {
            *aligned_dst++ = *aligned_src++;
10004d7c:	e51b3010 	ldr	r3, [fp, #-16]
10004d80:	e2832004 	add	r2, r3, #4
10004d84:	e50b2010 	str	r2, [fp, #-16]
10004d88:	e51b2014 	ldr	r2, [fp, #-20]
10004d8c:	e2821004 	add	r1, r2, #4
10004d90:	e50b1014 	str	r1, [fp, #-20]
10004d94:	e5922000 	ldr	r2, [r2]
10004d98:	e5832000 	str	r2, [r3]
            len -= LITTLEBLOCKSIZE;
10004d9c:	e51b3018 	ldr	r3, [fp, #-24]
10004da0:	e2433004 	sub	r3, r3, #4
10004da4:	e50b3018 	str	r3, [fp, #-24]
            *aligned_dst++ = *aligned_src++;
            len -= BIGBLOCKSIZE;
        }

        /* Copy one long word at a time if possible. */
        while (len >= LITTLEBLOCKSIZE)
10004da8:	e51b3018 	ldr	r3, [fp, #-24]
10004dac:	e3530003 	cmp	r3, #3
10004db0:	8afffff1 	bhi	10004d7c <rt_memcpy+0x104>
            *aligned_dst++ = *aligned_src++;
            len -= LITTLEBLOCKSIZE;
        }

        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
10004db4:	e51b3010 	ldr	r3, [fp, #-16]
10004db8:	e50b3008 	str	r3, [fp, #-8]
        src_ptr = (char *)aligned_src;
10004dbc:	e51b3014 	ldr	r3, [fp, #-20]
10004dc0:	e50b300c 	str	r3, [fp, #-12]
    }

    while (len--)
10004dc4:	ea000007 	b	10004de8 <rt_memcpy+0x170>
        *dst_ptr++ = *src_ptr++;
10004dc8:	e51b3008 	ldr	r3, [fp, #-8]
10004dcc:	e2832001 	add	r2, r3, #1
10004dd0:	e50b2008 	str	r2, [fp, #-8]
10004dd4:	e51b200c 	ldr	r2, [fp, #-12]
10004dd8:	e2821001 	add	r1, r2, #1
10004ddc:	e50b100c 	str	r1, [fp, #-12]
10004de0:	e5d22000 	ldrb	r2, [r2]
10004de4:	e5c32000 	strb	r2, [r3]
        /* Pick up any residual with a byte copier. */
        dst_ptr = (char *)aligned_dst;
        src_ptr = (char *)aligned_src;
    }

    while (len--)
10004de8:	e51b3018 	ldr	r3, [fp, #-24]
10004dec:	e2432001 	sub	r2, r3, #1
10004df0:	e50b2018 	str	r2, [fp, #-24]
10004df4:	e3530000 	cmp	r3, #0
10004df8:	1afffff2 	bne	10004dc8 <rt_memcpy+0x150>
        *dst_ptr++ = *src_ptr++;

    return dst;
10004dfc:	e51b3020 	ldr	r3, [fp, #-32]
#undef UNALIGNED
#undef BIGBLOCKSIZE
#undef LITTLEBLOCKSIZE
#undef TOO_SMALL
#endif
}
10004e00:	e1a00003 	mov	r0, r3
10004e04:	e24bd000 	sub	sp, fp, #0
10004e08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004e0c:	e12fff1e 	bx	lr

10004e10 <rt_memmove>:
 * @param n the copied length
 *
 * @return the address of destination memory
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
10004e10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004e14:	e28db000 	add	fp, sp, #0
10004e18:	e24dd01c 	sub	sp, sp, #28
10004e1c:	e50b0010 	str	r0, [fp, #-16]
10004e20:	e50b1014 	str	r1, [fp, #-20]
10004e24:	e50b2018 	str	r2, [fp, #-24]
    char *tmp = (char *)dest, *s = (char *)src;
10004e28:	e51b3010 	ldr	r3, [fp, #-16]
10004e2c:	e50b3008 	str	r3, [fp, #-8]
10004e30:	e51b3014 	ldr	r3, [fp, #-20]
10004e34:	e50b300c 	str	r3, [fp, #-12]

    if (s < tmp && tmp < s + n)
10004e38:	e51b200c 	ldr	r2, [fp, #-12]
10004e3c:	e51b3008 	ldr	r3, [fp, #-8]
10004e40:	e1520003 	cmp	r2, r3
10004e44:	2a00001e 	bcs	10004ec4 <rt_memmove+0xb4>
10004e48:	e51b200c 	ldr	r2, [fp, #-12]
10004e4c:	e51b3018 	ldr	r3, [fp, #-24]
10004e50:	e0822003 	add	r2, r2, r3
10004e54:	e51b3008 	ldr	r3, [fp, #-8]
10004e58:	e1520003 	cmp	r2, r3
10004e5c:	9a000018 	bls	10004ec4 <rt_memmove+0xb4>
    {
        tmp += n;
10004e60:	e51b2008 	ldr	r2, [fp, #-8]
10004e64:	e51b3018 	ldr	r3, [fp, #-24]
10004e68:	e0823003 	add	r3, r2, r3
10004e6c:	e50b3008 	str	r3, [fp, #-8]
        s += n;
10004e70:	e51b200c 	ldr	r2, [fp, #-12]
10004e74:	e51b3018 	ldr	r3, [fp, #-24]
10004e78:	e0823003 	add	r3, r2, r3
10004e7c:	e50b300c 	str	r3, [fp, #-12]

        while (n--)
10004e80:	ea000009 	b	10004eac <rt_memmove+0x9c>
            *(--tmp) = *(--s);
10004e84:	e51b3008 	ldr	r3, [fp, #-8]
10004e88:	e2433001 	sub	r3, r3, #1
10004e8c:	e50b3008 	str	r3, [fp, #-8]
10004e90:	e51b300c 	ldr	r3, [fp, #-12]
10004e94:	e2433001 	sub	r3, r3, #1
10004e98:	e50b300c 	str	r3, [fp, #-12]
10004e9c:	e51b300c 	ldr	r3, [fp, #-12]
10004ea0:	e5d32000 	ldrb	r2, [r3]
10004ea4:	e51b3008 	ldr	r3, [fp, #-8]
10004ea8:	e5c32000 	strb	r2, [r3]
    if (s < tmp && tmp < s + n)
    {
        tmp += n;
        s += n;

        while (n--)
10004eac:	e51b3018 	ldr	r3, [fp, #-24]
10004eb0:	e2432001 	sub	r2, r3, #1
10004eb4:	e50b2018 	str	r2, [fp, #-24]
10004eb8:	e3530000 	cmp	r3, #0
10004ebc:	1afffff0 	bne	10004e84 <rt_memmove+0x74>
 */
void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
{
    char *tmp = (char *)dest, *s = (char *)src;

    if (s < tmp && tmp < s + n)
10004ec0:	ea00000d 	b	10004efc <rt_memmove+0xec>
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
10004ec4:	ea000007 	b	10004ee8 <rt_memmove+0xd8>
            *tmp++ = *s++;
10004ec8:	e51b3008 	ldr	r3, [fp, #-8]
10004ecc:	e2832001 	add	r2, r3, #1
10004ed0:	e50b2008 	str	r2, [fp, #-8]
10004ed4:	e51b200c 	ldr	r2, [fp, #-12]
10004ed8:	e2821001 	add	r1, r2, #1
10004edc:	e50b100c 	str	r1, [fp, #-12]
10004ee0:	e5d22000 	ldrb	r2, [r2]
10004ee4:	e5c32000 	strb	r2, [r3]
        while (n--)
            *(--tmp) = *(--s);
    }
    else
    {
        while (n--)
10004ee8:	e51b3018 	ldr	r3, [fp, #-24]
10004eec:	e2432001 	sub	r2, r3, #1
10004ef0:	e50b2018 	str	r2, [fp, #-24]
10004ef4:	e3530000 	cmp	r3, #0
10004ef8:	1afffff2 	bne	10004ec8 <rt_memmove+0xb8>
            *tmp++ = *s++;
    }

    return dest;
10004efc:	e51b3010 	ldr	r3, [fp, #-16]
}
10004f00:	e1a00003 	mov	r0, r3
10004f04:	e24bd000 	sub	sp, fp, #0
10004f08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004f0c:	e12fff1e 	bx	lr

10004f10 <rt_memcmp>:
 * @param count the size of the area
 *
 * @return the result
 */
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
10004f10:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10004f14:	e28db000 	add	fp, sp, #0
10004f18:	e24dd024 	sub	sp, sp, #36	; 0x24
10004f1c:	e50b0018 	str	r0, [fp, #-24]
10004f20:	e50b101c 	str	r1, [fp, #-28]
10004f24:	e50b2020 	str	r2, [fp, #-32]
    const unsigned char *su1, *su2;
    int res = 0;
10004f28:	e3a03000 	mov	r3, #0
10004f2c:	e50b3010 	str	r3, [fp, #-16]

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
10004f30:	e51b3018 	ldr	r3, [fp, #-24]
10004f34:	e50b3008 	str	r3, [fp, #-8]
10004f38:	e51b301c 	ldr	r3, [fp, #-28]
10004f3c:	e50b300c 	str	r3, [fp, #-12]
10004f40:	ea000013 	b	10004f94 <rt_memcmp+0x84>
        if ((res = *su1 - *su2) != 0)
10004f44:	e51b3008 	ldr	r3, [fp, #-8]
10004f48:	e5d33000 	ldrb	r3, [r3]
10004f4c:	e1a02003 	mov	r2, r3
10004f50:	e51b300c 	ldr	r3, [fp, #-12]
10004f54:	e5d33000 	ldrb	r3, [r3]
10004f58:	e0633002 	rsb	r3, r3, r2
10004f5c:	e50b3010 	str	r3, [fp, #-16]
10004f60:	e51b3010 	ldr	r3, [fp, #-16]
10004f64:	e3530000 	cmp	r3, #0
10004f68:	0a000000 	beq	10004f70 <rt_memcmp+0x60>
            break;
10004f6c:	ea00000b 	b	10004fa0 <rt_memcmp+0x90>
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
{
    const unsigned char *su1, *su2;
    int res = 0;

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
10004f70:	e51b3008 	ldr	r3, [fp, #-8]
10004f74:	e2833001 	add	r3, r3, #1
10004f78:	e50b3008 	str	r3, [fp, #-8]
10004f7c:	e51b300c 	ldr	r3, [fp, #-12]
10004f80:	e2833001 	add	r3, r3, #1
10004f84:	e50b300c 	str	r3, [fp, #-12]
10004f88:	e51b3020 	ldr	r3, [fp, #-32]
10004f8c:	e2433001 	sub	r3, r3, #1
10004f90:	e50b3020 	str	r3, [fp, #-32]
10004f94:	e51b3020 	ldr	r3, [fp, #-32]
10004f98:	e3530000 	cmp	r3, #0
10004f9c:	1affffe8 	bne	10004f44 <rt_memcmp+0x34>
        if ((res = *su1 - *su2) != 0)
            break;

    return res;
10004fa0:	e51b3010 	ldr	r3, [fp, #-16]
}
10004fa4:	e1a00003 	mov	r0, r3
10004fa8:	e24bd000 	sub	sp, fp, #0
10004fac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10004fb0:	e12fff1e 	bx	lr

10004fb4 <rt_strstr>:
 * @param s2 the find string
 *
 * @return the first occurrence of a s2 in s1, or RT_NULL if no found.
 */
char *rt_strstr(const char *s1, const char *s2)
{
10004fb4:	e92d4800 	push	{fp, lr}
10004fb8:	e28db004 	add	fp, sp, #4
10004fbc:	e24dd010 	sub	sp, sp, #16
10004fc0:	e50b0010 	str	r0, [fp, #-16]
10004fc4:	e50b1014 	str	r1, [fp, #-20]
    int l1, l2;

    l2 = rt_strlen(s2);
10004fc8:	e51b0014 	ldr	r0, [fp, #-20]
10004fcc:	eb0000c6 	bl	100052ec <rt_strlen>
10004fd0:	e1a03000 	mov	r3, r0
10004fd4:	e50b300c 	str	r3, [fp, #-12]
    if (!l2)
10004fd8:	e51b300c 	ldr	r3, [fp, #-12]
10004fdc:	e3530000 	cmp	r3, #0
10004fe0:	1a000001 	bne	10004fec <rt_strstr+0x38>
        return (char *)s1;
10004fe4:	e51b3010 	ldr	r3, [fp, #-16]
10004fe8:	ea000019 	b	10005054 <rt_strstr+0xa0>
    l1 = rt_strlen(s1);
10004fec:	e51b0010 	ldr	r0, [fp, #-16]
10004ff0:	eb0000bd 	bl	100052ec <rt_strlen>
10004ff4:	e1a03000 	mov	r3, r0
10004ff8:	e50b3008 	str	r3, [fp, #-8]
    while (l1 >= l2)
10004ffc:	ea00000f 	b	10005040 <rt_strstr+0x8c>
    {
        l1 --;
10005000:	e51b3008 	ldr	r3, [fp, #-8]
10005004:	e2433001 	sub	r3, r3, #1
10005008:	e50b3008 	str	r3, [fp, #-8]
        if (!rt_memcmp(s1, s2, l2))
1000500c:	e51b300c 	ldr	r3, [fp, #-12]
10005010:	e51b0010 	ldr	r0, [fp, #-16]
10005014:	e51b1014 	ldr	r1, [fp, #-20]
10005018:	e1a02003 	mov	r2, r3
1000501c:	ebffffbb 	bl	10004f10 <rt_memcmp>
10005020:	e1a03000 	mov	r3, r0
10005024:	e3530000 	cmp	r3, #0
10005028:	1a000001 	bne	10005034 <rt_strstr+0x80>
            return (char *)s1;
1000502c:	e51b3010 	ldr	r3, [fp, #-16]
10005030:	ea000007 	b	10005054 <rt_strstr+0xa0>
        s1 ++;
10005034:	e51b3010 	ldr	r3, [fp, #-16]
10005038:	e2833001 	add	r3, r3, #1
1000503c:	e50b3010 	str	r3, [fp, #-16]

    l2 = rt_strlen(s2);
    if (!l2)
        return (char *)s1;
    l1 = rt_strlen(s1);
    while (l1 >= l2)
10005040:	e51b2008 	ldr	r2, [fp, #-8]
10005044:	e51b300c 	ldr	r3, [fp, #-12]
10005048:	e1520003 	cmp	r2, r3
1000504c:	aaffffeb 	bge	10005000 <rt_strstr+0x4c>
        if (!rt_memcmp(s1, s2, l2))
            return (char *)s1;
        s1 ++;
    }

    return RT_NULL;
10005050:	e3a03000 	mov	r3, #0
}
10005054:	e1a00003 	mov	r0, r3
10005058:	e24bd004 	sub	sp, fp, #4
1000505c:	e8bd8800 	pop	{fp, pc}

10005060 <rt_strcasecmp>:
 * @param b the string to be compared
 *
 * @return the result
 */
rt_uint32_t rt_strcasecmp(const char *a, const char *b)
{
10005060:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005064:	e28db000 	add	fp, sp, #0
10005068:	e24dd014 	sub	sp, sp, #20
1000506c:	e50b0010 	str	r0, [fp, #-16]
10005070:	e50b1014 	str	r1, [fp, #-20]
    int ca, cb;

    do
    {
        ca = *a++ & 0xff;
10005074:	e51b3010 	ldr	r3, [fp, #-16]
10005078:	e2832001 	add	r2, r3, #1
1000507c:	e50b2010 	str	r2, [fp, #-16]
10005080:	e5d33000 	ldrb	r3, [r3]
10005084:	e50b3008 	str	r3, [fp, #-8]
        cb = *b++ & 0xff;
10005088:	e51b3014 	ldr	r3, [fp, #-20]
1000508c:	e2832001 	add	r2, r3, #1
10005090:	e50b2014 	str	r2, [fp, #-20]
10005094:	e5d33000 	ldrb	r3, [r3]
10005098:	e50b300c 	str	r3, [fp, #-12]
        if (ca >= 'A' && ca <= 'Z')
1000509c:	e51b3008 	ldr	r3, [fp, #-8]
100050a0:	e3530040 	cmp	r3, #64	; 0x40
100050a4:	da000005 	ble	100050c0 <rt_strcasecmp+0x60>
100050a8:	e51b3008 	ldr	r3, [fp, #-8]
100050ac:	e353005a 	cmp	r3, #90	; 0x5a
100050b0:	ca000002 	bgt	100050c0 <rt_strcasecmp+0x60>
            ca += 'a' - 'A';
100050b4:	e51b3008 	ldr	r3, [fp, #-8]
100050b8:	e2833020 	add	r3, r3, #32
100050bc:	e50b3008 	str	r3, [fp, #-8]
        if (cb >= 'A' && cb <= 'Z')
100050c0:	e51b300c 	ldr	r3, [fp, #-12]
100050c4:	e3530040 	cmp	r3, #64	; 0x40
100050c8:	da000005 	ble	100050e4 <rt_strcasecmp+0x84>
100050cc:	e51b300c 	ldr	r3, [fp, #-12]
100050d0:	e353005a 	cmp	r3, #90	; 0x5a
100050d4:	ca000002 	bgt	100050e4 <rt_strcasecmp+0x84>
            cb += 'a' - 'A';
100050d8:	e51b300c 	ldr	r3, [fp, #-12]
100050dc:	e2833020 	add	r3, r3, #32
100050e0:	e50b300c 	str	r3, [fp, #-12]
    }
    while (ca == cb && ca != '\0');
100050e4:	e51b2008 	ldr	r2, [fp, #-8]
100050e8:	e51b300c 	ldr	r3, [fp, #-12]
100050ec:	e1520003 	cmp	r2, r3
100050f0:	1a000002 	bne	10005100 <rt_strcasecmp+0xa0>
100050f4:	e51b3008 	ldr	r3, [fp, #-8]
100050f8:	e3530000 	cmp	r3, #0
100050fc:	1affffdc 	bne	10005074 <rt_strcasecmp+0x14>

    return ca - cb;
10005100:	e51b2008 	ldr	r2, [fp, #-8]
10005104:	e51b300c 	ldr	r3, [fp, #-12]
10005108:	e0633002 	rsb	r3, r3, r2
}
1000510c:	e1a00003 	mov	r0, r3
10005110:	e24bd000 	sub	sp, fp, #0
10005114:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10005118:	e12fff1e 	bx	lr

1000511c <rt_strncpy>:
 * @param n the maximum copied length
 *
 * @return the result
 */
char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
1000511c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005120:	e28db000 	add	fp, sp, #0
10005124:	e24dd01c 	sub	sp, sp, #28
10005128:	e50b0010 	str	r0, [fp, #-16]
1000512c:	e50b1014 	str	r1, [fp, #-20]
10005130:	e50b2018 	str	r2, [fp, #-24]
    if (n != 0)
10005134:	e51b3018 	ldr	r3, [fp, #-24]
10005138:	e3530000 	cmp	r3, #0
1000513c:	0a000021 	beq	100051c8 <rt_strncpy+0xac>
    {
        char *d = dst;
10005140:	e51b3010 	ldr	r3, [fp, #-16]
10005144:	e50b3008 	str	r3, [fp, #-8]
        const char *s = src;
10005148:	e51b3014 	ldr	r3, [fp, #-20]
1000514c:	e50b300c 	str	r3, [fp, #-12]

        do
        {
            if ((*d++ = *s++) == 0)
10005150:	e51b3008 	ldr	r3, [fp, #-8]
10005154:	e2832001 	add	r2, r3, #1
10005158:	e50b2008 	str	r2, [fp, #-8]
1000515c:	e51b200c 	ldr	r2, [fp, #-12]
10005160:	e2821001 	add	r1, r2, #1
10005164:	e50b100c 	str	r1, [fp, #-12]
10005168:	e5d22000 	ldrb	r2, [r2]
1000516c:	e5c32000 	strb	r2, [r3]
10005170:	e5d33000 	ldrb	r3, [r3]
10005174:	e3530000 	cmp	r3, #0
10005178:	1a00000c 	bne	100051b0 <rt_strncpy+0x94>
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
1000517c:	ea000004 	b	10005194 <rt_strncpy+0x78>
                    *d++ = 0;
10005180:	e51b3008 	ldr	r3, [fp, #-8]
10005184:	e2832001 	add	r2, r3, #1
10005188:	e50b2008 	str	r2, [fp, #-8]
1000518c:	e3a02000 	mov	r2, #0
10005190:	e5c32000 	strb	r2, [r3]
        do
        {
            if ((*d++ = *s++) == 0)
            {
                /* NUL pad the remaining n-1 bytes */
                while (--n != 0)
10005194:	e51b3018 	ldr	r3, [fp, #-24]
10005198:	e2433001 	sub	r3, r3, #1
1000519c:	e50b3018 	str	r3, [fp, #-24]
100051a0:	e51b3018 	ldr	r3, [fp, #-24]
100051a4:	e3530000 	cmp	r3, #0
100051a8:	1afffff4 	bne	10005180 <rt_strncpy+0x64>
                    *d++ = 0;
                break;
100051ac:	ea000005 	b	100051c8 <rt_strncpy+0xac>
            }
        } while (--n != 0);
100051b0:	e51b3018 	ldr	r3, [fp, #-24]
100051b4:	e2433001 	sub	r3, r3, #1
100051b8:	e50b3018 	str	r3, [fp, #-24]
100051bc:	e51b3018 	ldr	r3, [fp, #-24]
100051c0:	e3530000 	cmp	r3, #0
100051c4:	1affffe1 	bne	10005150 <rt_strncpy+0x34>
    }

    return (dst);
100051c8:	e51b3010 	ldr	r3, [fp, #-16]
}
100051cc:	e1a00003 	mov	r0, r3
100051d0:	e24bd000 	sub	sp, fp, #0
100051d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100051d8:	e12fff1e 	bx	lr

100051dc <rt_strncmp>:
 * @param count the maximum compare length
 *
 * @return the result
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
100051dc:	e92d0810 	push	{r4, fp}
100051e0:	e28db004 	add	fp, sp, #4
100051e4:	e24dd010 	sub	sp, sp, #16
100051e8:	e50b0008 	str	r0, [fp, #-8]
100051ec:	e50b100c 	str	r1, [fp, #-12]
100051f0:	e50b2010 	str	r2, [fp, #-16]
    register signed char __res = 0;
100051f4:	e3a04000 	mov	r4, #0

    while (count)
100051f8:	ea000013 	b	1000524c <rt_strncmp+0x70>
    {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
100051fc:	e51b3008 	ldr	r3, [fp, #-8]
10005200:	e5d32000 	ldrb	r2, [r3]
10005204:	e51b300c 	ldr	r3, [fp, #-12]
10005208:	e2831001 	add	r1, r3, #1
1000520c:	e50b100c 	str	r1, [fp, #-12]
10005210:	e5d33000 	ldrb	r3, [r3]
10005214:	e0633002 	rsb	r3, r3, r2
10005218:	e6ef3073 	uxtb	r3, r3
1000521c:	e6ef4073 	uxtb	r4, r3
10005220:	e3540000 	cmp	r4, #0
10005224:	1a00000b 	bne	10005258 <rt_strncmp+0x7c>
10005228:	e51b3008 	ldr	r3, [fp, #-8]
1000522c:	e2832001 	add	r2, r3, #1
10005230:	e50b2008 	str	r2, [fp, #-8]
10005234:	e5d33000 	ldrb	r3, [r3]
10005238:	e3530000 	cmp	r3, #0
1000523c:	0a000005 	beq	10005258 <rt_strncmp+0x7c>
            break;
        count --;
10005240:	e51b3010 	ldr	r3, [fp, #-16]
10005244:	e2433001 	sub	r3, r3, #1
10005248:	e50b3010 	str	r3, [fp, #-16]
 */
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
{
    register signed char __res = 0;

    while (count)
1000524c:	e51b3010 	ldr	r3, [fp, #-16]
10005250:	e3530000 	cmp	r3, #0
10005254:	1affffe8 	bne	100051fc <rt_strncmp+0x20>
        if ((__res = *cs - *ct++) != 0 || !*cs++)
            break;
        count --;
    }

    return __res;
10005258:	e6af3074 	sxtb	r3, r4
}
1000525c:	e1a00003 	mov	r0, r3
10005260:	e24bd004 	sub	sp, fp, #4
10005264:	e8bd0810 	pop	{r4, fp}
10005268:	e12fff1e 	bx	lr

1000526c <rt_strcmp>:
 * @param ct the string to be compared
 *
 * @return the result
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
1000526c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005270:	e28db000 	add	fp, sp, #0
10005274:	e24dd00c 	sub	sp, sp, #12
10005278:	e50b0008 	str	r0, [fp, #-8]
1000527c:	e50b100c 	str	r1, [fp, #-12]
    while (*cs && *cs == *ct)
10005280:	ea000005 	b	1000529c <rt_strcmp+0x30>
        cs++, ct++;
10005284:	e51b3008 	ldr	r3, [fp, #-8]
10005288:	e2833001 	add	r3, r3, #1
1000528c:	e50b3008 	str	r3, [fp, #-8]
10005290:	e51b300c 	ldr	r3, [fp, #-12]
10005294:	e2833001 	add	r3, r3, #1
10005298:	e50b300c 	str	r3, [fp, #-12]
 *
 * @return the result
 */
rt_int32_t rt_strcmp(const char *cs, const char *ct)
{
    while (*cs && *cs == *ct)
1000529c:	e51b3008 	ldr	r3, [fp, #-8]
100052a0:	e5d33000 	ldrb	r3, [r3]
100052a4:	e3530000 	cmp	r3, #0
100052a8:	0a000005 	beq	100052c4 <rt_strcmp+0x58>
100052ac:	e51b3008 	ldr	r3, [fp, #-8]
100052b0:	e5d32000 	ldrb	r2, [r3]
100052b4:	e51b300c 	ldr	r3, [fp, #-12]
100052b8:	e5d33000 	ldrb	r3, [r3]
100052bc:	e1520003 	cmp	r2, r3
100052c0:	0affffef 	beq	10005284 <rt_strcmp+0x18>
        cs++, ct++;

    return (*cs - *ct);
100052c4:	e51b3008 	ldr	r3, [fp, #-8]
100052c8:	e5d33000 	ldrb	r3, [r3]
100052cc:	e1a02003 	mov	r2, r3
100052d0:	e51b300c 	ldr	r3, [fp, #-12]
100052d4:	e5d33000 	ldrb	r3, [r3]
100052d8:	e0633002 	rsb	r3, r3, r2
}
100052dc:	e1a00003 	mov	r0, r3
100052e0:	e24bd000 	sub	sp, fp, #0
100052e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100052e8:	e12fff1e 	bx	lr

100052ec <rt_strlen>:
 * @param s the string
 *
 * @return the length of string
 */
rt_size_t rt_strlen(const char *s)
{
100052ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100052f0:	e28db000 	add	fp, sp, #0
100052f4:	e24dd014 	sub	sp, sp, #20
100052f8:	e50b0010 	str	r0, [fp, #-16]
    const char *sc;

    for (sc = s; *sc != '\0'; ++sc) /* nothing */
100052fc:	e51b3010 	ldr	r3, [fp, #-16]
10005300:	e50b3008 	str	r3, [fp, #-8]
10005304:	ea000002 	b	10005314 <rt_strlen+0x28>
10005308:	e51b3008 	ldr	r3, [fp, #-8]
1000530c:	e2833001 	add	r3, r3, #1
10005310:	e50b3008 	str	r3, [fp, #-8]
10005314:	e51b3008 	ldr	r3, [fp, #-8]
10005318:	e5d33000 	ldrb	r3, [r3]
1000531c:	e3530000 	cmp	r3, #0
10005320:	1afffff8 	bne	10005308 <rt_strlen+0x1c>
        ;

    return sc - s;
10005324:	e51b2008 	ldr	r2, [fp, #-8]
10005328:	e51b3010 	ldr	r3, [fp, #-16]
1000532c:	e0633002 	rsb	r3, r3, r2
}
10005330:	e1a00003 	mov	r0, r3
10005334:	e24bd000 	sub	sp, fp, #0
10005338:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000533c:	e12fff1e 	bx	lr

10005340 <rt_strdup>:
 * @param s the string to be duplicated
 *
 * @return the duplicated string pointer
 */
char *rt_strdup(const char *s)
{
10005340:	e92d4800 	push	{fp, lr}
10005344:	e28db004 	add	fp, sp, #4
10005348:	e24dd010 	sub	sp, sp, #16
1000534c:	e50b0010 	str	r0, [fp, #-16]
    rt_size_t len = rt_strlen(s) + 1;
10005350:	e51b0010 	ldr	r0, [fp, #-16]
10005354:	ebffffe4 	bl	100052ec <rt_strlen>
10005358:	e1a03000 	mov	r3, r0
1000535c:	e2833001 	add	r3, r3, #1
10005360:	e50b3008 	str	r3, [fp, #-8]
    char *tmp = (char *)rt_malloc(len);
10005364:	e51b0008 	ldr	r0, [fp, #-8]
10005368:	eb0005ce 	bl	10006aa8 <rt_malloc>
1000536c:	e50b000c 	str	r0, [fp, #-12]

    if (!tmp)
10005370:	e51b300c 	ldr	r3, [fp, #-12]
10005374:	e3530000 	cmp	r3, #0
10005378:	1a000001 	bne	10005384 <rt_strdup+0x44>
        return RT_NULL;
1000537c:	e3a03000 	mov	r3, #0
10005380:	ea000004 	b	10005398 <rt_strdup+0x58>

    rt_memcpy(tmp, s, len);
10005384:	e51b000c 	ldr	r0, [fp, #-12]
10005388:	e51b1010 	ldr	r1, [fp, #-16]
1000538c:	e51b2008 	ldr	r2, [fp, #-8]
10005390:	ebfffe38 	bl	10004c78 <rt_memcpy>

    return tmp;
10005394:	e51b300c 	ldr	r3, [fp, #-12]
}
10005398:	e1a00003 	mov	r0, r3
1000539c:	e24bd004 	sub	sp, fp, #4
100053a0:	e8bd8800 	pop	{fp, pc}

100053a4 <rt_show_version>:

/**
 * This function will show the version of rt-thread rtos
 */
void rt_show_version(void)
{
100053a4:	e92d4800 	push	{fp, lr}
100053a8:	e28db004 	add	fp, sp, #4
100053ac:	e24dd008 	sub	sp, sp, #8
    rt_kprintf("\n \\ | /\n");
100053b0:	e30e063c 	movw	r0, #58940	; 0xe63c
100053b4:	e3410001 	movt	r0, #4097	; 0x1001
100053b8:	eb0003c5 	bl	100062d4 <rt_kprintf>
    rt_kprintf("- RT -     Thread Operating System\n");
100053bc:	e30e0648 	movw	r0, #58952	; 0xe648
100053c0:	e3410001 	movt	r0, #4097	; 0x1001
100053c4:	eb0003c2 	bl	100062d4 <rt_kprintf>
    rt_kprintf(" / | \\     %d.%d.%d build %s\n",
100053c8:	e30e368c 	movw	r3, #59020	; 0xe68c
100053cc:	e3413001 	movt	r3, #4097	; 0x1001
100053d0:	e58d3000 	str	r3, [sp]
100053d4:	e30e066c 	movw	r0, #58988	; 0xe66c
100053d8:	e3410001 	movt	r0, #4097	; 0x1001
100053dc:	e3a01002 	mov	r1, #2
100053e0:	e3a02001 	mov	r2, #1
100053e4:	e3a03000 	mov	r3, #0
100053e8:	eb0003b9 	bl	100062d4 <rt_kprintf>
               RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
    rt_kprintf(" 2006 - 2015 Copyright by rt-thread team\n");
100053ec:	e30e0698 	movw	r0, #59032	; 0xe698
100053f0:	e3410001 	movt	r0, #4097	; 0x1001
100053f4:	eb0003b6 	bl	100062d4 <rt_kprintf>
}
100053f8:	e24bd004 	sub	sp, fp, #4
100053fc:	e8bd8800 	pop	{fp, pc}

10005400 <divide>:

/* private function */
#define isdigit(c)  ((unsigned)((c) - '0') < 10)

rt_inline rt_int32_t divide(rt_int32_t *n, rt_int32_t base)
{
10005400:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10005404:	e28db000 	add	fp, sp, #0
10005408:	e24dd014 	sub	sp, sp, #20
1000540c:	e50b0010 	str	r0, [fp, #-16]
10005410:	e50b1014 	str	r1, [fp, #-20]
    rt_int32_t res;

    /* optimized for processor which does not support divide instructions. */
    if (base == 10)
10005414:	e51b3014 	ldr	r3, [fp, #-20]
10005418:	e353000a 	cmp	r3, #10
1000541c:	1a000016 	bne	1000547c <divide+0x7c>
    {
        res = ((rt_uint32_t)*n) % 10U;
10005420:	e51b3010 	ldr	r3, [fp, #-16]
10005424:	e5933000 	ldr	r3, [r3]
10005428:	e1a01003 	mov	r1, r3
1000542c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10005430:	e34c3ccc 	movt	r3, #52428	; 0xcccc
10005434:	e0832391 	umull	r2, r3, r1, r3
10005438:	e1a031a3 	lsr	r3, r3, #3
1000543c:	e1a03083 	lsl	r3, r3, #1
10005440:	e1a02103 	lsl	r2, r3, #2
10005444:	e0833002 	add	r3, r3, r2
10005448:	e0633001 	rsb	r3, r3, r1
1000544c:	e50b3008 	str	r3, [fp, #-8]
        *n = ((rt_uint32_t)*n) / 10U;
10005450:	e51b3010 	ldr	r3, [fp, #-16]
10005454:	e5933000 	ldr	r3, [r3]
10005458:	e1a02003 	mov	r2, r3
1000545c:	e30c3ccd 	movw	r3, #52429	; 0xcccd
10005460:	e34c3ccc 	movt	r3, #52428	; 0xcccc
10005464:	e0832392 	umull	r2, r3, r2, r3
10005468:	e1a031a3 	lsr	r3, r3, #3
1000546c:	e1a02003 	mov	r2, r3
10005470:	e51b3010 	ldr	r3, [fp, #-16]
10005474:	e5832000 	str	r2, [r3]
10005478:	ea000009 	b	100054a4 <divide+0xa4>
    }
    else
    {
        res = ((rt_uint32_t)*n) % 16U;
1000547c:	e51b3010 	ldr	r3, [fp, #-16]
10005480:	e5933000 	ldr	r3, [r3]
10005484:	e203300f 	and	r3, r3, #15
10005488:	e50b3008 	str	r3, [fp, #-8]
        *n = ((rt_uint32_t)*n) / 16U;
1000548c:	e51b3010 	ldr	r3, [fp, #-16]
10005490:	e5933000 	ldr	r3, [r3]
10005494:	e1a03223 	lsr	r3, r3, #4
10005498:	e1a02003 	mov	r2, r3
1000549c:	e51b3010 	ldr	r3, [fp, #-16]
100054a0:	e5832000 	str	r2, [r3]
    }

    return res;
100054a4:	e51b3008 	ldr	r3, [fp, #-8]
}
100054a8:	e1a00003 	mov	r0, r3
100054ac:	e24bd000 	sub	sp, fp, #0
100054b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100054b4:	e12fff1e 	bx	lr

100054b8 <skip_atoi>:

rt_inline int skip_atoi(const char **s)
{
100054b8:	e92d0810 	push	{r4, fp}
100054bc:	e28db004 	add	fp, sp, #4
100054c0:	e24dd008 	sub	sp, sp, #8
100054c4:	e50b0008 	str	r0, [fp, #-8]
    register int i=0;
100054c8:	e3a04000 	mov	r4, #0
    while (isdigit(**s))
100054cc:	ea00000b 	b	10005500 <skip_atoi+0x48>
        i = i * 10 + *((*s)++) - '0';
100054d0:	e1a03004 	mov	r3, r4
100054d4:	e1a03083 	lsl	r3, r3, #1
100054d8:	e1a02103 	lsl	r2, r3, #2
100054dc:	e0832002 	add	r2, r3, r2
100054e0:	e51b3008 	ldr	r3, [fp, #-8]
100054e4:	e5933000 	ldr	r3, [r3]
100054e8:	e2830001 	add	r0, r3, #1
100054ec:	e51b1008 	ldr	r1, [fp, #-8]
100054f0:	e5810000 	str	r0, [r1]
100054f4:	e5d33000 	ldrb	r3, [r3]
100054f8:	e0823003 	add	r3, r2, r3
100054fc:	e2434030 	sub	r4, r3, #48	; 0x30
}

rt_inline int skip_atoi(const char **s)
{
    register int i=0;
    while (isdigit(**s))
10005500:	e51b3008 	ldr	r3, [fp, #-8]
10005504:	e5933000 	ldr	r3, [r3]
10005508:	e5d33000 	ldrb	r3, [r3]
1000550c:	e2433030 	sub	r3, r3, #48	; 0x30
10005510:	e3530009 	cmp	r3, #9
10005514:	9affffed 	bls	100054d0 <skip_atoi+0x18>
        i = i * 10 + *((*s)++) - '0';

    return i;
10005518:	e1a03004 	mov	r3, r4
}
1000551c:	e1a00003 	mov	r0, r3
10005520:	e24bd004 	sub	sp, fp, #4
10005524:	e8bd0810 	pop	{r4, fp}
10005528:	e12fff1e 	bx	lr

1000552c <print_number>:
                          long  num,
                          int   base,
                          int   s,
                          int   type)
#endif
{
1000552c:	e92d4870 	push	{r4, r5, r6, fp, lr}
10005530:	e28db010 	add	fp, sp, #16
10005534:	e24dd034 	sub	sp, sp, #52	; 0x34
10005538:	e50b0038 	str	r0, [fp, #-56]	; 0x38
1000553c:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
10005540:	e50b2040 	str	r2, [fp, #-64]	; 0x40
10005544:	e50b3044 	str	r3, [fp, #-68]	; 0x44
    static const char small_digits[] = "0123456789abcdef";
    static const char large_digits[] = "0123456789ABCDEF";
    register int i;
    register int size;

    size = s;
10005548:	e59b4004 	ldr	r4, [fp, #4]

    digits = (type & LARGE) ? large_digits : small_digits;
1000554c:	e59b300c 	ldr	r3, [fp, #12]
10005550:	e2033040 	and	r3, r3, #64	; 0x40
10005554:	e3530000 	cmp	r3, #0
10005558:	0a000002 	beq	10005568 <print_number+0x3c>
1000555c:	e30e3804 	movw	r3, #59396	; 0xe804
10005560:	e3413001 	movt	r3, #4097	; 0x1001
10005564:	ea000001 	b	10005570 <print_number+0x44>
10005568:	e30e3818 	movw	r3, #59416	; 0xe818
1000556c:	e3413001 	movt	r3, #4097	; 0x1001
10005570:	e50b301c 	str	r3, [fp, #-28]
    if (type & LEFT)
10005574:	e59b300c 	ldr	r3, [fp, #12]
10005578:	e2033010 	and	r3, r3, #16
1000557c:	e3530000 	cmp	r3, #0
10005580:	0a000002 	beq	10005590 <print_number+0x64>
        type &= ~ZEROPAD;
10005584:	e59b300c 	ldr	r3, [fp, #12]
10005588:	e3c33001 	bic	r3, r3, #1
1000558c:	e58b300c 	str	r3, [fp, #12]

    c = (type & ZEROPAD) ? '0' : ' ';
10005590:	e59b300c 	ldr	r3, [fp, #12]
10005594:	e2033001 	and	r3, r3, #1
10005598:	e3530000 	cmp	r3, #0
1000559c:	0a000001 	beq	100055a8 <print_number+0x7c>
100055a0:	e3a03030 	mov	r3, #48	; 0x30
100055a4:	ea000000 	b	100055ac <print_number+0x80>
100055a8:	e3a03020 	mov	r3, #32
100055ac:	e54b301d 	strb	r3, [fp, #-29]

    /* get sign */
    sign = 0;
100055b0:	e3a03000 	mov	r3, #0
100055b4:	e54b3015 	strb	r3, [fp, #-21]
    if (type & SIGN)
100055b8:	e59b300c 	ldr	r3, [fp, #12]
100055bc:	e2033002 	and	r3, r3, #2
100055c0:	e3530000 	cmp	r3, #0
100055c4:	0a000015 	beq	10005620 <print_number+0xf4>
    {
        if (num < 0)
100055c8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100055cc:	e3530000 	cmp	r3, #0
100055d0:	aa000005 	bge	100055ec <print_number+0xc0>
        {
            sign = '-';
100055d4:	e3a0302d 	mov	r3, #45	; 0x2d
100055d8:	e54b3015 	strb	r3, [fp, #-21]
            num = -num;
100055dc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
100055e0:	e2633000 	rsb	r3, r3, #0
100055e4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
100055e8:	ea00000c 	b	10005620 <print_number+0xf4>
        }
        else if (type & PLUS)
100055ec:	e59b300c 	ldr	r3, [fp, #12]
100055f0:	e2033004 	and	r3, r3, #4
100055f4:	e3530000 	cmp	r3, #0
100055f8:	0a000002 	beq	10005608 <print_number+0xdc>
            sign = '+';
100055fc:	e3a0302b 	mov	r3, #43	; 0x2b
10005600:	e54b3015 	strb	r3, [fp, #-21]
10005604:	ea000005 	b	10005620 <print_number+0xf4>
        else if (type & SPACE)
10005608:	e59b300c 	ldr	r3, [fp, #12]
1000560c:	e2033008 	and	r3, r3, #8
10005610:	e3530000 	cmp	r3, #0
10005614:	0a000001 	beq	10005620 <print_number+0xf4>
            sign = ' ';
10005618:	e3a03020 	mov	r3, #32
1000561c:	e54b3015 	strb	r3, [fp, #-21]
        else if (base == 8)
            size--;
    }
#endif

    i = 0;
10005620:	e3a05000 	mov	r5, #0
    if (num == 0)
10005624:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10005628:	e3530000 	cmp	r3, #0
1000562c:	1a000006 	bne	1000564c <print_number+0x120>
        tmp[i++]='0';
10005630:	e1a03005 	mov	r3, r5
10005634:	e2835001 	add	r5, r3, #1
10005638:	e24b2014 	sub	r2, fp, #20
1000563c:	e0823003 	add	r3, r2, r3
10005640:	e3a02030 	mov	r2, #48	; 0x30
10005644:	e543201c 	strb	r2, [r3, #-28]
10005648:	ea000011 	b	10005694 <print_number+0x168>
    else
    {
        while (num != 0)
1000564c:	ea00000d 	b	10005688 <print_number+0x15c>
            tmp[i++] = digits[divide(&num, base)];
10005650:	e1a06005 	mov	r6, r5
10005654:	e2865001 	add	r5, r6, #1
10005658:	e24b3040 	sub	r3, fp, #64	; 0x40
1000565c:	e1a00003 	mov	r0, r3
10005660:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
10005664:	ebffff65 	bl	10005400 <divide>
10005668:	e1a03000 	mov	r3, r0
1000566c:	e1a02003 	mov	r2, r3
10005670:	e51b301c 	ldr	r3, [fp, #-28]
10005674:	e0833002 	add	r3, r3, r2
10005678:	e5d32000 	ldrb	r2, [r3]
1000567c:	e24b3014 	sub	r3, fp, #20
10005680:	e0833006 	add	r3, r3, r6
10005684:	e543201c 	strb	r2, [r3, #-28]
    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else
    {
        while (num != 0)
10005688:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1000568c:	e3530000 	cmp	r3, #0
10005690:	1affffee 	bne	10005650 <print_number+0x124>
            tmp[i++] = digits[divide(&num, base)];
    }

#ifdef RT_PRINTF_PRECISION
    if (i > precision)
10005694:	e59b3008 	ldr	r3, [fp, #8]
10005698:	e1550003 	cmp	r5, r3
1000569c:	da000000 	ble	100056a4 <print_number+0x178>
        precision = i;
100056a0:	e58b5008 	str	r5, [fp, #8]
    size -= precision;
100056a4:	e59b3008 	ldr	r3, [fp, #8]
100056a8:	e0634004 	rsb	r4, r3, r4
#else
    size -= i;
#endif

    if (!(type&(ZEROPAD | LEFT)))
100056ac:	e59b300c 	ldr	r3, [fp, #12]
100056b0:	e2033011 	and	r3, r3, #17
100056b4:	e3530000 	cmp	r3, #0
100056b8:	1a000014 	bne	10005710 <print_number+0x1e4>
    {
        if ((sign)&&(size>0))
100056bc:	e55b3015 	ldrb	r3, [fp, #-21]
100056c0:	e3530000 	cmp	r3, #0
100056c4:	0a000002 	beq	100056d4 <print_number+0x1a8>
100056c8:	e3540000 	cmp	r4, #0
100056cc:	da000000 	ble	100056d4 <print_number+0x1a8>
            size--;
100056d0:	e2444001 	sub	r4, r4, #1

        while (size-->0)
100056d4:	ea000009 	b	10005700 <print_number+0x1d4>
        {
            if (buf <= end)
100056d8:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
100056dc:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
100056e0:	e1520003 	cmp	r2, r3
100056e4:	8a000002 	bhi	100056f4 <print_number+0x1c8>
                *buf = ' ';
100056e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100056ec:	e3a02020 	mov	r2, #32
100056f0:	e5c32000 	strb	r2, [r3]
            ++ buf;
100056f4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100056f8:	e2833001 	add	r3, r3, #1
100056fc:	e50b3038 	str	r3, [fp, #-56]	; 0x38
    if (!(type&(ZEROPAD | LEFT)))
    {
        if ((sign)&&(size>0))
            size--;

        while (size-->0)
10005700:	e1a03004 	mov	r3, r4
10005704:	e2434001 	sub	r4, r3, #1
10005708:	e3530000 	cmp	r3, #0
1000570c:	cafffff1 	bgt	100056d8 <print_number+0x1ac>
                *buf = ' ';
            ++ buf;
        }
    }

    if (sign)
10005710:	e55b3015 	ldrb	r3, [fp, #-21]
10005714:	e3530000 	cmp	r3, #0
10005718:	0a00000a 	beq	10005748 <print_number+0x21c>
    {
        if (buf <= end)
1000571c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
10005720:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005724:	e1520003 	cmp	r2, r3
10005728:	8a000003 	bhi	1000573c <print_number+0x210>
        {
            *buf = sign;
1000572c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005730:	e55b2015 	ldrb	r2, [fp, #-21]
10005734:	e5c32000 	strb	r2, [r3]
            -- size;
10005738:	e2444001 	sub	r4, r4, #1
        }
        ++ buf;
1000573c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005740:	e2833001 	add	r3, r3, #1
10005744:	e50b3038 	str	r3, [fp, #-56]	; 0x38
        }
    }
#endif

    /* no align to the left */
    if (!(type & LEFT))
10005748:	e59b300c 	ldr	r3, [fp, #12]
1000574c:	e2033010 	and	r3, r3, #16
10005750:	e3530000 	cmp	r3, #0
10005754:	1a00000e 	bne	10005794 <print_number+0x268>
    {
        while (size-- > 0)
10005758:	ea000009 	b	10005784 <print_number+0x258>
        {
            if (buf <= end)
1000575c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
10005760:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005764:	e1520003 	cmp	r2, r3
10005768:	8a000002 	bhi	10005778 <print_number+0x24c>
                *buf = c;
1000576c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005770:	e55b201d 	ldrb	r2, [fp, #-29]
10005774:	e5c32000 	strb	r2, [r3]
            ++ buf;
10005778:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1000577c:	e2833001 	add	r3, r3, #1
10005780:	e50b3038 	str	r3, [fp, #-56]	; 0x38
#endif

    /* no align to the left */
    if (!(type & LEFT))
    {
        while (size-- > 0)
10005784:	e1a03004 	mov	r3, r4
10005788:	e2434001 	sub	r4, r3, #1
1000578c:	e3530000 	cmp	r3, #0
10005790:	cafffff1 	bgt	1000575c <print_number+0x230>
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
10005794:	ea000009 	b	100057c0 <print_number+0x294>
    {
        if (buf <= end)
10005798:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
1000579c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
100057a0:	e1520003 	cmp	r2, r3
100057a4:	8a000002 	bhi	100057b4 <print_number+0x288>
            *buf = '0';
100057a8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100057ac:	e3a02030 	mov	r2, #48	; 0x30
100057b0:	e5c32000 	strb	r2, [r3]
        ++ buf;
100057b4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100057b8:	e2833001 	add	r3, r3, #1
100057bc:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            ++ buf;
        }
    }

#ifdef RT_PRINTF_PRECISION
    while (i < precision--)
100057c0:	e59b3008 	ldr	r3, [fp, #8]
100057c4:	e2432001 	sub	r2, r3, #1
100057c8:	e58b2008 	str	r2, [fp, #8]
100057cc:	e1530005 	cmp	r3, r5
100057d0:	cafffff0 	bgt	10005798 <print_number+0x26c>
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
100057d4:	ea00000b 	b	10005808 <print_number+0x2dc>
    {
        if (buf <= end)
100057d8:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
100057dc:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
100057e0:	e1520003 	cmp	r2, r3
100057e4:	8a000004 	bhi	100057fc <print_number+0x2d0>
            *buf = tmp[i];
100057e8:	e24b3014 	sub	r3, fp, #20
100057ec:	e0833005 	add	r3, r3, r5
100057f0:	e553201c 	ldrb	r2, [r3, #-28]
100057f4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100057f8:	e5c32000 	strb	r2, [r3]
        ++ buf;
100057fc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005800:	e2833001 	add	r3, r3, #1
10005804:	e50b3038 	str	r3, [fp, #-56]	; 0x38
        ++ buf;
    }
#endif

    /* put number in the temporary buffer */
    while (i-- > 0)
10005808:	e1a03005 	mov	r3, r5
1000580c:	e2435001 	sub	r5, r3, #1
10005810:	e3530000 	cmp	r3, #0
10005814:	caffffef 	bgt	100057d8 <print_number+0x2ac>
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
10005818:	ea000009 	b	10005844 <print_number+0x318>
    {
        if (buf <= end)
1000581c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
10005820:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005824:	e1520003 	cmp	r2, r3
10005828:	8a000002 	bhi	10005838 <print_number+0x30c>
            *buf = ' ';
1000582c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005830:	e3a02020 	mov	r2, #32
10005834:	e5c32000 	strb	r2, [r3]
        ++ buf;
10005838:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1000583c:	e2833001 	add	r3, r3, #1
10005840:	e50b3038 	str	r3, [fp, #-56]	; 0x38
        if (buf <= end)
            *buf = tmp[i];
        ++ buf;
    }

    while (size-- > 0)
10005844:	e1a03004 	mov	r3, r4
10005848:	e2434001 	sub	r4, r3, #1
1000584c:	e3530000 	cmp	r3, #0
10005850:	cafffff1 	bgt	1000581c <print_number+0x2f0>
        if (buf <= end)
            *buf = ' ';
        ++ buf;
    }

    return buf;
10005854:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
}
10005858:	e1a00003 	mov	r0, r3
1000585c:	e24bd010 	sub	sp, fp, #16
10005860:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

10005864 <rt_vsnprintf>:

rt_int32_t rt_vsnprintf(char       *buf,
                        rt_size_t   size,
                        const char *fmt,
                        va_list     args)
{
10005864:	e92d4800 	push	{fp, lr}
10005868:	e28db004 	add	fp, sp, #4
1000586c:	e24dd048 	sub	sp, sp, #72	; 0x48
10005870:	e50b0030 	str	r0, [fp, #-48]	; 0x30
10005874:	e50b1034 	str	r1, [fp, #-52]	; 0x34
10005878:	e50b2038 	str	r2, [fp, #-56]	; 0x38
1000587c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c

#ifdef RT_PRINTF_PRECISION
    int precision;      /* min. # of digits for integers and max for a string */
#endif

    str = buf;
10005880:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10005884:	e50b3014 	str	r3, [fp, #-20]
    end = buf + size - 1;
10005888:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1000588c:	e2433001 	sub	r3, r3, #1
10005890:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
10005894:	e0823003 	add	r3, r2, r3
10005898:	e50b3018 	str	r3, [fp, #-24]

    /* Make sure end is always >= buf */
    if (end < buf)
1000589c:	e51b2018 	ldr	r2, [fp, #-24]
100058a0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100058a4:	e1520003 	cmp	r2, r3
100058a8:	2a000005 	bcs	100058c4 <rt_vsnprintf+0x60>
    {
        end  = ((char *)-1);
100058ac:	e3e03000 	mvn	r3, #0
100058b0:	e50b3018 	str	r3, [fp, #-24]
        size = end - buf;
100058b4:	e51b2018 	ldr	r2, [fp, #-24]
100058b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
100058bc:	e0633002 	rsb	r3, r3, r2
100058c0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
    }

    for (; *fmt ; ++fmt)
100058c4:	ea000205 	b	100060e0 <rt_vsnprintf+0x87c>
    {
        if (*fmt != '%')
100058c8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100058cc:	e5d33000 	ldrb	r3, [r3]
100058d0:	e3530025 	cmp	r3, #37	; 0x25
100058d4:	0a00000b 	beq	10005908 <rt_vsnprintf+0xa4>
        {
            if (str <= end)
100058d8:	e51b2014 	ldr	r2, [fp, #-20]
100058dc:	e51b3018 	ldr	r3, [fp, #-24]
100058e0:	e1520003 	cmp	r2, r3
100058e4:	8a000003 	bhi	100058f8 <rt_vsnprintf+0x94>
                *str = *fmt;
100058e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100058ec:	e5d32000 	ldrb	r2, [r3]
100058f0:	e51b3014 	ldr	r3, [fp, #-20]
100058f4:	e5c32000 	strb	r2, [r3]
            ++ str;
100058f8:	e51b3014 	ldr	r3, [fp, #-20]
100058fc:	e2833001 	add	r3, r3, #1
10005900:	e50b3014 	str	r3, [fp, #-20]
            continue;
10005904:	ea0001f2 	b	100060d4 <rt_vsnprintf+0x870>
        }

        /* process flags */
        flags = 0;
10005908:	e3a03000 	mov	r3, #0
1000590c:	e54b301e 	strb	r3, [fp, #-30]

        while (1)
        {
            /* skips the first '%' also */
            ++ fmt;
10005910:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005914:	e2833001 	add	r3, r3, #1
10005918:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            if (*fmt == '-') flags |= LEFT;
1000591c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005920:	e5d33000 	ldrb	r3, [r3]
10005924:	e353002d 	cmp	r3, #45	; 0x2d
10005928:	1a000003 	bne	1000593c <rt_vsnprintf+0xd8>
1000592c:	e55b301e 	ldrb	r3, [fp, #-30]
10005930:	e3833010 	orr	r3, r3, #16
10005934:	e54b301e 	strb	r3, [fp, #-30]
10005938:	ea000028 	b	100059e0 <rt_vsnprintf+0x17c>
            else if (*fmt == '+') flags |= PLUS;
1000593c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005940:	e5d33000 	ldrb	r3, [r3]
10005944:	e353002b 	cmp	r3, #43	; 0x2b
10005948:	1a000003 	bne	1000595c <rt_vsnprintf+0xf8>
1000594c:	e55b301e 	ldrb	r3, [fp, #-30]
10005950:	e3833004 	orr	r3, r3, #4
10005954:	e54b301e 	strb	r3, [fp, #-30]
10005958:	ea000020 	b	100059e0 <rt_vsnprintf+0x17c>
            else if (*fmt == ' ') flags |= SPACE;
1000595c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005960:	e5d33000 	ldrb	r3, [r3]
10005964:	e3530020 	cmp	r3, #32
10005968:	1a000003 	bne	1000597c <rt_vsnprintf+0x118>
1000596c:	e55b301e 	ldrb	r3, [fp, #-30]
10005970:	e3833008 	orr	r3, r3, #8
10005974:	e54b301e 	strb	r3, [fp, #-30]
10005978:	ea000018 	b	100059e0 <rt_vsnprintf+0x17c>
            else if (*fmt == '#') flags |= SPECIAL;
1000597c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005980:	e5d33000 	ldrb	r3, [r3]
10005984:	e3530023 	cmp	r3, #35	; 0x23
10005988:	1a000003 	bne	1000599c <rt_vsnprintf+0x138>
1000598c:	e55b301e 	ldrb	r3, [fp, #-30]
10005990:	e3833020 	orr	r3, r3, #32
10005994:	e54b301e 	strb	r3, [fp, #-30]
10005998:	ea000010 	b	100059e0 <rt_vsnprintf+0x17c>
            else if (*fmt == '0') flags |= ZEROPAD;
1000599c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100059a0:	e5d33000 	ldrb	r3, [r3]
100059a4:	e3530030 	cmp	r3, #48	; 0x30
100059a8:	1a000003 	bne	100059bc <rt_vsnprintf+0x158>
100059ac:	e55b301e 	ldrb	r3, [fp, #-30]
100059b0:	e3833001 	orr	r3, r3, #1
100059b4:	e54b301e 	strb	r3, [fp, #-30]
100059b8:	ea000008 	b	100059e0 <rt_vsnprintf+0x17c>
            else break;
100059bc:	e1a00000 	nop			; (mov r0, r0)
        }

        /* get field width */
        field_width = -1;
100059c0:	e3e03000 	mvn	r3, #0
100059c4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
100059c8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100059cc:	e5d33000 	ldrb	r3, [r3]
100059d0:	e2433030 	sub	r3, r3, #48	; 0x30
100059d4:	e3530009 	cmp	r3, #9
100059d8:	8a000006 	bhi	100059f8 <rt_vsnprintf+0x194>
100059dc:	ea000000 	b	100059e4 <rt_vsnprintf+0x180>
            else if (*fmt == '+') flags |= PLUS;
            else if (*fmt == ' ') flags |= SPACE;
            else if (*fmt == '#') flags |= SPECIAL;
            else if (*fmt == '0') flags |= ZEROPAD;
            else break;
        }
100059e0:	eaffffca 	b	10005910 <rt_vsnprintf+0xac>

        /* get field width */
        field_width = -1;
        if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
100059e4:	e24b3038 	sub	r3, fp, #56	; 0x38
100059e8:	e1a00003 	mov	r0, r3
100059ec:	ebfffeb1 	bl	100054b8 <skip_atoi>
100059f0:	e50b0024 	str	r0, [fp, #-36]	; 0x24
100059f4:	ea000014 	b	10005a4c <rt_vsnprintf+0x1e8>
        else if (*fmt == '*')
100059f8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100059fc:	e5d33000 	ldrb	r3, [r3]
10005a00:	e353002a 	cmp	r3, #42	; 0x2a
10005a04:	1a000010 	bne	10005a4c <rt_vsnprintf+0x1e8>
        {
            ++ fmt;
10005a08:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005a0c:	e2833001 	add	r3, r3, #1
10005a10:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            /* it's the next argument */
            field_width = va_arg(args, int);
10005a14:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005a18:	e2832004 	add	r2, r3, #4
10005a1c:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
10005a20:	e5933000 	ldr	r3, [r3]
10005a24:	e50b3024 	str	r3, [fp, #-36]	; 0x24
            if (field_width < 0)
10005a28:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005a2c:	e3530000 	cmp	r3, #0
10005a30:	aa000005 	bge	10005a4c <rt_vsnprintf+0x1e8>
            {
                field_width = -field_width;
10005a34:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005a38:	e2633000 	rsb	r3, r3, #0
10005a3c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
                flags |= LEFT;
10005a40:	e55b301e 	ldrb	r3, [fp, #-30]
10005a44:	e3833010 	orr	r3, r3, #16
10005a48:	e54b301e 	strb	r3, [fp, #-30]
            }
        }

#ifdef RT_PRINTF_PRECISION
        /* get the precision */
        precision = -1;
10005a4c:	e3e03000 	mvn	r3, #0
10005a50:	e50b3028 	str	r3, [fp, #-40]	; 0x28
        if (*fmt == '.')
10005a54:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005a58:	e5d33000 	ldrb	r3, [r3]
10005a5c:	e353002e 	cmp	r3, #46	; 0x2e
10005a60:	1a00001d 	bne	10005adc <rt_vsnprintf+0x278>
        {
            ++ fmt;
10005a64:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005a68:	e2833001 	add	r3, r3, #1
10005a6c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            if (isdigit(*fmt)) precision = skip_atoi(&fmt);
10005a70:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005a74:	e5d33000 	ldrb	r3, [r3]
10005a78:	e2433030 	sub	r3, r3, #48	; 0x30
10005a7c:	e3530009 	cmp	r3, #9
10005a80:	8a000004 	bhi	10005a98 <rt_vsnprintf+0x234>
10005a84:	e24b3038 	sub	r3, fp, #56	; 0x38
10005a88:	e1a00003 	mov	r0, r3
10005a8c:	ebfffe89 	bl	100054b8 <skip_atoi>
10005a90:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10005a94:	ea00000b 	b	10005ac8 <rt_vsnprintf+0x264>
            else if (*fmt == '*')
10005a98:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005a9c:	e5d33000 	ldrb	r3, [r3]
10005aa0:	e353002a 	cmp	r3, #42	; 0x2a
10005aa4:	1a000007 	bne	10005ac8 <rt_vsnprintf+0x264>
            {
                ++ fmt;
10005aa8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005aac:	e2833001 	add	r3, r3, #1
10005ab0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
                /* it's the next argument */
                precision = va_arg(args, int);
10005ab4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005ab8:	e2832004 	add	r2, r3, #4
10005abc:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
10005ac0:	e5933000 	ldr	r3, [r3]
10005ac4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
            }
            if (precision < 0) precision = 0;
10005ac8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10005acc:	e3530000 	cmp	r3, #0
10005ad0:	aa000001 	bge	10005adc <rt_vsnprintf+0x278>
10005ad4:	e3a03000 	mov	r3, #0
10005ad8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
        }
#endif
        /* get the conversion qualifier */
        qualifier = 0;
10005adc:	e3a03000 	mov	r3, #0
10005ae0:	e54b301f 	strb	r3, [fp, #-31]
#ifdef RT_PRINTF_LONGLONG
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
#else
        if (*fmt == 'h' || *fmt == 'l')
10005ae4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005ae8:	e5d33000 	ldrb	r3, [r3]
10005aec:	e3530068 	cmp	r3, #104	; 0x68
10005af0:	0a000003 	beq	10005b04 <rt_vsnprintf+0x2a0>
10005af4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005af8:	e5d33000 	ldrb	r3, [r3]
10005afc:	e353006c 	cmp	r3, #108	; 0x6c
10005b00:	1a000005 	bne	10005b1c <rt_vsnprintf+0x2b8>
#endif
        {
            qualifier = *fmt;
10005b04:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005b08:	e5d33000 	ldrb	r3, [r3]
10005b0c:	e54b301f 	strb	r3, [fp, #-31]
            ++ fmt;
10005b10:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005b14:	e2833001 	add	r3, r3, #1
10005b18:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            }
#endif
        }

        /* the default base */
        base = 10;
10005b1c:	e3a0300a 	mov	r3, #10
10005b20:	e54b301d 	strb	r3, [fp, #-29]

        switch (*fmt)
10005b24:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005b28:	e5d33000 	ldrb	r3, [r3]
10005b2c:	e2433025 	sub	r3, r3, #37	; 0x25
10005b30:	e3530053 	cmp	r3, #83	; 0x53
10005b34:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10005b38:	ea000112 	b	10005f88 <rt_vsnprintf+0x724>
10005b3c:	10005f28 	.word	0x10005f28
10005b40:	10005f88 	.word	0x10005f88
10005b44:	10005f88 	.word	0x10005f88
10005b48:	10005f88 	.word	0x10005f88
10005b4c:	10005f88 	.word	0x10005f88
10005b50:	10005f88 	.word	0x10005f88
10005b54:	10005f88 	.word	0x10005f88
10005b58:	10005f88 	.word	0x10005f88
10005b5c:	10005f88 	.word	0x10005f88
10005b60:	10005f88 	.word	0x10005f88
10005b64:	10005f88 	.word	0x10005f88
10005b68:	10005f88 	.word	0x10005f88
10005b6c:	10005f88 	.word	0x10005f88
10005b70:	10005f88 	.word	0x10005f88
10005b74:	10005f88 	.word	0x10005f88
10005b78:	10005f88 	.word	0x10005f88
10005b7c:	10005f88 	.word	0x10005f88
10005b80:	10005f88 	.word	0x10005f88
10005b84:	10005f88 	.word	0x10005f88
10005b88:	10005f88 	.word	0x10005f88
10005b8c:	10005f88 	.word	0x10005f88
10005b90:	10005f88 	.word	0x10005f88
10005b94:	10005f88 	.word	0x10005f88
10005b98:	10005f88 	.word	0x10005f88
10005b9c:	10005f88 	.word	0x10005f88
10005ba0:	10005f88 	.word	0x10005f88
10005ba4:	10005f88 	.word	0x10005f88
10005ba8:	10005f88 	.word	0x10005f88
10005bac:	10005f88 	.word	0x10005f88
10005bb0:	10005f88 	.word	0x10005f88
10005bb4:	10005f88 	.word	0x10005f88
10005bb8:	10005f88 	.word	0x10005f88
10005bbc:	10005f88 	.word	0x10005f88
10005bc0:	10005f88 	.word	0x10005f88
10005bc4:	10005f88 	.word	0x10005f88
10005bc8:	10005f88 	.word	0x10005f88
10005bcc:	10005f88 	.word	0x10005f88
10005bd0:	10005f88 	.word	0x10005f88
10005bd4:	10005f88 	.word	0x10005f88
10005bd8:	10005f88 	.word	0x10005f88
10005bdc:	10005f88 	.word	0x10005f88
10005be0:	10005f88 	.word	0x10005f88
10005be4:	10005f88 	.word	0x10005f88
10005be8:	10005f88 	.word	0x10005f88
10005bec:	10005f88 	.word	0x10005f88
10005bf0:	10005f88 	.word	0x10005f88
10005bf4:	10005f88 	.word	0x10005f88
10005bf8:	10005f88 	.word	0x10005f88
10005bfc:	10005f88 	.word	0x10005f88
10005c00:	10005f88 	.word	0x10005f88
10005c04:	10005f88 	.word	0x10005f88
10005c08:	10005f60 	.word	0x10005f60
10005c0c:	10005f88 	.word	0x10005f88
10005c10:	10005f88 	.word	0x10005f88
10005c14:	10005f88 	.word	0x10005f88
10005c18:	10005f88 	.word	0x10005f88
10005c1c:	10005f88 	.word	0x10005f88
10005c20:	10005f88 	.word	0x10005f88
10005c24:	10005f88 	.word	0x10005f88
10005c28:	10005f88 	.word	0x10005f88
10005c2c:	10005f88 	.word	0x10005f88
10005c30:	10005f88 	.word	0x10005f88
10005c34:	10005c8c 	.word	0x10005c8c
10005c38:	10005f78 	.word	0x10005f78
10005c3c:	10005f88 	.word	0x10005f88
10005c40:	10005f88 	.word	0x10005f88
10005c44:	10005f88 	.word	0x10005f88
10005c48:	10005f88 	.word	0x10005f88
10005c4c:	10005f78 	.word	0x10005f78
10005c50:	10005f88 	.word	0x10005f88
10005c54:	10005f88 	.word	0x10005f88
10005c58:	10005f88 	.word	0x10005f88
10005c5c:	10005f88 	.word	0x10005f88
10005c60:	10005f88 	.word	0x10005f88
10005c64:	10005f54 	.word	0x10005f54
10005c68:	10005ec0 	.word	0x10005ec0
10005c6c:	10005f88 	.word	0x10005f88
10005c70:	10005f88 	.word	0x10005f88
10005c74:	10005d64 	.word	0x10005d64
10005c78:	10005f88 	.word	0x10005f88
10005c7c:	10006000 	.word	0x10006000
10005c80:	10005f88 	.word	0x10005f88
10005c84:	10005f88 	.word	0x10005f88
10005c88:	10005f6c 	.word	0x10005f6c
        {
        case 'c':
            if (!(flags & LEFT))
10005c8c:	e55b301e 	ldrb	r3, [fp, #-30]
10005c90:	e2033010 	and	r3, r3, #16
10005c94:	e3530000 	cmp	r3, #0
10005c98:	1a000010 	bne	10005ce0 <rt_vsnprintf+0x47c>
            {
                while (--field_width > 0)
10005c9c:	ea000009 	b	10005cc8 <rt_vsnprintf+0x464>
                {
                    if (str <= end) *str = ' ';
10005ca0:	e51b2014 	ldr	r2, [fp, #-20]
10005ca4:	e51b3018 	ldr	r3, [fp, #-24]
10005ca8:	e1520003 	cmp	r2, r3
10005cac:	8a000002 	bhi	10005cbc <rt_vsnprintf+0x458>
10005cb0:	e51b3014 	ldr	r3, [fp, #-20]
10005cb4:	e3a02020 	mov	r2, #32
10005cb8:	e5c32000 	strb	r2, [r3]
                    ++ str;
10005cbc:	e51b3014 	ldr	r3, [fp, #-20]
10005cc0:	e2833001 	add	r3, r3, #1
10005cc4:	e50b3014 	str	r3, [fp, #-20]
        switch (*fmt)
        {
        case 'c':
            if (!(flags & LEFT))
            {
                while (--field_width > 0)
10005cc8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005ccc:	e2433001 	sub	r3, r3, #1
10005cd0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
10005cd4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005cd8:	e3530000 	cmp	r3, #0
10005cdc:	caffffef 	bgt	10005ca0 <rt_vsnprintf+0x43c>
                    ++ str;
                }
            }

            /* get character */
            c = (rt_uint8_t)va_arg(args, int);
10005ce0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005ce4:	e2832004 	add	r2, r3, #4
10005ce8:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
10005cec:	e5933000 	ldr	r3, [r3]
10005cf0:	e54b3029 	strb	r3, [fp, #-41]	; 0x29
            if (str <= end) *str = c;
10005cf4:	e51b2014 	ldr	r2, [fp, #-20]
10005cf8:	e51b3018 	ldr	r3, [fp, #-24]
10005cfc:	e1520003 	cmp	r2, r3
10005d00:	8a000002 	bhi	10005d10 <rt_vsnprintf+0x4ac>
10005d04:	e51b3014 	ldr	r3, [fp, #-20]
10005d08:	e55b2029 	ldrb	r2, [fp, #-41]	; 0x29
10005d0c:	e5c32000 	strb	r2, [r3]
            ++ str;
10005d10:	e51b3014 	ldr	r3, [fp, #-20]
10005d14:	e2833001 	add	r3, r3, #1
10005d18:	e50b3014 	str	r3, [fp, #-20]

            /* put width */
            while (--field_width > 0)
10005d1c:	ea000009 	b	10005d48 <rt_vsnprintf+0x4e4>
            {
                if (str <= end) *str = ' ';
10005d20:	e51b2014 	ldr	r2, [fp, #-20]
10005d24:	e51b3018 	ldr	r3, [fp, #-24]
10005d28:	e1520003 	cmp	r2, r3
10005d2c:	8a000002 	bhi	10005d3c <rt_vsnprintf+0x4d8>
10005d30:	e51b3014 	ldr	r3, [fp, #-20]
10005d34:	e3a02020 	mov	r2, #32
10005d38:	e5c32000 	strb	r2, [r3]
                ++ str;
10005d3c:	e51b3014 	ldr	r3, [fp, #-20]
10005d40:	e2833001 	add	r3, r3, #1
10005d44:	e50b3014 	str	r3, [fp, #-20]
            c = (rt_uint8_t)va_arg(args, int);
            if (str <= end) *str = c;
            ++ str;

            /* put width */
            while (--field_width > 0)
10005d48:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005d4c:	e2433001 	sub	r3, r3, #1
10005d50:	e50b3024 	str	r3, [fp, #-36]	; 0x24
10005d54:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005d58:	e3530000 	cmp	r3, #0
10005d5c:	caffffef 	bgt	10005d20 <rt_vsnprintf+0x4bc>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
10005d60:	ea0000db 	b	100060d4 <rt_vsnprintf+0x870>

        case 's':
            s = va_arg(args, char *);
10005d64:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005d68:	e2832004 	add	r2, r3, #4
10005d6c:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
10005d70:	e5933000 	ldr	r3, [r3]
10005d74:	e50b301c 	str	r3, [fp, #-28]
            if (!s) s = "(NULL)";
10005d78:	e51b301c 	ldr	r3, [fp, #-28]
10005d7c:	e3530000 	cmp	r3, #0
10005d80:	1a000002 	bne	10005d90 <rt_vsnprintf+0x52c>
10005d84:	e30e36c4 	movw	r3, #59076	; 0xe6c4
10005d88:	e3413001 	movt	r3, #4097	; 0x1001
10005d8c:	e50b301c 	str	r3, [fp, #-28]

            len = rt_strlen(s);
10005d90:	e51b001c 	ldr	r0, [fp, #-28]
10005d94:	ebfffd54 	bl	100052ec <rt_strlen>
10005d98:	e1a03000 	mov	r3, r0
10005d9c:	e50b3010 	str	r3, [fp, #-16]
#ifdef RT_PRINTF_PRECISION
            if (precision > 0 && len > precision) len = precision;
10005da0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10005da4:	e3530000 	cmp	r3, #0
10005da8:	da000005 	ble	10005dc4 <rt_vsnprintf+0x560>
10005dac:	e51b2010 	ldr	r2, [fp, #-16]
10005db0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10005db4:	e1520003 	cmp	r2, r3
10005db8:	da000001 	ble	10005dc4 <rt_vsnprintf+0x560>
10005dbc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10005dc0:	e50b3010 	str	r3, [fp, #-16]
#endif

            if (!(flags & LEFT))
10005dc4:	e55b301e 	ldrb	r3, [fp, #-30]
10005dc8:	e2033010 	and	r3, r3, #16
10005dcc:	e3530000 	cmp	r3, #0
10005dd0:	1a000010 	bne	10005e18 <rt_vsnprintf+0x5b4>
            {
                while (len < field_width--)
10005dd4:	ea000009 	b	10005e00 <rt_vsnprintf+0x59c>
                {
                    if (str <= end) *str = ' ';
10005dd8:	e51b2014 	ldr	r2, [fp, #-20]
10005ddc:	e51b3018 	ldr	r3, [fp, #-24]
10005de0:	e1520003 	cmp	r2, r3
10005de4:	8a000002 	bhi	10005df4 <rt_vsnprintf+0x590>
10005de8:	e51b3014 	ldr	r3, [fp, #-20]
10005dec:	e3a02020 	mov	r2, #32
10005df0:	e5c32000 	strb	r2, [r3]
                    ++ str;
10005df4:	e51b3014 	ldr	r3, [fp, #-20]
10005df8:	e2833001 	add	r3, r3, #1
10005dfc:	e50b3014 	str	r3, [fp, #-20]
            if (precision > 0 && len > precision) len = precision;
#endif

            if (!(flags & LEFT))
            {
                while (len < field_width--)
10005e00:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005e04:	e2432001 	sub	r2, r3, #1
10005e08:	e50b2024 	str	r2, [fp, #-36]	; 0x24
10005e0c:	e51b2010 	ldr	r2, [fp, #-16]
10005e10:	e1530002 	cmp	r3, r2
10005e14:	caffffef 	bgt	10005dd8 <rt_vsnprintf+0x574>
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
10005e18:	e3a03000 	mov	r3, #0
10005e1c:	e50b300c 	str	r3, [fp, #-12]
10005e20:	ea000010 	b	10005e68 <rt_vsnprintf+0x604>
            {
                if (str <= end) *str = *s;
10005e24:	e51b2014 	ldr	r2, [fp, #-20]
10005e28:	e51b3018 	ldr	r3, [fp, #-24]
10005e2c:	e1520003 	cmp	r2, r3
10005e30:	8a000003 	bhi	10005e44 <rt_vsnprintf+0x5e0>
10005e34:	e51b301c 	ldr	r3, [fp, #-28]
10005e38:	e5d32000 	ldrb	r2, [r3]
10005e3c:	e51b3014 	ldr	r3, [fp, #-20]
10005e40:	e5c32000 	strb	r2, [r3]
                ++ str;
10005e44:	e51b3014 	ldr	r3, [fp, #-20]
10005e48:	e2833001 	add	r3, r3, #1
10005e4c:	e50b3014 	str	r3, [fp, #-20]
                ++ s;
10005e50:	e51b301c 	ldr	r3, [fp, #-28]
10005e54:	e2833001 	add	r3, r3, #1
10005e58:	e50b301c 	str	r3, [fp, #-28]
                    if (str <= end) *str = ' ';
                    ++ str;
                }
            }

            for (i = 0; i < len; ++i)
10005e5c:	e51b300c 	ldr	r3, [fp, #-12]
10005e60:	e2833001 	add	r3, r3, #1
10005e64:	e50b300c 	str	r3, [fp, #-12]
10005e68:	e51b200c 	ldr	r2, [fp, #-12]
10005e6c:	e51b3010 	ldr	r3, [fp, #-16]
10005e70:	e1520003 	cmp	r2, r3
10005e74:	baffffea 	blt	10005e24 <rt_vsnprintf+0x5c0>
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
10005e78:	ea000009 	b	10005ea4 <rt_vsnprintf+0x640>
            {
                if (str <= end) *str = ' ';
10005e7c:	e51b2014 	ldr	r2, [fp, #-20]
10005e80:	e51b3018 	ldr	r3, [fp, #-24]
10005e84:	e1520003 	cmp	r2, r3
10005e88:	8a000002 	bhi	10005e98 <rt_vsnprintf+0x634>
10005e8c:	e51b3014 	ldr	r3, [fp, #-20]
10005e90:	e3a02020 	mov	r2, #32
10005e94:	e5c32000 	strb	r2, [r3]
                ++ str;
10005e98:	e51b3014 	ldr	r3, [fp, #-20]
10005e9c:	e2833001 	add	r3, r3, #1
10005ea0:	e50b3014 	str	r3, [fp, #-20]
                if (str <= end) *str = *s;
                ++ str;
                ++ s;
            }

            while (len < field_width--)
10005ea4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005ea8:	e2432001 	sub	r2, r3, #1
10005eac:	e50b2024 	str	r2, [fp, #-36]	; 0x24
10005eb0:	e51b2010 	ldr	r2, [fp, #-16]
10005eb4:	e1530002 	cmp	r3, r2
10005eb8:	caffffef 	bgt	10005e7c <rt_vsnprintf+0x618>
            {
                if (str <= end) *str = ' ';
                ++ str;
            }
            continue;
10005ebc:	ea000084 	b	100060d4 <rt_vsnprintf+0x870>

        case 'p':
            if (field_width == -1)
10005ec0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10005ec4:	e3730001 	cmn	r3, #1
10005ec8:	1a000004 	bne	10005ee0 <rt_vsnprintf+0x67c>
            {
                field_width = sizeof(void *) << 1;
10005ecc:	e3a03008 	mov	r3, #8
10005ed0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
                flags |= ZEROPAD;
10005ed4:	e55b301e 	ldrb	r3, [fp, #-30]
10005ed8:	e3833001 	orr	r3, r3, #1
10005edc:	e54b301e 	strb	r3, [fp, #-30]
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
                               (long)va_arg(args, void *),
10005ee0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10005ee4:	e2832004 	add	r2, r3, #4
10005ee8:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
10005eec:	e5933000 	ldr	r3, [r3]
            {
                field_width = sizeof(void *) << 1;
                flags |= ZEROPAD;
            }
#ifdef RT_PRINTF_PRECISION
            str = print_number(str, end,
10005ef0:	e1a0c003 	mov	ip, r3
10005ef4:	e55b301e 	ldrb	r3, [fp, #-30]
10005ef8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10005efc:	e58d2000 	str	r2, [sp]
10005f00:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10005f04:	e58d2004 	str	r2, [sp, #4]
10005f08:	e58d3008 	str	r3, [sp, #8]
10005f0c:	e51b0014 	ldr	r0, [fp, #-20]
10005f10:	e51b1018 	ldr	r1, [fp, #-24]
10005f14:	e1a0200c 	mov	r2, ip
10005f18:	e3a03010 	mov	r3, #16
10005f1c:	ebfffd82 	bl	1000552c <print_number>
10005f20:	e50b0014 	str	r0, [fp, #-20]
#else
            str = print_number(str, end,
                               (long)va_arg(args, void *),
                               16, field_width, flags);
#endif
            continue;
10005f24:	ea00006a 	b	100060d4 <rt_vsnprintf+0x870>

        case '%':
            if (str <= end) *str = '%';
10005f28:	e51b2014 	ldr	r2, [fp, #-20]
10005f2c:	e51b3018 	ldr	r3, [fp, #-24]
10005f30:	e1520003 	cmp	r2, r3
10005f34:	8a000002 	bhi	10005f44 <rt_vsnprintf+0x6e0>
10005f38:	e51b3014 	ldr	r3, [fp, #-20]
10005f3c:	e3a02025 	mov	r2, #37	; 0x25
10005f40:	e5c32000 	strb	r2, [r3]
            ++ str;
10005f44:	e51b3014 	ldr	r3, [fp, #-20]
10005f48:	e2833001 	add	r3, r3, #1
10005f4c:	e50b3014 	str	r3, [fp, #-20]
            continue;
10005f50:	ea00005f 	b	100060d4 <rt_vsnprintf+0x870>

            /* integer number formats - set up the flags and "break" */
        case 'o':
            base = 8;
10005f54:	e3a03008 	mov	r3, #8
10005f58:	e54b301d 	strb	r3, [fp, #-29]
            break;
10005f5c:	ea000028 	b	10006004 <rt_vsnprintf+0x7a0>

        case 'X':
            flags |= LARGE;
10005f60:	e55b301e 	ldrb	r3, [fp, #-30]
10005f64:	e3833040 	orr	r3, r3, #64	; 0x40
10005f68:	e54b301e 	strb	r3, [fp, #-30]
        case 'x':
            base = 16;
10005f6c:	e3a03010 	mov	r3, #16
10005f70:	e54b301d 	strb	r3, [fp, #-29]
            break;
10005f74:	ea000022 	b	10006004 <rt_vsnprintf+0x7a0>

        case 'd':
        case 'i':
            flags |= SIGN;
10005f78:	e55b301e 	ldrb	r3, [fp, #-30]
10005f7c:	e3833002 	orr	r3, r3, #2
10005f80:	e54b301e 	strb	r3, [fp, #-30]
        case 'u':
            break;
10005f84:	ea00001d 	b	10006000 <rt_vsnprintf+0x79c>

        default:
            if (str <= end) *str = '%';
10005f88:	e51b2014 	ldr	r2, [fp, #-20]
10005f8c:	e51b3018 	ldr	r3, [fp, #-24]
10005f90:	e1520003 	cmp	r2, r3
10005f94:	8a000002 	bhi	10005fa4 <rt_vsnprintf+0x740>
10005f98:	e51b3014 	ldr	r3, [fp, #-20]
10005f9c:	e3a02025 	mov	r2, #37	; 0x25
10005fa0:	e5c32000 	strb	r2, [r3]
            ++ str;
10005fa4:	e51b3014 	ldr	r3, [fp, #-20]
10005fa8:	e2833001 	add	r3, r3, #1
10005fac:	e50b3014 	str	r3, [fp, #-20]

            if (*fmt)
10005fb0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005fb4:	e5d33000 	ldrb	r3, [r3]
10005fb8:	e3530000 	cmp	r3, #0
10005fbc:	0a00000b 	beq	10005ff0 <rt_vsnprintf+0x78c>
            {
                if (str <= end) *str = *fmt;
10005fc0:	e51b2014 	ldr	r2, [fp, #-20]
10005fc4:	e51b3018 	ldr	r3, [fp, #-24]
10005fc8:	e1520003 	cmp	r2, r3
10005fcc:	8a000003 	bhi	10005fe0 <rt_vsnprintf+0x77c>
10005fd0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005fd4:	e5d32000 	ldrb	r2, [r3]
10005fd8:	e51b3014 	ldr	r3, [fp, #-20]
10005fdc:	e5c32000 	strb	r2, [r3]
                ++ str;
10005fe0:	e51b3014 	ldr	r3, [fp, #-20]
10005fe4:	e2833001 	add	r3, r3, #1
10005fe8:	e50b3014 	str	r3, [fp, #-20]
            }
            else
            {
                -- fmt;
            }
            continue;
10005fec:	ea000038 	b	100060d4 <rt_vsnprintf+0x870>
                if (str <= end) *str = *fmt;
                ++ str;
            }
            else
            {
                -- fmt;
10005ff0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10005ff4:	e2433001 	sub	r3, r3, #1
10005ff8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
            }
            continue;
10005ffc:	ea000034 	b	100060d4 <rt_vsnprintf+0x870>

        case 'd':
        case 'i':
            flags |= SIGN;
        case 'u':
            break;
10006000:	e1a00000 	nop			; (mov r0, r0)

#ifdef RT_PRINTF_LONGLONG
        if (qualifier == 'L') num = va_arg(args, long long);
        else if (qualifier == 'l')
#else
        if (qualifier == 'l')
10006004:	e55b301f 	ldrb	r3, [fp, #-31]
10006008:	e353006c 	cmp	r3, #108	; 0x6c
1000600c:	1a000008 	bne	10006034 <rt_vsnprintf+0x7d0>
#endif
        {
            num = va_arg(args, rt_uint32_t);
10006010:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10006014:	e2832004 	add	r2, r3, #4
10006018:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
1000601c:	e5933000 	ldr	r3, [r3]
10006020:	e50b3008 	str	r3, [fp, #-8]
            if (flags & SIGN) num = (rt_int32_t)num;
10006024:	e55b301e 	ldrb	r3, [fp, #-30]
10006028:	e2033002 	and	r3, r3, #2
1000602c:	e3530000 	cmp	r3, #0
10006030:	ea000019 	b	1000609c <rt_vsnprintf+0x838>
        }
        else if (qualifier == 'h')
10006034:	e55b301f 	ldrb	r3, [fp, #-31]
10006038:	e3530068 	cmp	r3, #104	; 0x68
1000603c:	1a00000e 	bne	1000607c <rt_vsnprintf+0x818>
        {
            num = (rt_uint16_t)va_arg(args, rt_int32_t);
10006040:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10006044:	e2832004 	add	r2, r3, #4
10006048:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
1000604c:	e5933000 	ldr	r3, [r3]
10006050:	e6ff3073 	uxth	r3, r3
10006054:	e50b3008 	str	r3, [fp, #-8]
            if (flags & SIGN) num = (rt_int16_t)num;
10006058:	e55b301e 	ldrb	r3, [fp, #-30]
1000605c:	e2033002 	and	r3, r3, #2
10006060:	e3530000 	cmp	r3, #0
10006064:	0a00000c 	beq	1000609c <rt_vsnprintf+0x838>
10006068:	e51b3008 	ldr	r3, [fp, #-8]
1000606c:	e6ff3073 	uxth	r3, r3
10006070:	e6bf3073 	sxth	r3, r3
10006074:	e50b3008 	str	r3, [fp, #-8]
10006078:	ea000007 	b	1000609c <rt_vsnprintf+0x838>
        }
        else
        {
            num = va_arg(args, rt_uint32_t);
1000607c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10006080:	e2832004 	add	r2, r3, #4
10006084:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
10006088:	e5933000 	ldr	r3, [r3]
1000608c:	e50b3008 	str	r3, [fp, #-8]
            if (flags & SIGN) num = (rt_int32_t)num;
10006090:	e55b301e 	ldrb	r3, [fp, #-30]
10006094:	e2033002 	and	r3, r3, #2
10006098:	e3530000 	cmp	r3, #0
        }
#ifdef RT_PRINTF_PRECISION
        str = print_number(str, end, num, base, field_width, precision, flags);
1000609c:	e51be008 	ldr	lr, [fp, #-8]
100060a0:	e55bc01d 	ldrb	ip, [fp, #-29]
100060a4:	e55b301e 	ldrb	r3, [fp, #-30]
100060a8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100060ac:	e58d2000 	str	r2, [sp]
100060b0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100060b4:	e58d2004 	str	r2, [sp, #4]
100060b8:	e58d3008 	str	r3, [sp, #8]
100060bc:	e51b0014 	ldr	r0, [fp, #-20]
100060c0:	e51b1018 	ldr	r1, [fp, #-24]
100060c4:	e1a0200e 	mov	r2, lr
100060c8:	e1a0300c 	mov	r3, ip
100060cc:	ebfffd16 	bl	1000552c <print_number>
100060d0:	e50b0014 	str	r0, [fp, #-20]
    {
        end  = ((char *)-1);
        size = end - buf;
    }

    for (; *fmt ; ++fmt)
100060d4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100060d8:	e2833001 	add	r3, r3, #1
100060dc:	e50b3038 	str	r3, [fp, #-56]	; 0x38
100060e0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100060e4:	e5d33000 	ldrb	r3, [r3]
100060e8:	e3530000 	cmp	r3, #0
100060ec:	1afffdf5 	bne	100058c8 <rt_vsnprintf+0x64>
#else
        str = print_number(str, end, num, base, field_width, flags);
#endif
    }

    if (str <= end) *str = '\0';
100060f0:	e51b2014 	ldr	r2, [fp, #-20]
100060f4:	e51b3018 	ldr	r3, [fp, #-24]
100060f8:	e1520003 	cmp	r2, r3
100060fc:	8a000003 	bhi	10006110 <rt_vsnprintf+0x8ac>
10006100:	e51b3014 	ldr	r3, [fp, #-20]
10006104:	e3a02000 	mov	r2, #0
10006108:	e5c32000 	strb	r2, [r3]
1000610c:	ea000002 	b	1000611c <rt_vsnprintf+0x8b8>
    else *end = '\0';
10006110:	e51b3018 	ldr	r3, [fp, #-24]
10006114:	e3a02000 	mov	r2, #0
10006118:	e5c32000 	strb	r2, [r3]

    /* the trailing null byte doesn't count towards the total
    * ++str;
    */
    return str - buf;
1000611c:	e51b2014 	ldr	r2, [fp, #-20]
10006120:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10006124:	e0633002 	rsb	r3, r3, r2
}
10006128:	e1a00003 	mov	r0, r3
1000612c:	e24bd004 	sub	sp, fp, #4
10006130:	e8bd8800 	pop	{fp, pc}

10006134 <rt_snprintf>:
 * @param buf the buffer to save formatted string
 * @param size the size of buffer
 * @param fmt the format
 */
rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
{
10006134:	e92d000c 	push	{r2, r3}
10006138:	e92d4800 	push	{fp, lr}
1000613c:	e28db004 	add	fp, sp, #4
10006140:	e24dd010 	sub	sp, sp, #16
10006144:	e50b0010 	str	r0, [fp, #-16]
10006148:	e50b1014 	str	r1, [fp, #-20]
    rt_int32_t n;
    va_list args;

    va_start(args, fmt);
1000614c:	e28b3008 	add	r3, fp, #8
10006150:	e50b300c 	str	r3, [fp, #-12]
    n = rt_vsnprintf(buf, size, fmt, args);
10006154:	e51b0010 	ldr	r0, [fp, #-16]
10006158:	e51b1014 	ldr	r1, [fp, #-20]
1000615c:	e59b2004 	ldr	r2, [fp, #4]
10006160:	e51b300c 	ldr	r3, [fp, #-12]
10006164:	ebfffdbe 	bl	10005864 <rt_vsnprintf>
10006168:	e50b0008 	str	r0, [fp, #-8]
    va_end(args);

    return n;
1000616c:	e51b3008 	ldr	r3, [fp, #-8]
}
10006170:	e1a00003 	mov	r0, r3
10006174:	e24bd004 	sub	sp, fp, #4
10006178:	e8bd4800 	pop	{fp, lr}
1000617c:	e28dd008 	add	sp, sp, #8
10006180:	e12fff1e 	bx	lr

10006184 <rt_vsprintf>:
 * @param buf the buffer to save formatted string
 * @param arg_ptr the arg_ptr
 * @param format the format
 */
rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
{
10006184:	e92d4800 	push	{fp, lr}
10006188:	e28db004 	add	fp, sp, #4
1000618c:	e24dd010 	sub	sp, sp, #16
10006190:	e50b0008 	str	r0, [fp, #-8]
10006194:	e50b100c 	str	r1, [fp, #-12]
10006198:	e50b2010 	str	r2, [fp, #-16]
    return rt_vsnprintf(buf, (rt_size_t) -1, format, arg_ptr);
1000619c:	e51b0008 	ldr	r0, [fp, #-8]
100061a0:	e3e01000 	mvn	r1, #0
100061a4:	e51b200c 	ldr	r2, [fp, #-12]
100061a8:	e51b3010 	ldr	r3, [fp, #-16]
100061ac:	ebfffdac 	bl	10005864 <rt_vsnprintf>
100061b0:	e1a03000 	mov	r3, r0
}
100061b4:	e1a00003 	mov	r0, r3
100061b8:	e24bd004 	sub	sp, fp, #4
100061bc:	e8bd8800 	pop	{fp, pc}

100061c0 <rt_sprintf>:
 *
 * @param buf the buffer to save formatted string
 * @param format the format
 */
rt_int32_t rt_sprintf(char *buf, const char *format, ...)
{
100061c0:	e92d000e 	push	{r1, r2, r3}
100061c4:	e92d4800 	push	{fp, lr}
100061c8:	e28db004 	add	fp, sp, #4
100061cc:	e24dd014 	sub	sp, sp, #20
100061d0:	e50b0014 	str	r0, [fp, #-20]
    rt_int32_t n;
    va_list arg_ptr;

    va_start(arg_ptr, format);
100061d4:	e28b3008 	add	r3, fp, #8
100061d8:	e50b3010 	str	r3, [fp, #-16]
    n = rt_vsprintf(buf ,format, arg_ptr);
100061dc:	e51b0014 	ldr	r0, [fp, #-20]
100061e0:	e59b1004 	ldr	r1, [fp, #4]
100061e4:	e51b2010 	ldr	r2, [fp, #-16]
100061e8:	ebffffe5 	bl	10006184 <rt_vsprintf>
100061ec:	e50b000c 	str	r0, [fp, #-12]
    va_end(arg_ptr);

    return n;
100061f0:	e51b300c 	ldr	r3, [fp, #-12]
}
100061f4:	e1a00003 	mov	r0, r3
100061f8:	e24bd004 	sub	sp, fp, #4
100061fc:	e8bd4800 	pop	{fp, lr}
10006200:	e28dd00c 	add	sp, sp, #12
10006204:	e12fff1e 	bx	lr

10006208 <rt_console_get_device>:
 * This function returns the device using in console.
 *
 * @return the device using in console or RT_NULL
 */
rt_device_t rt_console_get_device(void)
{
10006208:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000620c:	e28db000 	add	fp, sp, #0
    return _console_device;
10006210:	e3083324 	movw	r3, #33572	; 0x8324
10006214:	e3413002 	movt	r3, #4098	; 0x1002
10006218:	e5933000 	ldr	r3, [r3]
}
1000621c:	e1a00003 	mov	r0, r3
10006220:	e24bd000 	sub	sp, fp, #0
10006224:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006228:	e12fff1e 	bx	lr

1000622c <rt_console_set_device>:
 * @param name the name of new console device
 *
 * @return the old console device handler
 */
rt_device_t rt_console_set_device(const char *name)
{
1000622c:	e92d4800 	push	{fp, lr}
10006230:	e28db004 	add	fp, sp, #4
10006234:	e24dd010 	sub	sp, sp, #16
10006238:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t new, old;

    /* save old device */
    old = _console_device;
1000623c:	e3083324 	movw	r3, #33572	; 0x8324
10006240:	e3413002 	movt	r3, #4098	; 0x1002
10006244:	e5933000 	ldr	r3, [r3]
10006248:	e50b3008 	str	r3, [fp, #-8]

    /* find new console device */
    new = rt_device_find(name);
1000624c:	e51b0010 	ldr	r0, [fp, #-16]
10006250:	ebffeb2f 	bl	10000f14 <rt_device_find>
10006254:	e50b000c 	str	r0, [fp, #-12]
    if (new != RT_NULL)
10006258:	e51b300c 	ldr	r3, [fp, #-12]
1000625c:	e3530000 	cmp	r3, #0
10006260:	0a000010 	beq	100062a8 <rt_console_set_device+0x7c>
    {
        if (_console_device != RT_NULL)
10006264:	e3083324 	movw	r3, #33572	; 0x8324
10006268:	e3413002 	movt	r3, #4098	; 0x1002
1000626c:	e5933000 	ldr	r3, [r3]
10006270:	e3530000 	cmp	r3, #0
10006274:	0a000004 	beq	1000628c <rt_console_set_device+0x60>
        {
            /* close old console device */
            rt_device_close(_console_device);
10006278:	e3083324 	movw	r3, #33572	; 0x8324
1000627c:	e3413002 	movt	r3, #4098	; 0x1002
10006280:	e5933000 	ldr	r3, [r3]
10006284:	e1a00003 	mov	r0, r3
10006288:	ebffebeb 	bl	1000123c <rt_device_close>
        }

        /* set new console device */
        rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
1000628c:	e51b000c 	ldr	r0, [fp, #-12]
10006290:	e3a01043 	mov	r1, #67	; 0x43
10006294:	ebffeb82 	bl	100010a4 <rt_device_open>
        _console_device = new;
10006298:	e3083324 	movw	r3, #33572	; 0x8324
1000629c:	e3413002 	movt	r3, #4098	; 0x1002
100062a0:	e51b200c 	ldr	r2, [fp, #-12]
100062a4:	e5832000 	str	r2, [r3]
    }

    return old;
100062a8:	e51b3008 	ldr	r3, [fp, #-8]
}
100062ac:	e1a00003 	mov	r0, r3
100062b0:	e24bd004 	sub	sp, fp, #4
100062b4:	e8bd8800 	pop	{fp, pc}

100062b8 <rt_hw_console_output>:
RTM_EXPORT(rt_console_set_device);
#endif

WEAK void rt_hw_console_output(const char *str)
{
100062b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100062bc:	e28db000 	add	fp, sp, #0
100062c0:	e24dd00c 	sub	sp, sp, #12
100062c4:	e50b0008 	str	r0, [fp, #-8]
    /* empty console output */
}
100062c8:	e24bd000 	sub	sp, fp, #0
100062cc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100062d0:	e12fff1e 	bx	lr

100062d4 <rt_kprintf>:
 * This function will print a formatted string on system console
 *
 * @param fmt the format
 */
void rt_kprintf(const char *fmt, ...)
{
100062d4:	e92d000f 	push	{r0, r1, r2, r3}
100062d8:	e92d4800 	push	{fp, lr}
100062dc:	e28db004 	add	fp, sp, #4
100062e0:	e24dd010 	sub	sp, sp, #16
    va_list args;
    rt_size_t length;
    static char rt_log_buf[RT_CONSOLEBUF_SIZE];

    va_start(args, fmt);
100062e4:	e28b3008 	add	r3, fp, #8
100062e8:	e50b3010 	str	r3, [fp, #-16]
    /* the return value of vsnprintf is the number of bytes that would be
     * written to buffer had if the size of the buffer been sufficiently
     * large excluding the terminating null byte. If the output string
     * would be larger than the rt_log_buf, we have to adjust the output
     * length. */
    length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
100062ec:	e3080328 	movw	r0, #33576	; 0x8328
100062f0:	e3410002 	movt	r0, #4098	; 0x1002
100062f4:	e3a0107f 	mov	r1, #127	; 0x7f
100062f8:	e59b2004 	ldr	r2, [fp, #4]
100062fc:	e51b3010 	ldr	r3, [fp, #-16]
10006300:	ebfffd57 	bl	10005864 <rt_vsnprintf>
10006304:	e1a03000 	mov	r3, r0
10006308:	e50b3008 	str	r3, [fp, #-8]
    if (length > RT_CONSOLEBUF_SIZE - 1)
1000630c:	e51b3008 	ldr	r3, [fp, #-8]
10006310:	e353007f 	cmp	r3, #127	; 0x7f
10006314:	9a000001 	bls	10006320 <rt_kprintf+0x4c>
        length = RT_CONSOLEBUF_SIZE - 1;
10006318:	e3a0307f 	mov	r3, #127	; 0x7f
1000631c:	e50b3008 	str	r3, [fp, #-8]
#ifdef RT_USING_DEVICE
    if (_console_device == RT_NULL)
10006320:	e3083324 	movw	r3, #33572	; 0x8324
10006324:	e3413002 	movt	r3, #4098	; 0x1002
10006328:	e5933000 	ldr	r3, [r3]
1000632c:	e3530000 	cmp	r3, #0
10006330:	1a000003 	bne	10006344 <rt_kprintf+0x70>
    {
        rt_hw_console_output(rt_log_buf);
10006334:	e3080328 	movw	r0, #33576	; 0x8328
10006338:	e3410002 	movt	r0, #4098	; 0x1002
1000633c:	ebffffdd 	bl	100062b8 <rt_hw_console_output>
10006340:	ea00001c 	b	100063b8 <rt_kprintf+0xe4>
    }
    else
    {
        rt_uint16_t old_flag = _console_device->open_flag;
10006344:	e3083324 	movw	r3, #33572	; 0x8324
10006348:	e3413002 	movt	r3, #4098	; 0x1002
1000634c:	e5933000 	ldr	r3, [r3]
10006350:	e1d331b4 	ldrh	r3, [r3, #20]
10006354:	e14b30ba 	strh	r3, [fp, #-10]

        _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
10006358:	e3083324 	movw	r3, #33572	; 0x8324
1000635c:	e3413002 	movt	r3, #4098	; 0x1002
10006360:	e5932000 	ldr	r2, [r3]
10006364:	e3083324 	movw	r3, #33572	; 0x8324
10006368:	e3413002 	movt	r3, #4098	; 0x1002
1000636c:	e5933000 	ldr	r3, [r3]
10006370:	e1d331b4 	ldrh	r3, [r3, #20]
10006374:	e3833040 	orr	r3, r3, #64	; 0x40
10006378:	e6ff3073 	uxth	r3, r3
1000637c:	e1c231b4 	strh	r3, [r2, #20]
        rt_device_write(_console_device, 0, rt_log_buf, length);
10006380:	e3083324 	movw	r3, #33572	; 0x8324
10006384:	e3413002 	movt	r3, #4098	; 0x1002
10006388:	e5933000 	ldr	r3, [r3]
1000638c:	e1a00003 	mov	r0, r3
10006390:	e3a01000 	mov	r1, #0
10006394:	e3082328 	movw	r2, #33576	; 0x8328
10006398:	e3412002 	movt	r2, #4098	; 0x1002
1000639c:	e51b3008 	ldr	r3, [fp, #-8]
100063a0:	ebffec07 	bl	100013c4 <rt_device_write>
        _console_device->open_flag = old_flag;
100063a4:	e3083324 	movw	r3, #33572	; 0x8324
100063a8:	e3413002 	movt	r3, #4098	; 0x1002
100063ac:	e5933000 	ldr	r3, [r3]
100063b0:	e15b20ba 	ldrh	r2, [fp, #-10]
100063b4:	e1c321b4 	strh	r2, [r3, #20]
    }
#else
    rt_hw_console_output(rt_log_buf);
#endif
    va_end(args);
}
100063b8:	e24bd004 	sub	sp, fp, #4
100063bc:	e8bd4800 	pop	{fp, lr}
100063c0:	e28dd010 	add	sp, sp, #16
100063c4:	e12fff1e 	bx	lr

100063c8 <rt_malloc_align>:
 * @param align the alignment size
 *
 * @return the allocated memory block on successful, otherwise returns RT_NULL
 */
void* rt_malloc_align(rt_size_t size, rt_size_t align)
{
100063c8:	e92d4800 	push	{fp, lr}
100063cc:	e28db004 	add	fp, sp, #4
100063d0:	e24dd018 	sub	sp, sp, #24
100063d4:	e50b0018 	str	r0, [fp, #-24]
100063d8:	e50b101c 	str	r1, [fp, #-28]
    void *align_ptr;
    void *ptr;
    rt_size_t align_size;

    /* align the alignment size to 4 byte */
    align = ((align + 0x03) & ~0x03);
100063dc:	e51b301c 	ldr	r3, [fp, #-28]
100063e0:	e2833003 	add	r3, r3, #3
100063e4:	e3c33003 	bic	r3, r3, #3
100063e8:	e50b301c 	str	r3, [fp, #-28]

    /* get total aligned size */
    align_size = ((size + 0x03) & ~0x03) + align;
100063ec:	e51b3018 	ldr	r3, [fp, #-24]
100063f0:	e2833003 	add	r3, r3, #3
100063f4:	e3c32003 	bic	r2, r3, #3
100063f8:	e51b301c 	ldr	r3, [fp, #-28]
100063fc:	e0823003 	add	r3, r2, r3
10006400:	e50b3010 	str	r3, [fp, #-16]
    /* allocate memory block from heap */
    ptr = rt_malloc(align_size);
10006404:	e51b0010 	ldr	r0, [fp, #-16]
10006408:	eb0001a6 	bl	10006aa8 <rt_malloc>
1000640c:	e50b000c 	str	r0, [fp, #-12]
    if (ptr != RT_NULL)
10006410:	e51b300c 	ldr	r3, [fp, #-12]
10006414:	e3530000 	cmp	r3, #0
10006418:	0a000019 	beq	10006484 <rt_malloc_align+0xbc>
    {
         /* the allocated memory block is aligned */
        if (((rt_uint32_t)ptr & (align - 1)) == 0)
1000641c:	e51b301c 	ldr	r3, [fp, #-28]
10006420:	e2432001 	sub	r2, r3, #1
10006424:	e51b300c 	ldr	r3, [fp, #-12]
10006428:	e0033002 	and	r3, r3, r2
1000642c:	e3530000 	cmp	r3, #0
10006430:	1a000004 	bne	10006448 <rt_malloc_align+0x80>
        {
            align_ptr = (void *)((rt_uint32_t)ptr + align);
10006434:	e51b200c 	ldr	r2, [fp, #-12]
10006438:	e51b301c 	ldr	r3, [fp, #-28]
1000643c:	e0823003 	add	r3, r2, r3
10006440:	e50b3008 	str	r3, [fp, #-8]
10006444:	ea000007 	b	10006468 <rt_malloc_align+0xa0>
        }
        else
        {
            align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
10006448:	e51b200c 	ldr	r2, [fp, #-12]
1000644c:	e51b301c 	ldr	r3, [fp, #-28]
10006450:	e0823003 	add	r3, r2, r3
10006454:	e2432001 	sub	r2, r3, #1
10006458:	e51b301c 	ldr	r3, [fp, #-28]
1000645c:	e2633000 	rsb	r3, r3, #0
10006460:	e0033002 	and	r3, r3, r2
10006464:	e50b3008 	str	r3, [fp, #-8]
        }

        /* set the pointer before alignment pointer to the real pointer */
        *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
10006468:	e51b3008 	ldr	r3, [fp, #-8]
1000646c:	e2433004 	sub	r3, r3, #4
10006470:	e1a02003 	mov	r2, r3
10006474:	e51b300c 	ldr	r3, [fp, #-12]
10006478:	e5823000 	str	r3, [r2]

        ptr = align_ptr;
1000647c:	e51b3008 	ldr	r3, [fp, #-8]
10006480:	e50b300c 	str	r3, [fp, #-12]
    }

    return ptr;
10006484:	e51b300c 	ldr	r3, [fp, #-12]
}
10006488:	e1a00003 	mov	r0, r3
1000648c:	e24bd004 	sub	sp, fp, #4
10006490:	e8bd8800 	pop	{fp, pc}

10006494 <rt_free_align>:
 * rt_malloc_align function and address is aligned.
 *
 * @param ptr the memory block pointer
 */
void rt_free_align(void *ptr)
{
10006494:	e92d4800 	push	{fp, lr}
10006498:	e28db004 	add	fp, sp, #4
1000649c:	e24dd010 	sub	sp, sp, #16
100064a0:	e50b0010 	str	r0, [fp, #-16]
    void *real_ptr;

    real_ptr = (void *)*(rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
100064a4:	e51b3010 	ldr	r3, [fp, #-16]
100064a8:	e2433004 	sub	r3, r3, #4
100064ac:	e5933000 	ldr	r3, [r3]
100064b0:	e50b3008 	str	r3, [fp, #-8]
    rt_free(real_ptr);
100064b4:	e51b0008 	ldr	r0, [fp, #-8]
100064b8:	eb000395 	bl	10007314 <rt_free>
}
100064bc:	e24bd004 	sub	sp, fp, #4
100064c0:	e8bd8800 	pop	{fp, pc}

100064c4 <__rt_ffs>:
 *
 * @return return the index of the first bit set. If value is 0, then this function
 * shall return 0.
 */
int __rt_ffs(int value)
{
100064c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100064c8:	e28db000 	add	fp, sp, #0
100064cc:	e24dd00c 	sub	sp, sp, #12
100064d0:	e50b0008 	str	r0, [fp, #-8]
    if (value == 0) return 0;
100064d4:	e51b3008 	ldr	r3, [fp, #-8]
100064d8:	e3530000 	cmp	r3, #0
100064dc:	1a000001 	bne	100064e8 <__rt_ffs+0x24>
100064e0:	e3a03000 	mov	r3, #0
100064e4:	ea000028 	b	1000658c <__rt_ffs+0xc8>

    if (value & 0xff)
100064e8:	e51b3008 	ldr	r3, [fp, #-8]
100064ec:	e6ef3073 	uxtb	r3, r3
100064f0:	e3530000 	cmp	r3, #0
100064f4:	0a000006 	beq	10006514 <__rt_ffs+0x50>
        return __lowest_bit_bitmap[value & 0xff] + 1;
100064f8:	e51b3008 	ldr	r3, [fp, #-8]
100064fc:	e6ef2073 	uxtb	r2, r3
10006500:	e30e36cc 	movw	r3, #59084	; 0xe6cc
10006504:	e3413001 	movt	r3, #4097	; 0x1001
10006508:	e7d33002 	ldrb	r3, [r3, r2]
1000650c:	e2833001 	add	r3, r3, #1
10006510:	ea00001d 	b	1000658c <__rt_ffs+0xc8>

    if (value & 0xff00)
10006514:	e51b3008 	ldr	r3, [fp, #-8]
10006518:	e2033cff 	and	r3, r3, #65280	; 0xff00
1000651c:	e3530000 	cmp	r3, #0
10006520:	0a000007 	beq	10006544 <__rt_ffs+0x80>
        return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
10006524:	e51b3008 	ldr	r3, [fp, #-8]
10006528:	e2033cff 	and	r3, r3, #65280	; 0xff00
1000652c:	e1a02443 	asr	r2, r3, #8
10006530:	e30e36cc 	movw	r3, #59084	; 0xe6cc
10006534:	e3413001 	movt	r3, #4097	; 0x1001
10006538:	e7d33002 	ldrb	r3, [r3, r2]
1000653c:	e2833009 	add	r3, r3, #9
10006540:	ea000011 	b	1000658c <__rt_ffs+0xc8>

    if (value & 0xff0000)
10006544:	e51b3008 	ldr	r3, [fp, #-8]
10006548:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
1000654c:	e3530000 	cmp	r3, #0
10006550:	0a000007 	beq	10006574 <__rt_ffs+0xb0>
        return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
10006554:	e51b3008 	ldr	r3, [fp, #-8]
10006558:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
1000655c:	e1a02843 	asr	r2, r3, #16
10006560:	e30e36cc 	movw	r3, #59084	; 0xe6cc
10006564:	e3413001 	movt	r3, #4097	; 0x1001
10006568:	e7d33002 	ldrb	r3, [r3, r2]
1000656c:	e2833011 	add	r3, r3, #17
10006570:	ea000005 	b	1000658c <__rt_ffs+0xc8>

    return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
10006574:	e51b3008 	ldr	r3, [fp, #-8]
10006578:	e1a02c23 	lsr	r2, r3, #24
1000657c:	e30e36cc 	movw	r3, #59084	; 0xe6cc
10006580:	e3413001 	movt	r3, #4097	; 0x1001
10006584:	e7d33002 	ldrb	r3, [r3, r2]
10006588:	e2833019 	add	r3, r3, #25
}
1000658c:	e1a00003 	mov	r0, r3
10006590:	e24bd000 	sub	sp, fp, #0
10006594:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006598:	e12fff1e 	bx	lr

1000659c <rt_assert_set_hook>:
/**
 * This function will set a hook function to RT_ASSERT(EX). It will run when the expression is false.
 *
 * @param hook the hook function
 */
void rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line)) {
1000659c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100065a0:	e28db000 	add	fp, sp, #0
100065a4:	e24dd00c 	sub	sp, sp, #12
100065a8:	e50b0008 	str	r0, [fp, #-8]
    rt_assert_hook = hook;
100065ac:	e3093d84 	movw	r3, #40324	; 0x9d84
100065b0:	e3413002 	movt	r3, #4098	; 0x1002
100065b4:	e51b2008 	ldr	r2, [fp, #-8]
100065b8:	e5832000 	str	r2, [r3]
}
100065bc:	e24bd000 	sub	sp, fp, #0
100065c0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100065c4:	e12fff1e 	bx	lr

100065c8 <rt_assert_handler>:
 * @param ex the assertion condition string
 * @param func the function name when assertion.
 * @param line the file line number when assertion.
 */
void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
{
100065c8:	e92d4800 	push	{fp, lr}
100065cc:	e28db004 	add	fp, sp, #4
100065d0:	e24dd018 	sub	sp, sp, #24
100065d4:	e50b0010 	str	r0, [fp, #-16]
100065d8:	e50b1014 	str	r1, [fp, #-20]
100065dc:	e50b2018 	str	r2, [fp, #-24]
    volatile char dummy = 0;
100065e0:	e3a03000 	mov	r3, #0
100065e4:	e54b3005 	strb	r3, [fp, #-5]

    if (rt_assert_hook == RT_NULL)
100065e8:	e3093d84 	movw	r3, #40324	; 0x9d84
100065ec:	e3413002 	movt	r3, #4098	; 0x1002
100065f0:	e5933000 	ldr	r3, [r3]
100065f4:	e3530000 	cmp	r3, #0
100065f8:	1a00000b 	bne	1000662c <rt_assert_handler+0x64>
			rt_schedule();
		}
		else
#endif
		{
	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
100065fc:	e30e07cc 	movw	r0, #59340	; 0xe7cc
10006600:	e3410001 	movt	r0, #4097	; 0x1001
10006604:	e51b1010 	ldr	r1, [fp, #-16]
10006608:	e51b2014 	ldr	r2, [fp, #-20]
1000660c:	e51b3018 	ldr	r3, [fp, #-24]
10006610:	ebffff2f 	bl	100062d4 <rt_kprintf>
	        while (dummy == 0);
10006614:	e1a00000 	nop			; (mov r0, r0)
10006618:	e55b3005 	ldrb	r3, [fp, #-5]
1000661c:	e6ef3073 	uxtb	r3, r3
10006620:	e3530000 	cmp	r3, #0
10006624:	0afffffb 	beq	10006618 <rt_assert_handler+0x50>
10006628:	ea000006 	b	10006648 <rt_assert_handler+0x80>
		}
    }
	else
	{
        rt_assert_hook(ex_string, func, line);
1000662c:	e3093d84 	movw	r3, #40324	; 0x9d84
10006630:	e3413002 	movt	r3, #4098	; 0x1002
10006634:	e5933000 	ldr	r3, [r3]
10006638:	e51b0010 	ldr	r0, [fp, #-16]
1000663c:	e51b1014 	ldr	r1, [fp, #-20]
10006640:	e51b2018 	ldr	r2, [fp, #-24]
10006644:	e12fff33 	blx	r3
    }                                                                     
}
10006648:	e24bd004 	sub	sp, fp, #4
1000664c:	e8bd8800 	pop	{fp, pc}

10006650 <rt_malloc_sethook>:
 * block is allocated from heap memory.
 *
 * @param hook the hook function
 */
void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
{
10006650:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006654:	e28db000 	add	fp, sp, #0
10006658:	e24dd00c 	sub	sp, sp, #12
1000665c:	e50b0008 	str	r0, [fp, #-8]
    rt_malloc_hook = hook;
10006660:	e30833a8 	movw	r3, #33704	; 0x83a8
10006664:	e3413002 	movt	r3, #4098	; 0x1002
10006668:	e51b2008 	ldr	r2, [fp, #-8]
1000666c:	e5832000 	str	r2, [r3]
}
10006670:	e24bd000 	sub	sp, fp, #0
10006674:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10006678:	e12fff1e 	bx	lr

1000667c <rt_free_sethook>:
 * block is released to heap memory.
 *
 * @param hook the hook function
 */
void rt_free_sethook(void (*hook)(void *ptr))
{
1000667c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10006680:	e28db000 	add	fp, sp, #0
10006684:	e24dd00c 	sub	sp, sp, #12
10006688:	e50b0008 	str	r0, [fp, #-8]
    rt_free_hook = hook;
1000668c:	e30833ac 	movw	r3, #33708	; 0x83ac
10006690:	e3413002 	movt	r3, #4098	; 0x1002
10006694:	e51b2008 	ldr	r2, [fp, #-8]
10006698:	e5832000 	str	r2, [r3]
}
1000669c:	e24bd000 	sub	sp, fp, #0
100066a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100066a4:	e12fff1e 	bx	lr

100066a8 <plug_holes>:
#ifdef RT_MEM_STATS
static rt_size_t used_mem, max_mem;
#endif

static void plug_holes(struct heap_mem *mem)
{
100066a8:	e92d4800 	push	{fp, lr}
100066ac:	e28db004 	add	fp, sp, #4
100066b0:	e24dd010 	sub	sp, sp, #16
100066b4:	e50b0010 	str	r0, [fp, #-16]
    struct heap_mem *nmem;
    struct heap_mem *pmem;

    RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
100066b8:	e30833b0 	movw	r3, #33712	; 0x83b0
100066bc:	e3413002 	movt	r3, #4098	; 0x1002
100066c0:	e5933000 	ldr	r3, [r3]
100066c4:	e51b2010 	ldr	r2, [fp, #-16]
100066c8:	e1520003 	cmp	r2, r3
100066cc:	2a000005 	bcs	100066e8 <plug_holes+0x40>
100066d0:	e30e082c 	movw	r0, #59436	; 0xe82c
100066d4:	e3410001 	movt	r0, #4097	; 0x1001
100066d8:	e30e1adc 	movw	r1, #60124	; 0xeadc
100066dc:	e3411001 	movt	r1, #4097	; 0x1001
100066e0:	e3a0208d 	mov	r2, #141	; 0x8d
100066e4:	ebffffb7 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
100066e8:	e30833b4 	movw	r3, #33716	; 0x83b4
100066ec:	e3413002 	movt	r3, #4098	; 0x1002
100066f0:	e5933000 	ldr	r3, [r3]
100066f4:	e51b2010 	ldr	r2, [fp, #-16]
100066f8:	e1520003 	cmp	r2, r3
100066fc:	3a000005 	bcc	10006718 <plug_holes+0x70>
10006700:	e30e084c 	movw	r0, #59468	; 0xe84c
10006704:	e3410001 	movt	r0, #4097	; 0x1001
10006708:	e30e1adc 	movw	r1, #60124	; 0xeadc
1000670c:	e3411001 	movt	r1, #4097	; 0x1001
10006710:	e3a0208e 	mov	r2, #142	; 0x8e
10006714:	ebffffab 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(mem->used == 0);
10006718:	e51b3010 	ldr	r3, [fp, #-16]
1000671c:	e1d330b2 	ldrh	r3, [r3, #2]
10006720:	e3530000 	cmp	r3, #0
10006724:	0a000005 	beq	10006740 <plug_holes+0x98>
10006728:	e30e0878 	movw	r0, #59512	; 0xe878
1000672c:	e3410001 	movt	r0, #4097	; 0x1001
10006730:	e30e1adc 	movw	r1, #60124	; 0xeadc
10006734:	e3411001 	movt	r1, #4097	; 0x1001
10006738:	e3a0208f 	mov	r2, #143	; 0x8f
1000673c:	ebffffa1 	bl	100065c8 <rt_assert_handler>

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
10006740:	e30833b0 	movw	r3, #33712	; 0x83b0
10006744:	e3413002 	movt	r3, #4098	; 0x1002
10006748:	e5932000 	ldr	r2, [r3]
1000674c:	e51b3010 	ldr	r3, [fp, #-16]
10006750:	e5933004 	ldr	r3, [r3, #4]
10006754:	e0823003 	add	r3, r2, r3
10006758:	e50b3008 	str	r3, [fp, #-8]
    if (mem != nmem &&
1000675c:	e51b2010 	ldr	r2, [fp, #-16]
10006760:	e51b3008 	ldr	r3, [fp, #-8]
10006764:	e1520003 	cmp	r2, r3
10006768:	0a000023 	beq	100067fc <plug_holes+0x154>
        nmem->used == 0 &&
1000676c:	e51b3008 	ldr	r3, [fp, #-8]
10006770:	e1d330b2 	ldrh	r3, [r3, #2]
    RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
10006774:	e3530000 	cmp	r3, #0
10006778:	1a00001f 	bne	100067fc <plug_holes+0x154>
        nmem->used == 0 &&
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
1000677c:	e30833b4 	movw	r3, #33716	; 0x83b4
10006780:	e3413002 	movt	r3, #4098	; 0x1002
10006784:	e5933000 	ldr	r3, [r3]
    RT_ASSERT(mem->used == 0);

    /* plug hole forward */
    nmem = (struct heap_mem *)&heap_ptr[mem->next];
    if (mem != nmem &&
        nmem->used == 0 &&
10006788:	e51b2008 	ldr	r2, [fp, #-8]
1000678c:	e1520003 	cmp	r2, r3
10006790:	0a000019 	beq	100067fc <plug_holes+0x154>
        (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
    {
        /* if mem->next is unused and not end of heap_ptr,
         * combine mem and mem->next
         */
        if (lfree == nmem)
10006794:	e30833b8 	movw	r3, #33720	; 0x83b8
10006798:	e3413002 	movt	r3, #4098	; 0x1002
1000679c:	e5932000 	ldr	r2, [r3]
100067a0:	e51b3008 	ldr	r3, [fp, #-8]
100067a4:	e1520003 	cmp	r2, r3
100067a8:	1a000003 	bne	100067bc <plug_holes+0x114>
        {
            lfree = mem;
100067ac:	e30833b8 	movw	r3, #33720	; 0x83b8
100067b0:	e3413002 	movt	r3, #4098	; 0x1002
100067b4:	e51b2010 	ldr	r2, [fp, #-16]
100067b8:	e5832000 	str	r2, [r3]
        }
        mem->next = nmem->next;
100067bc:	e51b3008 	ldr	r3, [fp, #-8]
100067c0:	e5932004 	ldr	r2, [r3, #4]
100067c4:	e51b3010 	ldr	r3, [fp, #-16]
100067c8:	e5832004 	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
100067cc:	e30833b0 	movw	r3, #33712	; 0x83b0
100067d0:	e3413002 	movt	r3, #4098	; 0x1002
100067d4:	e5932000 	ldr	r2, [r3]
100067d8:	e51b3008 	ldr	r3, [fp, #-8]
100067dc:	e5933004 	ldr	r3, [r3, #4]
100067e0:	e0822003 	add	r2, r2, r3
100067e4:	e51b1010 	ldr	r1, [fp, #-16]
100067e8:	e30833b0 	movw	r3, #33712	; 0x83b0
100067ec:	e3413002 	movt	r3, #4098	; 0x1002
100067f0:	e5933000 	ldr	r3, [r3]
100067f4:	e0633001 	rsb	r3, r3, r1
100067f8:	e5823008 	str	r3, [r2, #8]
    }

    /* plug hole backward */
    pmem = (struct heap_mem *)&heap_ptr[mem->prev];
100067fc:	e30833b0 	movw	r3, #33712	; 0x83b0
10006800:	e3413002 	movt	r3, #4098	; 0x1002
10006804:	e5932000 	ldr	r2, [r3]
10006808:	e51b3010 	ldr	r3, [fp, #-16]
1000680c:	e5933008 	ldr	r3, [r3, #8]
10006810:	e0823003 	add	r3, r2, r3
10006814:	e50b300c 	str	r3, [fp, #-12]
    if (pmem != mem && pmem->used == 0)
10006818:	e51b200c 	ldr	r2, [fp, #-12]
1000681c:	e51b3010 	ldr	r3, [fp, #-16]
10006820:	e1520003 	cmp	r2, r3
10006824:	0a00001d 	beq	100068a0 <plug_holes+0x1f8>
10006828:	e51b300c 	ldr	r3, [fp, #-12]
1000682c:	e1d330b2 	ldrh	r3, [r3, #2]
10006830:	e3530000 	cmp	r3, #0
10006834:	1a000019 	bne	100068a0 <plug_holes+0x1f8>
    {
        /* if mem->prev is unused, combine mem and mem->prev */
        if (lfree == mem)
10006838:	e30833b8 	movw	r3, #33720	; 0x83b8
1000683c:	e3413002 	movt	r3, #4098	; 0x1002
10006840:	e5932000 	ldr	r2, [r3]
10006844:	e51b3010 	ldr	r3, [fp, #-16]
10006848:	e1520003 	cmp	r2, r3
1000684c:	1a000003 	bne	10006860 <plug_holes+0x1b8>
        {
            lfree = pmem;
10006850:	e30833b8 	movw	r3, #33720	; 0x83b8
10006854:	e3413002 	movt	r3, #4098	; 0x1002
10006858:	e51b200c 	ldr	r2, [fp, #-12]
1000685c:	e5832000 	str	r2, [r3]
        }
        pmem->next = mem->next;
10006860:	e51b3010 	ldr	r3, [fp, #-16]
10006864:	e5932004 	ldr	r2, [r3, #4]
10006868:	e51b300c 	ldr	r3, [fp, #-12]
1000686c:	e5832004 	str	r2, [r3, #4]
        ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
10006870:	e30833b0 	movw	r3, #33712	; 0x83b0
10006874:	e3413002 	movt	r3, #4098	; 0x1002
10006878:	e5932000 	ldr	r2, [r3]
1000687c:	e51b3010 	ldr	r3, [fp, #-16]
10006880:	e5933004 	ldr	r3, [r3, #4]
10006884:	e0822003 	add	r2, r2, r3
10006888:	e51b100c 	ldr	r1, [fp, #-12]
1000688c:	e30833b0 	movw	r3, #33712	; 0x83b0
10006890:	e3413002 	movt	r3, #4098	; 0x1002
10006894:	e5933000 	ldr	r3, [r3]
10006898:	e0633001 	rsb	r3, r3, r1
1000689c:	e5823008 	str	r3, [r2, #8]
    }
}
100068a0:	e24bd004 	sub	sp, fp, #4
100068a4:	e8bd8800 	pop	{fp, pc}

100068a8 <rt_system_heap_init>:
 *
 * @param begin_addr the beginning address of system heap memory.
 * @param end_addr the end address of system heap memory.
 */
void rt_system_heap_init(void *begin_addr, void *end_addr)
{
100068a8:	e92d4800 	push	{fp, lr}
100068ac:	e28db004 	add	fp, sp, #4
100068b0:	e24dd018 	sub	sp, sp, #24
100068b4:	e50b0018 	str	r0, [fp, #-24]
100068b8:	e50b101c 	str	r1, [fp, #-28]
    struct heap_mem *mem;
    rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
100068bc:	e51b3018 	ldr	r3, [fp, #-24]
100068c0:	e2833003 	add	r3, r3, #3
100068c4:	e3c33003 	bic	r3, r3, #3
100068c8:	e50b3008 	str	r3, [fp, #-8]
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
100068cc:	e51b301c 	ldr	r3, [fp, #-28]
100068d0:	e3c33003 	bic	r3, r3, #3
100068d4:	e50b300c 	str	r3, [fp, #-12]

    RT_DEBUG_NOT_IN_INTERRUPT;
100068d8:	eb0012f7 	bl	1000b4bc <rt_hw_interrupt_disable>
100068dc:	e50b0010 	str	r0, [fp, #-16]
100068e0:	ebfff836 	bl	100049c0 <rt_interrupt_get_nest>
100068e4:	e1a03000 	mov	r3, r0
100068e8:	e3530000 	cmp	r3, #0
100068ec:	0a00000a 	beq	1000691c <rt_system_heap_init+0x74>
100068f0:	e30e0888 	movw	r0, #59528	; 0xe888
100068f4:	e3410001 	movt	r0, #4097	; 0x1001
100068f8:	e30e1ae8 	movw	r1, #60136	; 0xeae8
100068fc:	e3411001 	movt	r1, #4097	; 0x1001
10006900:	ebfffe73 	bl	100062d4 <rt_kprintf>
10006904:	e30e08ac 	movw	r0, #59564	; 0xe8ac
10006908:	e3410001 	movt	r0, #4097	; 0x1001
1000690c:	e30e1ae8 	movw	r1, #60136	; 0xeae8
10006910:	e3411001 	movt	r1, #4097	; 0x1001
10006914:	e3a020be 	mov	r2, #190	; 0xbe
10006918:	ebffff2a 	bl	100065c8 <rt_assert_handler>
1000691c:	e51b0010 	ldr	r0, [fp, #-16]
10006920:	eb0012e9 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
10006924:	e51b300c 	ldr	r3, [fp, #-12]
10006928:	e3530018 	cmp	r3, #24
1000692c:	9a000053 	bls	10006a80 <rt_system_heap_init+0x1d8>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
10006930:	e51b300c 	ldr	r3, [fp, #-12]
10006934:	e2432018 	sub	r2, r3, #24
    rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);

    RT_DEBUG_NOT_IN_INTERRUPT;

    /* alignment addr */
    if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
10006938:	e51b3008 	ldr	r3, [fp, #-8]
1000693c:	e1520003 	cmp	r2, r3
10006940:	3a00004e 	bcc	10006a80 <rt_system_heap_init+0x1d8>
        ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
    {
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
10006944:	e51b200c 	ldr	r2, [fp, #-12]
10006948:	e51b3008 	ldr	r3, [fp, #-8]
1000694c:	e0633002 	rsb	r3, r3, r2
10006950:	e2432018 	sub	r2, r3, #24
10006954:	e30833d8 	movw	r3, #33752	; 0x83d8
10006958:	e3413002 	movt	r3, #4098	; 0x1002
1000695c:	e5832000 	str	r2, [r3]

        return;
    }

    /* point to begin address of heap */
    heap_ptr = (rt_uint8_t *)begin_align;
10006960:	e51b2008 	ldr	r2, [fp, #-8]
10006964:	e30833b0 	movw	r3, #33712	; 0x83b0
10006968:	e3413002 	movt	r3, #4098	; 0x1002
1000696c:	e5832000 	str	r2, [r3]

    RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
                                (rt_uint32_t)heap_ptr, mem_size_aligned));

    /* initialize the start of the heap */
    mem        = (struct heap_mem *)heap_ptr;
10006970:	e30833b0 	movw	r3, #33712	; 0x83b0
10006974:	e3413002 	movt	r3, #4098	; 0x1002
10006978:	e5933000 	ldr	r3, [r3]
1000697c:	e50b3014 	str	r3, [fp, #-20]
    mem->magic = HEAP_MAGIC;
10006980:	e51b3014 	ldr	r3, [fp, #-20]
10006984:	e3012ea0 	movw	r2, #7840	; 0x1ea0
10006988:	e1c320b0 	strh	r2, [r3]
    mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
1000698c:	e30833d8 	movw	r3, #33752	; 0x83d8
10006990:	e3413002 	movt	r3, #4098	; 0x1002
10006994:	e5933000 	ldr	r3, [r3]
10006998:	e283200c 	add	r2, r3, #12
1000699c:	e51b3014 	ldr	r3, [fp, #-20]
100069a0:	e5832004 	str	r2, [r3, #4]
    mem->prev  = 0;
100069a4:	e51b3014 	ldr	r3, [fp, #-20]
100069a8:	e3a02000 	mov	r2, #0
100069ac:	e5832008 	str	r2, [r3, #8]
    mem->used  = 0;
100069b0:	e51b3014 	ldr	r3, [fp, #-20]
100069b4:	e3a02000 	mov	r2, #0
100069b8:	e1c320b2 	strh	r2, [r3, #2]

    /* initialize the end of the heap */
    heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
100069bc:	e30833b0 	movw	r3, #33712	; 0x83b0
100069c0:	e3413002 	movt	r3, #4098	; 0x1002
100069c4:	e5932000 	ldr	r2, [r3]
100069c8:	e51b3014 	ldr	r3, [fp, #-20]
100069cc:	e5933004 	ldr	r3, [r3, #4]
100069d0:	e0822003 	add	r2, r2, r3
100069d4:	e30833b4 	movw	r3, #33716	; 0x83b4
100069d8:	e3413002 	movt	r3, #4098	; 0x1002
100069dc:	e5832000 	str	r2, [r3]
    heap_end->magic = HEAP_MAGIC;
100069e0:	e30833b4 	movw	r3, #33716	; 0x83b4
100069e4:	e3413002 	movt	r3, #4098	; 0x1002
100069e8:	e5933000 	ldr	r3, [r3]
100069ec:	e3012ea0 	movw	r2, #7840	; 0x1ea0
100069f0:	e1c320b0 	strh	r2, [r3]
    heap_end->used  = 1;
100069f4:	e30833b4 	movw	r3, #33716	; 0x83b4
100069f8:	e3413002 	movt	r3, #4098	; 0x1002
100069fc:	e5933000 	ldr	r3, [r3]
10006a00:	e3a02001 	mov	r2, #1
10006a04:	e1c320b2 	strh	r2, [r3, #2]
    heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
10006a08:	e30833b4 	movw	r3, #33716	; 0x83b4
10006a0c:	e3413002 	movt	r3, #4098	; 0x1002
10006a10:	e5932000 	ldr	r2, [r3]
10006a14:	e30833d8 	movw	r3, #33752	; 0x83d8
10006a18:	e3413002 	movt	r3, #4098	; 0x1002
10006a1c:	e5933000 	ldr	r3, [r3]
10006a20:	e283300c 	add	r3, r3, #12
10006a24:	e5823004 	str	r3, [r2, #4]
    heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
10006a28:	e30833b4 	movw	r3, #33716	; 0x83b4
10006a2c:	e3413002 	movt	r3, #4098	; 0x1002
10006a30:	e5932000 	ldr	r2, [r3]
10006a34:	e30833d8 	movw	r3, #33752	; 0x83d8
10006a38:	e3413002 	movt	r3, #4098	; 0x1002
10006a3c:	e5933000 	ldr	r3, [r3]
10006a40:	e283300c 	add	r3, r3, #12
10006a44:	e5823008 	str	r3, [r2, #8]

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
10006a48:	e30803bc 	movw	r0, #33724	; 0x83bc
10006a4c:	e3410002 	movt	r0, #4098	; 0x1002
10006a50:	e30e18ec 	movw	r1, #59628	; 0xe8ec
10006a54:	e3411001 	movt	r1, #4097	; 0x1001
10006a58:	e3a02001 	mov	r2, #1
10006a5c:	e3a03000 	mov	r3, #0
10006a60:	ebffec1a 	bl	10001ad0 <rt_sem_init>

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
10006a64:	e30833b0 	movw	r3, #33712	; 0x83b0
10006a68:	e3413002 	movt	r3, #4098	; 0x1002
10006a6c:	e5932000 	ldr	r2, [r3]
10006a70:	e30833b8 	movw	r3, #33720	; 0x83b8
10006a74:	e3413002 	movt	r3, #4098	; 0x1002
10006a78:	e5832000 	str	r2, [r3]
10006a7c:	ea000007 	b	10006aa0 <rt_system_heap_init+0x1f8>
        /* calculate the aligned memory size */
        mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
    }
    else
    {
        rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
10006a80:	e51b2018 	ldr	r2, [fp, #-24]
10006a84:	e51b301c 	ldr	r3, [fp, #-28]
10006a88:	e30e08b0 	movw	r0, #59568	; 0xe8b0
10006a8c:	e3410001 	movt	r0, #4097	; 0x1001
10006a90:	e1a01002 	mov	r1, r2
10006a94:	e1a02003 	mov	r2, r3
10006a98:	ebfffe0d 	bl	100062d4 <rt_kprintf>
                   (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);

        return;
10006a9c:	e1a00000 	nop			; (mov r0, r0)

    rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);

    /* initialize the lowest-free pointer to the start of the heap */
    lfree = (struct heap_mem *)heap_ptr;
}
10006aa0:	e24bd004 	sub	sp, fp, #4
10006aa4:	e8bd8800 	pop	{fp, pc}

10006aa8 <rt_malloc>:
 * @param size is the minimum size of the requested block in bytes.
 *
 * @return pointer to allocated memory or NULL if no free memory was found.
 */
void *rt_malloc(rt_size_t size)
{
10006aa8:	e92d4800 	push	{fp, lr}
10006aac:	e28db004 	add	fp, sp, #4
10006ab0:	e24dd020 	sub	sp, sp, #32
10006ab4:	e50b0020 	str	r0, [fp, #-32]
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;

    RT_DEBUG_NOT_IN_INTERRUPT;
10006ab8:	eb00127f 	bl	1000b4bc <rt_hw_interrupt_disable>
10006abc:	e50b000c 	str	r0, [fp, #-12]
10006ac0:	ebfff7be 	bl	100049c0 <rt_interrupt_get_nest>
10006ac4:	e1a03000 	mov	r3, r0
10006ac8:	e3530000 	cmp	r3, #0
10006acc:	0a00000a 	beq	10006afc <rt_malloc+0x54>
10006ad0:	e30e0888 	movw	r0, #59528	; 0xe888
10006ad4:	e3410001 	movt	r0, #4097	; 0x1001
10006ad8:	e30e1afc 	movw	r1, #60156	; 0xeafc
10006adc:	e3411001 	movt	r1, #4097	; 0x1001
10006ae0:	ebfffdfb 	bl	100062d4 <rt_kprintf>
10006ae4:	e30e08ac 	movw	r0, #59564	; 0xe8ac
10006ae8:	e3410001 	movt	r0, #4097	; 0x1001
10006aec:	e30e1afc 	movw	r1, #60156	; 0xeafc
10006af0:	e3411001 	movt	r1, #4097	; 0x1001
10006af4:	e3a020fb 	mov	r2, #251	; 0xfb
10006af8:	ebfffeb2 	bl	100065c8 <rt_assert_handler>
10006afc:	e51b000c 	ldr	r0, [fp, #-12]
10006b00:	eb001271 	bl	1000b4cc <rt_hw_interrupt_enable>

    if (size == 0)
10006b04:	e51b3020 	ldr	r3, [fp, #-32]
10006b08:	e3530000 	cmp	r3, #0
10006b0c:	1a000001 	bne	10006b18 <rt_malloc+0x70>
        return RT_NULL;
10006b10:	e3a03000 	mov	r3, #0
10006b14:	ea00011e 	b	10006f94 <rt_malloc+0x4ec>
                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));
    else
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));

    /* alignment size */
    size = RT_ALIGN(size, RT_ALIGN_SIZE);
10006b18:	e51b3020 	ldr	r3, [fp, #-32]
10006b1c:	e2833003 	add	r3, r3, #3
10006b20:	e3c33003 	bic	r3, r3, #3
10006b24:	e50b3020 	str	r3, [fp, #-32]

    if (size > mem_size_aligned)
10006b28:	e30833d8 	movw	r3, #33752	; 0x83d8
10006b2c:	e3413002 	movt	r3, #4098	; 0x1002
10006b30:	e5933000 	ldr	r3, [r3]
10006b34:	e51b2020 	ldr	r2, [fp, #-32]
10006b38:	e1520003 	cmp	r2, r3
10006b3c:	9a000001 	bls	10006b48 <rt_malloc+0xa0>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));

        return RT_NULL;
10006b40:	e3a03000 	mov	r3, #0
10006b44:	ea000112 	b	10006f94 <rt_malloc+0x4ec>
    }

    /* every data block must be at least MIN_SIZE_ALIGNED long */
    if (size < MIN_SIZE_ALIGNED)
10006b48:	e51b3020 	ldr	r3, [fp, #-32]
10006b4c:	e353000b 	cmp	r3, #11
10006b50:	8a000001 	bhi	10006b5c <rt_malloc+0xb4>
        size = MIN_SIZE_ALIGNED;
10006b54:	e3a0300c 	mov	r3, #12
10006b58:	e50b3020 	str	r3, [fp, #-32]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
10006b5c:	e30803bc 	movw	r0, #33724	; 0x83bc
10006b60:	e3410002 	movt	r0, #4098	; 0x1002
10006b64:	e3e01000 	mvn	r1, #0
10006b68:	ebffec6f 	bl	10001d2c <rt_sem_take>

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
10006b6c:	e30833b8 	movw	r3, #33720	; 0x83b8
10006b70:	e3413002 	movt	r3, #4098	; 0x1002
10006b74:	e5933000 	ldr	r3, [r3]
10006b78:	e1a02003 	mov	r2, r3
10006b7c:	e30833b0 	movw	r3, #33712	; 0x83b0
10006b80:	e3413002 	movt	r3, #4098	; 0x1002
10006b84:	e5933000 	ldr	r3, [r3]
10006b88:	e0633002 	rsb	r3, r3, r2
10006b8c:	e50b3008 	str	r3, [fp, #-8]
10006b90:	ea0000f3 	b	10006f64 <rt_malloc+0x4bc>
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
    {
        mem = (struct heap_mem *)&heap_ptr[ptr];
10006b94:	e30833b0 	movw	r3, #33712	; 0x83b0
10006b98:	e3413002 	movt	r3, #4098	; 0x1002
10006b9c:	e5932000 	ldr	r2, [r3]
10006ba0:	e51b3008 	ldr	r3, [fp, #-8]
10006ba4:	e0823003 	add	r3, r2, r3
10006ba8:	e50b3010 	str	r3, [fp, #-16]

        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
10006bac:	e51b3010 	ldr	r3, [fp, #-16]
10006bb0:	e1d330b2 	ldrh	r3, [r3, #2]
10006bb4:	e3530000 	cmp	r3, #0
10006bb8:	1a0000e2 	bne	10006f48 <rt_malloc+0x4a0>
10006bbc:	e51b3010 	ldr	r3, [fp, #-16]
10006bc0:	e5932004 	ldr	r2, [r3, #4]
10006bc4:	e51b3008 	ldr	r3, [fp, #-8]
10006bc8:	e0633002 	rsb	r3, r3, r2
10006bcc:	e243200c 	sub	r2, r3, #12
10006bd0:	e51b3020 	ldr	r3, [fp, #-32]
10006bd4:	e1520003 	cmp	r2, r3
10006bd8:	3a0000da 	bcc	10006f48 <rt_malloc+0x4a0>
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
10006bdc:	e51b3010 	ldr	r3, [fp, #-16]
10006be0:	e5932004 	ldr	r2, [r3, #4]
10006be4:	e51b3008 	ldr	r3, [fp, #-8]
10006be8:	e0633002 	rsb	r3, r3, r2
10006bec:	e243200c 	sub	r2, r3, #12
                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
10006bf0:	e51b3020 	ldr	r3, [fp, #-32]
10006bf4:	e2833018 	add	r3, r3, #24
        if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
        {
            /* mem is not used and at least perfect fit is possible:
             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
10006bf8:	e1520003 	cmp	r2, r3
10006bfc:	3a000042 	bcc	10006d0c <rt_malloc+0x264>
                 * struct heap_mem would fit in but no data between mem2 and mem2->next
                 * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
                 *       region that couldn't hold data, but when mem->next gets freed,
                 *       the 2 regions would be combined, resulting in more free memory
                 */
                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
10006c00:	e51b2008 	ldr	r2, [fp, #-8]
10006c04:	e51b3020 	ldr	r3, [fp, #-32]
10006c08:	e0823003 	add	r3, r2, r3
10006c0c:	e283300c 	add	r3, r3, #12
10006c10:	e50b3014 	str	r3, [fp, #-20]

                /* create mem2 struct */
                mem2       = (struct heap_mem *)&heap_ptr[ptr2];
10006c14:	e30833b0 	movw	r3, #33712	; 0x83b0
10006c18:	e3413002 	movt	r3, #4098	; 0x1002
10006c1c:	e5932000 	ldr	r2, [r3]
10006c20:	e51b3014 	ldr	r3, [fp, #-20]
10006c24:	e0823003 	add	r3, r2, r3
10006c28:	e50b3018 	str	r3, [fp, #-24]
                mem2->used = 0;
10006c2c:	e51b3018 	ldr	r3, [fp, #-24]
10006c30:	e3a02000 	mov	r2, #0
10006c34:	e1c320b2 	strh	r2, [r3, #2]
                mem2->next = mem->next;
10006c38:	e51b3010 	ldr	r3, [fp, #-16]
10006c3c:	e5932004 	ldr	r2, [r3, #4]
10006c40:	e51b3018 	ldr	r3, [fp, #-24]
10006c44:	e5832004 	str	r2, [r3, #4]
                mem2->prev = ptr;
10006c48:	e51b3018 	ldr	r3, [fp, #-24]
10006c4c:	e51b2008 	ldr	r2, [fp, #-8]
10006c50:	e5832008 	str	r2, [r3, #8]

                /* and insert it between mem and mem->next */
                mem->next = ptr2;
10006c54:	e51b3010 	ldr	r3, [fp, #-16]
10006c58:	e51b2014 	ldr	r2, [fp, #-20]
10006c5c:	e5832004 	str	r2, [r3, #4]
                mem->used = 1;
10006c60:	e51b3010 	ldr	r3, [fp, #-16]
10006c64:	e3a02001 	mov	r2, #1
10006c68:	e1c320b2 	strh	r2, [r3, #2]

                if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
10006c6c:	e51b3018 	ldr	r3, [fp, #-24]
10006c70:	e5932004 	ldr	r2, [r3, #4]
10006c74:	e30833d8 	movw	r3, #33752	; 0x83d8
10006c78:	e3413002 	movt	r3, #4098	; 0x1002
10006c7c:	e5933000 	ldr	r3, [r3]
10006c80:	e283300c 	add	r3, r3, #12
10006c84:	e1520003 	cmp	r2, r3
10006c88:	0a000007 	beq	10006cac <rt_malloc+0x204>
                {
                    ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
10006c8c:	e30833b0 	movw	r3, #33712	; 0x83b0
10006c90:	e3413002 	movt	r3, #4098	; 0x1002
10006c94:	e5932000 	ldr	r2, [r3]
10006c98:	e51b3018 	ldr	r3, [fp, #-24]
10006c9c:	e5933004 	ldr	r3, [r3, #4]
10006ca0:	e0823003 	add	r3, r2, r3
10006ca4:	e51b2014 	ldr	r2, [fp, #-20]
10006ca8:	e5832008 	str	r2, [r3, #8]
                }
#ifdef RT_MEM_STATS
                used_mem += (size + SIZEOF_STRUCT_MEM);
10006cac:	e30833dc 	movw	r3, #33756	; 0x83dc
10006cb0:	e3413002 	movt	r3, #4098	; 0x1002
10006cb4:	e5932000 	ldr	r2, [r3]
10006cb8:	e51b3020 	ldr	r3, [fp, #-32]
10006cbc:	e0823003 	add	r3, r2, r3
10006cc0:	e283200c 	add	r2, r3, #12
10006cc4:	e30833dc 	movw	r3, #33756	; 0x83dc
10006cc8:	e3413002 	movt	r3, #4098	; 0x1002
10006ccc:	e5832000 	str	r2, [r3]
                if (max_mem < used_mem)
10006cd0:	e30833e0 	movw	r3, #33760	; 0x83e0
10006cd4:	e3413002 	movt	r3, #4098	; 0x1002
10006cd8:	e5932000 	ldr	r2, [r3]
10006cdc:	e30833dc 	movw	r3, #33756	; 0x83dc
10006ce0:	e3413002 	movt	r3, #4098	; 0x1002
10006ce4:	e5933000 	ldr	r3, [r3]
10006ce8:	e1520003 	cmp	r2, r3
10006cec:	2a000027 	bcs	10006d90 <rt_malloc+0x2e8>
                    max_mem = used_mem;
10006cf0:	e30833dc 	movw	r3, #33756	; 0x83dc
10006cf4:	e3413002 	movt	r3, #4098	; 0x1002
10006cf8:	e5932000 	ldr	r2, [r3]
10006cfc:	e30833e0 	movw	r3, #33760	; 0x83e0
10006d00:	e3413002 	movt	r3, #4098	; 0x1002
10006d04:	e5832000 	str	r2, [r3]
10006d08:	ea000020 	b	10006d90 <rt_malloc+0x2e8>
                 * take care of this).
                 * -> near fit or excact fit: do not split, no mem2 creation
                 * also can't move mem->next directly behind mem, since mem->next
                 * will always be used at this point!
                 */
                mem->used = 1;
10006d0c:	e51b3010 	ldr	r3, [fp, #-16]
10006d10:	e3a02001 	mov	r2, #1
10006d14:	e1c320b2 	strh	r2, [r3, #2]
#ifdef RT_MEM_STATS
                used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
10006d18:	e51b3010 	ldr	r3, [fp, #-16]
10006d1c:	e5932004 	ldr	r2, [r3, #4]
10006d20:	e30833b0 	movw	r3, #33712	; 0x83b0
10006d24:	e3413002 	movt	r3, #4098	; 0x1002
10006d28:	e5933000 	ldr	r3, [r3]
10006d2c:	e1a01003 	mov	r1, r3
10006d30:	e51b3010 	ldr	r3, [fp, #-16]
10006d34:	e0633001 	rsb	r3, r3, r1
10006d38:	e0822003 	add	r2, r2, r3
10006d3c:	e30833dc 	movw	r3, #33756	; 0x83dc
10006d40:	e3413002 	movt	r3, #4098	; 0x1002
10006d44:	e5933000 	ldr	r3, [r3]
10006d48:	e0822003 	add	r2, r2, r3
10006d4c:	e30833dc 	movw	r3, #33756	; 0x83dc
10006d50:	e3413002 	movt	r3, #4098	; 0x1002
10006d54:	e5832000 	str	r2, [r3]
                if (max_mem < used_mem)
10006d58:	e30833e0 	movw	r3, #33760	; 0x83e0
10006d5c:	e3413002 	movt	r3, #4098	; 0x1002
10006d60:	e5932000 	ldr	r2, [r3]
10006d64:	e30833dc 	movw	r3, #33756	; 0x83dc
10006d68:	e3413002 	movt	r3, #4098	; 0x1002
10006d6c:	e5933000 	ldr	r3, [r3]
10006d70:	e1520003 	cmp	r2, r3
10006d74:	2a000005 	bcs	10006d90 <rt_malloc+0x2e8>
                    max_mem = used_mem;
10006d78:	e30833dc 	movw	r3, #33756	; 0x83dc
10006d7c:	e3413002 	movt	r3, #4098	; 0x1002
10006d80:	e5932000 	ldr	r2, [r3]
10006d84:	e30833e0 	movw	r3, #33760	; 0x83e0
10006d88:	e3413002 	movt	r3, #4098	; 0x1002
10006d8c:	e5832000 	str	r2, [r3]
#endif
            }
            /* set memory block magic */
            mem->magic = HEAP_MAGIC;
10006d90:	e51b3010 	ldr	r3, [fp, #-16]
10006d94:	e3012ea0 	movw	r2, #7840	; 0x1ea0
10006d98:	e1c320b0 	strh	r2, [r3]

            if (mem == lfree)
10006d9c:	e30833b8 	movw	r3, #33720	; 0x83b8
10006da0:	e3413002 	movt	r3, #4098	; 0x1002
10006da4:	e5933000 	ldr	r3, [r3]
10006da8:	e51b2010 	ldr	r2, [fp, #-16]
10006dac:	e1520003 	cmp	r2, r3
10006db0:	1a00002d 	bne	10006e6c <rt_malloc+0x3c4>
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
10006db4:	ea00000a 	b	10006de4 <rt_malloc+0x33c>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];
10006db8:	e30833b0 	movw	r3, #33712	; 0x83b0
10006dbc:	e3413002 	movt	r3, #4098	; 0x1002
10006dc0:	e5932000 	ldr	r2, [r3]
10006dc4:	e30833b8 	movw	r3, #33720	; 0x83b8
10006dc8:	e3413002 	movt	r3, #4098	; 0x1002
10006dcc:	e5933000 	ldr	r3, [r3]
10006dd0:	e5933004 	ldr	r3, [r3, #4]
10006dd4:	e0822003 	add	r2, r2, r3
10006dd8:	e30833b8 	movw	r3, #33720	; 0x83b8
10006ddc:	e3413002 	movt	r3, #4098	; 0x1002
10006de0:	e5832000 	str	r2, [r3]
            mem->magic = HEAP_MAGIC;

            if (mem == lfree)
            {
                /* Find next free block after mem and update lowest free pointer */
                while (lfree->used && lfree != heap_end)
10006de4:	e30833b8 	movw	r3, #33720	; 0x83b8
10006de8:	e3413002 	movt	r3, #4098	; 0x1002
10006dec:	e5933000 	ldr	r3, [r3]
10006df0:	e1d330b2 	ldrh	r3, [r3, #2]
10006df4:	e3530000 	cmp	r3, #0
10006df8:	0a000007 	beq	10006e1c <rt_malloc+0x374>
10006dfc:	e30833b8 	movw	r3, #33720	; 0x83b8
10006e00:	e3413002 	movt	r3, #4098	; 0x1002
10006e04:	e5932000 	ldr	r2, [r3]
10006e08:	e30833b4 	movw	r3, #33716	; 0x83b4
10006e0c:	e3413002 	movt	r3, #4098	; 0x1002
10006e10:	e5933000 	ldr	r3, [r3]
10006e14:	e1520003 	cmp	r2, r3
10006e18:	1affffe6 	bne	10006db8 <rt_malloc+0x310>
                    lfree = (struct heap_mem *)&heap_ptr[lfree->next];

                RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
10006e1c:	e30833b8 	movw	r3, #33720	; 0x83b8
10006e20:	e3413002 	movt	r3, #4098	; 0x1002
10006e24:	e5932000 	ldr	r2, [r3]
10006e28:	e30833b4 	movw	r3, #33716	; 0x83b4
10006e2c:	e3413002 	movt	r3, #4098	; 0x1002
10006e30:	e5933000 	ldr	r3, [r3]
10006e34:	e1520003 	cmp	r2, r3
10006e38:	0a00000b 	beq	10006e6c <rt_malloc+0x3c4>
10006e3c:	e30833b8 	movw	r3, #33720	; 0x83b8
10006e40:	e3413002 	movt	r3, #4098	; 0x1002
10006e44:	e5933000 	ldr	r3, [r3]
10006e48:	e1d330b2 	ldrh	r3, [r3, #2]
10006e4c:	e3530000 	cmp	r3, #0
10006e50:	0a000005 	beq	10006e6c <rt_malloc+0x3c4>
10006e54:	e30e08f4 	movw	r0, #59636	; 0xe8f4
10006e58:	e3410001 	movt	r0, #4097	; 0x1001
10006e5c:	e30e1afc 	movw	r1, #60156	; 0xeafc
10006e60:	e3411001 	movt	r1, #4097	; 0x1001
10006e64:	e300215e 	movw	r2, #350	; 0x15e
10006e68:	ebfffdd6 	bl	100065c8 <rt_assert_handler>
            }

            rt_sem_release(&heap_sem);
10006e6c:	e30803bc 	movw	r0, #33724	; 0x83bc
10006e70:	e3410002 	movt	r0, #4098	; 0x1002
10006e74:	ebffec40 	bl	10001f7c <rt_sem_release>
            RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
10006e78:	e51b2010 	ldr	r2, [fp, #-16]
10006e7c:	e51b3020 	ldr	r3, [fp, #-32]
10006e80:	e0823003 	add	r3, r2, r3
10006e84:	e283200c 	add	r2, r3, #12
10006e88:	e30833b4 	movw	r3, #33716	; 0x83b4
10006e8c:	e3413002 	movt	r3, #4098	; 0x1002
10006e90:	e5933000 	ldr	r3, [r3]
10006e94:	e1520003 	cmp	r2, r3
10006e98:	9a000005 	bls	10006eb4 <rt_malloc+0x40c>
10006e9c:	e30e091c 	movw	r0, #59676	; 0xe91c
10006ea0:	e3410001 	movt	r0, #4097	; 0x1001
10006ea4:	e30e1afc 	movw	r1, #60156	; 0xeafc
10006ea8:	e3411001 	movt	r1, #4097	; 0x1001
10006eac:	e3002162 	movw	r2, #354	; 0x162
10006eb0:	ebfffdc4 	bl	100065c8 <rt_assert_handler>
            RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
10006eb4:	e51b3010 	ldr	r3, [fp, #-16]
10006eb8:	e283300c 	add	r3, r3, #12
10006ebc:	e2033003 	and	r3, r3, #3
10006ec0:	e3530000 	cmp	r3, #0
10006ec4:	0a000005 	beq	10006ee0 <rt_malloc+0x438>
10006ec8:	e30e0964 	movw	r0, #59748	; 0xe964
10006ecc:	e3410001 	movt	r0, #4097	; 0x1001
10006ed0:	e30e1afc 	movw	r1, #60156	; 0xeafc
10006ed4:	e3411001 	movt	r1, #4097	; 0x1001
10006ed8:	e3002163 	movw	r2, #355	; 0x163
10006edc:	ebfffdb9 	bl	100065c8 <rt_assert_handler>
            RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
10006ee0:	e51b3010 	ldr	r3, [fp, #-16]
10006ee4:	e2033003 	and	r3, r3, #3
10006ee8:	e3530000 	cmp	r3, #0
10006eec:	0a000005 	beq	10006f08 <rt_malloc+0x460>
10006ef0:	e30e09b0 	movw	r0, #59824	; 0xe9b0
10006ef4:	e3410001 	movt	r0, #4097	; 0x1001
10006ef8:	e30e1afc 	movw	r1, #60156	; 0xeafc
10006efc:	e3411001 	movt	r1, #4097	; 0x1001
10006f00:	e3a02f59 	mov	r2, #356	; 0x164
10006f04:	ebfffdaf 	bl	100065c8 <rt_assert_handler>
            RT_DEBUG_LOG(RT_DEBUG_MEM,
                         ("allocate memory at 0x%x, size: %d\n",
                          (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
                          (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));

            RT_OBJECT_HOOK_CALL(rt_malloc_hook,
10006f08:	e30833a8 	movw	r3, #33704	; 0x83a8
10006f0c:	e3413002 	movt	r3, #4098	; 0x1002
10006f10:	e5933000 	ldr	r3, [r3]
10006f14:	e3530000 	cmp	r3, #0
10006f18:	0a000007 	beq	10006f3c <rt_malloc+0x494>
10006f1c:	e30833a8 	movw	r3, #33704	; 0x83a8
10006f20:	e3413002 	movt	r3, #4098	; 0x1002
10006f24:	e5933000 	ldr	r3, [r3]
10006f28:	e51b2010 	ldr	r2, [fp, #-16]
10006f2c:	e282200c 	add	r2, r2, #12
10006f30:	e1a00002 	mov	r0, r2
10006f34:	e51b1020 	ldr	r1, [fp, #-32]
10006f38:	e12fff33 	blx	r3
                                (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));

            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
10006f3c:	e51b3010 	ldr	r3, [fp, #-16]
10006f40:	e283300c 	add	r3, r3, #12
10006f44:	ea000012 	b	10006f94 <rt_malloc+0x4ec>
    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
         ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
10006f48:	e30833b0 	movw	r3, #33712	; 0x83b0
10006f4c:	e3413002 	movt	r3, #4098	; 0x1002
10006f50:	e5932000 	ldr	r2, [r3]
10006f54:	e51b3008 	ldr	r3, [fp, #-8]
10006f58:	e0823003 	add	r3, r2, r3
10006f5c:	e5933004 	ldr	r3, [r3, #4]
10006f60:	e50b3008 	str	r3, [fp, #-8]

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
         ptr < mem_size_aligned - size;
10006f64:	e30833d8 	movw	r3, #33752	; 0x83d8
10006f68:	e3413002 	movt	r3, #4098	; 0x1002
10006f6c:	e5932000 	ldr	r2, [r3]
10006f70:	e51b3020 	ldr	r3, [fp, #-32]
10006f74:	e0632002 	rsb	r2, r3, r2
        size = MIN_SIZE_ALIGNED;

    /* take memory semaphore */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    for (ptr = (rt_uint8_t *)lfree - heap_ptr;
10006f78:	e51b3008 	ldr	r3, [fp, #-8]
10006f7c:	e1520003 	cmp	r2, r3
10006f80:	8affff03 	bhi	10006b94 <rt_malloc+0xec>
            /* return the memory data except mem struct */
            return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
        }
    }

    rt_sem_release(&heap_sem);
10006f84:	e30803bc 	movw	r0, #33724	; 0x83bc
10006f88:	e3410002 	movt	r0, #4098	; 0x1002
10006f8c:	ebffebfa 	bl	10001f7c <rt_sem_release>

    return RT_NULL;
10006f90:	e3a03000 	mov	r3, #0
}
10006f94:	e1a00003 	mov	r0, r3
10006f98:	e24bd004 	sub	sp, fp, #4
10006f9c:	e8bd8800 	pop	{fp, pc}

10006fa0 <rt_realloc>:
 * @param newsize the required new size
 *
 * @return the changed memory block address
 */
void *rt_realloc(void *rmem, rt_size_t newsize)
{
10006fa0:	e92d4800 	push	{fp, lr}
10006fa4:	e28db004 	add	fp, sp, #4
10006fa8:	e24dd028 	sub	sp, sp, #40	; 0x28
10006fac:	e50b0028 	str	r0, [fp, #-40]	; 0x28
10006fb0:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
    rt_size_t size;
    rt_size_t ptr, ptr2;
    struct heap_mem *mem, *mem2;
    void *nmem;

    RT_DEBUG_NOT_IN_INTERRUPT;
10006fb4:	eb001140 	bl	1000b4bc <rt_hw_interrupt_disable>
10006fb8:	e50b0008 	str	r0, [fp, #-8]
10006fbc:	ebfff67f 	bl	100049c0 <rt_interrupt_get_nest>
10006fc0:	e1a03000 	mov	r3, r0
10006fc4:	e3530000 	cmp	r3, #0
10006fc8:	0a00000a 	beq	10006ff8 <rt_realloc+0x58>
10006fcc:	e30e0888 	movw	r0, #59528	; 0xe888
10006fd0:	e3410001 	movt	r0, #4097	; 0x1001
10006fd4:	e30e1b08 	movw	r1, #60168	; 0xeb08
10006fd8:	e3411001 	movt	r1, #4097	; 0x1001
10006fdc:	ebfffcbc 	bl	100062d4 <rt_kprintf>
10006fe0:	e30e08ac 	movw	r0, #59564	; 0xe8ac
10006fe4:	e3410001 	movt	r0, #4097	; 0x1001
10006fe8:	e30e1b08 	movw	r1, #60168	; 0xeb08
10006fec:	e3411001 	movt	r1, #4097	; 0x1001
10006ff0:	e3a02f62 	mov	r2, #392	; 0x188
10006ff4:	ebfffd73 	bl	100065c8 <rt_assert_handler>
10006ff8:	e51b0008 	ldr	r0, [fp, #-8]
10006ffc:	eb001132 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* alignment size */
    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
10007000:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10007004:	e2833003 	add	r3, r3, #3
10007008:	e3c33003 	bic	r3, r3, #3
1000700c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    if (newsize > mem_size_aligned)
10007010:	e30833d8 	movw	r3, #33752	; 0x83d8
10007014:	e3413002 	movt	r3, #4098	; 0x1002
10007018:	e5933000 	ldr	r3, [r3]
1000701c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
10007020:	e1520003 	cmp	r2, r3
10007024:	9a000001 	bls	10007030 <rt_realloc+0x90>
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));

        return RT_NULL;
10007028:	e3a03000 	mov	r3, #0
1000702c:	ea000089 	b	10007258 <rt_realloc+0x2b8>
    }

    /* allocate a new memory block */
    if (rmem == RT_NULL)
10007030:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10007034:	e3530000 	cmp	r3, #0
10007038:	1a000003 	bne	1000704c <rt_realloc+0xac>
        return rt_malloc(newsize);
1000703c:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
10007040:	ebfffe98 	bl	10006aa8 <rt_malloc>
10007044:	e1a03000 	mov	r3, r0
10007048:	ea000082 	b	10007258 <rt_realloc+0x2b8>

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
1000704c:	e30803bc 	movw	r0, #33724	; 0x83bc
10007050:	e3410002 	movt	r0, #4098	; 0x1002
10007054:	e3e01000 	mvn	r1, #0
10007058:	ebffeb33 	bl	10001d2c <rt_sem_take>

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
1000705c:	e30833b0 	movw	r3, #33712	; 0x83b0
10007060:	e3413002 	movt	r3, #4098	; 0x1002
10007064:	e5933000 	ldr	r3, [r3]
10007068:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1000706c:	e1520003 	cmp	r2, r3
10007070:	3a000005 	bcc	1000708c <rt_realloc+0xec>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
10007074:	e30833b4 	movw	r3, #33716	; 0x83b4
10007078:	e3413002 	movt	r3, #4098	; 0x1002
1000707c:	e5933000 	ldr	r3, [r3]
    if (rmem == RT_NULL)
        return rt_malloc(newsize);

    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
10007080:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10007084:	e1520003 	cmp	r2, r3
10007088:	3a000004 	bcc	100070a0 <rt_realloc+0x100>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        /* illegal memory */
        rt_sem_release(&heap_sem);
1000708c:	e30803bc 	movw	r0, #33724	; 0x83bc
10007090:	e3410002 	movt	r0, #4098	; 0x1002
10007094:	ebffebb8 	bl	10001f7c <rt_sem_release>

        return rmem;
10007098:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000709c:	ea00006d 	b	10007258 <rt_realloc+0x2b8>
    }

    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
100070a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100070a4:	e243300c 	sub	r3, r3, #12
100070a8:	e50b300c 	str	r3, [fp, #-12]

    ptr = (rt_uint8_t *)mem - heap_ptr;
100070ac:	e51b200c 	ldr	r2, [fp, #-12]
100070b0:	e30833b0 	movw	r3, #33712	; 0x83b0
100070b4:	e3413002 	movt	r3, #4098	; 0x1002
100070b8:	e5933000 	ldr	r3, [r3]
100070bc:	e0633002 	rsb	r3, r3, r2
100070c0:	e50b3010 	str	r3, [fp, #-16]
    size = mem->next - ptr - SIZEOF_STRUCT_MEM;
100070c4:	e51b300c 	ldr	r3, [fp, #-12]
100070c8:	e5932004 	ldr	r2, [r3, #4]
100070cc:	e51b3010 	ldr	r3, [fp, #-16]
100070d0:	e0633002 	rsb	r3, r3, r2
100070d4:	e243300c 	sub	r3, r3, #12
100070d8:	e50b3014 	str	r3, [fp, #-20]
    if (size == newsize)
100070dc:	e51b2014 	ldr	r2, [fp, #-20]
100070e0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
100070e4:	e1520003 	cmp	r2, r3
100070e8:	1a000004 	bne	10007100 <rt_realloc+0x160>
    {
        /* the size is the same as */
        rt_sem_release(&heap_sem);
100070ec:	e30803bc 	movw	r0, #33724	; 0x83bc
100070f0:	e3410002 	movt	r0, #4098	; 0x1002
100070f4:	ebffeba0 	bl	10001f7c <rt_sem_release>

        return rmem;
100070f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100070fc:	ea000055 	b	10007258 <rt_realloc+0x2b8>
    }

    if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
10007100:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10007104:	e2832018 	add	r2, r3, #24
10007108:	e51b3014 	ldr	r3, [fp, #-20]
1000710c:	e1520003 	cmp	r2, r3
10007110:	2a00003b 	bcs	10007204 <rt_realloc+0x264>
    {
        /* split memory block */
#ifdef RT_MEM_STATS
        used_mem -= (size - newsize);
10007114:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
10007118:	e51b3014 	ldr	r3, [fp, #-20]
1000711c:	e0632002 	rsb	r2, r3, r2
10007120:	e30833dc 	movw	r3, #33756	; 0x83dc
10007124:	e3413002 	movt	r3, #4098	; 0x1002
10007128:	e5933000 	ldr	r3, [r3]
1000712c:	e0822003 	add	r2, r2, r3
10007130:	e30833dc 	movw	r3, #33756	; 0x83dc
10007134:	e3413002 	movt	r3, #4098	; 0x1002
10007138:	e5832000 	str	r2, [r3]
#endif

        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
1000713c:	e51b2010 	ldr	r2, [fp, #-16]
10007140:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10007144:	e0823003 	add	r3, r2, r3
10007148:	e283300c 	add	r3, r3, #12
1000714c:	e50b3018 	str	r3, [fp, #-24]
        mem2 = (struct heap_mem *)&heap_ptr[ptr2];
10007150:	e30833b0 	movw	r3, #33712	; 0x83b0
10007154:	e3413002 	movt	r3, #4098	; 0x1002
10007158:	e5932000 	ldr	r2, [r3]
1000715c:	e51b3018 	ldr	r3, [fp, #-24]
10007160:	e0823003 	add	r3, r2, r3
10007164:	e50b301c 	str	r3, [fp, #-28]
        mem2->magic= HEAP_MAGIC;
10007168:	e51b301c 	ldr	r3, [fp, #-28]
1000716c:	e3012ea0 	movw	r2, #7840	; 0x1ea0
10007170:	e1c320b0 	strh	r2, [r3]
        mem2->used = 0;
10007174:	e51b301c 	ldr	r3, [fp, #-28]
10007178:	e3a02000 	mov	r2, #0
1000717c:	e1c320b2 	strh	r2, [r3, #2]
        mem2->next = mem->next;
10007180:	e51b300c 	ldr	r3, [fp, #-12]
10007184:	e5932004 	ldr	r2, [r3, #4]
10007188:	e51b301c 	ldr	r3, [fp, #-28]
1000718c:	e5832004 	str	r2, [r3, #4]
        mem2->prev = ptr;
10007190:	e51b301c 	ldr	r3, [fp, #-28]
10007194:	e51b2010 	ldr	r2, [fp, #-16]
10007198:	e5832008 	str	r2, [r3, #8]
        mem->next = ptr2;
1000719c:	e51b300c 	ldr	r3, [fp, #-12]
100071a0:	e51b2018 	ldr	r2, [fp, #-24]
100071a4:	e5832004 	str	r2, [r3, #4]
        if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
100071a8:	e51b301c 	ldr	r3, [fp, #-28]
100071ac:	e5932004 	ldr	r2, [r3, #4]
100071b0:	e30833d8 	movw	r3, #33752	; 0x83d8
100071b4:	e3413002 	movt	r3, #4098	; 0x1002
100071b8:	e5933000 	ldr	r3, [r3]
100071bc:	e283300c 	add	r3, r3, #12
100071c0:	e1520003 	cmp	r2, r3
100071c4:	0a000007 	beq	100071e8 <rt_realloc+0x248>
        {
            ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
100071c8:	e30833b0 	movw	r3, #33712	; 0x83b0
100071cc:	e3413002 	movt	r3, #4098	; 0x1002
100071d0:	e5932000 	ldr	r2, [r3]
100071d4:	e51b301c 	ldr	r3, [fp, #-28]
100071d8:	e5933004 	ldr	r3, [r3, #4]
100071dc:	e0823003 	add	r3, r2, r3
100071e0:	e51b2018 	ldr	r2, [fp, #-24]
100071e4:	e5832008 	str	r2, [r3, #8]
        }

        plug_holes(mem2);
100071e8:	e51b001c 	ldr	r0, [fp, #-28]
100071ec:	ebfffd2d 	bl	100066a8 <plug_holes>

        rt_sem_release(&heap_sem);
100071f0:	e30803bc 	movw	r0, #33724	; 0x83bc
100071f4:	e3410002 	movt	r0, #4098	; 0x1002
100071f8:	ebffeb5f 	bl	10001f7c <rt_sem_release>

        return rmem;
100071fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10007200:	ea000014 	b	10007258 <rt_realloc+0x2b8>
    }
    rt_sem_release(&heap_sem);
10007204:	e30803bc 	movw	r0, #33724	; 0x83bc
10007208:	e3410002 	movt	r0, #4098	; 0x1002
1000720c:	ebffeb5a 	bl	10001f7c <rt_sem_release>

    /* expand memory */
    nmem = rt_malloc(newsize);
10007210:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
10007214:	ebfffe23 	bl	10006aa8 <rt_malloc>
10007218:	e50b0020 	str	r0, [fp, #-32]
    if (nmem != RT_NULL) /* check memory */
1000721c:	e51b3020 	ldr	r3, [fp, #-32]
10007220:	e3530000 	cmp	r3, #0
10007224:	0a00000a 	beq	10007254 <rt_realloc+0x2b4>
    {
        rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
10007228:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
1000722c:	e51b3014 	ldr	r3, [fp, #-20]
10007230:	e1520003 	cmp	r2, r3
10007234:	31a03002 	movcc	r3, r2
10007238:	21a03003 	movcs	r3, r3
1000723c:	e51b0020 	ldr	r0, [fp, #-32]
10007240:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
10007244:	e1a02003 	mov	r2, r3
10007248:	ebfff68a 	bl	10004c78 <rt_memcpy>
        rt_free(rmem);
1000724c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10007250:	eb00002f 	bl	10007314 <rt_free>
    }

    return nmem;
10007254:	e51b3020 	ldr	r3, [fp, #-32]
}
10007258:	e1a00003 	mov	r0, r3
1000725c:	e24bd004 	sub	sp, fp, #4
10007260:	e8bd8800 	pop	{fp, pc}

10007264 <rt_calloc>:
 * @param size size of the objects to allocate
 *
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *rt_calloc(rt_size_t count, rt_size_t size)
{
10007264:	e92d4800 	push	{fp, lr}
10007268:	e28db004 	add	fp, sp, #4
1000726c:	e24dd010 	sub	sp, sp, #16
10007270:	e50b0010 	str	r0, [fp, #-16]
10007274:	e50b1014 	str	r1, [fp, #-20]
    void *p;

    RT_DEBUG_NOT_IN_INTERRUPT;
10007278:	eb00108f 	bl	1000b4bc <rt_hw_interrupt_disable>
1000727c:	e50b0008 	str	r0, [fp, #-8]
10007280:	ebfff5ce 	bl	100049c0 <rt_interrupt_get_nest>
10007284:	e1a03000 	mov	r3, r0
10007288:	e3530000 	cmp	r3, #0
1000728c:	0a00000a 	beq	100072bc <rt_calloc+0x58>
10007290:	e30e0888 	movw	r0, #59528	; 0xe888
10007294:	e3410001 	movt	r0, #4097	; 0x1001
10007298:	e30e1b14 	movw	r1, #60180	; 0xeb14
1000729c:	e3411001 	movt	r1, #4097	; 0x1001
100072a0:	ebfffc0b 	bl	100062d4 <rt_kprintf>
100072a4:	e30e08ac 	movw	r0, #59564	; 0xe8ac
100072a8:	e3410001 	movt	r0, #4097	; 0x1001
100072ac:	e30e1b14 	movw	r1, #60180	; 0xeb14
100072b0:	e3411001 	movt	r1, #4097	; 0x1001
100072b4:	e30021e5 	movw	r2, #485	; 0x1e5
100072b8:	ebfffcc2 	bl	100065c8 <rt_assert_handler>
100072bc:	e51b0008 	ldr	r0, [fp, #-8]
100072c0:	eb001081 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* allocate 'count' objects of size 'size' */
    p = rt_malloc(count * size);
100072c4:	e51b3010 	ldr	r3, [fp, #-16]
100072c8:	e51b2014 	ldr	r2, [fp, #-20]
100072cc:	e0030392 	mul	r3, r2, r3
100072d0:	e1a00003 	mov	r0, r3
100072d4:	ebfffdf3 	bl	10006aa8 <rt_malloc>
100072d8:	e50b000c 	str	r0, [fp, #-12]

    /* zero the memory */
    if (p)
100072dc:	e51b300c 	ldr	r3, [fp, #-12]
100072e0:	e3530000 	cmp	r3, #0
100072e4:	0a000006 	beq	10007304 <rt_calloc+0xa0>
        rt_memset(p, 0, count * size);
100072e8:	e51b3010 	ldr	r3, [fp, #-16]
100072ec:	e51b2014 	ldr	r2, [fp, #-20]
100072f0:	e0030392 	mul	r3, r2, r3
100072f4:	e51b000c 	ldr	r0, [fp, #-12]
100072f8:	e3a01000 	mov	r1, #0
100072fc:	e1a02003 	mov	r2, r3
10007300:	ebfff604 	bl	10004b18 <rt_memset>

    return p;
10007304:	e51b300c 	ldr	r3, [fp, #-12]
}
10007308:	e1a00003 	mov	r0, r3
1000730c:	e24bd004 	sub	sp, fp, #4
10007310:	e8bd8800 	pop	{fp, pc}

10007314 <rt_free>:
 * rt_malloc. The released memory block is taken back to system heap.
 *
 * @param rmem the address of memory which will be released
 */
void rt_free(void *rmem)
{
10007314:	e92d4800 	push	{fp, lr}
10007318:	e28db004 	add	fp, sp, #4
1000731c:	e24dd010 	sub	sp, sp, #16
10007320:	e50b0010 	str	r0, [fp, #-16]
    struct heap_mem *mem;

    RT_DEBUG_NOT_IN_INTERRUPT;
10007324:	eb001064 	bl	1000b4bc <rt_hw_interrupt_disable>
10007328:	e50b0008 	str	r0, [fp, #-8]
1000732c:	ebfff5a3 	bl	100049c0 <rt_interrupt_get_nest>
10007330:	e1a03000 	mov	r3, r0
10007334:	e3530000 	cmp	r3, #0
10007338:	0a00000a 	beq	10007368 <rt_free+0x54>
1000733c:	e30e0888 	movw	r0, #59528	; 0xe888
10007340:	e3410001 	movt	r0, #4097	; 0x1001
10007344:	e30e1b20 	movw	r1, #60192	; 0xeb20
10007348:	e3411001 	movt	r1, #4097	; 0x1001
1000734c:	ebfffbe0 	bl	100062d4 <rt_kprintf>
10007350:	e30e08ac 	movw	r0, #59564	; 0xe8ac
10007354:	e3410001 	movt	r0, #4097	; 0x1001
10007358:	e30e1b20 	movw	r1, #60192	; 0xeb20
1000735c:	e3411001 	movt	r1, #4097	; 0x1001
10007360:	e3a02f7f 	mov	r2, #508	; 0x1fc
10007364:	ebfffc97 	bl	100065c8 <rt_assert_handler>
10007368:	e51b0008 	ldr	r0, [fp, #-8]
1000736c:	eb001056 	bl	1000b4cc <rt_hw_interrupt_enable>

    if (rmem == RT_NULL)
10007370:	e51b3010 	ldr	r3, [fp, #-16]
10007374:	e3530000 	cmp	r3, #0
10007378:	1a000000 	bne	10007380 <rt_free+0x6c>
        return;
1000737c:	ea000073 	b	10007550 <rt_free+0x23c>
    RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
10007380:	e51b3010 	ldr	r3, [fp, #-16]
10007384:	e2033003 	and	r3, r3, #3
10007388:	e3530000 	cmp	r3, #0
1000738c:	0a000005 	beq	100073a8 <rt_free+0x94>
10007390:	e30e09e0 	movw	r0, #59872	; 0xe9e0
10007394:	e3410001 	movt	r0, #4097	; 0x1001
10007398:	e30e1b20 	movw	r1, #60192	; 0xeb20
1000739c:	e3411001 	movt	r1, #4097	; 0x1001
100073a0:	e3a02c02 	mov	r2, #512	; 0x200
100073a4:	ebfffc87 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
100073a8:	e30833b0 	movw	r3, #33712	; 0x83b0
100073ac:	e3413002 	movt	r3, #4098	; 0x1002
100073b0:	e5933000 	ldr	r3, [r3]
100073b4:	e51b2010 	ldr	r2, [fp, #-16]
100073b8:	e1520003 	cmp	r2, r3
100073bc:	3a000005 	bcc	100073d8 <rt_free+0xc4>
100073c0:	e30833b4 	movw	r3, #33716	; 0x83b4
100073c4:	e3413002 	movt	r3, #4098	; 0x1002
100073c8:	e5933000 	ldr	r3, [r3]
100073cc:	e51b2010 	ldr	r2, [fp, #-16]
100073d0:	e1520003 	cmp	r2, r3
100073d4:	3a000005 	bcc	100073f0 <rt_free+0xdc>
100073d8:	e30e0a10 	movw	r0, #59920	; 0xea10
100073dc:	e3410001 	movt	r0, #4097	; 0x1001
100073e0:	e30e1b20 	movw	r1, #60192	; 0xeb20
100073e4:	e3411001 	movt	r1, #4097	; 0x1001
100073e8:	e3002202 	movw	r2, #514	; 0x202
100073ec:	ebfffc75 	bl	100065c8 <rt_assert_handler>
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
100073f0:	e30833ac 	movw	r3, #33708	; 0x83ac
100073f4:	e3413002 	movt	r3, #4098	; 0x1002
100073f8:	e5933000 	ldr	r3, [r3]
100073fc:	e3530000 	cmp	r3, #0
10007400:	0a000004 	beq	10007418 <rt_free+0x104>
10007404:	e30833ac 	movw	r3, #33708	; 0x83ac
10007408:	e3413002 	movt	r3, #4098	; 0x1002
1000740c:	e5933000 	ldr	r3, [r3]
10007410:	e51b0010 	ldr	r0, [fp, #-16]
10007414:	e12fff33 	blx	r3

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
10007418:	e30833b0 	movw	r3, #33712	; 0x83b0
1000741c:	e3413002 	movt	r3, #4098	; 0x1002
10007420:	e5933000 	ldr	r3, [r3]
10007424:	e51b2010 	ldr	r2, [fp, #-16]
10007428:	e1520003 	cmp	r2, r3
1000742c:	3a000005 	bcc	10007448 <rt_free+0x134>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
10007430:	e30833b4 	movw	r3, #33716	; 0x83b4
10007434:	e3413002 	movt	r3, #4098	; 0x1002
10007438:	e5933000 	ldr	r3, [r3]
    RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
              (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);

    RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));

    if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
1000743c:	e51b2010 	ldr	r2, [fp, #-16]
10007440:	e1520003 	cmp	r2, r3
10007444:	3a000000 	bcc	1000744c <rt_free+0x138>
        (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
    {
        RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));

        return;
10007448:	ea000040 	b	10007550 <rt_free+0x23c>
    }

    /* Get the corresponding struct heap_mem ... */
    mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
1000744c:	e51b3010 	ldr	r3, [fp, #-16]
10007450:	e243300c 	sub	r3, r3, #12
10007454:	e50b300c 	str	r3, [fp, #-12]
                  (rt_uint32_t)rmem,
                  (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));


    /* protect the heap from concurrent access */
    rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
10007458:	e30803bc 	movw	r0, #33724	; 0x83bc
1000745c:	e3410002 	movt	r0, #4098	; 0x1002
10007460:	e3e01000 	mvn	r1, #0
10007464:	ebffea30 	bl	10001d2c <rt_sem_take>

    /* ... which has to be in a used state ... */
    RT_ASSERT(mem->used);
10007468:	e51b300c 	ldr	r3, [fp, #-12]
1000746c:	e1d330b2 	ldrh	r3, [r3, #2]
10007470:	e3530000 	cmp	r3, #0
10007474:	1a000005 	bne	10007490 <rt_free+0x17c>
10007478:	e30e0a6c 	movw	r0, #60012	; 0xea6c
1000747c:	e3410001 	movt	r0, #4097	; 0x1001
10007480:	e30e1b20 	movw	r1, #60192	; 0xeb20
10007484:	e3411001 	movt	r1, #4097	; 0x1001
10007488:	e300221b 	movw	r2, #539	; 0x21b
1000748c:	ebfffc4d 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(mem->magic == HEAP_MAGIC);
10007490:	e51b300c 	ldr	r3, [fp, #-12]
10007494:	e1d330b0 	ldrh	r3, [r3]
10007498:	e3012ea0 	movw	r2, #7840	; 0x1ea0
1000749c:	e1530002 	cmp	r3, r2
100074a0:	0a000005 	beq	100074bc <rt_free+0x1a8>
100074a4:	e30e0a78 	movw	r0, #60024	; 0xea78
100074a8:	e3410001 	movt	r0, #4097	; 0x1001
100074ac:	e30e1b20 	movw	r1, #60192	; 0xeb20
100074b0:	e3411001 	movt	r1, #4097	; 0x1001
100074b4:	e3a02f87 	mov	r2, #540	; 0x21c
100074b8:	ebfffc42 	bl	100065c8 <rt_assert_handler>
    /* ... and is now unused. */
    mem->used  = 0;
100074bc:	e51b300c 	ldr	r3, [fp, #-12]
100074c0:	e3a02000 	mov	r2, #0
100074c4:	e1c320b2 	strh	r2, [r3, #2]
    mem->magic = 0;
100074c8:	e51b300c 	ldr	r3, [fp, #-12]
100074cc:	e3a02000 	mov	r2, #0
100074d0:	e1c320b0 	strh	r2, [r3]

    if (mem < lfree)
100074d4:	e30833b8 	movw	r3, #33720	; 0x83b8
100074d8:	e3413002 	movt	r3, #4098	; 0x1002
100074dc:	e5933000 	ldr	r3, [r3]
100074e0:	e51b200c 	ldr	r2, [fp, #-12]
100074e4:	e1520003 	cmp	r2, r3
100074e8:	2a000003 	bcs	100074fc <rt_free+0x1e8>
    {
        /* the newly freed struct is now the lowest */
        lfree = mem;
100074ec:	e30833b8 	movw	r3, #33720	; 0x83b8
100074f0:	e3413002 	movt	r3, #4098	; 0x1002
100074f4:	e51b200c 	ldr	r2, [fp, #-12]
100074f8:	e5832000 	str	r2, [r3]
    }

#ifdef RT_MEM_STATS
    used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
100074fc:	e30833dc 	movw	r3, #33756	; 0x83dc
10007500:	e3413002 	movt	r3, #4098	; 0x1002
10007504:	e5932000 	ldr	r2, [r3]
10007508:	e51b300c 	ldr	r3, [fp, #-12]
1000750c:	e5931004 	ldr	r1, [r3, #4]
10007510:	e30833b0 	movw	r3, #33712	; 0x83b0
10007514:	e3413002 	movt	r3, #4098	; 0x1002
10007518:	e5933000 	ldr	r3, [r3]
1000751c:	e1a00003 	mov	r0, r3
10007520:	e51b300c 	ldr	r3, [fp, #-12]
10007524:	e0633000 	rsb	r3, r3, r0
10007528:	e0813003 	add	r3, r1, r3
1000752c:	e0632002 	rsb	r2, r3, r2
10007530:	e30833dc 	movw	r3, #33756	; 0x83dc
10007534:	e3413002 	movt	r3, #4098	; 0x1002
10007538:	e5832000 	str	r2, [r3]
#endif

    /* finally, see if prev or next are free also */
    plug_holes(mem);
1000753c:	e51b000c 	ldr	r0, [fp, #-12]
10007540:	ebfffc58 	bl	100066a8 <plug_holes>
    rt_sem_release(&heap_sem);
10007544:	e30803bc 	movw	r0, #33724	; 0x83bc
10007548:	e3410002 	movt	r0, #4098	; 0x1002
1000754c:	ebffea8a 	bl	10001f7c <rt_sem_release>
}
10007550:	e24bd004 	sub	sp, fp, #4
10007554:	e8bd8800 	pop	{fp, pc}

10007558 <rt_memory_info>:

#ifdef RT_MEM_STATS
void rt_memory_info(rt_uint32_t *total,
                    rt_uint32_t *used,
                    rt_uint32_t *max_used)
{
10007558:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000755c:	e28db000 	add	fp, sp, #0
10007560:	e24dd014 	sub	sp, sp, #20
10007564:	e50b0008 	str	r0, [fp, #-8]
10007568:	e50b100c 	str	r1, [fp, #-12]
1000756c:	e50b2010 	str	r2, [fp, #-16]
    if (total != RT_NULL)
10007570:	e51b3008 	ldr	r3, [fp, #-8]
10007574:	e3530000 	cmp	r3, #0
10007578:	0a000004 	beq	10007590 <rt_memory_info+0x38>
        *total = mem_size_aligned;
1000757c:	e30833d8 	movw	r3, #33752	; 0x83d8
10007580:	e3413002 	movt	r3, #4098	; 0x1002
10007584:	e5932000 	ldr	r2, [r3]
10007588:	e51b3008 	ldr	r3, [fp, #-8]
1000758c:	e5832000 	str	r2, [r3]
    if (used  != RT_NULL)
10007590:	e51b300c 	ldr	r3, [fp, #-12]
10007594:	e3530000 	cmp	r3, #0
10007598:	0a000004 	beq	100075b0 <rt_memory_info+0x58>
        *used = used_mem;
1000759c:	e30833dc 	movw	r3, #33756	; 0x83dc
100075a0:	e3413002 	movt	r3, #4098	; 0x1002
100075a4:	e5932000 	ldr	r2, [r3]
100075a8:	e51b300c 	ldr	r3, [fp, #-12]
100075ac:	e5832000 	str	r2, [r3]
    if (max_used != RT_NULL)
100075b0:	e51b3010 	ldr	r3, [fp, #-16]
100075b4:	e3530000 	cmp	r3, #0
100075b8:	0a000004 	beq	100075d0 <rt_memory_info+0x78>
        *max_used = max_mem;
100075bc:	e30833e0 	movw	r3, #33760	; 0x83e0
100075c0:	e3413002 	movt	r3, #4098	; 0x1002
100075c4:	e5932000 	ldr	r2, [r3]
100075c8:	e51b3010 	ldr	r3, [fp, #-16]
100075cc:	e5832000 	str	r2, [r3]
}
100075d0:	e24bd000 	sub	sp, fp, #0
100075d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100075d8:	e12fff1e 	bx	lr

100075dc <list_mem>:

#ifdef RT_USING_FINSH
#include <finsh.h>

void list_mem(void)
{
100075dc:	e92d4800 	push	{fp, lr}
100075e0:	e28db004 	add	fp, sp, #4
    rt_kprintf("total memory: %d\n", mem_size_aligned);
100075e4:	e30833d8 	movw	r3, #33752	; 0x83d8
100075e8:	e3413002 	movt	r3, #4098	; 0x1002
100075ec:	e5933000 	ldr	r3, [r3]
100075f0:	e30e0a94 	movw	r0, #60052	; 0xea94
100075f4:	e3410001 	movt	r0, #4097	; 0x1001
100075f8:	e1a01003 	mov	r1, r3
100075fc:	ebfffb34 	bl	100062d4 <rt_kprintf>
    rt_kprintf("used memory : %d\n", used_mem);
10007600:	e30833dc 	movw	r3, #33756	; 0x83dc
10007604:	e3413002 	movt	r3, #4098	; 0x1002
10007608:	e5933000 	ldr	r3, [r3]
1000760c:	e30e0aa8 	movw	r0, #60072	; 0xeaa8
10007610:	e3410001 	movt	r0, #4097	; 0x1001
10007614:	e1a01003 	mov	r1, r3
10007618:	ebfffb2d 	bl	100062d4 <rt_kprintf>
    rt_kprintf("maximum allocated memory: %d\n", max_mem);
1000761c:	e30833e0 	movw	r3, #33760	; 0x83e0
10007620:	e3413002 	movt	r3, #4098	; 0x1002
10007624:	e5933000 	ldr	r3, [r3]
10007628:	e30e0abc 	movw	r0, #60092	; 0xeabc
1000762c:	e3410001 	movt	r0, #4097	; 0x1001
10007630:	e1a01003 	mov	r1, r3
10007634:	ebfffb26 	bl	100062d4 <rt_kprintf>
}
10007638:	e8bd8800 	pop	{fp, pc}

1000763c <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
1000763c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007640:	e28db000 	add	fp, sp, #0
10007644:	e24dd00c 	sub	sp, sp, #12
10007648:	e50b0008 	str	r0, [fp, #-8]
1000764c:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
10007650:	e51b3008 	ldr	r3, [fp, #-8]
10007654:	e5933000 	ldr	r3, [r3]
10007658:	e51b200c 	ldr	r2, [fp, #-12]
1000765c:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
10007660:	e51b3008 	ldr	r3, [fp, #-8]
10007664:	e5932000 	ldr	r2, [r3]
10007668:	e51b300c 	ldr	r3, [fp, #-12]
1000766c:	e5832000 	str	r2, [r3]

    l->next = n;
10007670:	e51b3008 	ldr	r3, [fp, #-8]
10007674:	e51b200c 	ldr	r2, [fp, #-12]
10007678:	e5832000 	str	r2, [r3]
    n->prev = l;
1000767c:	e51b300c 	ldr	r3, [fp, #-12]
10007680:	e51b2008 	ldr	r2, [fp, #-8]
10007684:	e5832004 	str	r2, [r3, #4]
}
10007688:	e24bd000 	sub	sp, fp, #0
1000768c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007690:	e12fff1e 	bx	lr

10007694 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
10007694:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007698:	e28db000 	add	fp, sp, #0
1000769c:	e24dd00c 	sub	sp, sp, #12
100076a0:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
100076a4:	e51b3008 	ldr	r3, [fp, #-8]
100076a8:	e5933000 	ldr	r3, [r3]
100076ac:	e51b2008 	ldr	r2, [fp, #-8]
100076b0:	e5922004 	ldr	r2, [r2, #4]
100076b4:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
100076b8:	e51b3008 	ldr	r3, [fp, #-8]
100076bc:	e5933004 	ldr	r3, [r3, #4]
100076c0:	e51b2008 	ldr	r2, [fp, #-8]
100076c4:	e5922000 	ldr	r2, [r2]
100076c8:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
100076cc:	e51b3008 	ldr	r3, [fp, #-8]
100076d0:	e51b2008 	ldr	r2, [fp, #-8]
100076d4:	e5832004 	str	r2, [r3, #4]
100076d8:	e51b3008 	ldr	r3, [fp, #-8]
100076dc:	e5932004 	ldr	r2, [r3, #4]
100076e0:	e51b3008 	ldr	r3, [fp, #-8]
100076e4:	e5832000 	str	r2, [r3]
}
100076e8:	e24bd000 	sub	sp, fp, #0
100076ec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100076f0:	e12fff1e 	bx	lr

100076f4 <rt_object_attach_sethook>:
 * attaches to kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_attach_sethook(void (*hook)(struct rt_object *object))
{
100076f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100076f8:	e28db000 	add	fp, sp, #0
100076fc:	e24dd00c 	sub	sp, sp, #12
10007700:	e50b0008 	str	r0, [fp, #-8]
    rt_object_attach_hook = hook;
10007704:	e30833e4 	movw	r3, #33764	; 0x83e4
10007708:	e3413002 	movt	r3, #4098	; 0x1002
1000770c:	e51b2008 	ldr	r2, [fp, #-8]
10007710:	e5832000 	str	r2, [r3]
}
10007714:	e24bd000 	sub	sp, fp, #0
10007718:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000771c:	e12fff1e 	bx	lr

10007720 <rt_object_detach_sethook>:
 * detaches from kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_detach_sethook(void (*hook)(struct rt_object *object))
{
10007720:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007724:	e28db000 	add	fp, sp, #0
10007728:	e24dd00c 	sub	sp, sp, #12
1000772c:	e50b0008 	str	r0, [fp, #-8]
    rt_object_detach_hook = hook;
10007730:	e30833e8 	movw	r3, #33768	; 0x83e8
10007734:	e3413002 	movt	r3, #4098	; 0x1002
10007738:	e51b2008 	ldr	r2, [fp, #-8]
1000773c:	e5832000 	str	r2, [r3]
}
10007740:	e24bd000 	sub	sp, fp, #0
10007744:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007748:	e12fff1e 	bx	lr

1000774c <rt_object_trytake_sethook>:
 * message queue - message is received by thread
 *
 * @param hook the hook function
 */
void rt_object_trytake_sethook(void (*hook)(struct rt_object *object))
{
1000774c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007750:	e28db000 	add	fp, sp, #0
10007754:	e24dd00c 	sub	sp, sp, #12
10007758:	e50b0008 	str	r0, [fp, #-8]
    rt_object_trytake_hook = hook;
1000775c:	e3093d90 	movw	r3, #40336	; 0x9d90
10007760:	e3413002 	movt	r3, #4098	; 0x1002
10007764:	e51b2008 	ldr	r2, [fp, #-8]
10007768:	e5832000 	str	r2, [r3]
}
1000776c:	e24bd000 	sub	sp, fp, #0
10007770:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007774:	e12fff1e 	bx	lr

10007778 <rt_object_take_sethook>:
 * timer - timer is started
 *
 * @param hook the hook function
 */
void rt_object_take_sethook(void (*hook)(struct rt_object *object))
{
10007778:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000777c:	e28db000 	add	fp, sp, #0
10007780:	e24dd00c 	sub	sp, sp, #12
10007784:	e50b0008 	str	r0, [fp, #-8]
    rt_object_take_hook = hook;
10007788:	e3093d8c 	movw	r3, #40332	; 0x9d8c
1000778c:	e3413002 	movt	r3, #4098	; 0x1002
10007790:	e51b2008 	ldr	r2, [fp, #-8]
10007794:	e5832000 	str	r2, [r3]
}
10007798:	e24bd000 	sub	sp, fp, #0
1000779c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100077a0:	e12fff1e 	bx	lr

100077a4 <rt_object_put_sethook>:
 * is put to kernel object system.
 *
 * @param hook the hook function
 */
void rt_object_put_sethook(void (*hook)(struct rt_object *object))
{
100077a4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100077a8:	e28db000 	add	fp, sp, #0
100077ac:	e24dd00c 	sub	sp, sp, #12
100077b0:	e50b0008 	str	r0, [fp, #-8]
    rt_object_put_hook = hook;
100077b4:	e3093d88 	movw	r3, #40328	; 0x9d88
100077b8:	e3413002 	movt	r3, #4098	; 0x1002
100077bc:	e51b2008 	ldr	r2, [fp, #-8]
100077c0:	e5832000 	str	r2, [r3]
}
100077c4:	e24bd000 	sub	sp, fp, #0
100077c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100077cc:	e12fff1e 	bx	lr

100077d0 <rt_system_object_init>:
 *
 * @deprecated since 0.3.0, this function does not need to be invoked
 * in the system initialization.
 */
void rt_system_object_init(void)
{
100077d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100077d4:	e28db000 	add	fp, sp, #0
}
100077d8:	e24bd000 	sub	sp, fp, #0
100077dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100077e0:	e12fff1e 	bx	lr

100077e4 <rt_object_get_information>:
 * @param type the type of object
 * @return the object type information or RT_NULL
 */
struct rt_object_information *
rt_object_get_information(enum rt_object_class_type type)
{
100077e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100077e8:	e28db000 	add	fp, sp, #0
100077ec:	e24dd00c 	sub	sp, sp, #12
100077f0:	e1a03000 	mov	r3, r0
100077f4:	e54b3005 	strb	r3, [fp, #-5]
    return &rt_object_container[type];
100077f8:	e55b3005 	ldrb	r3, [fp, #-5]
100077fc:	e1a02203 	lsl	r2, r3, #4
10007800:	e30039b8 	movw	r3, #2488	; 0x9b8
10007804:	e3413002 	movt	r3, #4098	; 0x1002
10007808:	e0823003 	add	r3, r2, r3
}
1000780c:	e1a00003 	mov	r0, r3
10007810:	e24bd000 	sub	sp, fp, #0
10007814:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007818:	e12fff1e 	bx	lr

1000781c <rt_object_init>:
 * @param name the object name. In system, the object's name must be unique.
 */
void rt_object_init(struct rt_object         *object,
                    enum rt_object_class_type type,
                    const char               *name)
{
1000781c:	e92d4810 	push	{r4, fp, lr}
10007820:	e28db008 	add	fp, sp, #8
10007824:	e24dd01c 	sub	sp, sp, #28
10007828:	e50b0018 	str	r0, [fp, #-24]
1000782c:	e1a03001 	mov	r3, r1
10007830:	e50b2020 	str	r2, [fp, #-32]
10007834:	e54b3019 	strb	r3, [fp, #-25]
    /* get module object information */
    information = (rt_module_self() != RT_NULL) ?
        &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
10007838:	e55b3019 	ldrb	r3, [fp, #-25]
1000783c:	e1a02203 	lsl	r2, r3, #4
10007840:	e30039b8 	movw	r3, #2488	; 0x9b8
10007844:	e3413002 	movt	r3, #4098	; 0x1002
10007848:	e0823003 	add	r3, r2, r3
1000784c:	e50b3010 	str	r3, [fp, #-16]
#endif

    /* initialize object's parameters */

    /* set object type to static */
    object->type = type | RT_Object_Class_Static;
10007850:	e55b3019 	ldrb	r3, [fp, #-25]
10007854:	e1e03c83 	mvn	r3, r3, lsl #25
10007858:	e1e03ca3 	mvn	r3, r3, lsr #25
1000785c:	e6ef2073 	uxtb	r2, r3
10007860:	e51b3018 	ldr	r3, [fp, #-24]
10007864:	e5c32006 	strb	r2, [r3, #6]

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
10007868:	e51b3018 	ldr	r3, [fp, #-24]
1000786c:	e1a00003 	mov	r0, r3
10007870:	e51b1020 	ldr	r1, [fp, #-32]
10007874:	e3a02006 	mov	r2, #6
10007878:	ebfff627 	bl	1000511c <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
1000787c:	e30833e4 	movw	r3, #33764	; 0x83e4
10007880:	e3413002 	movt	r3, #4098	; 0x1002
10007884:	e5933000 	ldr	r3, [r3]
10007888:	e3530000 	cmp	r3, #0
1000788c:	0a000004 	beq	100078a4 <rt_object_init+0x88>
10007890:	e30833e4 	movw	r3, #33764	; 0x83e4
10007894:	e3413002 	movt	r3, #4098	; 0x1002
10007898:	e5933000 	ldr	r3, [r3]
1000789c:	e51b0018 	ldr	r0, [fp, #-24]
100078a0:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
100078a4:	eb000f04 	bl	1000b4bc <rt_hw_interrupt_disable>
100078a8:	e1a04000 	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
100078ac:	e51b3010 	ldr	r3, [fp, #-16]
100078b0:	e2832004 	add	r2, r3, #4
100078b4:	e51b3018 	ldr	r3, [fp, #-24]
100078b8:	e2833008 	add	r3, r3, #8
100078bc:	e1a00002 	mov	r0, r2
100078c0:	e1a01003 	mov	r1, r3
100078c4:	ebffff5c 	bl	1000763c <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
100078c8:	e1a00004 	mov	r0, r4
100078cc:	eb000efe 	bl	1000b4cc <rt_hw_interrupt_enable>
}
100078d0:	e24bd008 	sub	sp, fp, #8
100078d4:	e8bd8810 	pop	{r4, fp, pc}

100078d8 <rt_object_detach>:
 * and the memory of static object is not freed.
 *
 * @param object the specified object to be detached.
 */
void rt_object_detach(rt_object_t object)
{
100078d8:	e92d4810 	push	{r4, fp, lr}
100078dc:	e28db008 	add	fp, sp, #8
100078e0:	e24dd00c 	sub	sp, sp, #12
100078e4:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
100078e8:	e51b3010 	ldr	r3, [fp, #-16]
100078ec:	e3530000 	cmp	r3, #0
100078f0:	1a000005 	bne	1000790c <rt_object_detach+0x34>
100078f4:	e30e0b28 	movw	r0, #60200	; 0xeb28
100078f8:	e3410001 	movt	r0, #4097	; 0x1001
100078fc:	e30e1b90 	movw	r1, #60304	; 0xeb90
10007900:	e3411001 	movt	r1, #4097	; 0x1001
10007904:	e3a020fb 	mov	r2, #251	; 0xfb
10007908:	ebfffb2e 	bl	100065c8 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
1000790c:	e30833e8 	movw	r3, #33768	; 0x83e8
10007910:	e3413002 	movt	r3, #4098	; 0x1002
10007914:	e5933000 	ldr	r3, [r3]
10007918:	e3530000 	cmp	r3, #0
1000791c:	0a000004 	beq	10007934 <rt_object_detach+0x5c>
10007920:	e30833e8 	movw	r3, #33768	; 0x83e8
10007924:	e3413002 	movt	r3, #4098	; 0x1002
10007928:	e5933000 	ldr	r3, [r3]
1000792c:	e51b0010 	ldr	r0, [fp, #-16]
10007930:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10007934:	eb000ee0 	bl	1000b4bc <rt_hw_interrupt_disable>
10007938:	e1a04000 	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
1000793c:	e51b3010 	ldr	r3, [fp, #-16]
10007940:	e2833008 	add	r3, r3, #8
10007944:	e1a00003 	mov	r0, r3
10007948:	ebffff51 	bl	10007694 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
1000794c:	e1a00004 	mov	r0, r4
10007950:	eb000edd 	bl	1000b4cc <rt_hw_interrupt_enable>
}
10007954:	e24bd008 	sub	sp, fp, #8
10007958:	e8bd8810 	pop	{r4, fp, pc}

1000795c <rt_object_allocate>:
 * @param name the object name. In system, the object's name must be unique.
 *
 * @return object
 */
rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
{
1000795c:	e92d4810 	push	{r4, fp, lr}
10007960:	e28db008 	add	fp, sp, #8
10007964:	e24dd01c 	sub	sp, sp, #28
10007968:	e1a03000 	mov	r3, r0
1000796c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
10007970:	e54b301d 	strb	r3, [fp, #-29]
    struct rt_object *object;
    register rt_base_t temp;
    struct rt_object_information *information;

    RT_DEBUG_NOT_IN_INTERRUPT;
10007974:	eb000ed0 	bl	1000b4bc <rt_hw_interrupt_disable>
10007978:	e50b0010 	str	r0, [fp, #-16]
1000797c:	ebfff40f 	bl	100049c0 <rt_interrupt_get_nest>
10007980:	e1a03000 	mov	r3, r0
10007984:	e3530000 	cmp	r3, #0
10007988:	0a00000a 	beq	100079b8 <rt_object_allocate+0x5c>
1000798c:	e30e0b3c 	movw	r0, #60220	; 0xeb3c
10007990:	e3410001 	movt	r0, #4097	; 0x1001
10007994:	e30e1ba4 	movw	r1, #60324	; 0xeba4
10007998:	e3411001 	movt	r1, #4097	; 0x1001
1000799c:	ebfffa4c 	bl	100062d4 <rt_kprintf>
100079a0:	e30e0b60 	movw	r0, #60256	; 0xeb60
100079a4:	e3410001 	movt	r0, #4097	; 0x1001
100079a8:	e30e1ba4 	movw	r1, #60324	; 0xeba4
100079ac:	e3411001 	movt	r1, #4097	; 0x1001
100079b0:	e3a02f46 	mov	r2, #280	; 0x118
100079b4:	ebfffb03 	bl	100065c8 <rt_assert_handler>
100079b8:	e51b0010 	ldr	r0, [fp, #-16]
100079bc:	eb000ec2 	bl	1000b4cc <rt_hw_interrupt_enable>
     */
    information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
                  &rt_module_self()->module_object[type] : &rt_object_container[type];
#else
    /* get object information */
    information = &rt_object_container[type];
100079c0:	e55b301d 	ldrb	r3, [fp, #-29]
100079c4:	e1a02203 	lsl	r2, r3, #4
100079c8:	e30039b8 	movw	r3, #2488	; 0x9b8
100079cc:	e3413002 	movt	r3, #4098	; 0x1002
100079d0:	e0823003 	add	r3, r2, r3
100079d4:	e50b3014 	str	r3, [fp, #-20]
#endif

    object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
100079d8:	e51b3014 	ldr	r3, [fp, #-20]
100079dc:	e593300c 	ldr	r3, [r3, #12]
100079e0:	e1a00003 	mov	r0, r3
100079e4:	ebfffc2f 	bl	10006aa8 <rt_malloc>
100079e8:	e50b0018 	str	r0, [fp, #-24]
    if (object == RT_NULL)
100079ec:	e51b3018 	ldr	r3, [fp, #-24]
100079f0:	e3530000 	cmp	r3, #0
100079f4:	1a000001 	bne	10007a00 <rt_object_allocate+0xa4>
    {
        /* no memory can be allocated */
        return RT_NULL;
100079f8:	e3a03000 	mov	r3, #0
100079fc:	ea000020 	b	10007a84 <rt_object_allocate+0x128>
    }

    /* initialize object's parameters */

    /* set object type */
    object->type = type;
10007a00:	e51b3018 	ldr	r3, [fp, #-24]
10007a04:	e55b201d 	ldrb	r2, [fp, #-29]
10007a08:	e5c32006 	strb	r2, [r3, #6]

    /* set object flag */
    object->flag = 0;
10007a0c:	e51b3018 	ldr	r3, [fp, #-24]
10007a10:	e3a02000 	mov	r2, #0
10007a14:	e5c32007 	strb	r2, [r3, #7]
    }
    object->module_id = (void *)rt_module_self();
#endif

    /* copy name */
    rt_strncpy(object->name, name, RT_NAME_MAX);
10007a18:	e51b3018 	ldr	r3, [fp, #-24]
10007a1c:	e1a00003 	mov	r0, r3
10007a20:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
10007a24:	e3a02006 	mov	r2, #6
10007a28:	ebfff5bb 	bl	1000511c <rt_strncpy>

    RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
10007a2c:	e30833e4 	movw	r3, #33764	; 0x83e4
10007a30:	e3413002 	movt	r3, #4098	; 0x1002
10007a34:	e5933000 	ldr	r3, [r3]
10007a38:	e3530000 	cmp	r3, #0
10007a3c:	0a000004 	beq	10007a54 <rt_object_allocate+0xf8>
10007a40:	e30833e4 	movw	r3, #33764	; 0x83e4
10007a44:	e3413002 	movt	r3, #4098	; 0x1002
10007a48:	e5933000 	ldr	r3, [r3]
10007a4c:	e51b0018 	ldr	r0, [fp, #-24]
10007a50:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10007a54:	eb000e98 	bl	1000b4bc <rt_hw_interrupt_disable>
10007a58:	e1a04000 	mov	r4, r0

    /* insert object into information object list */
    rt_list_insert_after(&(information->object_list), &(object->list));
10007a5c:	e51b3014 	ldr	r3, [fp, #-20]
10007a60:	e2832004 	add	r2, r3, #4
10007a64:	e51b3018 	ldr	r3, [fp, #-24]
10007a68:	e2833008 	add	r3, r3, #8
10007a6c:	e1a00002 	mov	r0, r2
10007a70:	e1a01003 	mov	r1, r3
10007a74:	ebfffef0 	bl	1000763c <rt_list_insert_after>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
10007a78:	e1a00004 	mov	r0, r4
10007a7c:	eb000e92 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* return object */
    return object;
10007a80:	e51b3018 	ldr	r3, [fp, #-24]
}
10007a84:	e1a00003 	mov	r0, r3
10007a88:	e24bd008 	sub	sp, fp, #8
10007a8c:	e8bd8810 	pop	{r4, fp, pc}

10007a90 <rt_object_delete>:
 * This function will delete an object and release object memory.
 *
 * @param object the specified object to be deleted.
 */
void rt_object_delete(rt_object_t object)
{
10007a90:	e92d4810 	push	{r4, fp, lr}
10007a94:	e28db008 	add	fp, sp, #8
10007a98:	e24dd00c 	sub	sp, sp, #12
10007a9c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* object check */
    RT_ASSERT(object != RT_NULL);
10007aa0:	e51b3010 	ldr	r3, [fp, #-16]
10007aa4:	e3530000 	cmp	r3, #0
10007aa8:	1a000005 	bne	10007ac4 <rt_object_delete+0x34>
10007aac:	e30e0b28 	movw	r0, #60200	; 0xeb28
10007ab0:	e3410001 	movt	r0, #4097	; 0x1001
10007ab4:	e30e1bb8 	movw	r1, #60344	; 0xebb8
10007ab8:	e3411001 	movt	r1, #4097	; 0x1001
10007abc:	e3002159 	movw	r2, #345	; 0x159
10007ac0:	ebfffac0 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(!(object->type & RT_Object_Class_Static));
10007ac4:	e51b3010 	ldr	r3, [fp, #-16]
10007ac8:	e5d33006 	ldrb	r3, [r3, #6]
10007acc:	e6ef3073 	uxtb	r3, r3
10007ad0:	e6af3073 	sxtb	r3, r3
10007ad4:	e3530000 	cmp	r3, #0
10007ad8:	aa000005 	bge	10007af4 <rt_object_delete+0x64>
10007adc:	e30e0b64 	movw	r0, #60260	; 0xeb64
10007ae0:	e3410001 	movt	r0, #4097	; 0x1001
10007ae4:	e30e1bb8 	movw	r1, #60344	; 0xebb8
10007ae8:	e3411001 	movt	r1, #4097	; 0x1001
10007aec:	e300215a 	movw	r2, #346	; 0x15a
10007af0:	ebfffab4 	bl	100065c8 <rt_assert_handler>

    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
10007af4:	e30833e8 	movw	r3, #33768	; 0x83e8
10007af8:	e3413002 	movt	r3, #4098	; 0x1002
10007afc:	e5933000 	ldr	r3, [r3]
10007b00:	e3530000 	cmp	r3, #0
10007b04:	0a000004 	beq	10007b1c <rt_object_delete+0x8c>
10007b08:	e30833e8 	movw	r3, #33768	; 0x83e8
10007b0c:	e3413002 	movt	r3, #4098	; 0x1002
10007b10:	e5933000 	ldr	r3, [r3]
10007b14:	e51b0010 	ldr	r0, [fp, #-16]
10007b18:	e12fff33 	blx	r3

    /* lock interrupt */
    temp = rt_hw_interrupt_disable();
10007b1c:	eb000e66 	bl	1000b4bc <rt_hw_interrupt_disable>
10007b20:	e1a04000 	mov	r4, r0

    /* remove from old list */
    rt_list_remove(&(object->list));
10007b24:	e51b3010 	ldr	r3, [fp, #-16]
10007b28:	e2833008 	add	r3, r3, #8
10007b2c:	e1a00003 	mov	r0, r3
10007b30:	ebfffed7 	bl	10007694 <rt_list_remove>

    /* unlock interrupt */
    rt_hw_interrupt_enable(temp);
10007b34:	e1a00004 	mov	r0, r4
10007b38:	eb000e63 	bl	1000b4cc <rt_hw_interrupt_enable>
        rt_module_free((rt_module_t)object->module_id, object);
    else
#endif

    /* free the memory of object */
    RT_KERNEL_FREE(object);
10007b3c:	e51b0010 	ldr	r0, [fp, #-16]
10007b40:	ebfffdf3 	bl	10007314 <rt_free>
}
10007b44:	e24bd008 	sub	sp, fp, #8
10007b48:	e8bd8810 	pop	{r4, fp, pc}

10007b4c <rt_object_is_systemobject>:
 * @param object the specified object to be judged.
 *
 * @return RT_TRUE if a system object, RT_FALSE for others.
 */
rt_bool_t rt_object_is_systemobject(rt_object_t object)
{
10007b4c:	e92d4800 	push	{fp, lr}
10007b50:	e28db004 	add	fp, sp, #4
10007b54:	e24dd008 	sub	sp, sp, #8
10007b58:	e50b0008 	str	r0, [fp, #-8]
    /* object check */
    RT_ASSERT(object != RT_NULL);
10007b5c:	e51b3008 	ldr	r3, [fp, #-8]
10007b60:	e3530000 	cmp	r3, #0
10007b64:	1a000005 	bne	10007b80 <rt_object_is_systemobject+0x34>
10007b68:	e30e0b28 	movw	r0, #60200	; 0xeb28
10007b6c:	e3410001 	movt	r0, #4097	; 0x1001
10007b70:	e30e1bcc 	movw	r1, #60364	; 0xebcc
10007b74:	e3411001 	movt	r1, #4097	; 0x1001
10007b78:	e300217e 	movw	r2, #382	; 0x17e
10007b7c:	ebfffa91 	bl	100065c8 <rt_assert_handler>

    if (object->type & RT_Object_Class_Static)
10007b80:	e51b3008 	ldr	r3, [fp, #-8]
10007b84:	e5d33006 	ldrb	r3, [r3, #6]
10007b88:	e6ef3073 	uxtb	r3, r3
10007b8c:	e6af3073 	sxtb	r3, r3
10007b90:	e3530000 	cmp	r3, #0
10007b94:	aa000001 	bge	10007ba0 <rt_object_is_systemobject+0x54>
        return RT_TRUE;
10007b98:	e3a03001 	mov	r3, #1
10007b9c:	ea000000 	b	10007ba4 <rt_object_is_systemobject+0x58>

    return RT_FALSE;
10007ba0:	e3a03000 	mov	r3, #0
}
10007ba4:	e1a00003 	mov	r0, r3
10007ba8:	e24bd004 	sub	sp, fp, #4
10007bac:	e8bd8800 	pop	{fp, pc}

10007bb0 <rt_object_find>:
 * in object container.
 *
 * @note this function shall not be invoked in interrupt status.
 */
rt_object_t rt_object_find(const char *name, rt_uint8_t type)
{
10007bb0:	e92d4800 	push	{fp, lr}
10007bb4:	e28db004 	add	fp, sp, #4
10007bb8:	e24dd018 	sub	sp, sp, #24
10007bbc:	e50b0018 	str	r0, [fp, #-24]
10007bc0:	e1a03001 	mov	r3, r1
10007bc4:	e54b3019 	strb	r3, [fp, #-25]
    struct rt_object *object = RT_NULL;
10007bc8:	e3a03000 	mov	r3, #0
10007bcc:	e50b3010 	str	r3, [fp, #-16]
    struct rt_list_node *node = RT_NULL;
10007bd0:	e3a03000 	mov	r3, #0
10007bd4:	e50b3008 	str	r3, [fp, #-8]
    struct rt_object_information *information = RT_NULL;
10007bd8:	e3a03000 	mov	r3, #0
10007bdc:	e50b300c 	str	r3, [fp, #-12]

    /* parameter check */
    if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
10007be0:	e51b3018 	ldr	r3, [fp, #-24]
10007be4:	e3530000 	cmp	r3, #0
10007be8:	0a000002 	beq	10007bf8 <rt_object_find+0x48>
10007bec:	e55b3019 	ldrb	r3, [fp, #-25]
10007bf0:	e3530009 	cmp	r3, #9
10007bf4:	9a000001 	bls	10007c00 <rt_object_find+0x50>
        return RT_NULL;
10007bf8:	e3a03000 	mov	r3, #0
10007bfc:	ea000038 	b	10007ce4 <rt_object_find+0x134>

    /* which is invoke in interrupt status */
    RT_DEBUG_NOT_IN_INTERRUPT;
10007c00:	eb000e2d 	bl	1000b4bc <rt_hw_interrupt_disable>
10007c04:	e50b0014 	str	r0, [fp, #-20]
10007c08:	ebfff36c 	bl	100049c0 <rt_interrupt_get_nest>
10007c0c:	e1a03000 	mov	r3, r0
10007c10:	e3530000 	cmp	r3, #0
10007c14:	0a00000a 	beq	10007c44 <rt_object_find+0x94>
10007c18:	e30e0b3c 	movw	r0, #60220	; 0xeb3c
10007c1c:	e3410001 	movt	r0, #4097	; 0x1001
10007c20:	e30e1be8 	movw	r1, #60392	; 0xebe8
10007c24:	e3411001 	movt	r1, #4097	; 0x1001
10007c28:	ebfff9a9 	bl	100062d4 <rt_kprintf>
10007c2c:	e30e0b60 	movw	r0, #60256	; 0xeb60
10007c30:	e3410001 	movt	r0, #4097	; 0x1001
10007c34:	e30e1be8 	movw	r1, #60392	; 0xebe8
10007c38:	e3411001 	movt	r1, #4097	; 0x1001
10007c3c:	e300219d 	movw	r2, #413	; 0x19d
10007c40:	ebfffa60 	bl	100065c8 <rt_assert_handler>
10007c44:	e51b0014 	ldr	r0, [fp, #-20]
10007c48:	eb000e1f 	bl	1000b4cc <rt_hw_interrupt_enable>
        }
    }
#endif

    /* enter critical */
    rt_enter_critical();
10007c4c:	eb000195 	bl	100082a8 <rt_enter_critical>

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
10007c50:	e51b300c 	ldr	r3, [fp, #-12]
10007c54:	e3530000 	cmp	r3, #0
10007c58:	1a000005 	bne	10007c74 <rt_object_find+0xc4>
10007c5c:	e55b3019 	ldrb	r3, [fp, #-25]
10007c60:	e1a02203 	lsl	r2, r3, #4
10007c64:	e30039b8 	movw	r3, #2488	; 0x9b8
10007c68:	e3413002 	movt	r3, #4098	; 0x1002
10007c6c:	e0823003 	add	r3, r2, r3
10007c70:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
10007c74:	e51b300c 	ldr	r3, [fp, #-12]
10007c78:	e5933004 	ldr	r3, [r3, #4]
10007c7c:	e50b3008 	str	r3, [fp, #-8]
10007c80:	ea000010 	b	10007cc8 <rt_object_find+0x118>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
10007c84:	e51b3008 	ldr	r3, [fp, #-8]
10007c88:	e2433008 	sub	r3, r3, #8
10007c8c:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
10007c90:	e51b3010 	ldr	r3, [fp, #-16]
10007c94:	e1a00003 	mov	r0, r3
10007c98:	e51b1018 	ldr	r1, [fp, #-24]
10007c9c:	e3a02006 	mov	r2, #6
10007ca0:	ebfff54d 	bl	100051dc <rt_strncmp>
10007ca4:	e1a03000 	mov	r3, r0
10007ca8:	e3530000 	cmp	r3, #0
10007cac:	1a000002 	bne	10007cbc <rt_object_find+0x10c>
        {
            /* leave critical */
            rt_exit_critical();
10007cb0:	eb00018e 	bl	100082f0 <rt_exit_critical>

            return object;
10007cb4:	e51b3010 	ldr	r3, [fp, #-16]
10007cb8:	ea000009 	b	10007ce4 <rt_object_find+0x134>

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
10007cbc:	e51b3008 	ldr	r3, [fp, #-8]
10007cc0:	e5933000 	ldr	r3, [r3]
10007cc4:	e50b3008 	str	r3, [fp, #-8]
    rt_enter_critical();

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
         node != &(information->object_list);
10007cc8:	e51b300c 	ldr	r3, [fp, #-12]
10007ccc:	e2832004 	add	r2, r3, #4
    /* enter critical */
    rt_enter_critical();

    /* try to find object */
    if (information == RT_NULL) information = &rt_object_container[type];
    for (node  = information->object_list.next;
10007cd0:	e51b3008 	ldr	r3, [fp, #-8]
10007cd4:	e1520003 	cmp	r2, r3
10007cd8:	1affffe9 	bne	10007c84 <rt_object_find+0xd4>
            return object;
        }
    }

    /* leave critical */
    rt_exit_critical();
10007cdc:	eb000183 	bl	100082f0 <rt_exit_critical>

    return RT_NULL;
10007ce0:	e3a03000 	mov	r3, #0
}
10007ce4:	e1a00003 	mov	r0, r3
10007ce8:	e24bd004 	sub	sp, fp, #4
10007cec:	e8bd8800 	pop	{fp, pc}

10007cf0 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10007cf0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007cf4:	e28db000 	add	fp, sp, #0
10007cf8:	e24dd00c 	sub	sp, sp, #12
10007cfc:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10007d00:	e51b3008 	ldr	r3, [fp, #-8]
10007d04:	e51b2008 	ldr	r2, [fp, #-8]
10007d08:	e5832004 	str	r2, [r3, #4]
10007d0c:	e51b3008 	ldr	r3, [fp, #-8]
10007d10:	e5932004 	ldr	r2, [r3, #4]
10007d14:	e51b3008 	ldr	r3, [fp, #-8]
10007d18:	e5832000 	str	r2, [r3]
}
10007d1c:	e24bd000 	sub	sp, fp, #0
10007d20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007d24:	e12fff1e 	bx	lr

10007d28 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
10007d28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007d2c:	e28db000 	add	fp, sp, #0
10007d30:	e24dd00c 	sub	sp, sp, #12
10007d34:	e50b0008 	str	r0, [fp, #-8]
10007d38:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
10007d3c:	e51b3008 	ldr	r3, [fp, #-8]
10007d40:	e5933004 	ldr	r3, [r3, #4]
10007d44:	e51b200c 	ldr	r2, [fp, #-12]
10007d48:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
10007d4c:	e51b3008 	ldr	r3, [fp, #-8]
10007d50:	e5932004 	ldr	r2, [r3, #4]
10007d54:	e51b300c 	ldr	r3, [fp, #-12]
10007d58:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
10007d5c:	e51b3008 	ldr	r3, [fp, #-8]
10007d60:	e51b200c 	ldr	r2, [fp, #-12]
10007d64:	e5832004 	str	r2, [r3, #4]
    n->next = l;
10007d68:	e51b300c 	ldr	r3, [fp, #-12]
10007d6c:	e51b2008 	ldr	r2, [fp, #-8]
10007d70:	e5832000 	str	r2, [r3]
}
10007d74:	e24bd000 	sub	sp, fp, #0
10007d78:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007d7c:	e12fff1e 	bx	lr

10007d80 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
10007d80:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007d84:	e28db000 	add	fp, sp, #0
10007d88:	e24dd00c 	sub	sp, sp, #12
10007d8c:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
10007d90:	e51b3008 	ldr	r3, [fp, #-8]
10007d94:	e5933000 	ldr	r3, [r3]
10007d98:	e51b2008 	ldr	r2, [fp, #-8]
10007d9c:	e5922004 	ldr	r2, [r2, #4]
10007da0:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
10007da4:	e51b3008 	ldr	r3, [fp, #-8]
10007da8:	e5933004 	ldr	r3, [r3, #4]
10007dac:	e51b2008 	ldr	r2, [fp, #-8]
10007db0:	e5922000 	ldr	r2, [r2]
10007db4:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
10007db8:	e51b3008 	ldr	r3, [fp, #-8]
10007dbc:	e51b2008 	ldr	r2, [fp, #-8]
10007dc0:	e5832004 	str	r2, [r3, #4]
10007dc4:	e51b3008 	ldr	r3, [fp, #-8]
10007dc8:	e5932004 	ldr	r2, [r3, #4]
10007dcc:	e51b3008 	ldr	r3, [fp, #-8]
10007dd0:	e5832000 	str	r2, [r3]
}
10007dd4:	e24bd000 	sub	sp, fp, #0
10007dd8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007ddc:	e12fff1e 	bx	lr

10007de0 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10007de0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007de4:	e28db000 	add	fp, sp, #0
10007de8:	e24dd00c 	sub	sp, sp, #12
10007dec:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10007df0:	e51b3008 	ldr	r3, [fp, #-8]
10007df4:	e5932000 	ldr	r2, [r3]
10007df8:	e51b3008 	ldr	r3, [fp, #-8]
10007dfc:	e1520003 	cmp	r2, r3
10007e00:	03a03001 	moveq	r3, #1
10007e04:	13a03000 	movne	r3, #0
10007e08:	e6ef3073 	uxtb	r3, r3
}
10007e0c:	e1a00003 	mov	r0, r3
10007e10:	e24bd000 	sub	sp, fp, #0
10007e14:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007e18:	e12fff1e 	bx	lr

10007e1c <rt_scheduler_sethook>:
 *
 * @param hook the hook function
 */
void
rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
{
10007e1c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10007e20:	e28db000 	add	fp, sp, #0
10007e24:	e24dd00c 	sub	sp, sp, #12
10007e28:	e50b0008 	str	r0, [fp, #-8]
    rt_scheduler_hook = hook;
10007e2c:	e30833f0 	movw	r3, #33776	; 0x83f0
10007e30:	e3413002 	movt	r3, #4098	; 0x1002
10007e34:	e51b2008 	ldr	r2, [fp, #-8]
10007e38:	e5832000 	str	r2, [r3]
}
10007e3c:	e24bd000 	sub	sp, fp, #0
10007e40:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10007e44:	e12fff1e 	bx	lr

10007e48 <_rt_scheduler_stack_check>:
/*@}*/
#endif

#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
10007e48:	e92d4800 	push	{fp, lr}
10007e4c:	e28db004 	add	fp, sp, #4
10007e50:	e24dd010 	sub	sp, sp, #16
10007e54:	e50b0010 	str	r0, [fp, #-16]
    RT_ASSERT(thread != RT_NULL);
10007e58:	e51b3010 	ldr	r3, [fp, #-16]
10007e5c:	e3530000 	cmp	r3, #0
10007e60:	1a000005 	bne	10007e7c <_rt_scheduler_stack_check+0x34>
10007e64:	e30e0bf8 	movw	r0, #60408	; 0xebf8
10007e68:	e3410001 	movt	r0, #4097	; 0x1001
10007e6c:	e30e1c60 	movw	r1, #60512	; 0xec60
10007e70:	e3411001 	movt	r1, #4097	; 0x1001
10007e74:	e3a0205a 	mov	r2, #90	; 0x5a
10007e78:	ebfff9d2 	bl	100065c8 <rt_assert_handler>

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
10007e7c:	e51b3010 	ldr	r3, [fp, #-16]
10007e80:	e5933018 	ldr	r3, [r3, #24]
10007e84:	e1a02003 	mov	r2, r3
10007e88:	e51b3010 	ldr	r3, [fp, #-16]
10007e8c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10007e90:	e1520003 	cmp	r2, r3
10007e94:	9a00000a 	bls	10007ec4 <_rt_scheduler_stack_check+0x7c>
        (rt_uint32_t)thread->sp >
10007e98:	e51b3010 	ldr	r3, [fp, #-16]
10007e9c:	e5933018 	ldr	r3, [r3, #24]
10007ea0:	e1a02003 	mov	r2, r3
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
10007ea4:	e51b3010 	ldr	r3, [fp, #-16]
10007ea8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10007eac:	e1a01003 	mov	r1, r3
10007eb0:	e51b3010 	ldr	r3, [fp, #-16]
10007eb4:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
10007eb8:	e0813003 	add	r3, r1, r3
#ifdef RT_USING_OVERFLOW_CHECK
static void _rt_scheduler_stack_check(struct rt_thread *thread)
{
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
10007ebc:	e1520003 	cmp	r2, r3
10007ec0:	9a00000c 	bls	10007ef8 <_rt_scheduler_stack_check+0xb0>
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
        rt_uint32_t level;

        rt_kprintf("thread:%s stack overflow\n", thread->name);
10007ec4:	e51b3010 	ldr	r3, [fp, #-16]
10007ec8:	e30e0c0c 	movw	r0, #60428	; 0xec0c
10007ecc:	e3410001 	movt	r0, #4097	; 0x1001
10007ed0:	e1a01003 	mov	r1, r3
10007ed4:	ebfff8fe 	bl	100062d4 <rt_kprintf>
        #ifdef RT_USING_FINSH
        {
            extern long list_thread(void);
            list_thread();
10007ed8:	eb0028e9 	bl	10012284 <list_thread>
        }
        #endif
        level = rt_hw_interrupt_disable();
10007edc:	eb000d76 	bl	1000b4bc <rt_hw_interrupt_disable>
10007ee0:	e1a03000 	mov	r3, r0
10007ee4:	e50b3008 	str	r3, [fp, #-8]
        while (level);
10007ee8:	e51b3008 	ldr	r3, [fp, #-8]
10007eec:	e3530000 	cmp	r3, #0
10007ef0:	1afffffc 	bne	10007ee8 <_rt_scheduler_stack_check+0xa0>
    RT_ASSERT(thread != RT_NULL);

    if ((rt_uint32_t)thread->sp <= (rt_uint32_t)thread->stack_addr ||
        (rt_uint32_t)thread->sp >
        (rt_uint32_t)thread->stack_addr + (rt_uint32_t)thread->stack_size)
    {
10007ef4:	ea00000c 	b	10007f2c <_rt_scheduler_stack_check+0xe4>
        }
        #endif
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
10007ef8:	e51b3010 	ldr	r3, [fp, #-16]
10007efc:	e5933018 	ldr	r3, [r3, #24]
10007f00:	e1a02003 	mov	r2, r3
10007f04:	e51b3010 	ldr	r3, [fp, #-16]
10007f08:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10007f0c:	e2833020 	add	r3, r3, #32
10007f10:	e1520003 	cmp	r2, r3
10007f14:	8a000004 	bhi	10007f2c <_rt_scheduler_stack_check+0xe4>
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
                   thread->name);
10007f18:	e51b3010 	ldr	r3, [fp, #-16]
        level = rt_hw_interrupt_disable();
        while (level);
    }
    else if ((rt_uint32_t)thread->sp <= ((rt_uint32_t)thread->stack_addr + 32))
    {
        rt_kprintf("warning: %s stack is close to end of stack address.\n",
10007f1c:	e30e0c28 	movw	r0, #60456	; 0xec28
10007f20:	e3410001 	movt	r0, #4097	; 0x1001
10007f24:	e1a01003 	mov	r1, r3
10007f28:	ebfff8e9 	bl	100062d4 <rt_kprintf>
                   thread->name);
    }
}
10007f2c:	e24bd004 	sub	sp, fp, #4
10007f30:	e8bd8800 	pop	{fp, pc}

10007f34 <rt_system_scheduler_init>:
/**
 * @ingroup SystemInit
 * This function will initialize the system scheduler
 */
void rt_system_scheduler_init(void)
{
10007f34:	e92d4818 	push	{r3, r4, fp, lr}
10007f38:	e28db00c 	add	fp, sp, #12
    register rt_base_t offset;

    rt_scheduler_lock_nest = 0;
10007f3c:	e30833ec 	movw	r3, #33772	; 0x83ec
10007f40:	e3413002 	movt	r3, #4098	; 0x1002
10007f44:	e3a02000 	mov	r2, #0
10007f48:	e1c320b0 	strh	r2, [r3]

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
10007f4c:	e3a04000 	mov	r4, #0
10007f50:	ea000006 	b	10007f70 <rt_system_scheduler_init+0x3c>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
10007f54:	e1a02184 	lsl	r2, r4, #3
10007f58:	e3093d94 	movw	r3, #40340	; 0x9d94
10007f5c:	e3413002 	movt	r3, #4098	; 0x1002
10007f60:	e0823003 	add	r3, r2, r3
10007f64:	e1a00003 	mov	r0, r3
10007f68:	ebffff60 	bl	10007cf0 <rt_list_init>
    rt_scheduler_lock_nest = 0;

    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
                                      RT_THREAD_PRIORITY_MAX));

    for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
10007f6c:	e2844001 	add	r4, r4, #1
10007f70:	e354001f 	cmp	r4, #31
10007f74:	dafffff6 	ble	10007f54 <rt_system_scheduler_init+0x20>
    {
        rt_list_init(&rt_thread_priority_table[offset]);
    }

    rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
10007f78:	e3093e94 	movw	r3, #40596	; 0x9e94
10007f7c:	e3413002 	movt	r3, #4098	; 0x1002
10007f80:	e3a0201f 	mov	r2, #31
10007f84:	e5c32000 	strb	r2, [r3]
    rt_current_thread = RT_NULL;
10007f88:	e3093e98 	movw	r3, #40600	; 0x9e98
10007f8c:	e3413002 	movt	r3, #4098	; 0x1002
10007f90:	e3a02000 	mov	r2, #0
10007f94:	e5832000 	str	r2, [r3]

    /* initialize ready priority group */
    rt_thread_ready_priority_group = 0;
10007f98:	e3093e9c 	movw	r3, #40604	; 0x9e9c
10007f9c:	e3413002 	movt	r3, #4098	; 0x1002
10007fa0:	e3a02000 	mov	r2, #0
10007fa4:	e5832000 	str	r2, [r3]
    /* initialize ready table */
    rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
#endif

    /* initialize thread defunct */
    rt_list_init(&rt_thread_defunct);
10007fa8:	e3090ea0 	movw	r0, #40608	; 0x9ea0
10007fac:	e3410002 	movt	r0, #4098	; 0x1002
10007fb0:	ebffff4e 	bl	10007cf0 <rt_list_init>
}
10007fb4:	e8bd8818 	pop	{r3, r4, fp, pc}

10007fb8 <rt_system_scheduler_start>:
 * @ingroup SystemInit
 * This function will startup scheduler. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_system_scheduler_start(void)
{
10007fb8:	e92d4818 	push	{r3, r4, fp, lr}
10007fbc:	e28db00c 	add	fp, sp, #12
    register rt_ubase_t number;

    number = __rt_ffs(rt_thread_ready_priority_group) - 1;
    highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#else
    highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
10007fc0:	e3093e9c 	movw	r3, #40604	; 0x9e9c
10007fc4:	e3413002 	movt	r3, #4098	; 0x1002
10007fc8:	e5933000 	ldr	r3, [r3]
10007fcc:	e1a00003 	mov	r0, r3
10007fd0:	ebfff93b 	bl	100064c4 <__rt_ffs>
10007fd4:	e1a03000 	mov	r3, r0
10007fd8:	e2433001 	sub	r3, r3, #1
10007fdc:	e1a04003 	mov	r4, r3
#endif

    /* get switch to thread */
    to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
10007fe0:	e3093d94 	movw	r3, #40340	; 0x9d94
10007fe4:	e3413002 	movt	r3, #4098	; 0x1002
10007fe8:	e7933184 	ldr	r3, [r3, r4, lsl #3]
10007fec:	e2434010 	sub	r4, r3, #16
                              struct rt_thread,
                              tlist);

    rt_current_thread = to_thread;
10007ff0:	e3093e98 	movw	r3, #40600	; 0x9e98
10007ff4:	e3413002 	movt	r3, #4098	; 0x1002
10007ff8:	e5834000 	str	r4, [r3]

    /* switch to new thread */
    rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
10007ffc:	e2843018 	add	r3, r4, #24
10008000:	e1a00003 	mov	r0, r3
10008004:	eb000d3e 	bl	1000b504 <rt_hw_context_switch_to>

    /* never come back */
}
10008008:	e8bd8818 	pop	{r3, r4, fp, pc}

1000800c <rt_schedule>:
/**
 * This function will perform one schedule. It will select one thread
 * with the highest priority level, then switch to it.
 */
void rt_schedule(void)
{
1000800c:	e92d4810 	push	{r4, fp, lr}
10008010:	e28db008 	add	fp, sp, #8
10008014:	e24dd014 	sub	sp, sp, #20
    rt_base_t level;
    struct rt_thread *to_thread;
    struct rt_thread *from_thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10008018:	eb000d27 	bl	1000b4bc <rt_hw_interrupt_disable>
1000801c:	e50b0010 	str	r0, [fp, #-16]

    /* check the scheduler is enabled or not */
    if (rt_scheduler_lock_nest == 0)
10008020:	e30833ec 	movw	r3, #33772	; 0x83ec
10008024:	e3413002 	movt	r3, #4098	; 0x1002
10008028:	e1d330b0 	ldrh	r3, [r3]
1000802c:	e3530000 	cmp	r3, #0
10008030:	1a000042 	bne	10008140 <rt_schedule+0x134>
    {
        register rt_ubase_t highest_ready_priority;

#if RT_THREAD_PRIORITY_MAX <= 32
        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
10008034:	e3093e9c 	movw	r3, #40604	; 0x9e9c
10008038:	e3413002 	movt	r3, #4098	; 0x1002
1000803c:	e5933000 	ldr	r3, [r3]
10008040:	e1a00003 	mov	r0, r3
10008044:	ebfff91e 	bl	100064c4 <__rt_ffs>
10008048:	e1a03000 	mov	r3, r0
1000804c:	e2433001 	sub	r3, r3, #1
10008050:	e1a04003 	mov	r4, r3
        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
#endif

        /* get switch to thread */
        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
10008054:	e3093d94 	movw	r3, #40340	; 0x9d94
10008058:	e3413002 	movt	r3, #4098	; 0x1002
1000805c:	e7933184 	ldr	r3, [r3, r4, lsl #3]
10008060:	e2433010 	sub	r3, r3, #16
10008064:	e50b3014 	str	r3, [fp, #-20]
                                  struct rt_thread,
                                  tlist);

        /* if the destination thread is not the same as current thread */
        if (to_thread != rt_current_thread)
10008068:	e3093e98 	movw	r3, #40600	; 0x9e98
1000806c:	e3413002 	movt	r3, #4098	; 0x1002
10008070:	e5933000 	ldr	r3, [r3]
10008074:	e51b2014 	ldr	r2, [fp, #-20]
10008078:	e1520003 	cmp	r2, r3
1000807c:	0a00002f 	beq	10008140 <rt_schedule+0x134>
        {
            rt_current_priority = (rt_uint8_t)highest_ready_priority;
10008080:	e6ef2074 	uxtb	r2, r4
10008084:	e3093e94 	movw	r3, #40596	; 0x9e94
10008088:	e3413002 	movt	r3, #4098	; 0x1002
1000808c:	e5c32000 	strb	r2, [r3]
            from_thread         = rt_current_thread;
10008090:	e3093e98 	movw	r3, #40600	; 0x9e98
10008094:	e3413002 	movt	r3, #4098	; 0x1002
10008098:	e5933000 	ldr	r3, [r3]
1000809c:	e50b3018 	str	r3, [fp, #-24]
            rt_current_thread   = to_thread;
100080a0:	e3093e98 	movw	r3, #40600	; 0x9e98
100080a4:	e3413002 	movt	r3, #4098	; 0x1002
100080a8:	e51b2014 	ldr	r2, [fp, #-20]
100080ac:	e5832000 	str	r2, [r3]

            RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
100080b0:	e30833f0 	movw	r3, #33776	; 0x83f0
100080b4:	e3413002 	movt	r3, #4098	; 0x1002
100080b8:	e5933000 	ldr	r3, [r3]
100080bc:	e3530000 	cmp	r3, #0
100080c0:	0a000005 	beq	100080dc <rt_schedule+0xd0>
100080c4:	e30833f0 	movw	r3, #33776	; 0x83f0
100080c8:	e3413002 	movt	r3, #4098	; 0x1002
100080cc:	e5933000 	ldr	r3, [r3]
100080d0:	e51b0018 	ldr	r0, [fp, #-24]
100080d4:	e51b1014 	ldr	r1, [fp, #-20]
100080d8:	e12fff33 	blx	r3
                          rt_interrupt_nest, highest_ready_priority,
                          RT_NAME_MAX, to_thread->name, to_thread->sp,
                          RT_NAME_MAX, from_thread->name, from_thread->sp));

#ifdef RT_USING_OVERFLOW_CHECK
            _rt_scheduler_stack_check(to_thread);
100080dc:	e51b0014 	ldr	r0, [fp, #-20]
100080e0:	ebffff58 	bl	10007e48 <_rt_scheduler_stack_check>
#endif

            if (rt_interrupt_nest == 0)
100080e4:	e3093d80 	movw	r3, #40320	; 0x9d80
100080e8:	e3413002 	movt	r3, #4098	; 0x1002
100080ec:	e5d33000 	ldrb	r3, [r3]
100080f0:	e6ef3073 	uxtb	r3, r3
100080f4:	e3530000 	cmp	r3, #0
100080f8:	1a000008 	bne	10008120 <rt_schedule+0x114>
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
100080fc:	e51b3018 	ldr	r3, [fp, #-24]
10008100:	e2833018 	add	r3, r3, #24
10008104:	e1a02003 	mov	r2, r3
                                     (rt_uint32_t)&to_thread->sp);
10008108:	e51b3014 	ldr	r3, [fp, #-20]
1000810c:	e2833018 	add	r3, r3, #24
            _rt_scheduler_stack_check(to_thread);
#endif

            if (rt_interrupt_nest == 0)
            {
                rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
10008110:	e1a00002 	mov	r0, r2
10008114:	e1a01003 	mov	r1, r3
10008118:	eb000ced 	bl	1000b4d4 <rt_hw_context_switch>
1000811c:	ea000007 	b	10008140 <rt_schedule+0x134>
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
10008120:	e51b3018 	ldr	r3, [fp, #-24]
10008124:	e2833018 	add	r3, r3, #24
10008128:	e1a02003 	mov	r2, r3
                                               (rt_uint32_t)&to_thread->sp);
1000812c:	e51b3014 	ldr	r3, [fp, #-20]
10008130:	e2833018 	add	r3, r3, #24
            }
            else
            {
                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));

                rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
10008134:	e1a00002 	mov	r0, r2
10008138:	e1a01003 	mov	r1, r3
1000813c:	eb000cf6 	bl	1000b51c <rt_hw_context_switch_interrupt>
            }
        }
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10008140:	e51b0010 	ldr	r0, [fp, #-16]
10008144:	eb000ce0 	bl	1000b4cc <rt_hw_interrupt_enable>
}
10008148:	e24bd008 	sub	sp, fp, #8
1000814c:	e8bd8810 	pop	{r4, fp, pc}

10008150 <rt_schedule_insert_thread>:
 *
 * @param thread the thread to be inserted
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_insert_thread(struct rt_thread *thread)
{
10008150:	e92d4810 	push	{r4, fp, lr}
10008154:	e28db008 	add	fp, sp, #8
10008158:	e24dd00c 	sub	sp, sp, #12
1000815c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
10008160:	e51b3010 	ldr	r3, [fp, #-16]
10008164:	e3530000 	cmp	r3, #0
10008168:	1a000005 	bne	10008184 <rt_schedule_insert_thread+0x34>
1000816c:	e30e0bf8 	movw	r0, #60408	; 0xebf8
10008170:	e3410001 	movt	r0, #4097	; 0x1001
10008174:	e30e1c7c 	movw	r1, #60540	; 0xec7c
10008178:	e3411001 	movt	r1, #4097	; 0x1001
1000817c:	e300210f 	movw	r2, #271	; 0x10f
10008180:	ebfff910 	bl	100065c8 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10008184:	eb000ccc 	bl	1000b4bc <rt_hw_interrupt_disable>
10008188:	e1a04000 	mov	r4, r0

    /* change stat */
    thread->stat = RT_THREAD_READY;
1000818c:	e51b3010 	ldr	r3, [fp, #-16]
10008190:	e3a02001 	mov	r2, #1
10008194:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* insert thread to ready list */
    rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
10008198:	e51b3010 	ldr	r3, [fp, #-16]
1000819c:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
100081a0:	e1a02183 	lsl	r2, r3, #3
100081a4:	e3093d94 	movw	r3, #40340	; 0x9d94
100081a8:	e3413002 	movt	r3, #4098	; 0x1002
100081ac:	e0822003 	add	r2, r2, r3
100081b0:	e51b3010 	ldr	r3, [fp, #-16]
100081b4:	e2833010 	add	r3, r3, #16
100081b8:	e1a00002 	mov	r0, r2
100081bc:	e1a01003 	mov	r1, r3
100081c0:	ebfffed8 	bl	10007d28 <rt_list_insert_before>
#endif

#if RT_THREAD_PRIORITY_MAX > 32
    rt_thread_ready_table[thread->number] |= thread->high_mask;
#endif
    rt_thread_ready_priority_group |= thread->number_mask;
100081c4:	e51b3010 	ldr	r3, [fp, #-16]
100081c8:	e5932034 	ldr	r2, [r3, #52]	; 0x34
100081cc:	e3093e9c 	movw	r3, #40604	; 0x9e9c
100081d0:	e3413002 	movt	r3, #4098	; 0x1002
100081d4:	e5933000 	ldr	r3, [r3]
100081d8:	e1822003 	orr	r2, r2, r3
100081dc:	e3093e9c 	movw	r3, #40604	; 0x9e9c
100081e0:	e3413002 	movt	r3, #4098	; 0x1002
100081e4:	e5832000 	str	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
100081e8:	e1a00004 	mov	r0, r4
100081ec:	eb000cb6 	bl	1000b4cc <rt_hw_interrupt_enable>
}
100081f0:	e24bd008 	sub	sp, fp, #8
100081f4:	e8bd8810 	pop	{r4, fp, pc}

100081f8 <rt_schedule_remove_thread>:
 * @param thread the thread to be removed
 *
 * @note Please do not invoke this function in user application.
 */
void rt_schedule_remove_thread(struct rt_thread *thread)
{
100081f8:	e92d4810 	push	{r4, fp, lr}
100081fc:	e28db008 	add	fp, sp, #8
10008200:	e24dd00c 	sub	sp, sp, #12
10008204:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    RT_ASSERT(thread != RT_NULL);
10008208:	e51b3010 	ldr	r3, [fp, #-16]
1000820c:	e3530000 	cmp	r3, #0
10008210:	1a000005 	bne	1000822c <rt_schedule_remove_thread+0x34>
10008214:	e30e0bf8 	movw	r0, #60408	; 0xebf8
10008218:	e3410001 	movt	r0, #4097	; 0x1001
1000821c:	e30e1c98 	movw	r1, #60568	; 0xec98
10008220:	e3411001 	movt	r1, #4097	; 0x1001
10008224:	e300213d 	movw	r2, #317	; 0x13d
10008228:	ebfff8e6 	bl	100065c8 <rt_assert_handler>

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
1000822c:	eb000ca2 	bl	1000b4bc <rt_hw_interrupt_disable>
10008230:	e1a04000 	mov	r4, r0
                  thread->number_mask,
                  thread->high_mask));
#endif

    /* remove thread from ready list */
    rt_list_remove(&(thread->tlist));
10008234:	e51b3010 	ldr	r3, [fp, #-16]
10008238:	e2833010 	add	r3, r3, #16
1000823c:	e1a00003 	mov	r0, r3
10008240:	ebfffece 	bl	10007d80 <rt_list_remove>
    if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
10008244:	e51b3010 	ldr	r3, [fp, #-16]
10008248:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
1000824c:	e1a02183 	lsl	r2, r3, #3
10008250:	e3093d94 	movw	r3, #40340	; 0x9d94
10008254:	e3413002 	movt	r3, #4098	; 0x1002
10008258:	e0823003 	add	r3, r2, r3
1000825c:	e1a00003 	mov	r0, r3
10008260:	ebfffede 	bl	10007de0 <rt_list_isempty>
10008264:	e1a03000 	mov	r3, r0
10008268:	e3530000 	cmp	r3, #0
1000826c:	0a000009 	beq	10008298 <rt_schedule_remove_thread+0xa0>
        if (rt_thread_ready_table[thread->number] == 0)
        {
            rt_thread_ready_priority_group &= ~thread->number_mask;
        }
#else
        rt_thread_ready_priority_group &= ~thread->number_mask;
10008270:	e51b3010 	ldr	r3, [fp, #-16]
10008274:	e5933034 	ldr	r3, [r3, #52]	; 0x34
10008278:	e1e02003 	mvn	r2, r3
1000827c:	e3093e9c 	movw	r3, #40604	; 0x9e9c
10008280:	e3413002 	movt	r3, #4098	; 0x1002
10008284:	e5933000 	ldr	r3, [r3]
10008288:	e0022003 	and	r2, r2, r3
1000828c:	e3093e9c 	movw	r3, #40604	; 0x9e9c
10008290:	e3413002 	movt	r3, #4098	; 0x1002
10008294:	e5832000 	str	r2, [r3]
#endif
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10008298:	e1a00004 	mov	r0, r4
1000829c:	eb000c8a 	bl	1000b4cc <rt_hw_interrupt_enable>
}
100082a0:	e24bd008 	sub	sp, fp, #8
100082a4:	e8bd8810 	pop	{r4, fp, pc}

100082a8 <rt_enter_critical>:

/**
 * This function will lock the thread scheduler.
 */
void rt_enter_critical(void)
{
100082a8:	e92d4818 	push	{r3, r4, fp, lr}
100082ac:	e28db00c 	add	fp, sp, #12
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100082b0:	eb000c81 	bl	1000b4bc <rt_hw_interrupt_disable>
100082b4:	e1a04000 	mov	r4, r0

    /*
     * the maximal number of nest is RT_UINT16_MAX, which is big
     * enough and does not check here
     */
    rt_scheduler_lock_nest ++;
100082b8:	e30833ec 	movw	r3, #33772	; 0x83ec
100082bc:	e3413002 	movt	r3, #4098	; 0x1002
100082c0:	e1d330b0 	ldrh	r3, [r3]
100082c4:	e6ff3073 	uxth	r3, r3
100082c8:	e6ff3073 	uxth	r3, r3
100082cc:	e2833001 	add	r3, r3, #1
100082d0:	e6ff3073 	uxth	r3, r3
100082d4:	e6ff2073 	uxth	r2, r3
100082d8:	e30833ec 	movw	r3, #33772	; 0x83ec
100082dc:	e3413002 	movt	r3, #4098	; 0x1002
100082e0:	e1c320b0 	strh	r2, [r3]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100082e4:	e1a00004 	mov	r0, r4
100082e8:	eb000c77 	bl	1000b4cc <rt_hw_interrupt_enable>
}
100082ec:	e8bd8818 	pop	{r3, r4, fp, pc}

100082f0 <rt_exit_critical>:

/**
 * This function will unlock the thread scheduler.
 */
void rt_exit_critical(void)
{
100082f0:	e92d4818 	push	{r3, r4, fp, lr}
100082f4:	e28db00c 	add	fp, sp, #12
    register rt_base_t level;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100082f8:	eb000c6f 	bl	1000b4bc <rt_hw_interrupt_disable>
100082fc:	e1a04000 	mov	r4, r0

    rt_scheduler_lock_nest --;
10008300:	e30833ec 	movw	r3, #33772	; 0x83ec
10008304:	e3413002 	movt	r3, #4098	; 0x1002
10008308:	e1d330b0 	ldrh	r3, [r3]
1000830c:	e6ff3073 	uxth	r3, r3
10008310:	e6ff3073 	uxth	r3, r3
10008314:	e2433001 	sub	r3, r3, #1
10008318:	e6ff3073 	uxth	r3, r3
1000831c:	e6ff2073 	uxth	r2, r3
10008320:	e30833ec 	movw	r3, #33772	; 0x83ec
10008324:	e3413002 	movt	r3, #4098	; 0x1002
10008328:	e1c320b0 	strh	r2, [r3]

    if (rt_scheduler_lock_nest <= 0)
1000832c:	e30833ec 	movw	r3, #33772	; 0x83ec
10008330:	e3413002 	movt	r3, #4098	; 0x1002
10008334:	e1d330b0 	ldrh	r3, [r3]
10008338:	e6bf3073 	sxth	r3, r3
1000833c:	e3530000 	cmp	r3, #0
10008340:	ca000007 	bgt	10008364 <rt_exit_critical+0x74>
    {
        rt_scheduler_lock_nest = 0;
10008344:	e30833ec 	movw	r3, #33772	; 0x83ec
10008348:	e3413002 	movt	r3, #4098	; 0x1002
1000834c:	e3a02000 	mov	r2, #0
10008350:	e1c320b0 	strh	r2, [r3]
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10008354:	e1a00004 	mov	r0, r4
10008358:	eb000c5b 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
1000835c:	ebffff2a 	bl	1000800c <rt_schedule>
10008360:	ea000001 	b	1000836c <rt_exit_critical+0x7c>
    }
    else
    {
        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10008364:	e1a00004 	mov	r0, r4
10008368:	eb000c57 	bl	1000b4cc <rt_hw_interrupt_enable>
    }
}
1000836c:	e8bd8818 	pop	{r3, r4, fp, pc}

10008370 <rt_critical_level>:
 * Get the scheduler lock level
 *
 * @return the level of the scheduler lock. 0 means unlocked.
 */
rt_uint16_t rt_critical_level(void)
{
10008370:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008374:	e28db000 	add	fp, sp, #0
    return rt_scheduler_lock_nest;
10008378:	e30833ec 	movw	r3, #33772	; 0x83ec
1000837c:	e3413002 	movt	r3, #4098	; 0x1002
10008380:	e1d330b0 	ldrh	r3, [r3]
10008384:	e6ff3073 	uxth	r3, r3
}
10008388:	e1a00003 	mov	r0, r3
1000838c:	e24bd000 	sub	sp, fp, #0
10008390:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008394:	e12fff1e 	bx	lr

10008398 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10008398:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000839c:	e28db000 	add	fp, sp, #0
100083a0:	e24dd00c 	sub	sp, sp, #12
100083a4:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
100083a8:	e51b3008 	ldr	r3, [fp, #-8]
100083ac:	e51b2008 	ldr	r2, [fp, #-8]
100083b0:	e5832004 	str	r2, [r3, #4]
100083b4:	e51b3008 	ldr	r3, [fp, #-8]
100083b8:	e5932004 	ldr	r2, [r3, #4]
100083bc:	e51b3008 	ldr	r3, [fp, #-8]
100083c0:	e5832000 	str	r2, [r3]
}
100083c4:	e24bd000 	sub	sp, fp, #0
100083c8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100083cc:	e12fff1e 	bx	lr

100083d0 <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
100083d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100083d4:	e28db000 	add	fp, sp, #0
100083d8:	e24dd00c 	sub	sp, sp, #12
100083dc:	e50b0008 	str	r0, [fp, #-8]
100083e0:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
100083e4:	e51b3008 	ldr	r3, [fp, #-8]
100083e8:	e5933000 	ldr	r3, [r3]
100083ec:	e51b200c 	ldr	r2, [fp, #-12]
100083f0:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
100083f4:	e51b3008 	ldr	r3, [fp, #-8]
100083f8:	e5932000 	ldr	r2, [r3]
100083fc:	e51b300c 	ldr	r3, [fp, #-12]
10008400:	e5832000 	str	r2, [r3]

    l->next = n;
10008404:	e51b3008 	ldr	r3, [fp, #-8]
10008408:	e51b200c 	ldr	r2, [fp, #-12]
1000840c:	e5832000 	str	r2, [r3]
    n->prev = l;
10008410:	e51b300c 	ldr	r3, [fp, #-12]
10008414:	e51b2008 	ldr	r2, [fp, #-8]
10008418:	e5832004 	str	r2, [r3, #4]
}
1000841c:	e24bd000 	sub	sp, fp, #0
10008420:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10008424:	e12fff1e 	bx	lr

10008428 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
10008428:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000842c:	e28db000 	add	fp, sp, #0
10008430:	e24dd00c 	sub	sp, sp, #12
10008434:	e50b0008 	str	r0, [fp, #-8]
10008438:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
1000843c:	e51b3008 	ldr	r3, [fp, #-8]
10008440:	e5933004 	ldr	r3, [r3, #4]
10008444:	e51b200c 	ldr	r2, [fp, #-12]
10008448:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
1000844c:	e51b3008 	ldr	r3, [fp, #-8]
10008450:	e5932004 	ldr	r2, [r3, #4]
10008454:	e51b300c 	ldr	r3, [fp, #-12]
10008458:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
1000845c:	e51b3008 	ldr	r3, [fp, #-8]
10008460:	e51b200c 	ldr	r2, [fp, #-12]
10008464:	e5832004 	str	r2, [r3, #4]
    n->next = l;
10008468:	e51b300c 	ldr	r3, [fp, #-12]
1000846c:	e51b2008 	ldr	r2, [fp, #-8]
10008470:	e5832000 	str	r2, [r3]
}
10008474:	e24bd000 	sub	sp, fp, #0
10008478:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000847c:	e12fff1e 	bx	lr

10008480 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
10008480:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008484:	e28db000 	add	fp, sp, #0
10008488:	e24dd00c 	sub	sp, sp, #12
1000848c:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
10008490:	e51b3008 	ldr	r3, [fp, #-8]
10008494:	e5933000 	ldr	r3, [r3]
10008498:	e51b2008 	ldr	r2, [fp, #-8]
1000849c:	e5922004 	ldr	r2, [r2, #4]
100084a0:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
100084a4:	e51b3008 	ldr	r3, [fp, #-8]
100084a8:	e5933004 	ldr	r3, [r3, #4]
100084ac:	e51b2008 	ldr	r2, [fp, #-8]
100084b0:	e5922000 	ldr	r2, [r2]
100084b4:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
100084b8:	e51b3008 	ldr	r3, [fp, #-8]
100084bc:	e51b2008 	ldr	r2, [fp, #-8]
100084c0:	e5832004 	str	r2, [r3, #4]
100084c4:	e51b3008 	ldr	r3, [fp, #-8]
100084c8:	e5932004 	ldr	r2, [r3, #4]
100084cc:	e51b3008 	ldr	r3, [fp, #-8]
100084d0:	e5832000 	str	r2, [r3]
}
100084d4:	e24bd000 	sub	sp, fp, #0
100084d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100084dc:	e12fff1e 	bx	lr

100084e0 <rt_thread_exit>:
extern rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
extern struct rt_thread *rt_current_thread;
extern rt_list_t rt_thread_defunct;

static void rt_thread_exit(void)
{
100084e0:	e92d4810 	push	{r4, fp, lr}
100084e4:	e28db008 	add	fp, sp, #8
100084e8:	e24dd00c 	sub	sp, sp, #12
    struct rt_thread *thread;
    register rt_base_t level;

    /* get current thread */
    thread = rt_current_thread;
100084ec:	e3093e98 	movw	r3, #40600	; 0x9e98
100084f0:	e3413002 	movt	r3, #4098	; 0x1002
100084f4:	e5933000 	ldr	r3, [r3]
100084f8:	e50b3010 	str	r3, [fp, #-16]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100084fc:	eb000bee 	bl	1000b4bc <rt_hw_interrupt_disable>
10008500:	e1a04000 	mov	r4, r0

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
10008504:	e51b0010 	ldr	r0, [fp, #-16]
10008508:	ebffff3a 	bl	100081f8 <rt_schedule_remove_thread>
    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
1000850c:	e51b3010 	ldr	r3, [fp, #-16]
10008510:	e3a02004 	mov	r2, #4
10008514:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);
10008518:	e51b3010 	ldr	r3, [fp, #-16]
1000851c:	e2833048 	add	r3, r3, #72	; 0x48
10008520:	e1a00003 	mov	r0, r3
10008524:	eb000375 	bl	10009300 <rt_timer_detach>

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
10008528:	e51b0010 	ldr	r0, [fp, #-16]
1000852c:	ebfffd86 	bl	10007b4c <rt_object_is_systemobject>
10008530:	e1a03000 	mov	r3, r0
10008534:	e3530001 	cmp	r3, #1
10008538:	1a000006 	bne	10008558 <rt_thread_exit+0x78>
        thread->cleanup == RT_NULL)
1000853c:	e51b3010 	ldr	r3, [fp, #-16]
10008540:	e5933070 	ldr	r3, [r3, #112]	; 0x70
    thread->stat = RT_THREAD_CLOSE;

    /* remove it from timer list */
    rt_timer_detach(&thread->thread_timer);

    if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
10008544:	e3530000 	cmp	r3, #0
10008548:	1a000002 	bne	10008558 <rt_thread_exit+0x78>
        thread->cleanup == RT_NULL)
    {
        rt_object_detach((rt_object_t)thread);
1000854c:	e51b0010 	ldr	r0, [fp, #-16]
10008550:	ebfffce0 	bl	100078d8 <rt_object_detach>
10008554:	ea000005 	b	10008570 <rt_thread_exit+0x90>
    }
    else
    {
        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
10008558:	e51b3010 	ldr	r3, [fp, #-16]
1000855c:	e2833010 	add	r3, r3, #16
10008560:	e3090ea0 	movw	r0, #40608	; 0x9ea0
10008564:	e3410002 	movt	r0, #4098	; 0x1002
10008568:	e1a01003 	mov	r1, r3
1000856c:	ebffff97 	bl	100083d0 <rt_list_insert_after>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10008570:	e1a00004 	mov	r0, r4
10008574:	eb000bd4 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* switch to next task */
    rt_schedule();
10008578:	ebfffea3 	bl	1000800c <rt_schedule>
}
1000857c:	e24bd008 	sub	sp, fp, #8
10008580:	e8bd8810 	pop	{r4, fp, pc}

10008584 <_rt_thread_init>:
                                void             *parameter,
                                void             *stack_start,
                                rt_uint32_t       stack_size,
                                rt_uint8_t        priority,
                                rt_uint32_t       tick)
{
10008584:	e92d4800 	push	{fp, lr}
10008588:	e28db004 	add	fp, sp, #4
1000858c:	e24dd018 	sub	sp, sp, #24
10008590:	e50b0008 	str	r0, [fp, #-8]
10008594:	e50b100c 	str	r1, [fp, #-12]
10008598:	e50b2010 	str	r2, [fp, #-16]
1000859c:	e50b3014 	str	r3, [fp, #-20]
    /* init thread list */
    rt_list_init(&(thread->tlist));
100085a0:	e51b3008 	ldr	r3, [fp, #-8]
100085a4:	e2833010 	add	r3, r3, #16
100085a8:	e1a00003 	mov	r0, r3
100085ac:	ebffff79 	bl	10008398 <rt_list_init>

    thread->entry = (void *)entry;
100085b0:	e51b3008 	ldr	r3, [fp, #-8]
100085b4:	e51b2010 	ldr	r2, [fp, #-16]
100085b8:	e583201c 	str	r2, [r3, #28]
    thread->parameter = parameter;
100085bc:	e51b3008 	ldr	r3, [fp, #-8]
100085c0:	e51b2014 	ldr	r2, [fp, #-20]
100085c4:	e5832020 	str	r2, [r3, #32]

    /* stack init */
    thread->stack_addr = stack_start;
100085c8:	e51b3008 	ldr	r3, [fp, #-8]
100085cc:	e59b2004 	ldr	r2, [fp, #4]
100085d0:	e5832024 	str	r2, [r3, #36]	; 0x24
    thread->stack_size = (rt_uint16_t)stack_size;
100085d4:	e59b3008 	ldr	r3, [fp, #8]
100085d8:	e6ff2073 	uxth	r2, r3
100085dc:	e51b3008 	ldr	r3, [fp, #-8]
100085e0:	e1c322b8 	strh	r2, [r3, #40]	; 0x28

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
100085e4:	e51b3008 	ldr	r3, [fp, #-8]
100085e8:	e5932024 	ldr	r2, [r3, #36]	; 0x24
100085ec:	e51b3008 	ldr	r3, [fp, #-8]
100085f0:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
100085f4:	e1a00002 	mov	r0, r2
100085f8:	e3a01023 	mov	r1, #35	; 0x23
100085fc:	e1a02003 	mov	r2, r3
10008600:	ebfff144 	bl	10004b18 <rt_memset>
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
10008604:	e51b3008 	ldr	r3, [fp, #-8]
10008608:	e593001c 	ldr	r0, [r3, #28]
1000860c:	e51b3008 	ldr	r3, [fp, #-8]
10008610:	e5931020 	ldr	r1, [r3, #32]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
10008614:	e51b3008 	ldr	r3, [fp, #-8]
10008618:	e5932024 	ldr	r2, [r3, #36]	; 0x24
1000861c:	e51b3008 	ldr	r3, [fp, #-8]
10008620:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
10008624:	e2433004 	sub	r3, r3, #4
10008628:	e0823003 	add	r3, r2, r3
    thread->stack_addr = stack_start;
    thread->stack_size = (rt_uint16_t)stack_size;

    /* init thread stack */
    rt_memset(thread->stack_addr, '#', thread->stack_size);
    thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
1000862c:	e1a02003 	mov	r2, r3
10008630:	e30834e0 	movw	r3, #34016	; 0x84e0
10008634:	e3413000 	movt	r3, #4096	; 0x1000
10008638:	eb000a53 	bl	1000af8c <rt_hw_stack_init>
1000863c:	e1a02000 	mov	r2, r0
10008640:	e51b3008 	ldr	r3, [fp, #-8]
10008644:	e5832018 	str	r2, [r3, #24]
        (void *)((char *)thread->stack_addr + thread->stack_size - 4),
        (void *)rt_thread_exit);

    /* priority init */
    RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
10008648:	e5db300c 	ldrb	r3, [fp, #12]
1000864c:	e353001f 	cmp	r3, #31
10008650:	9a000005 	bls	1000866c <_rt_thread_init+0xe8>
10008654:	e30e0cb4 	movw	r0, #60596	; 0xecb4
10008658:	e3410001 	movt	r0, #4097	; 0x1001
1000865c:	e30e1d48 	movw	r1, #60744	; 0xed48
10008660:	e3411001 	movt	r1, #4097	; 0x1001
10008664:	e3a0206e 	mov	r2, #110	; 0x6e
10008668:	ebfff7d6 	bl	100065c8 <rt_assert_handler>
    thread->init_priority    = priority;
1000866c:	e51b3008 	ldr	r3, [fp, #-8]
10008670:	e5db200c 	ldrb	r2, [fp, #12]
10008674:	e5c32032 	strb	r2, [r3, #50]	; 0x32
    thread->current_priority = priority;
10008678:	e51b3008 	ldr	r3, [fp, #-8]
1000867c:	e5db200c 	ldrb	r2, [fp, #12]
10008680:	e5c32031 	strb	r2, [r3, #49]	; 0x31

    /* tick init */
    thread->init_tick      = tick;
10008684:	e51b3008 	ldr	r3, [fp, #-8]
10008688:	e59b2010 	ldr	r2, [fp, #16]
1000868c:	e5832040 	str	r2, [r3, #64]	; 0x40
    thread->remaining_tick = tick;
10008690:	e51b3008 	ldr	r3, [fp, #-8]
10008694:	e59b2010 	ldr	r2, [fp, #16]
10008698:	e5832044 	str	r2, [r3, #68]	; 0x44

    /* error and flags */
    thread->error = RT_EOK;
1000869c:	e51b3008 	ldr	r3, [fp, #-8]
100086a0:	e3a02000 	mov	r2, #0
100086a4:	e583202c 	str	r2, [r3, #44]	; 0x2c
    thread->stat  = RT_THREAD_INIT;
100086a8:	e51b3008 	ldr	r3, [fp, #-8]
100086ac:	e3a02000 	mov	r2, #0
100086b0:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
100086b4:	e51b3008 	ldr	r3, [fp, #-8]
100086b8:	e3a02000 	mov	r2, #0
100086bc:	e5832070 	str	r2, [r3, #112]	; 0x70
    thread->user_data = 0;
100086c0:	e51b3008 	ldr	r3, [fp, #-8]
100086c4:	e3a02000 	mov	r2, #0
100086c8:	e5832074 	str	r2, [r3, #116]	; 0x74

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
100086cc:	e51b3008 	ldr	r3, [fp, #-8]
100086d0:	e2831048 	add	r1, r3, #72	; 0x48
                  thread->name,
100086d4:	e51b2008 	ldr	r2, [fp, #-8]
    /* initialize cleanup function and user data */
    thread->cleanup   = 0;
    thread->user_data = 0;

    /* init thread timer */
    rt_timer_init(&(thread->thread_timer),
100086d8:	e3a03000 	mov	r3, #0
100086dc:	e58d3000 	str	r3, [sp]
100086e0:	e3a03000 	mov	r3, #0
100086e4:	e58d3004 	str	r3, [sp, #4]
100086e8:	e1a00001 	mov	r0, r1
100086ec:	e1a01002 	mov	r1, r2
100086f0:	e3082e74 	movw	r2, #36468	; 0x8e74
100086f4:	e3412000 	movt	r2, #4096	; 0x1000
100086f8:	e51b3008 	ldr	r3, [fp, #-8]
100086fc:	eb0002e2 	bl	1000928c <rt_timer_init>
                  rt_thread_timeout,
                  thread,
                  0,
                  RT_TIMER_FLAG_ONE_SHOT);

    return RT_EOK;
10008700:	e3a03000 	mov	r3, #0
}
10008704:	e1a00003 	mov	r0, r3
10008708:	e24bd004 	sub	sp, fp, #4
1000870c:	e8bd8800 	pop	{fp, pc}

10008710 <rt_thread_init>:
                        void             *parameter,
                        void             *stack_start,
                        rt_uint32_t       stack_size,
                        rt_uint8_t        priority,
                        rt_uint32_t       tick)
{
10008710:	e92d4800 	push	{fp, lr}
10008714:	e28db004 	add	fp, sp, #4
10008718:	e24dd020 	sub	sp, sp, #32
1000871c:	e50b0008 	str	r0, [fp, #-8]
10008720:	e50b100c 	str	r1, [fp, #-12]
10008724:	e50b2010 	str	r2, [fp, #-16]
10008728:	e50b3014 	str	r3, [fp, #-20]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
1000872c:	e51b3008 	ldr	r3, [fp, #-8]
10008730:	e3530000 	cmp	r3, #0
10008734:	1a000005 	bne	10008750 <rt_thread_init+0x40>
10008738:	e30e0cd8 	movw	r0, #60632	; 0xecd8
1000873c:	e3410001 	movt	r0, #4097	; 0x1001
10008740:	e30e1d58 	movw	r1, #60760	; 0xed58
10008744:	e3411001 	movt	r1, #4097	; 0x1001
10008748:	e3a020a8 	mov	r2, #168	; 0xa8
1000874c:	ebfff79d 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(stack_start != RT_NULL);
10008750:	e59b3004 	ldr	r3, [fp, #4]
10008754:	e3530000 	cmp	r3, #0
10008758:	1a000005 	bne	10008774 <rt_thread_init+0x64>
1000875c:	e30e0cec 	movw	r0, #60652	; 0xecec
10008760:	e3410001 	movt	r0, #4097	; 0x1001
10008764:	e30e1d58 	movw	r1, #60760	; 0xed58
10008768:	e3411001 	movt	r1, #4097	; 0x1001
1000876c:	e3a020a9 	mov	r2, #169	; 0xa9
10008770:	ebfff794 	bl	100065c8 <rt_assert_handler>

    /* init thread object */
    rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
10008774:	e51b0008 	ldr	r0, [fp, #-8]
10008778:	e3a01000 	mov	r1, #0
1000877c:	e51b200c 	ldr	r2, [fp, #-12]
10008780:	ebfffc25 	bl	1000781c <rt_object_init>

    return _rt_thread_init(thread,
10008784:	e59b3004 	ldr	r3, [fp, #4]
10008788:	e58d3000 	str	r3, [sp]
1000878c:	e59b3008 	ldr	r3, [fp, #8]
10008790:	e58d3004 	str	r3, [sp, #4]
10008794:	e5db300c 	ldrb	r3, [fp, #12]
10008798:	e58d3008 	str	r3, [sp, #8]
1000879c:	e59b3010 	ldr	r3, [fp, #16]
100087a0:	e58d300c 	str	r3, [sp, #12]
100087a4:	e51b0008 	ldr	r0, [fp, #-8]
100087a8:	e51b100c 	ldr	r1, [fp, #-12]
100087ac:	e51b2010 	ldr	r2, [fp, #-16]
100087b0:	e51b3014 	ldr	r3, [fp, #-20]
100087b4:	ebffff72 	bl	10008584 <_rt_thread_init>
100087b8:	e1a03000 	mov	r3, r0
                           parameter,
                           stack_start,
                           stack_size,
                           priority,
                           tick);
}
100087bc:	e1a00003 	mov	r0, r3
100087c0:	e24bd004 	sub	sp, fp, #4
100087c4:	e8bd8800 	pop	{fp, pc}

100087c8 <rt_thread_self>:
 * This function will return self thread object
 *
 * @return the self thread object
 */
rt_thread_t rt_thread_self(void)
{
100087c8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100087cc:	e28db000 	add	fp, sp, #0
    return rt_current_thread;
100087d0:	e3093e98 	movw	r3, #40600	; 0x9e98
100087d4:	e3413002 	movt	r3, #4098	; 0x1002
100087d8:	e5933000 	ldr	r3, [r3]
}
100087dc:	e1a00003 	mov	r0, r3
100087e0:	e24bd000 	sub	sp, fp, #0
100087e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100087e8:	e12fff1e 	bx	lr

100087ec <rt_thread_startup>:
 * @param thread the thread to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_startup(rt_thread_t thread)
{
100087ec:	e92d4800 	push	{fp, lr}
100087f0:	e28db004 	add	fp, sp, #4
100087f4:	e24dd008 	sub	sp, sp, #8
100087f8:	e50b0008 	str	r0, [fp, #-8]
    /* thread check */
    RT_ASSERT(thread != RT_NULL);
100087fc:	e51b3008 	ldr	r3, [fp, #-8]
10008800:	e3530000 	cmp	r3, #0
10008804:	1a000005 	bne	10008820 <rt_thread_startup+0x34>
10008808:	e30e0cd8 	movw	r0, #60632	; 0xecd8
1000880c:	e3410001 	movt	r0, #4097	; 0x1001
10008810:	e30e1d68 	movw	r1, #60776	; 0xed68
10008814:	e3411001 	movt	r1, #4097	; 0x1001
10008818:	e3a020ce 	mov	r2, #206	; 0xce
1000881c:	ebfff769 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_INIT);
10008820:	e51b3008 	ldr	r3, [fp, #-8]
10008824:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10008828:	e3530000 	cmp	r3, #0
1000882c:	0a000005 	beq	10008848 <rt_thread_startup+0x5c>
10008830:	e30e0d04 	movw	r0, #60676	; 0xed04
10008834:	e3410001 	movt	r0, #4097	; 0x1001
10008838:	e30e1d68 	movw	r1, #60776	; 0xed68
1000883c:	e3411001 	movt	r1, #4097	; 0x1001
10008840:	e3a020cf 	mov	r2, #207	; 0xcf
10008844:	ebfff75f 	bl	100065c8 <rt_assert_handler>

    /* set current priority to init priority */
    thread->current_priority = thread->init_priority;
10008848:	e51b3008 	ldr	r3, [fp, #-8]
1000884c:	e5d32032 	ldrb	r2, [r3, #50]	; 0x32
10008850:	e51b3008 	ldr	r3, [fp, #-8]
10008854:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
    thread->number      = thread->current_priority >> 3;            /* 5bit */
    thread->number_mask = 1L << thread->number;
    thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
#else
    thread->number_mask = 1L << thread->current_priority;
10008858:	e51b3008 	ldr	r3, [fp, #-8]
1000885c:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10008860:	e1a02003 	mov	r2, r3
10008864:	e3a03001 	mov	r3, #1
10008868:	e1a03213 	lsl	r3, r3, r2
1000886c:	e1a02003 	mov	r2, r3
10008870:	e51b3008 	ldr	r3, [fp, #-8]
10008874:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
                                   thread->name, thread->init_priority));
    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
10008878:	e51b3008 	ldr	r3, [fp, #-8]
1000887c:	e3a02002 	mov	r2, #2
10008880:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    /* then resume it */
    rt_thread_resume(thread);
10008884:	e51b0008 	ldr	r0, [fp, #-8]
10008888:	eb000154 	bl	10008de0 <rt_thread_resume>
    if (rt_thread_self() != RT_NULL)
1000888c:	ebffffcd 	bl	100087c8 <rt_thread_self>
10008890:	e1a03000 	mov	r3, r0
10008894:	e3530000 	cmp	r3, #0
10008898:	0a000000 	beq	100088a0 <rt_thread_startup+0xb4>
    {
        /* do a scheduling */
        rt_schedule();
1000889c:	ebfffdda 	bl	1000800c <rt_schedule>
    }

    return RT_EOK;
100088a0:	e3a03000 	mov	r3, #0
}
100088a4:	e1a00003 	mov	r0, r3
100088a8:	e24bd004 	sub	sp, fp, #4
100088ac:	e8bd8800 	pop	{fp, pc}

100088b0 <rt_thread_detach>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_detach(rt_thread_t thread)
{
100088b0:	e92d4800 	push	{fp, lr}
100088b4:	e28db004 	add	fp, sp, #4
100088b8:	e24dd010 	sub	sp, sp, #16
100088bc:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
100088c0:	e51b3010 	ldr	r3, [fp, #-16]
100088c4:	e3530000 	cmp	r3, #0
100088c8:	1a000005 	bne	100088e4 <rt_thread_detach+0x34>
100088cc:	e30e0cd8 	movw	r0, #60632	; 0xecd8
100088d0:	e3410001 	movt	r0, #4097	; 0x1001
100088d4:	e30e1d7c 	movw	r1, #60796	; 0xed7c
100088d8:	e3411001 	movt	r1, #4097	; 0x1001
100088dc:	e3a020fa 	mov	r2, #250	; 0xfa
100088e0:	ebfff738 	bl	100065c8 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
100088e4:	e51b0010 	ldr	r0, [fp, #-16]
100088e8:	ebfffe42 	bl	100081f8 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
100088ec:	e51b3010 	ldr	r3, [fp, #-16]
100088f0:	e2833048 	add	r3, r3, #72	; 0x48
100088f4:	e1a00003 	mov	r0, r3
100088f8:	eb000280 	bl	10009300 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
100088fc:	e51b3010 	ldr	r3, [fp, #-16]
10008900:	e3a02004 	mov	r2, #4
10008904:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* detach object */
    rt_object_detach((rt_object_t)thread);
10008908:	e51b0010 	ldr	r0, [fp, #-16]
1000890c:	ebfffbf1 	bl	100078d8 <rt_object_detach>

    if (thread->cleanup != RT_NULL)
10008910:	e51b3010 	ldr	r3, [fp, #-16]
10008914:	e5933070 	ldr	r3, [r3, #112]	; 0x70
10008918:	e3530000 	cmp	r3, #0
1000891c:	0a000009 	beq	10008948 <rt_thread_detach+0x98>
    {
        /* disable interrupt */
        lock = rt_hw_interrupt_disable();
10008920:	eb000ae5 	bl	1000b4bc <rt_hw_interrupt_disable>
10008924:	e50b0008 	str	r0, [fp, #-8]

        /* insert to defunct thread list */
        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
10008928:	e51b3010 	ldr	r3, [fp, #-16]
1000892c:	e2833010 	add	r3, r3, #16
10008930:	e3090ea0 	movw	r0, #40608	; 0x9ea0
10008934:	e3410002 	movt	r0, #4098	; 0x1002
10008938:	e1a01003 	mov	r1, r3
1000893c:	ebfffea3 	bl	100083d0 <rt_list_insert_after>

        /* enable interrupt */
        rt_hw_interrupt_enable(lock);
10008940:	e51b0008 	ldr	r0, [fp, #-8]
10008944:	eb000ae0 	bl	1000b4cc <rt_hw_interrupt_enable>
    }

    return RT_EOK;
10008948:	e3a03000 	mov	r3, #0
}
1000894c:	e1a00003 	mov	r0, r3
10008950:	e24bd004 	sub	sp, fp, #4
10008954:	e8bd8800 	pop	{fp, pc}

10008958 <rt_thread_create>:
                             void (*entry)(void *parameter),
                             void       *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t  priority,
                             rt_uint32_t tick)
{
10008958:	e92d4800 	push	{fp, lr}
1000895c:	e28db004 	add	fp, sp, #4
10008960:	e24dd028 	sub	sp, sp, #40	; 0x28
10008964:	e50b0010 	str	r0, [fp, #-16]
10008968:	e50b1014 	str	r1, [fp, #-20]
1000896c:	e50b2018 	str	r2, [fp, #-24]
10008970:	e50b301c 	str	r3, [fp, #-28]
    struct rt_thread *thread;
    void *stack_start;

    thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
10008974:	e3a00000 	mov	r0, #0
10008978:	e51b1010 	ldr	r1, [fp, #-16]
1000897c:	ebfffbf6 	bl	1000795c <rt_object_allocate>
10008980:	e50b0008 	str	r0, [fp, #-8]
                                                    name);
    if (thread == RT_NULL)
10008984:	e51b3008 	ldr	r3, [fp, #-8]
10008988:	e3530000 	cmp	r3, #0
1000898c:	1a000001 	bne	10008998 <rt_thread_create+0x40>
        return RT_NULL;
10008990:	e3a03000 	mov	r3, #0
10008994:	ea000017 	b	100089f8 <rt_thread_create+0xa0>

    stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
10008998:	e51b001c 	ldr	r0, [fp, #-28]
1000899c:	ebfff841 	bl	10006aa8 <rt_malloc>
100089a0:	e50b000c 	str	r0, [fp, #-12]
    if (stack_start == RT_NULL)
100089a4:	e51b300c 	ldr	r3, [fp, #-12]
100089a8:	e3530000 	cmp	r3, #0
100089ac:	1a000003 	bne	100089c0 <rt_thread_create+0x68>
    {
        /* allocate stack failure */
        rt_object_delete((rt_object_t)thread);
100089b0:	e51b0008 	ldr	r0, [fp, #-8]
100089b4:	ebfffc35 	bl	10007a90 <rt_object_delete>

        return RT_NULL;
100089b8:	e3a03000 	mov	r3, #0
100089bc:	ea00000d 	b	100089f8 <rt_thread_create+0xa0>
    }

    _rt_thread_init(thread,
100089c0:	e51b300c 	ldr	r3, [fp, #-12]
100089c4:	e58d3000 	str	r3, [sp]
100089c8:	e51b301c 	ldr	r3, [fp, #-28]
100089cc:	e58d3004 	str	r3, [sp, #4]
100089d0:	e5db3004 	ldrb	r3, [fp, #4]
100089d4:	e58d3008 	str	r3, [sp, #8]
100089d8:	e59b3008 	ldr	r3, [fp, #8]
100089dc:	e58d300c 	str	r3, [sp, #12]
100089e0:	e51b0008 	ldr	r0, [fp, #-8]
100089e4:	e51b1010 	ldr	r1, [fp, #-16]
100089e8:	e51b2014 	ldr	r2, [fp, #-20]
100089ec:	e51b3018 	ldr	r3, [fp, #-24]
100089f0:	ebfffee3 	bl	10008584 <_rt_thread_init>
                    stack_start,
                    stack_size,
                    priority,
                    tick);

    return thread;
100089f4:	e51b3008 	ldr	r3, [fp, #-8]
}
100089f8:	e1a00003 	mov	r0, r3
100089fc:	e24bd004 	sub	sp, fp, #4
10008a00:	e8bd8800 	pop	{fp, pc}

10008a04 <rt_thread_delete>:
 * @param thread the thread to be deleted
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_delete(rt_thread_t thread)
{
10008a04:	e92d4800 	push	{fp, lr}
10008a08:	e28db004 	add	fp, sp, #4
10008a0c:	e24dd010 	sub	sp, sp, #16
10008a10:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t lock;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10008a14:	e51b3010 	ldr	r3, [fp, #-16]
10008a18:	e3530000 	cmp	r3, #0
10008a1c:	1a000005 	bne	10008a38 <rt_thread_delete+0x34>
10008a20:	e30e0cd8 	movw	r0, #60632	; 0xecd8
10008a24:	e3410001 	movt	r0, #4097	; 0x1001
10008a28:	e30e1d90 	movw	r1, #60816	; 0xed90
10008a2c:	e3411001 	movt	r1, #4097	; 0x1001
10008a30:	e3002159 	movw	r2, #345	; 0x159
10008a34:	ebfff6e3 	bl	100065c8 <rt_assert_handler>

    /* remove from schedule */
    rt_schedule_remove_thread(thread);
10008a38:	e51b0010 	ldr	r0, [fp, #-16]
10008a3c:	ebfffded 	bl	100081f8 <rt_schedule_remove_thread>

    /* release thread timer */
    rt_timer_detach(&(thread->thread_timer));
10008a40:	e51b3010 	ldr	r3, [fp, #-16]
10008a44:	e2833048 	add	r3, r3, #72	; 0x48
10008a48:	e1a00003 	mov	r0, r3
10008a4c:	eb00022b 	bl	10009300 <rt_timer_detach>

    /* change stat */
    thread->stat = RT_THREAD_CLOSE;
10008a50:	e51b3010 	ldr	r3, [fp, #-16]
10008a54:	e3a02004 	mov	r2, #4
10008a58:	e5c32030 	strb	r2, [r3, #48]	; 0x30

    /* disable interrupt */
    lock = rt_hw_interrupt_disable();
10008a5c:	eb000a96 	bl	1000b4bc <rt_hw_interrupt_disable>
10008a60:	e50b0008 	str	r0, [fp, #-8]

    /* insert to defunct thread list */
    rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
10008a64:	e51b3010 	ldr	r3, [fp, #-16]
10008a68:	e2833010 	add	r3, r3, #16
10008a6c:	e3090ea0 	movw	r0, #40608	; 0x9ea0
10008a70:	e3410002 	movt	r0, #4098	; 0x1002
10008a74:	e1a01003 	mov	r1, r3
10008a78:	ebfffe54 	bl	100083d0 <rt_list_insert_after>

    /* enable interrupt */
    rt_hw_interrupt_enable(lock);
10008a7c:	e51b0008 	ldr	r0, [fp, #-8]
10008a80:	eb000a91 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
10008a84:	e3a03000 	mov	r3, #0
}
10008a88:	e1a00003 	mov	r0, r3
10008a8c:	e24bd004 	sub	sp, fp, #4
10008a90:	e8bd8800 	pop	{fp, pc}

10008a94 <rt_thread_yield>:
 * is still in READY state.
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_yield(void)
{
10008a94:	e92d4810 	push	{r4, fp, lr}
10008a98:	e28db008 	add	fp, sp, #8
10008a9c:	e24dd00c 	sub	sp, sp, #12
    register rt_base_t level;
    struct rt_thread *thread;

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10008aa0:	eb000a85 	bl	1000b4bc <rt_hw_interrupt_disable>
10008aa4:	e1a04000 	mov	r4, r0

    /* set to current thread */
    thread = rt_current_thread;
10008aa8:	e3093e98 	movw	r3, #40600	; 0x9e98
10008aac:	e3413002 	movt	r3, #4098	; 0x1002
10008ab0:	e5933000 	ldr	r3, [r3]
10008ab4:	e50b3010 	str	r3, [fp, #-16]

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
10008ab8:	e51b3010 	ldr	r3, [fp, #-16]
10008abc:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10008ac0:	e3530001 	cmp	r3, #1
10008ac4:	1a000019 	bne	10008b30 <rt_thread_yield+0x9c>
        thread->tlist.next != thread->tlist.prev)
10008ac8:	e51b3010 	ldr	r3, [fp, #-16]
10008acc:	e5932010 	ldr	r2, [r3, #16]
10008ad0:	e51b3010 	ldr	r3, [fp, #-16]
10008ad4:	e5933014 	ldr	r3, [r3, #20]

    /* set to current thread */
    thread = rt_current_thread;

    /* if the thread stat is READY and on ready queue list */
    if (thread->stat == RT_THREAD_READY &&
10008ad8:	e1520003 	cmp	r2, r3
10008adc:	0a000013 	beq	10008b30 <rt_thread_yield+0x9c>
        thread->tlist.next != thread->tlist.prev)
    {
        /* remove thread from thread list */
        rt_list_remove(&(thread->tlist));
10008ae0:	e51b3010 	ldr	r3, [fp, #-16]
10008ae4:	e2833010 	add	r3, r3, #16
10008ae8:	e1a00003 	mov	r0, r3
10008aec:	ebfffe63 	bl	10008480 <rt_list_remove>

        /* put thread to end of ready queue */
        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
10008af0:	e51b3010 	ldr	r3, [fp, #-16]
10008af4:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10008af8:	e1a02183 	lsl	r2, r3, #3
10008afc:	e3093d94 	movw	r3, #40340	; 0x9d94
10008b00:	e3413002 	movt	r3, #4098	; 0x1002
10008b04:	e0822003 	add	r2, r2, r3
10008b08:	e51b3010 	ldr	r3, [fp, #-16]
10008b0c:	e2833010 	add	r3, r3, #16
10008b10:	e1a00002 	mov	r0, r2
10008b14:	e1a01003 	mov	r1, r3
10008b18:	ebfffe42 	bl	10008428 <rt_list_insert_before>
                              &(thread->tlist));

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
10008b1c:	e1a00004 	mov	r0, r4
10008b20:	eb000a69 	bl	1000b4cc <rt_hw_interrupt_enable>

        rt_schedule();
10008b24:	ebfffd38 	bl	1000800c <rt_schedule>

        return RT_EOK;
10008b28:	e3a03000 	mov	r3, #0
10008b2c:	ea000002 	b	10008b3c <rt_thread_yield+0xa8>
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10008b30:	e1a00004 	mov	r0, r4
10008b34:	eb000a64 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
10008b38:	e3a03000 	mov	r3, #0
}
10008b3c:	e1a00003 	mov	r0, r3
10008b40:	e24bd008 	sub	sp, fp, #8
10008b44:	e8bd8810 	pop	{r4, fp, pc}

10008b48 <rt_thread_sleep>:
 * @param tick the sleep ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_sleep(rt_tick_t tick)
{
10008b48:	e92d4810 	push	{r4, fp, lr}
10008b4c:	e28db008 	add	fp, sp, #8
10008b50:	e24dd014 	sub	sp, sp, #20
10008b54:	e50b0018 	str	r0, [fp, #-24]
    register rt_base_t temp;
    struct rt_thread *thread;

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10008b58:	eb000a57 	bl	1000b4bc <rt_hw_interrupt_disable>
10008b5c:	e1a04000 	mov	r4, r0
    /* set to current thread */
    thread = rt_current_thread;
10008b60:	e3093e98 	movw	r3, #40600	; 0x9e98
10008b64:	e3413002 	movt	r3, #4098	; 0x1002
10008b68:	e5933000 	ldr	r3, [r3]
10008b6c:	e50b3010 	str	r3, [fp, #-16]
    RT_ASSERT(thread != RT_NULL);
10008b70:	e51b3010 	ldr	r3, [fp, #-16]
10008b74:	e3530000 	cmp	r3, #0
10008b78:	1a000005 	bne	10008b94 <rt_thread_sleep+0x4c>
10008b7c:	e30e0cd8 	movw	r0, #60632	; 0xecd8
10008b80:	e3410001 	movt	r0, #4097	; 0x1001
10008b84:	e30e1da4 	movw	r1, #60836	; 0xeda4
10008b88:	e3411001 	movt	r1, #4097	; 0x1001
10008b8c:	e30021ae 	movw	r2, #430	; 0x1ae
10008b90:	ebfff68c 	bl	100065c8 <rt_assert_handler>

    /* suspend thread */
    rt_thread_suspend(thread);
10008b94:	e51b0010 	ldr	r0, [fp, #-16]
10008b98:	eb00006c 	bl	10008d50 <rt_thread_suspend>

    /* reset the timeout of thread timer and start it */
    rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
10008b9c:	e51b3010 	ldr	r3, [fp, #-16]
10008ba0:	e2832048 	add	r2, r3, #72	; 0x48
10008ba4:	e24b3018 	sub	r3, fp, #24
10008ba8:	e1a00002 	mov	r0, r2
10008bac:	e3a01000 	mov	r1, #0
10008bb0:	e1a02003 	mov	r2, r3
10008bb4:	eb000314 	bl	1000980c <rt_timer_control>
    rt_timer_start(&(thread->thread_timer));
10008bb8:	e51b3010 	ldr	r3, [fp, #-16]
10008bbc:	e2833048 	add	r3, r3, #72	; 0x48
10008bc0:	e1a00003 	mov	r0, r3
10008bc4:	eb00021a 	bl	10009434 <rt_timer_start>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10008bc8:	e1a00004 	mov	r0, r4
10008bcc:	eb000a3e 	bl	1000b4cc <rt_hw_interrupt_enable>
	
    rt_schedule();
10008bd0:	ebfffd0d 	bl	1000800c <rt_schedule>

    /* clear error number of this thread to RT_EOK */
    if (thread->error == -RT_ETIMEOUT)
10008bd4:	e51b3010 	ldr	r3, [fp, #-16]
10008bd8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
10008bdc:	e3730002 	cmn	r3, #2
10008be0:	1a000002 	bne	10008bf0 <rt_thread_sleep+0xa8>
        thread->error = RT_EOK;
10008be4:	e51b3010 	ldr	r3, [fp, #-16]
10008be8:	e3a02000 	mov	r2, #0
10008bec:	e583202c 	str	r2, [r3, #44]	; 0x2c

    return RT_EOK;
10008bf0:	e3a03000 	mov	r3, #0
}
10008bf4:	e1a00003 	mov	r0, r3
10008bf8:	e24bd008 	sub	sp, fp, #8
10008bfc:	e8bd8810 	pop	{r4, fp, pc}

10008c00 <rt_thread_delay>:
 * @param tick the delay ticks
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_delay(rt_tick_t tick)
{
10008c00:	e92d4800 	push	{fp, lr}
10008c04:	e28db004 	add	fp, sp, #4
10008c08:	e24dd008 	sub	sp, sp, #8
10008c0c:	e50b0008 	str	r0, [fp, #-8]
    return rt_thread_sleep(tick);
10008c10:	e51b0008 	ldr	r0, [fp, #-8]
10008c14:	ebffffcb 	bl	10008b48 <rt_thread_sleep>
10008c18:	e1a03000 	mov	r3, r0
}
10008c1c:	e1a00003 	mov	r0, r3
10008c20:	e24bd004 	sub	sp, fp, #4
10008c24:	e8bd8800 	pop	{fp, pc}

10008c28 <rt_thread_control>:
 * @param arg the argument of control command
 *
 * @return RT_EOK
 */
rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
{
10008c28:	e92d4810 	push	{r4, fp, lr}
10008c2c:	e28db008 	add	fp, sp, #8
10008c30:	e24dd014 	sub	sp, sp, #20
10008c34:	e50b0010 	str	r0, [fp, #-16]
10008c38:	e1a03001 	mov	r3, r1
10008c3c:	e50b2018 	str	r2, [fp, #-24]
10008c40:	e54b3011 	strb	r3, [fp, #-17]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10008c44:	e51b3010 	ldr	r3, [fp, #-16]
10008c48:	e3530000 	cmp	r3, #0
10008c4c:	1a000005 	bne	10008c68 <rt_thread_control+0x40>
10008c50:	e30e0cd8 	movw	r0, #60632	; 0xecd8
10008c54:	e3410001 	movt	r0, #4097	; 0x1001
10008c58:	e30e1db4 	movw	r1, #60852	; 0xedb4
10008c5c:	e3411001 	movt	r1, #4097	; 0x1001
10008c60:	e30021e1 	movw	r2, #481	; 0x1e1
10008c64:	ebfff657 	bl	100065c8 <rt_assert_handler>

    switch (cmd)
10008c68:	e55b3011 	ldrb	r3, [fp, #-17]
10008c6c:	e3530001 	cmp	r3, #1
10008c70:	0a00002e 	beq	10008d30 <rt_thread_control+0x108>
10008c74:	e3530002 	cmp	r3, #2
10008c78:	0a000002 	beq	10008c88 <rt_thread_control+0x60>
10008c7c:	e3530000 	cmp	r3, #0
10008c80:	0a000026 	beq	10008d20 <rt_thread_control+0xf8>
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
#endif

    default:
        break;
10008c84:	ea00002d 	b	10008d40 <rt_thread_control+0x118>

    switch (cmd)
    {
    case RT_THREAD_CTRL_CHANGE_PRIORITY:
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
10008c88:	eb000a0b 	bl	1000b4bc <rt_hw_interrupt_disable>
10008c8c:	e1a04000 	mov	r4, r0

        /* for ready thread, change queue */
        if (thread->stat == RT_THREAD_READY)
10008c90:	e51b3010 	ldr	r3, [fp, #-16]
10008c94:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10008c98:	e3530001 	cmp	r3, #1
10008c9c:	1a000010 	bne	10008ce4 <rt_thread_control+0xbc>
        {
            /* remove thread from schedule queue first */
            rt_schedule_remove_thread(thread);
10008ca0:	e51b0010 	ldr	r0, [fp, #-16]
10008ca4:	ebfffd53 	bl	100081f8 <rt_schedule_remove_thread>

            /* change thread priority */
            thread->current_priority = *(rt_uint8_t *)arg;
10008ca8:	e51b3018 	ldr	r3, [fp, #-24]
10008cac:	e5d32000 	ldrb	r2, [r3]
10008cb0:	e51b3010 	ldr	r3, [fp, #-16]
10008cb4:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
10008cb8:	e51b3010 	ldr	r3, [fp, #-16]
10008cbc:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10008cc0:	e1a02003 	mov	r2, r3
10008cc4:	e3a03001 	mov	r3, #1
10008cc8:	e1a03213 	lsl	r3, r3, r2
10008ccc:	e1a02003 	mov	r2, r3
10008cd0:	e51b3010 	ldr	r3, [fp, #-16]
10008cd4:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif

            /* insert thread to schedule queue again */
            rt_schedule_insert_thread(thread);
10008cd8:	e51b0010 	ldr	r0, [fp, #-16]
10008cdc:	ebfffd1b 	bl	10008150 <rt_schedule_insert_thread>
10008ce0:	ea00000b 	b	10008d14 <rt_thread_control+0xec>
        }
        else
        {
            thread->current_priority = *(rt_uint8_t *)arg;
10008ce4:	e51b3018 	ldr	r3, [fp, #-24]
10008ce8:	e5d32000 	ldrb	r2, [r3]
10008cec:	e51b3010 	ldr	r3, [fp, #-16]
10008cf0:	e5c32031 	strb	r2, [r3, #49]	; 0x31
#if RT_THREAD_PRIORITY_MAX > 32
            thread->number      = thread->current_priority >> 3;            /* 5bit */
            thread->number_mask = 1 << thread->number;
            thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
#else
            thread->number_mask = 1 << thread->current_priority;
10008cf4:	e51b3010 	ldr	r3, [fp, #-16]
10008cf8:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
10008cfc:	e1a02003 	mov	r2, r3
10008d00:	e3a03001 	mov	r3, #1
10008d04:	e1a03213 	lsl	r3, r3, r2
10008d08:	e1a02003 	mov	r2, r3
10008d0c:	e51b3010 	ldr	r3, [fp, #-16]
10008d10:	e5832034 	str	r2, [r3, #52]	; 0x34
#endif
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
10008d14:	e1a00004 	mov	r0, r4
10008d18:	eb0009eb 	bl	1000b4cc <rt_hw_interrupt_enable>
        break;
10008d1c:	ea000007 	b	10008d40 <rt_thread_control+0x118>

    case RT_THREAD_CTRL_STARTUP:
        return rt_thread_startup(thread);
10008d20:	e51b0010 	ldr	r0, [fp, #-16]
10008d24:	ebfffeb0 	bl	100087ec <rt_thread_startup>
10008d28:	e1a03000 	mov	r3, r0
10008d2c:	ea000004 	b	10008d44 <rt_thread_control+0x11c>

#ifdef RT_USING_HEAP
    case RT_THREAD_CTRL_CLOSE:
        return rt_thread_delete(thread);
10008d30:	e51b0010 	ldr	r0, [fp, #-16]
10008d34:	ebffff32 	bl	10008a04 <rt_thread_delete>
10008d38:	e1a03000 	mov	r3, r0
10008d3c:	ea000000 	b	10008d44 <rt_thread_control+0x11c>

    default:
        break;
    }

    return RT_EOK;
10008d40:	e3a03000 	mov	r3, #0
}
10008d44:	e1a00003 	mov	r0, r3
10008d48:	e24bd008 	sub	sp, fp, #8
10008d4c:	e8bd8810 	pop	{r4, fp, pc}

10008d50 <rt_thread_suspend>:
 *
 * @note if suspend self thread, after this function call, the
 * rt_schedule() must be invoked.
 */
rt_err_t rt_thread_suspend(rt_thread_t thread)
{
10008d50:	e92d4810 	push	{r4, fp, lr}
10008d54:	e28db008 	add	fp, sp, #8
10008d58:	e24dd00c 	sub	sp, sp, #12
10008d5c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10008d60:	e51b3010 	ldr	r3, [fp, #-16]
10008d64:	e3530000 	cmp	r3, #0
10008d68:	1a000005 	bne	10008d84 <rt_thread_suspend+0x34>
10008d6c:	e30e0cd8 	movw	r0, #60632	; 0xecd8
10008d70:	e3410001 	movt	r0, #4097	; 0x1001
10008d74:	e30e1dc8 	movw	r1, #60872	; 0xedc8
10008d78:	e3411001 	movt	r1, #4097	; 0x1001
10008d7c:	e300222f 	movw	r2, #559	; 0x22f
10008d80:	ebfff610 	bl	100065c8 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_READY)
10008d84:	e51b3010 	ldr	r3, [fp, #-16]
10008d88:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10008d8c:	e3530001 	cmp	r3, #1
10008d90:	0a000001 	beq	10008d9c <rt_thread_suspend+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
10008d94:	e3e03000 	mvn	r3, #0
10008d98:	ea00000d 	b	10008dd4 <rt_thread_suspend+0x84>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10008d9c:	eb0009c6 	bl	1000b4bc <rt_hw_interrupt_disable>
10008da0:	e1a04000 	mov	r4, r0

    /* change thread stat */
    thread->stat = RT_THREAD_SUSPEND;
10008da4:	e51b3010 	ldr	r3, [fp, #-16]
10008da8:	e3a02002 	mov	r2, #2
10008dac:	e5c32030 	strb	r2, [r3, #48]	; 0x30
    rt_schedule_remove_thread(thread);
10008db0:	e51b0010 	ldr	r0, [fp, #-16]
10008db4:	ebfffd0f 	bl	100081f8 <rt_schedule_remove_thread>

    /* stop thread timer anyway */
    rt_timer_stop(&(thread->thread_timer));
10008db8:	e51b3010 	ldr	r3, [fp, #-16]
10008dbc:	e2833048 	add	r3, r3, #72	; 0x48
10008dc0:	e1a00003 	mov	r0, r3
10008dc4:	eb000261 	bl	10009750 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10008dc8:	e1a00004 	mov	r0, r4
10008dcc:	eb0009be 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
10008dd0:	e3a03000 	mov	r3, #0
}
10008dd4:	e1a00003 	mov	r0, r3
10008dd8:	e24bd008 	sub	sp, fp, #8
10008ddc:	e8bd8810 	pop	{r4, fp, pc}

10008de0 <rt_thread_resume>:
 * @param thread the thread to be resumed
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_thread_resume(rt_thread_t thread)
{
10008de0:	e92d4810 	push	{r4, fp, lr}
10008de4:	e28db008 	add	fp, sp, #8
10008de8:	e24dd00c 	sub	sp, sp, #12
10008dec:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t temp;

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10008df0:	e51b3010 	ldr	r3, [fp, #-16]
10008df4:	e3530000 	cmp	r3, #0
10008df8:	1a000005 	bne	10008e14 <rt_thread_resume+0x34>
10008dfc:	e30e0cd8 	movw	r0, #60632	; 0xecd8
10008e00:	e3410001 	movt	r0, #4097	; 0x1001
10008e04:	e30e1ddc 	movw	r1, #60892	; 0xeddc
10008e08:	e3411001 	movt	r1, #4097	; 0x1001
10008e0c:	e3a02f96 	mov	r2, #600	; 0x258
10008e10:	ebfff5ec 	bl	100065c8 <rt_assert_handler>

    RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));

    if (thread->stat != RT_THREAD_SUSPEND)
10008e14:	e51b3010 	ldr	r3, [fp, #-16]
10008e18:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10008e1c:	e3530002 	cmp	r3, #2
10008e20:	0a000001 	beq	10008e2c <rt_thread_resume+0x4c>
    {
        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
                                       thread->stat));

        return -RT_ERROR;
10008e24:	e3e03000 	mvn	r3, #0
10008e28:	ea00000e 	b	10008e68 <rt_thread_resume+0x88>
    }

    /* disable interrupt */
    temp = rt_hw_interrupt_disable();
10008e2c:	eb0009a2 	bl	1000b4bc <rt_hw_interrupt_disable>
10008e30:	e1a04000 	mov	r4, r0

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
10008e34:	e51b3010 	ldr	r3, [fp, #-16]
10008e38:	e2833010 	add	r3, r3, #16
10008e3c:	e1a00003 	mov	r0, r3
10008e40:	ebfffd8e 	bl	10008480 <rt_list_remove>

    rt_timer_stop(&thread->thread_timer);
10008e44:	e51b3010 	ldr	r3, [fp, #-16]
10008e48:	e2833048 	add	r3, r3, #72	; 0x48
10008e4c:	e1a00003 	mov	r0, r3
10008e50:	eb00023e 	bl	10009750 <rt_timer_stop>

    /* enable interrupt */
    rt_hw_interrupt_enable(temp);
10008e54:	e1a00004 	mov	r0, r4
10008e58:	eb00099b 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
10008e5c:	e51b0010 	ldr	r0, [fp, #-16]
10008e60:	ebfffcba 	bl	10008150 <rt_schedule_insert_thread>

    return RT_EOK;
10008e64:	e3a03000 	mov	r3, #0
}
10008e68:	e1a00003 	mov	r0, r3
10008e6c:	e24bd008 	sub	sp, fp, #8
10008e70:	e8bd8810 	pop	{r4, fp, pc}

10008e74 <rt_thread_timeout>:
 * when thread is timeout to wait some resource.
 *
 * @param parameter the parameter of thread timeout function
 */
void rt_thread_timeout(void *parameter)
{
10008e74:	e92d4800 	push	{fp, lr}
10008e78:	e28db004 	add	fp, sp, #4
10008e7c:	e24dd010 	sub	sp, sp, #16
10008e80:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;

    thread = (struct rt_thread *)parameter;
10008e84:	e51b3010 	ldr	r3, [fp, #-16]
10008e88:	e50b3008 	str	r3, [fp, #-8]

    /* thread check */
    RT_ASSERT(thread != RT_NULL);
10008e8c:	e51b3008 	ldr	r3, [fp, #-8]
10008e90:	e3530000 	cmp	r3, #0
10008e94:	1a000005 	bne	10008eb0 <rt_thread_timeout+0x3c>
10008e98:	e30e0cd8 	movw	r0, #60632	; 0xecd8
10008e9c:	e3410001 	movt	r0, #4097	; 0x1001
10008ea0:	e30e1df0 	movw	r1, #60912	; 0xedf0
10008ea4:	e3411001 	movt	r1, #4097	; 0x1001
10008ea8:	e3002283 	movw	r2, #643	; 0x283
10008eac:	ebfff5c5 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
10008eb0:	e51b3008 	ldr	r3, [fp, #-8]
10008eb4:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10008eb8:	e3530002 	cmp	r3, #2
10008ebc:	0a000005 	beq	10008ed8 <rt_thread_timeout+0x64>
10008ec0:	e30e0d24 	movw	r0, #60708	; 0xed24
10008ec4:	e3410001 	movt	r0, #4097	; 0x1001
10008ec8:	e30e1df0 	movw	r1, #60912	; 0xedf0
10008ecc:	e3411001 	movt	r1, #4097	; 0x1001
10008ed0:	e3a02fa1 	mov	r2, #644	; 0x284
10008ed4:	ebfff5bb 	bl	100065c8 <rt_assert_handler>

    /* set error number */
    thread->error = -RT_ETIMEOUT;
10008ed8:	e51b3008 	ldr	r3, [fp, #-8]
10008edc:	e3e02001 	mvn	r2, #1
10008ee0:	e583202c 	str	r2, [r3, #44]	; 0x2c

    /* remove from suspend list */
    rt_list_remove(&(thread->tlist));
10008ee4:	e51b3008 	ldr	r3, [fp, #-8]
10008ee8:	e2833010 	add	r3, r3, #16
10008eec:	e1a00003 	mov	r0, r3
10008ef0:	ebfffd62 	bl	10008480 <rt_list_remove>

    /* insert to schedule ready list */
    rt_schedule_insert_thread(thread);
10008ef4:	e51b0008 	ldr	r0, [fp, #-8]
10008ef8:	ebfffc94 	bl	10008150 <rt_schedule_insert_thread>

    /* do schedule */
    rt_schedule();
10008efc:	ebfffc42 	bl	1000800c <rt_schedule>
}
10008f00:	e24bd004 	sub	sp, fp, #4
10008f04:	e8bd8800 	pop	{fp, pc}

10008f08 <rt_thread_find>:
 * @return the found thread
 *
 * @note please don't invoke this function in interrupt status.
 */
rt_thread_t rt_thread_find(char *name)
{
10008f08:	e92d4800 	push	{fp, lr}
10008f0c:	e28db004 	add	fp, sp, #4
10008f10:	e24dd018 	sub	sp, sp, #24
10008f14:	e50b0018 	str	r0, [fp, #-24]
    struct rt_list_node *node;

    extern struct rt_object_information rt_object_container[];

    /* enter critical */
    if (rt_thread_self() != RT_NULL)
10008f18:	ebfffe2a 	bl	100087c8 <rt_thread_self>
10008f1c:	e1a03000 	mov	r3, r0
10008f20:	e3530000 	cmp	r3, #0
10008f24:	0a000000 	beq	10008f2c <rt_thread_find+0x24>
        rt_enter_critical();
10008f28:	ebfffcde 	bl	100082a8 <rt_enter_critical>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
10008f2c:	e30039b8 	movw	r3, #2488	; 0x9b8
10008f30:	e3413002 	movt	r3, #4098	; 0x1002
10008f34:	e50b300c 	str	r3, [fp, #-12]
    for (node  = information->object_list.next;
10008f38:	e51b300c 	ldr	r3, [fp, #-12]
10008f3c:	e5933004 	ldr	r3, [r3, #4]
10008f40:	e50b3008 	str	r3, [fp, #-8]
10008f44:	ea000014 	b	10008f9c <rt_thread_find+0x94>
         node != &(information->object_list);
         node  = node->next)
    {
        object = rt_list_entry(node, struct rt_object, list);
10008f48:	e51b3008 	ldr	r3, [fp, #-8]
10008f4c:	e2433008 	sub	r3, r3, #8
10008f50:	e50b3010 	str	r3, [fp, #-16]
        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
10008f54:	e51b3010 	ldr	r3, [fp, #-16]
10008f58:	e1a00003 	mov	r0, r3
10008f5c:	e51b1018 	ldr	r1, [fp, #-24]
10008f60:	e3a02006 	mov	r2, #6
10008f64:	ebfff09c 	bl	100051dc <rt_strncmp>
10008f68:	e1a03000 	mov	r3, r0
10008f6c:	e3530000 	cmp	r3, #0
10008f70:	1a000006 	bne	10008f90 <rt_thread_find+0x88>
        {
            /* leave critical */
            if (rt_thread_self() != RT_NULL)
10008f74:	ebfffe13 	bl	100087c8 <rt_thread_self>
10008f78:	e1a03000 	mov	r3, r0
10008f7c:	e3530000 	cmp	r3, #0
10008f80:	0a000000 	beq	10008f88 <rt_thread_find+0x80>
                rt_exit_critical();
10008f84:	ebfffcd9 	bl	100082f0 <rt_exit_critical>

            return (rt_thread_t)object;
10008f88:	e51b3010 	ldr	r3, [fp, #-16]
10008f8c:	ea00000d 	b	10008fc8 <rt_thread_find+0xc0>

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
         node != &(information->object_list);
         node  = node->next)
10008f90:	e51b3008 	ldr	r3, [fp, #-8]
10008f94:	e5933000 	ldr	r3, [r3]
10008f98:	e50b3008 	str	r3, [fp, #-8]
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
         node != &(information->object_list);
10008f9c:	e51b300c 	ldr	r3, [fp, #-12]
10008fa0:	e2832004 	add	r2, r3, #4
    if (rt_thread_self() != RT_NULL)
        rt_enter_critical();

    /* try to find device object */
    information = &rt_object_container[RT_Object_Class_Thread];
    for (node  = information->object_list.next;
10008fa4:	e51b3008 	ldr	r3, [fp, #-8]
10008fa8:	e1520003 	cmp	r2, r3
10008fac:	1affffe5 	bne	10008f48 <rt_thread_find+0x40>
            return (rt_thread_t)object;
        }
    }

    /* leave critical */
    if (rt_thread_self() != RT_NULL)
10008fb0:	ebfffe04 	bl	100087c8 <rt_thread_self>
10008fb4:	e1a03000 	mov	r3, r0
10008fb8:	e3530000 	cmp	r3, #0
10008fbc:	0a000000 	beq	10008fc4 <rt_thread_find+0xbc>
        rt_exit_critical();
10008fc0:	ebfffcca 	bl	100082f0 <rt_exit_critical>

    /* not found */
    return RT_NULL;
10008fc4:	e3a03000 	mov	r3, #0
}
10008fc8:	e1a00003 	mov	r0, r3
10008fcc:	e24bd004 	sub	sp, fp, #4
10008fd0:	e8bd8800 	pop	{fp, pc}

10008fd4 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
10008fd4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10008fd8:	e28db000 	add	fp, sp, #0
10008fdc:	e24dd00c 	sub	sp, sp, #12
10008fe0:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
10008fe4:	e51b3008 	ldr	r3, [fp, #-8]
10008fe8:	e51b2008 	ldr	r2, [fp, #-8]
10008fec:	e5832004 	str	r2, [r3, #4]
10008ff0:	e51b3008 	ldr	r3, [fp, #-8]
10008ff4:	e5932004 	ldr	r2, [r3, #4]
10008ff8:	e51b3008 	ldr	r3, [fp, #-8]
10008ffc:	e5832000 	str	r2, [r3]
}
10009000:	e24bd000 	sub	sp, fp, #0
10009004:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009008:	e12fff1e 	bx	lr

1000900c <rt_list_insert_after>:
 *
 * @param l list to insert it
 * @param n new node to be inserted
 */
rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
1000900c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009010:	e28db000 	add	fp, sp, #0
10009014:	e24dd00c 	sub	sp, sp, #12
10009018:	e50b0008 	str	r0, [fp, #-8]
1000901c:	e50b100c 	str	r1, [fp, #-12]
    l->next->prev = n;
10009020:	e51b3008 	ldr	r3, [fp, #-8]
10009024:	e5933000 	ldr	r3, [r3]
10009028:	e51b200c 	ldr	r2, [fp, #-12]
1000902c:	e5832004 	str	r2, [r3, #4]
    n->next = l->next;
10009030:	e51b3008 	ldr	r3, [fp, #-8]
10009034:	e5932000 	ldr	r2, [r3]
10009038:	e51b300c 	ldr	r3, [fp, #-12]
1000903c:	e5832000 	str	r2, [r3]

    l->next = n;
10009040:	e51b3008 	ldr	r3, [fp, #-8]
10009044:	e51b200c 	ldr	r2, [fp, #-12]
10009048:	e5832000 	str	r2, [r3]
    n->prev = l;
1000904c:	e51b300c 	ldr	r3, [fp, #-12]
10009050:	e51b2008 	ldr	r2, [fp, #-8]
10009054:	e5832004 	str	r2, [r3, #4]
}
10009058:	e24bd000 	sub	sp, fp, #0
1000905c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009060:	e12fff1e 	bx	lr

10009064 <rt_list_remove>:
/**
 * @brief remove node from list.
 * @param n the node to remove from the list.
 */
rt_inline void rt_list_remove(rt_list_t *n)
{
10009064:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009068:	e28db000 	add	fp, sp, #0
1000906c:	e24dd00c 	sub	sp, sp, #12
10009070:	e50b0008 	str	r0, [fp, #-8]
    n->next->prev = n->prev;
10009074:	e51b3008 	ldr	r3, [fp, #-8]
10009078:	e5933000 	ldr	r3, [r3]
1000907c:	e51b2008 	ldr	r2, [fp, #-8]
10009080:	e5922004 	ldr	r2, [r2, #4]
10009084:	e5832004 	str	r2, [r3, #4]
    n->prev->next = n->next;
10009088:	e51b3008 	ldr	r3, [fp, #-8]
1000908c:	e5933004 	ldr	r3, [r3, #4]
10009090:	e51b2008 	ldr	r2, [fp, #-8]
10009094:	e5922000 	ldr	r2, [r2]
10009098:	e5832000 	str	r2, [r3]

    n->next = n->prev = n;
1000909c:	e51b3008 	ldr	r3, [fp, #-8]
100090a0:	e51b2008 	ldr	r2, [fp, #-8]
100090a4:	e5832004 	str	r2, [r3, #4]
100090a8:	e51b3008 	ldr	r3, [fp, #-8]
100090ac:	e5932004 	ldr	r2, [r3, #4]
100090b0:	e51b3008 	ldr	r3, [fp, #-8]
100090b4:	e5832000 	str	r2, [r3]
}
100090b8:	e24bd000 	sub	sp, fp, #0
100090bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100090c0:	e12fff1e 	bx	lr

100090c4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
100090c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100090c8:	e28db000 	add	fp, sp, #0
100090cc:	e24dd00c 	sub	sp, sp, #12
100090d0:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
100090d4:	e51b3008 	ldr	r3, [fp, #-8]
100090d8:	e5932000 	ldr	r2, [r3]
100090dc:	e51b3008 	ldr	r3, [fp, #-8]
100090e0:	e1520003 	cmp	r2, r3
100090e4:	03a03001 	moveq	r3, #1
100090e8:	13a03000 	movne	r3, #0
100090ec:	e6ef3073 	uxtb	r3, r3
}
100090f0:	e1a00003 	mov	r0, r3
100090f4:	e24bd000 	sub	sp, fp, #0
100090f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100090fc:	e12fff1e 	bx	lr

10009100 <rt_timer_timeout_sethook>:
 * is timeout.
 *
 * @param hook the hook function
 */
void rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer))
{
10009100:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009104:	e28db000 	add	fp, sp, #0
10009108:	e24dd00c 	sub	sp, sp, #12
1000910c:	e50b0008 	str	r0, [fp, #-8]
    rt_timer_timeout_hook = hook;
10009110:	e30833fc 	movw	r3, #33788	; 0x83fc
10009114:	e3413002 	movt	r3, #4098	; 0x1002
10009118:	e51b2008 	ldr	r2, [fp, #-8]
1000911c:	e5832000 	str	r2, [r3]
}
10009120:	e24bd000 	sub	sp, fp, #0
10009124:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009128:	e12fff1e 	bx	lr

1000912c <_rt_timer_init>:
static void _rt_timer_init(rt_timer_t timer,
                           void (*timeout)(void *parameter),
                           void      *parameter,
                           rt_tick_t  time,
                           rt_uint8_t flag)
{
1000912c:	e92d4800 	push	{fp, lr}
10009130:	e28db004 	add	fp, sp, #4
10009134:	e24dd018 	sub	sp, sp, #24
10009138:	e50b0010 	str	r0, [fp, #-16]
1000913c:	e50b1014 	str	r1, [fp, #-20]
10009140:	e50b2018 	str	r2, [fp, #-24]
10009144:	e50b301c 	str	r3, [fp, #-28]
    int i;

    /* set flag */
    timer->parent.flag  = flag;
10009148:	e51b3010 	ldr	r3, [fp, #-16]
1000914c:	e5db2004 	ldrb	r2, [fp, #4]
10009150:	e5c32007 	strb	r2, [r3, #7]

    /* set deactivated */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
10009154:	e51b3010 	ldr	r3, [fp, #-16]
10009158:	e5d33007 	ldrb	r3, [r3, #7]
1000915c:	e3c33001 	bic	r3, r3, #1
10009160:	e6ef2073 	uxtb	r2, r3
10009164:	e51b3010 	ldr	r3, [fp, #-16]
10009168:	e5c32007 	strb	r2, [r3, #7]

    timer->timeout_func = timeout;
1000916c:	e51b3010 	ldr	r3, [fp, #-16]
10009170:	e51b2014 	ldr	r2, [fp, #-20]
10009174:	e5832018 	str	r2, [r3, #24]
    timer->parameter    = parameter;
10009178:	e51b3010 	ldr	r3, [fp, #-16]
1000917c:	e51b2018 	ldr	r2, [fp, #-24]
10009180:	e583201c 	str	r2, [r3, #28]

    timer->timeout_tick = 0;
10009184:	e51b3010 	ldr	r3, [fp, #-16]
10009188:	e3a02000 	mov	r2, #0
1000918c:	e5832024 	str	r2, [r3, #36]	; 0x24
    timer->init_tick    = time;
10009190:	e51b3010 	ldr	r3, [fp, #-16]
10009194:	e51b201c 	ldr	r2, [fp, #-28]
10009198:	e5832020 	str	r2, [r3, #32]

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
1000919c:	e3a03000 	mov	r3, #0
100091a0:	e50b3008 	str	r3, [fp, #-8]
100091a4:	ea000009 	b	100091d0 <_rt_timer_init+0xa4>
    {
        rt_list_init(&(timer->row[i]));
100091a8:	e51b3008 	ldr	r3, [fp, #-8]
100091ac:	e2833002 	add	r3, r3, #2
100091b0:	e1a03183 	lsl	r3, r3, #3
100091b4:	e51b2010 	ldr	r2, [fp, #-16]
100091b8:	e0823003 	add	r3, r2, r3
100091bc:	e1a00003 	mov	r0, r3
100091c0:	ebffff83 	bl	10008fd4 <rt_list_init>

    timer->timeout_tick = 0;
    timer->init_tick    = time;

    /* initialize timer list */
    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
100091c4:	e51b3008 	ldr	r3, [fp, #-8]
100091c8:	e2833001 	add	r3, r3, #1
100091cc:	e50b3008 	str	r3, [fp, #-8]
100091d0:	e51b3008 	ldr	r3, [fp, #-8]
100091d4:	e3530000 	cmp	r3, #0
100091d8:	dafffff2 	ble	100091a8 <_rt_timer_init+0x7c>
    {
        rt_list_init(&(timer->row[i]));
    }
}
100091dc:	e24bd004 	sub	sp, fp, #4
100091e0:	e8bd8800 	pop	{fp, pc}

100091e4 <rt_timer_list_next_timeout>:

/* the fist timer always in the last row */
static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
{
100091e4:	e92d4800 	push	{fp, lr}
100091e8:	e28db004 	add	fp, sp, #4
100091ec:	e24dd010 	sub	sp, sp, #16
100091f0:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;

    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
100091f4:	e51b0010 	ldr	r0, [fp, #-16]
100091f8:	ebffffb1 	bl	100090c4 <rt_list_isempty>
100091fc:	e1a03000 	mov	r3, r0
10009200:	e3530000 	cmp	r3, #0
10009204:	0a000001 	beq	10009210 <rt_timer_list_next_timeout+0x2c>
        return RT_TICK_MAX;
10009208:	e3e03000 	mvn	r3, #0
1000920c:	ea000005 	b	10009228 <rt_timer_list_next_timeout+0x44>

    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
10009210:	e51b3010 	ldr	r3, [fp, #-16]
10009214:	e5933000 	ldr	r3, [r3]
10009218:	e2433010 	sub	r3, r3, #16
1000921c:	e50b3008 	str	r3, [fp, #-8]
                          struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);

    return timer->timeout_tick;
10009220:	e51b3008 	ldr	r3, [fp, #-8]
10009224:	e5933024 	ldr	r3, [r3, #36]	; 0x24
}
10009228:	e1a00003 	mov	r0, r3
1000922c:	e24bd004 	sub	sp, fp, #4
10009230:	e8bd8800 	pop	{fp, pc}

10009234 <_rt_timer_remove>:

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
10009234:	e92d4800 	push	{fp, lr}
10009238:	e28db004 	add	fp, sp, #4
1000923c:	e24dd010 	sub	sp, sp, #16
10009240:	e50b0010 	str	r0, [fp, #-16]
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
10009244:	e3a03000 	mov	r3, #0
10009248:	e50b3008 	str	r3, [fp, #-8]
1000924c:	ea000009 	b	10009278 <_rt_timer_remove+0x44>
    {
        rt_list_remove(&timer->row[i]);
10009250:	e51b3008 	ldr	r3, [fp, #-8]
10009254:	e2833002 	add	r3, r3, #2
10009258:	e1a03183 	lsl	r3, r3, #3
1000925c:	e51b2010 	ldr	r2, [fp, #-16]
10009260:	e0823003 	add	r3, r2, r3
10009264:	e1a00003 	mov	r0, r3
10009268:	ebffff7d 	bl	10009064 <rt_list_remove>

rt_inline void _rt_timer_remove(rt_timer_t timer)
{
    int i;

    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
1000926c:	e51b3008 	ldr	r3, [fp, #-8]
10009270:	e2833001 	add	r3, r3, #1
10009274:	e50b3008 	str	r3, [fp, #-8]
10009278:	e51b3008 	ldr	r3, [fp, #-8]
1000927c:	e3530000 	cmp	r3, #0
10009280:	dafffff2 	ble	10009250 <_rt_timer_remove+0x1c>
    {
        rt_list_remove(&timer->row[i]);
    }
}
10009284:	e24bd004 	sub	sp, fp, #4
10009288:	e8bd8800 	pop	{fp, pc}

1000928c <rt_timer_init>:
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
1000928c:	e92d4800 	push	{fp, lr}
10009290:	e28db004 	add	fp, sp, #4
10009294:	e24dd018 	sub	sp, sp, #24
10009298:	e50b0008 	str	r0, [fp, #-8]
1000929c:	e50b100c 	str	r1, [fp, #-12]
100092a0:	e50b2010 	str	r2, [fp, #-16]
100092a4:	e50b3014 	str	r3, [fp, #-20]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
100092a8:	e51b3008 	ldr	r3, [fp, #-8]
100092ac:	e3530000 	cmp	r3, #0
100092b0:	1a000005 	bne	100092cc <rt_timer_init+0x40>
100092b4:	e30e0e04 	movw	r0, #60932	; 0xee04
100092b8:	e3410001 	movt	r0, #4097	; 0x1001
100092bc:	e30e1e3c 	movw	r1, #60988	; 0xee3c
100092c0:	e3411001 	movt	r1, #4097	; 0x1001
100092c4:	e3a020bc 	mov	r2, #188	; 0xbc
100092c8:	ebfff4be 	bl	100065c8 <rt_assert_handler>

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
100092cc:	e51b0008 	ldr	r0, [fp, #-8]
100092d0:	e3a01008 	mov	r1, #8
100092d4:	e51b200c 	ldr	r2, [fp, #-12]
100092d8:	ebfff94f 	bl	1000781c <rt_object_init>

    _rt_timer_init(timer, timeout, parameter, time, flag);
100092dc:	e5db3008 	ldrb	r3, [fp, #8]
100092e0:	e58d3000 	str	r3, [sp]
100092e4:	e51b0008 	ldr	r0, [fp, #-8]
100092e8:	e51b1010 	ldr	r1, [fp, #-16]
100092ec:	e51b2014 	ldr	r2, [fp, #-20]
100092f0:	e59b3004 	ldr	r3, [fp, #4]
100092f4:	ebffff8c 	bl	1000912c <_rt_timer_init>
}
100092f8:	e24bd004 	sub	sp, fp, #4
100092fc:	e8bd8800 	pop	{fp, pc}

10009300 <rt_timer_detach>:
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
{
10009300:	e92d4810 	push	{r4, fp, lr}
10009304:	e28db008 	add	fp, sp, #8
10009308:	e24dd00c 	sub	sp, sp, #12
1000930c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
10009310:	e51b3010 	ldr	r3, [fp, #-16]
10009314:	e3530000 	cmp	r3, #0
10009318:	1a000005 	bne	10009334 <rt_timer_detach+0x34>
1000931c:	e30e0e04 	movw	r0, #60932	; 0xee04
10009320:	e3410001 	movt	r0, #4097	; 0x1001
10009324:	e30e1e4c 	movw	r1, #61004	; 0xee4c
10009328:	e3411001 	movt	r1, #4097	; 0x1001
1000932c:	e3a020d1 	mov	r2, #209	; 0xd1
10009330:	ebfff4a4 	bl	100065c8 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10009334:	eb000860 	bl	1000b4bc <rt_hw_interrupt_disable>
10009338:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
1000933c:	e51b0010 	ldr	r0, [fp, #-16]
10009340:	ebffffbb 	bl	10009234 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10009344:	e1a00004 	mov	r0, r4
10009348:	eb00085f 	bl	1000b4cc <rt_hw_interrupt_enable>

    rt_object_detach((rt_object_t)timer);
1000934c:	e51b0010 	ldr	r0, [fp, #-16]
10009350:	ebfff960 	bl	100078d8 <rt_object_detach>

    return -RT_EOK;
10009354:	e3a03000 	mov	r3, #0
}
10009358:	e1a00003 	mov	r0, r3
1000935c:	e24bd008 	sub	sp, fp, #8
10009360:	e8bd8810 	pop	{r4, fp, pc}

10009364 <rt_timer_create>:
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
{
10009364:	e92d4800 	push	{fp, lr}
10009368:	e28db004 	add	fp, sp, #4
1000936c:	e24dd020 	sub	sp, sp, #32
10009370:	e50b0010 	str	r0, [fp, #-16]
10009374:	e50b1014 	str	r1, [fp, #-20]
10009378:	e50b2018 	str	r2, [fp, #-24]
1000937c:	e50b301c 	str	r3, [fp, #-28]
    struct rt_timer *timer;

    /* allocate a object */
    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
10009380:	e3a00008 	mov	r0, #8
10009384:	e51b1010 	ldr	r1, [fp, #-16]
10009388:	ebfff973 	bl	1000795c <rt_object_allocate>
1000938c:	e50b0008 	str	r0, [fp, #-8]
    if (timer == RT_NULL)
10009390:	e51b3008 	ldr	r3, [fp, #-8]
10009394:	e3530000 	cmp	r3, #0
10009398:	1a000001 	bne	100093a4 <rt_timer_create+0x40>
    {
        return RT_NULL;
1000939c:	e3a03000 	mov	r3, #0
100093a0:	ea000007 	b	100093c4 <rt_timer_create+0x60>
    }

    _rt_timer_init(timer, timeout, parameter, time, flag);
100093a4:	e5db3004 	ldrb	r3, [fp, #4]
100093a8:	e58d3000 	str	r3, [sp]
100093ac:	e51b0008 	ldr	r0, [fp, #-8]
100093b0:	e51b1014 	ldr	r1, [fp, #-20]
100093b4:	e51b2018 	ldr	r2, [fp, #-24]
100093b8:	e51b301c 	ldr	r3, [fp, #-28]
100093bc:	ebffff5a 	bl	1000912c <_rt_timer_init>

    return timer;
100093c0:	e51b3008 	ldr	r3, [fp, #-8]
}
100093c4:	e1a00003 	mov	r0, r3
100093c8:	e24bd004 	sub	sp, fp, #4
100093cc:	e8bd8800 	pop	{fp, pc}

100093d0 <rt_timer_delete>:
 * @param timer the timer to be deleted
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_delete(rt_timer_t timer)
{
100093d0:	e92d4810 	push	{r4, fp, lr}
100093d4:	e28db008 	add	fp, sp, #8
100093d8:	e24dd00c 	sub	sp, sp, #12
100093dc:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
100093e0:	e51b3010 	ldr	r3, [fp, #-16]
100093e4:	e3530000 	cmp	r3, #0
100093e8:	1a000005 	bne	10009404 <rt_timer_delete+0x34>
100093ec:	e30e0e04 	movw	r0, #60932	; 0xee04
100093f0:	e3410001 	movt	r0, #4097	; 0x1001
100093f4:	e30e1e5c 	movw	r1, #61020	; 0xee5c
100093f8:	e3411001 	movt	r1, #4097	; 0x1001
100093fc:	e300210e 	movw	r2, #270	; 0x10e
10009400:	ebfff470 	bl	100065c8 <rt_assert_handler>

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10009404:	eb00082c 	bl	1000b4bc <rt_hw_interrupt_disable>
10009408:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
1000940c:	e51b0010 	ldr	r0, [fp, #-16]
10009410:	ebffff87 	bl	10009234 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10009414:	e1a00004 	mov	r0, r4
10009418:	eb00082b 	bl	1000b4cc <rt_hw_interrupt_enable>

    rt_object_delete((rt_object_t)timer);
1000941c:	e51b0010 	ldr	r0, [fp, #-16]
10009420:	ebfff99a 	bl	10007a90 <rt_object_delete>

    return -RT_EOK;
10009424:	e3a03000 	mov	r3, #0
}
10009428:	e1a00003 	mov	r0, r3
1000942c:	e24bd008 	sub	sp, fp, #8
10009430:	e8bd8810 	pop	{r4, fp, pc}

10009434 <rt_timer_start>:
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
{
10009434:	e92d4810 	push	{r4, fp, lr}
10009438:	e28db008 	add	fp, sp, #8
1000943c:	e24dd024 	sub	sp, sp, #36	; 0x24
10009440:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
    unsigned int tst_nr;
    static unsigned int random_nr;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
10009444:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10009448:	e3530000 	cmp	r3, #0
1000944c:	1a000005 	bne	10009468 <rt_timer_start+0x34>
10009450:	e30e0e04 	movw	r0, #60932	; 0xee04
10009454:	e3410001 	movt	r0, #4097	; 0x1001
10009458:	e30e1e6c 	movw	r1, #61036	; 0xee6c
1000945c:	e3411001 	movt	r1, #4097	; 0x1001
10009460:	e3a02e13 	mov	r2, #304	; 0x130
10009464:	ebfff457 	bl	100065c8 <rt_assert_handler>

	/* stop timer firstly */
	level = rt_hw_interrupt_disable();
10009468:	eb000813 	bl	1000b4bc <rt_hw_interrupt_disable>
1000946c:	e1a04000 	mov	r4, r0
	/* remove timer from list */
    _rt_timer_remove(timer);
10009470:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10009474:	ebffff6e 	bl	10009234 <_rt_timer_remove>
    /* change status of timer */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
10009478:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000947c:	e5d33007 	ldrb	r3, [r3, #7]
10009480:	e3c33001 	bic	r3, r3, #1
10009484:	e6ef2073 	uxtb	r2, r3
10009488:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000948c:	e5c32007 	strb	r2, [r3, #7]
    rt_hw_interrupt_enable(level);
10009490:	e1a00004 	mov	r0, r4
10009494:	eb00080c 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
10009498:	e3093d8c 	movw	r3, #40332	; 0x9d8c
1000949c:	e3413002 	movt	r3, #4098	; 0x1002
100094a0:	e5933000 	ldr	r3, [r3]
100094a4:	e3530000 	cmp	r3, #0
100094a8:	0a000005 	beq	100094c4 <rt_timer_start+0x90>
100094ac:	e3093d8c 	movw	r3, #40332	; 0x9d8c
100094b0:	e3413002 	movt	r3, #4098	; 0x1002
100094b4:	e5933000 	ldr	r3, [r3]
100094b8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100094bc:	e1a00002 	mov	r0, r2
100094c0:	e12fff33 	blx	r3

    /*
     * get timeout tick,
     * the max timeout tick shall not great than RT_TICK_MAX/2
     */
    RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
100094c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100094c8:	e5933020 	ldr	r3, [r3, #32]
100094cc:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
100094d0:	9a000005 	bls	100094ec <rt_timer_start+0xb8>
100094d4:	e30e0e18 	movw	r0, #60952	; 0xee18
100094d8:	e3410001 	movt	r0, #4097	; 0x1001
100094dc:	e30e1e6c 	movw	r1, #61036	; 0xee6c
100094e0:	e3411001 	movt	r1, #4097	; 0x1001
100094e4:	e3a02d05 	mov	r2, #320	; 0x140
100094e8:	ebfff436 	bl	100065c8 <rt_assert_handler>
    timer->timeout_tick = rt_tick_get() + timer->init_tick;
100094ec:	ebffddc4 	bl	10000c04 <rt_tick_get>
100094f0:	e1a02000 	mov	r2, r0
100094f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100094f8:	e5933020 	ldr	r3, [r3, #32]
100094fc:	e0822003 	add	r2, r2, r3
10009500:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10009504:	e5832024 	str	r2, [r3, #36]	; 0x24

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
10009508:	eb0007eb 	bl	1000b4bc <rt_hw_interrupt_disable>
1000950c:	e1a04000 	mov	r4, r0
    }
    else
#endif
    {
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
10009510:	e30833f4 	movw	r3, #33780	; 0x83f4
10009514:	e3413002 	movt	r3, #4098	; 0x1002
10009518:	e50b3018 	str	r3, [fp, #-24]
    }

    row_head[0]  = &timer_list[0];
1000951c:	e51b3018 	ldr	r3, [fp, #-24]
10009520:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
10009524:	e3a03000 	mov	r3, #0
10009528:	e50b3010 	str	r3, [fp, #-16]
1000952c:	ea000046 	b	1000964c <rt_timer_start+0x218>
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
10009530:	ea000027 	b	100095d4 <rt_timer_start+0x1a0>
             row_head[row_lvl]  = row_head[row_lvl]->next)
        {
            struct rt_timer *t;
            rt_list_t *p = row_head[row_lvl]->next;
10009534:	e51b3010 	ldr	r3, [fp, #-16]
10009538:	e1a03103 	lsl	r3, r3, #2
1000953c:	e24b200c 	sub	r2, fp, #12
10009540:	e0823003 	add	r3, r2, r3
10009544:	e5133018 	ldr	r3, [r3, #-24]
10009548:	e5933000 	ldr	r3, [r3]
1000954c:	e50b301c 	str	r3, [fp, #-28]

            /* fix up the entry pointer */
            t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
10009550:	e51b3010 	ldr	r3, [fp, #-16]
10009554:	e1a03183 	lsl	r3, r3, #3
10009558:	e2833010 	add	r3, r3, #16
1000955c:	e2633000 	rsb	r3, r3, #0
10009560:	e51b201c 	ldr	r2, [fp, #-28]
10009564:	e0823003 	add	r3, r2, r3
10009568:	e50b3020 	str	r3, [fp, #-32]
            /* If we have two timers that timeout at the same time, it's
             * preferred that the timer inserted early get called early.
             * So insert the new timer to the end the the some-timeout timer
             * list.
             */
            if ((t->timeout_tick - timer->timeout_tick) == 0)
1000956c:	e51b3020 	ldr	r3, [fp, #-32]
10009570:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10009574:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10009578:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000957c:	e1520003 	cmp	r2, r3
10009580:	1a000000 	bne	10009588 <rt_timer_start+0x154>
            {
                continue;
10009584:	ea000007 	b	100095a8 <rt_timer_start+0x174>
            }
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
10009588:	e51b3020 	ldr	r3, [fp, #-32]
1000958c:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10009590:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10009594:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10009598:	e0633002 	rsb	r3, r3, r2
1000959c:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
100095a0:	8a000000 	bhi	100095a8 <rt_timer_start+0x174>
            {
                break;
100095a4:	ea000016 	b	10009604 <rt_timer_start+0x1d0>

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
             row_head[row_lvl]  = row_head[row_lvl]->next)
100095a8:	e51b3010 	ldr	r3, [fp, #-16]
100095ac:	e1a03103 	lsl	r3, r3, #2
100095b0:	e24b200c 	sub	r2, fp, #12
100095b4:	e0823003 	add	r3, r2, r3
100095b8:	e5133018 	ldr	r3, [r3, #-24]
100095bc:	e5932000 	ldr	r2, [r3]
100095c0:	e51b3010 	ldr	r3, [fp, #-16]
100095c4:	e1a03103 	lsl	r3, r3, #2
100095c8:	e24b100c 	sub	r1, fp, #12
100095cc:	e0813003 	add	r3, r1, r3
100095d0:	e5032018 	str	r2, [r3, #-24]
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        for (;row_head[row_lvl] != timer_list[row_lvl].prev;
100095d4:	e51b3010 	ldr	r3, [fp, #-16]
100095d8:	e1a03103 	lsl	r3, r3, #2
100095dc:	e24b200c 	sub	r2, fp, #12
100095e0:	e0823003 	add	r3, r2, r3
100095e4:	e5132018 	ldr	r2, [r3, #-24]
100095e8:	e51b3010 	ldr	r3, [fp, #-16]
100095ec:	e1a03183 	lsl	r3, r3, #3
100095f0:	e51b1018 	ldr	r1, [fp, #-24]
100095f4:	e0813003 	add	r3, r1, r3
100095f8:	e5933004 	ldr	r3, [r3, #4]
100095fc:	e1520003 	cmp	r2, r3
10009600:	1affffcb 	bne	10009534 <rt_timer_start+0x100>
            else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
            {
                break;
            }
        }
        if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
10009604:	e51b3010 	ldr	r3, [fp, #-16]
10009608:	e3530000 	cmp	r3, #0
1000960c:	0a00000b 	beq	10009640 <rt_timer_start+0x20c>
            row_head[row_lvl+1] = row_head[row_lvl]+1;
10009610:	e51b3010 	ldr	r3, [fp, #-16]
10009614:	e2831001 	add	r1, r3, #1
10009618:	e51b3010 	ldr	r3, [fp, #-16]
1000961c:	e1a03103 	lsl	r3, r3, #2
10009620:	e24b200c 	sub	r2, fp, #12
10009624:	e0823003 	add	r3, r2, r3
10009628:	e5133018 	ldr	r3, [r3, #-24]
1000962c:	e2832008 	add	r2, r3, #8
10009630:	e1a03101 	lsl	r3, r1, #2
10009634:	e24b100c 	sub	r1, fp, #12
10009638:	e0813003 	add	r3, r1, r3
1000963c:	e5032018 	str	r2, [r3, #-24]
        /* insert timer to system timer list */
        timer_list = rt_timer_list;
    }

    row_head[0]  = &timer_list[0];
    for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
10009640:	e51b3010 	ldr	r3, [fp, #-16]
10009644:	e2833001 	add	r3, r3, #1
10009648:	e50b3010 	str	r3, [fp, #-16]
1000964c:	e51b3010 	ldr	r3, [fp, #-16]
10009650:	e3530000 	cmp	r3, #0
10009654:	0affffb5 	beq	10009530 <rt_timer_start+0xfc>

    /* Interestingly, this super simple timer insert counter works very very
     * well on distributing the list height uniformly. By means of "very very
     * well", I mean it beats the randomness of timer->timeout_tick very easily
     * (actually, the timeout_tick is not random and easy to be attacked). */
    random_nr++;
10009658:	e3083400 	movw	r3, #33792	; 0x8400
1000965c:	e3413002 	movt	r3, #4098	; 0x1002
10009660:	e5933000 	ldr	r3, [r3]
10009664:	e2832001 	add	r2, r3, #1
10009668:	e3083400 	movw	r3, #33792	; 0x8400
1000966c:	e3413002 	movt	r3, #4098	; 0x1002
10009670:	e5832000 	str	r2, [r3]
    tst_nr = random_nr;
10009674:	e3083400 	movw	r3, #33792	; 0x8400
10009678:	e3413002 	movt	r3, #4098	; 0x1002
1000967c:	e5933000 	ldr	r3, [r3]
10009680:	e50b3014 	str	r3, [fp, #-20]

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
10009684:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10009688:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000968c:	e2833010 	add	r3, r3, #16
10009690:	e1a00002 	mov	r0, r2
10009694:	e1a01003 	mov	r1, r3
10009698:	ebfffe5b 	bl	1000900c <rt_list_insert_after>
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
1000969c:	e3a03002 	mov	r3, #2
100096a0:	e50b3010 	str	r3, [fp, #-16]
100096a4:	ea00001a 	b	10009714 <rt_timer_start+0x2e0>
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
100096a8:	e51b3014 	ldr	r3, [fp, #-20]
100096ac:	e2033003 	and	r3, r3, #3
100096b0:	e3530000 	cmp	r3, #0
100096b4:	1a00000f 	bne	100096f8 <rt_timer_start+0x2c4>
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
100096b8:	e51b3010 	ldr	r3, [fp, #-16]
100096bc:	e2633001 	rsb	r3, r3, #1
100096c0:	e1a03103 	lsl	r3, r3, #2
100096c4:	e24b200c 	sub	r2, fp, #12
100096c8:	e0823003 	add	r3, r2, r3
100096cc:	e5131018 	ldr	r1, [r3, #-24]
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
100096d0:	e51b3010 	ldr	r3, [fp, #-16]
100096d4:	e2633001 	rsb	r3, r3, #1
    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
    {
        if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
            rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
100096d8:	e2833002 	add	r3, r3, #2
100096dc:	e1a03183 	lsl	r3, r3, #3
100096e0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100096e4:	e0823003 	add	r3, r2, r3
100096e8:	e1a00001 	mov	r0, r1
100096ec:	e1a01003 	mov	r1, r3
100096f0:	ebfffe45 	bl	1000900c <rt_list_insert_after>
100096f4:	ea000000 	b	100096fc <rt_timer_start+0x2c8>
                                 &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
        else
            break;
100096f8:	ea000008 	b	10009720 <rt_timer_start+0x2ec>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
100096fc:	e51b3014 	ldr	r3, [fp, #-20]
10009700:	e1a03123 	lsr	r3, r3, #2
10009704:	e50b3014 	str	r3, [fp, #-20]
    random_nr++;
    tst_nr = random_nr;

    rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
                         &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
    for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
10009708:	e51b3010 	ldr	r3, [fp, #-16]
1000970c:	e2833001 	add	r3, r3, #1
10009710:	e50b3010 	str	r3, [fp, #-16]
10009714:	e51b3010 	ldr	r3, [fp, #-16]
10009718:	e3530001 	cmp	r3, #1
1000971c:	9affffe1 	bls	100096a8 <rt_timer_start+0x274>
        /* Shift over the bits we have tested. Works well with 1 bit and 2
         * bits. */
        tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
    }

    timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
10009720:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10009724:	e5d33007 	ldrb	r3, [r3, #7]
10009728:	e3833001 	orr	r3, r3, #1
1000972c:	e6ef2073 	uxtb	r2, r3
10009730:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10009734:	e5c32007 	strb	r2, [r3, #7]

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
10009738:	e1a00004 	mov	r0, r4
1000973c:	eb000762 	bl	1000b4cc <rt_hw_interrupt_enable>
            rt_schedule();
        }
    }
#endif

    return -RT_EOK;
10009740:	e3a03000 	mov	r3, #0
}
10009744:	e1a00003 	mov	r0, r3
10009748:	e24bd008 	sub	sp, fp, #8
1000974c:	e8bd8810 	pop	{r4, fp, pc}

10009750 <rt_timer_stop>:
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
{
10009750:	e92d4810 	push	{r4, fp, lr}
10009754:	e28db008 	add	fp, sp, #8
10009758:	e24dd00c 	sub	sp, sp, #12
1000975c:	e50b0010 	str	r0, [fp, #-16]
    register rt_base_t level;

    /* timer check */
    RT_ASSERT(timer != RT_NULL);
10009760:	e51b3010 	ldr	r3, [fp, #-16]
10009764:	e3530000 	cmp	r3, #0
10009768:	1a000005 	bne	10009784 <rt_timer_stop+0x34>
1000976c:	e30e0e04 	movw	r0, #60932	; 0xee04
10009770:	e3410001 	movt	r0, #4097	; 0x1001
10009774:	e30e1e7c 	movw	r1, #61052	; 0xee7c
10009778:	e3411001 	movt	r1, #4097	; 0x1001
1000977c:	e3a02f6a 	mov	r2, #424	; 0x1a8
10009780:	ebfff390 	bl	100065c8 <rt_assert_handler>
    if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
10009784:	e51b3010 	ldr	r3, [fp, #-16]
10009788:	e5d33007 	ldrb	r3, [r3, #7]
1000978c:	e2033001 	and	r3, r3, #1
10009790:	e3530000 	cmp	r3, #0
10009794:	1a000001 	bne	100097a0 <rt_timer_stop+0x50>
        return -RT_ERROR;
10009798:	e3e03000 	mvn	r3, #0
1000979c:	ea000017 	b	10009800 <rt_timer_stop+0xb0>

    RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
100097a0:	e3093d88 	movw	r3, #40328	; 0x9d88
100097a4:	e3413002 	movt	r3, #4098	; 0x1002
100097a8:	e5933000 	ldr	r3, [r3]
100097ac:	e3530000 	cmp	r3, #0
100097b0:	0a000005 	beq	100097cc <rt_timer_stop+0x7c>
100097b4:	e3093d88 	movw	r3, #40328	; 0x9d88
100097b8:	e3413002 	movt	r3, #4098	; 0x1002
100097bc:	e5933000 	ldr	r3, [r3]
100097c0:	e51b2010 	ldr	r2, [fp, #-16]
100097c4:	e1a00002 	mov	r0, r2
100097c8:	e12fff33 	blx	r3

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100097cc:	eb00073a 	bl	1000b4bc <rt_hw_interrupt_disable>
100097d0:	e1a04000 	mov	r4, r0

    _rt_timer_remove(timer);
100097d4:	e51b0010 	ldr	r0, [fp, #-16]
100097d8:	ebfffe95 	bl	10009234 <_rt_timer_remove>

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100097dc:	e1a00004 	mov	r0, r4
100097e0:	eb000739 	bl	1000b4cc <rt_hw_interrupt_enable>

    /* change stat */
    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
100097e4:	e51b3010 	ldr	r3, [fp, #-16]
100097e8:	e5d33007 	ldrb	r3, [r3, #7]
100097ec:	e3c33001 	bic	r3, r3, #1
100097f0:	e6ef2073 	uxtb	r2, r3
100097f4:	e51b3010 	ldr	r3, [fp, #-16]
100097f8:	e5c32007 	strb	r2, [r3, #7]

    return RT_EOK;
100097fc:	e3a03000 	mov	r3, #0
}
10009800:	e1a00003 	mov	r0, r3
10009804:	e24bd008 	sub	sp, fp, #8
10009808:	e8bd8810 	pop	{r4, fp, pc}

1000980c <rt_timer_control>:
 * @param arg the argument
 *
 * @return RT_EOK
 */
rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
{
1000980c:	e92d4800 	push	{fp, lr}
10009810:	e28db004 	add	fp, sp, #4
10009814:	e24dd010 	sub	sp, sp, #16
10009818:	e50b0008 	str	r0, [fp, #-8]
1000981c:	e1a03001 	mov	r3, r1
10009820:	e50b2010 	str	r2, [fp, #-16]
10009824:	e54b3009 	strb	r3, [fp, #-9]
    /* timer check */
    RT_ASSERT(timer != RT_NULL);
10009828:	e51b3008 	ldr	r3, [fp, #-8]
1000982c:	e3530000 	cmp	r3, #0
10009830:	1a000005 	bne	1000984c <rt_timer_control+0x40>
10009834:	e30e0e04 	movw	r0, #60932	; 0xee04
10009838:	e3410001 	movt	r0, #4097	; 0x1001
1000983c:	e30e1e8c 	movw	r1, #61068	; 0xee8c
10009840:	e3411001 	movt	r1, #4097	; 0x1001
10009844:	e30021c9 	movw	r2, #457	; 0x1c9
10009848:	ebfff35e 	bl	100065c8 <rt_assert_handler>

    switch (cmd)
1000984c:	e55b3009 	ldrb	r3, [fp, #-9]
10009850:	e3530003 	cmp	r3, #3
10009854:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10009858:	ea00001b 	b	100098cc <rt_timer_control+0xc0>
1000985c:	10009880 	.word	0x10009880
10009860:	1000986c 	.word	0x1000986c
10009864:	10009894 	.word	0x10009894
10009868:	100098b0 	.word	0x100098b0
    {
    case RT_TIMER_CTRL_GET_TIME:
        *(rt_tick_t *)arg = timer->init_tick;
1000986c:	e51b3008 	ldr	r3, [fp, #-8]
10009870:	e5932020 	ldr	r2, [r3, #32]
10009874:	e51b3010 	ldr	r3, [fp, #-16]
10009878:	e5832000 	str	r2, [r3]
        break;
1000987c:	ea000012 	b	100098cc <rt_timer_control+0xc0>

    case RT_TIMER_CTRL_SET_TIME:
        timer->init_tick = *(rt_tick_t *)arg;
10009880:	e51b3010 	ldr	r3, [fp, #-16]
10009884:	e5932000 	ldr	r2, [r3]
10009888:	e51b3008 	ldr	r3, [fp, #-8]
1000988c:	e5832020 	str	r2, [r3, #32]
        break;
10009890:	ea00000d 	b	100098cc <rt_timer_control+0xc0>

    case RT_TIMER_CTRL_SET_ONESHOT:
        timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
10009894:	e51b3008 	ldr	r3, [fp, #-8]
10009898:	e5d33007 	ldrb	r3, [r3, #7]
1000989c:	e3c33002 	bic	r3, r3, #2
100098a0:	e6ef2073 	uxtb	r2, r3
100098a4:	e51b3008 	ldr	r3, [fp, #-8]
100098a8:	e5c32007 	strb	r2, [r3, #7]
        break;
100098ac:	ea000006 	b	100098cc <rt_timer_control+0xc0>

    case RT_TIMER_CTRL_SET_PERIODIC:
        timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
100098b0:	e51b3008 	ldr	r3, [fp, #-8]
100098b4:	e5d33007 	ldrb	r3, [r3, #7]
100098b8:	e3833002 	orr	r3, r3, #2
100098bc:	e6ef2073 	uxtb	r2, r3
100098c0:	e51b3008 	ldr	r3, [fp, #-8]
100098c4:	e5c32007 	strb	r2, [r3, #7]
        break;
100098c8:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
100098cc:	e3a03000 	mov	r3, #0
}
100098d0:	e1a00003 	mov	r0, r3
100098d4:	e24bd004 	sub	sp, fp, #4
100098d8:	e8bd8800 	pop	{fp, pc}

100098dc <rt_timer_check>:
 * corresponding timeout function will be invoked.
 *
 * @note this function shall be invoked in operating system timer interrupt.
 */
void rt_timer_check(void)
{
100098dc:	e92d4810 	push	{r4, fp, lr}
100098e0:	e28db008 	add	fp, sp, #8
100098e4:	e24dd00c 	sub	sp, sp, #12
    rt_tick_t current_tick;
    register rt_base_t level;

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));

    current_tick = rt_tick_get();
100098e8:	ebffdcc5 	bl	10000c04 <rt_tick_get>
100098ec:	e50b0010 	str	r0, [fp, #-16]

    /* disable interrupt */
    level = rt_hw_interrupt_disable();
100098f0:	eb0006f1 	bl	1000b4bc <rt_hw_interrupt_disable>
100098f4:	e1a04000 	mov	r4, r0

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
100098f8:	ea000039 	b	100099e4 <rt_timer_check+0x108>
    {
        t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
100098fc:	e30833f4 	movw	r3, #33780	; 0x83f4
10009900:	e3413002 	movt	r3, #4098	; 0x1002
10009904:	e5933000 	ldr	r3, [r3]
10009908:	e2433010 	sub	r3, r3, #16
1000990c:	e50b3014 	str	r3, [fp, #-20]

        /*
         * It supposes that the new tick shall less than the half duration of
         * tick max.
         */
        if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
10009910:	e51b3014 	ldr	r3, [fp, #-20]
10009914:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10009918:	e51b2010 	ldr	r2, [fp, #-16]
1000991c:	e0633002 	rsb	r3, r3, r2
10009920:	e373010a 	cmn	r3, #-2147483646	; 0x80000002
10009924:	8a00002d 	bhi	100099e0 <rt_timer_check+0x104>
        {
            RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
10009928:	e30833fc 	movw	r3, #33788	; 0x83fc
1000992c:	e3413002 	movt	r3, #4098	; 0x1002
10009930:	e5933000 	ldr	r3, [r3]
10009934:	e3530000 	cmp	r3, #0
10009938:	0a000004 	beq	10009950 <rt_timer_check+0x74>
1000993c:	e30833fc 	movw	r3, #33788	; 0x83fc
10009940:	e3413002 	movt	r3, #4098	; 0x1002
10009944:	e5933000 	ldr	r3, [r3]
10009948:	e51b0014 	ldr	r0, [fp, #-20]
1000994c:	e12fff33 	blx	r3

            /* remove timer from timer list firstly */
            _rt_timer_remove(t);
10009950:	e51b0014 	ldr	r0, [fp, #-20]
10009954:	ebfffe36 	bl	10009234 <_rt_timer_remove>

            /* call timeout function */
            t->timeout_func(t->parameter);
10009958:	e51b3014 	ldr	r3, [fp, #-20]
1000995c:	e5933018 	ldr	r3, [r3, #24]
10009960:	e51b2014 	ldr	r2, [fp, #-20]
10009964:	e592201c 	ldr	r2, [r2, #28]
10009968:	e1a00002 	mov	r0, r2
1000996c:	e12fff33 	blx	r3

            /* re-get tick */
            current_tick = rt_tick_get();
10009970:	ebffdca3 	bl	10000c04 <rt_tick_get>
10009974:	e50b0010 	str	r0, [fp, #-16]

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
10009978:	e51b3014 	ldr	r3, [fp, #-20]
1000997c:	e5d33007 	ldrb	r3, [r3, #7]
10009980:	e2033002 	and	r3, r3, #2
10009984:	e3530000 	cmp	r3, #0
10009988:	0a00000d 	beq	100099c4 <rt_timer_check+0xe8>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
1000998c:	e51b3014 	ldr	r3, [fp, #-20]
10009990:	e5d33007 	ldrb	r3, [r3, #7]
10009994:	e2033001 	and	r3, r3, #1
            /* re-get tick */
            current_tick = rt_tick_get();

            RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));

            if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
10009998:	e3530000 	cmp	r3, #0
1000999c:	0a000008 	beq	100099c4 <rt_timer_check+0xe8>
                (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
            {
                /* start it */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
100099a0:	e51b3014 	ldr	r3, [fp, #-20]
100099a4:	e5d33007 	ldrb	r3, [r3, #7]
100099a8:	e3c33001 	bic	r3, r3, #1
100099ac:	e6ef2073 	uxtb	r2, r3
100099b0:	e51b3014 	ldr	r3, [fp, #-20]
100099b4:	e5c32007 	strb	r2, [r3, #7]
                rt_timer_start(t);
100099b8:	e51b0014 	ldr	r0, [fp, #-20]
100099bc:	ebfffe9c 	bl	10009434 <rt_timer_start>
100099c0:	ea000005 	b	100099dc <rt_timer_check+0x100>
            }
            else
            {
                /* stop timer */
                t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
100099c4:	e51b3014 	ldr	r3, [fp, #-20]
100099c8:	e5d33007 	ldrb	r3, [r3, #7]
100099cc:	e3c33001 	bic	r3, r3, #1
100099d0:	e6ef2073 	uxtb	r2, r3
100099d4:	e51b3014 	ldr	r3, [fp, #-20]
100099d8:	e5c32007 	strb	r2, [r3, #7]
100099dc:	ea000000 	b	100099e4 <rt_timer_check+0x108>
            }
        }
        else
            break;
100099e0:	ea000005 	b	100099fc <rt_timer_check+0x120>
    current_tick = rt_tick_get();

    /* disable interrupt */
    level = rt_hw_interrupt_disable();

    while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
100099e4:	e30803f4 	movw	r0, #33780	; 0x83f4
100099e8:	e3410002 	movt	r0, #4098	; 0x1002
100099ec:	ebfffdb4 	bl	100090c4 <rt_list_isempty>
100099f0:	e1a03000 	mov	r3, r0
100099f4:	e3530000 	cmp	r3, #0
100099f8:	0affffbf 	beq	100098fc <rt_timer_check+0x20>
        else
            break;
    }

    /* enable interrupt */
    rt_hw_interrupt_enable(level);
100099fc:	e1a00004 	mov	r0, r4
10009a00:	eb0006b1 	bl	1000b4cc <rt_hw_interrupt_enable>

    RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
}
10009a04:	e24bd008 	sub	sp, fp, #8
10009a08:	e8bd8810 	pop	{r4, fp, pc}

10009a0c <rt_timer_next_timeout_tick>:
 * This function will return the next timeout tick in the system.
 *
 * @return the next timeout tick in the system
 */
rt_tick_t rt_timer_next_timeout_tick(void)
{
10009a0c:	e92d4800 	push	{fp, lr}
10009a10:	e28db004 	add	fp, sp, #4
    return rt_timer_list_next_timeout(rt_timer_list);
10009a14:	e30803f4 	movw	r0, #33780	; 0x83f4
10009a18:	e3410002 	movt	r0, #4098	; 0x1002
10009a1c:	ebfffdf0 	bl	100091e4 <rt_timer_list_next_timeout>
10009a20:	e1a03000 	mov	r3, r0
}
10009a24:	e1a00003 	mov	r0, r3
10009a28:	e8bd8800 	pop	{fp, pc}

10009a2c <rt_system_timer_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
10009a2c:	e92d4800 	push	{fp, lr}
10009a30:	e28db004 	add	fp, sp, #4
10009a34:	e24dd008 	sub	sp, sp, #8
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
10009a38:	e3a03000 	mov	r3, #0
10009a3c:	e50b3008 	str	r3, [fp, #-8]
10009a40:	ea000009 	b	10009a6c <rt_system_timer_init+0x40>
    {
        rt_list_init(rt_timer_list+i);
10009a44:	e51b3008 	ldr	r3, [fp, #-8]
10009a48:	e1a02183 	lsl	r2, r3, #3
10009a4c:	e30833f4 	movw	r3, #33780	; 0x83f4
10009a50:	e3413002 	movt	r3, #4098	; 0x1002
10009a54:	e0823003 	add	r3, r2, r3
10009a58:	e1a00003 	mov	r0, r3
10009a5c:	ebfffd5c 	bl	10008fd4 <rt_list_init>
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
10009a60:	e51b3008 	ldr	r3, [fp, #-8]
10009a64:	e2833001 	add	r3, r3, #1
10009a68:	e50b3008 	str	r3, [fp, #-8]
10009a6c:	e51b3008 	ldr	r3, [fp, #-8]
10009a70:	e3530000 	cmp	r3, #0
10009a74:	0afffff2 	beq	10009a44 <rt_system_timer_init+0x18>
    {
        rt_list_init(rt_timer_list+i);
    }
}
10009a78:	e24bd004 	sub	sp, fp, #4
10009a7c:	e8bd8800 	pop	{fp, pc}

10009a80 <rt_system_timer_thread_init>:
 * @ingroup SystemInit
 *
 * This function will initialize system timer thread
 */
void rt_system_timer_thread_init(void)
{
10009a80:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009a84:	e28db000 	add	fp, sp, #0
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
#endif
}
10009a88:	e24bd000 	sub	sp, fp, #0
10009a8c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10009a90:	e12fff1e 	bx	lr

10009a94 <rt_hw_cpu_reset>:
/**
 * reset cpu by dog's time-out
 *
 */
void rt_hw_cpu_reset()
{
10009a94:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10009a98:	e28db000 	add	fp, sp, #0
    while (1);  /* loop forever and wait for reset to happen */
10009a9c:	eafffffe 	b	10009a9c <rt_hw_cpu_reset+0x8>

10009aa0 <rt_hw_cpu_shutdown>:
/**
 *  shutdown CPU
 *
 */
void rt_hw_cpu_shutdown()
{
10009aa0:	e92d4800 	push	{fp, lr}
10009aa4:	e28db004 	add	fp, sp, #4
10009aa8:	e24dd008 	sub	sp, sp, #8
    rt_uint32_t level;
    rt_kprintf("shutdown...\n");
10009aac:	e30e0ea0 	movw	r0, #61088	; 0xeea0
10009ab0:	e3410001 	movt	r0, #4097	; 0x1001
10009ab4:	ebfff206 	bl	100062d4 <rt_kprintf>

    level = rt_hw_interrupt_disable();
10009ab8:	eb00067f 	bl	1000b4bc <rt_hw_interrupt_disable>
10009abc:	e1a03000 	mov	r3, r0
10009ac0:	e50b3008 	str	r3, [fp, #-8]
    while (level)
10009ac4:	ea000005 	b	10009ae0 <rt_hw_cpu_shutdown+0x40>
    {
        RT_ASSERT(0);
10009ac8:	e30e0eb0 	movw	r0, #61104	; 0xeeb0
10009acc:	e3410001 	movt	r0, #4097	; 0x1001
10009ad0:	e30e1eb4 	movw	r1, #61108	; 0xeeb4
10009ad4:	e3411001 	movt	r1, #4097	; 0x1001
10009ad8:	e3a0202a 	mov	r2, #42	; 0x2a
10009adc:	ebfff2b9 	bl	100065c8 <rt_assert_handler>
{
    rt_uint32_t level;
    rt_kprintf("shutdown...\n");

    level = rt_hw_interrupt_disable();
    while (level)
10009ae0:	e51b3008 	ldr	r3, [fp, #-8]
10009ae4:	e3530000 	cmp	r3, #0
10009ae8:	1afffff6 	bne	10009ac8 <rt_hw_cpu_shutdown+0x28>
    {
        RT_ASSERT(0);
    }
}
10009aec:	e24bd004 	sub	sp, fp, #4
10009af0:	e8bd8800 	pop	{fp, pc}

10009af4 <arm_gic_get_active_irq>:
#define GIC_DIST_ICPIDR2(hw_base)           __REG32((hw_base) + 0xfe8)

static unsigned int _gic_max_irq;

int arm_gic_get_active_irq(rt_uint32_t index)
{
10009af4:	e92d4800 	push	{fp, lr}
10009af8:	e28db004 	add	fp, sp, #4
10009afc:	e24dd010 	sub	sp, sp, #16
10009b00:	e50b0010 	str	r0, [fp, #-16]
    int irq;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10009b04:	e51b3010 	ldr	r3, [fp, #-16]
10009b08:	e3530000 	cmp	r3, #0
10009b0c:	0a000005 	beq	10009b28 <arm_gic_get_active_irq+0x34>
10009b10:	e30e0ec8 	movw	r0, #61128	; 0xeec8
10009b14:	e3410001 	movt	r0, #4097	; 0x1001
10009b18:	e30e1f74 	movw	r1, #61300	; 0xef74
10009b1c:	e3411001 	movt	r1, #4097	; 0x1001
10009b20:	e3a02041 	mov	r2, #65	; 0x41
10009b24:	ebfff2a7 	bl	100065c8 <rt_assert_handler>

    irq = GIC_CPU_INTACK(_gic_table[index].cpu_hw_base);
10009b28:	e3082404 	movw	r2, #33796	; 0x8404
10009b2c:	e3412002 	movt	r2, #4098	; 0x1002
10009b30:	e51b3010 	ldr	r3, [fp, #-16]
10009b34:	e1a01003 	mov	r1, r3
10009b38:	e1a03101 	lsl	r3, r1, #2
10009b3c:	e1a01003 	mov	r1, r3
10009b40:	e1a03101 	lsl	r3, r1, #2
10009b44:	e0613003 	rsb	r3, r1, r3
10009b48:	e0823003 	add	r3, r2, r3
10009b4c:	e2833008 	add	r3, r3, #8
10009b50:	e5933000 	ldr	r3, [r3]
10009b54:	e283300c 	add	r3, r3, #12
10009b58:	e5933000 	ldr	r3, [r3]
10009b5c:	e50b3008 	str	r3, [fp, #-8]
    irq += _gic_table[index].offset;
10009b60:	e3082404 	movw	r2, #33796	; 0x8404
10009b64:	e3412002 	movt	r2, #4098	; 0x1002
10009b68:	e51b3010 	ldr	r3, [fp, #-16]
10009b6c:	e1a01003 	mov	r1, r3
10009b70:	e1a03101 	lsl	r3, r1, #2
10009b74:	e1a01003 	mov	r1, r3
10009b78:	e1a03101 	lsl	r3, r1, #2
10009b7c:	e0613003 	rsb	r3, r1, r3
10009b80:	e0823003 	add	r3, r2, r3
10009b84:	e5932000 	ldr	r2, [r3]
10009b88:	e51b3008 	ldr	r3, [fp, #-8]
10009b8c:	e0823003 	add	r3, r2, r3
10009b90:	e50b3008 	str	r3, [fp, #-8]
    return irq;
10009b94:	e51b3008 	ldr	r3, [fp, #-8]
}
10009b98:	e1a00003 	mov	r0, r3
10009b9c:	e24bd004 	sub	sp, fp, #4
10009ba0:	e8bd8800 	pop	{fp, pc}

10009ba4 <arm_gic_ack>:

void arm_gic_ack(rt_uint32_t index, int irq)
{
10009ba4:	e92d4800 	push	{fp, lr}
10009ba8:	e28db004 	add	fp, sp, #4
10009bac:	e24dd010 	sub	sp, sp, #16
10009bb0:	e50b0010 	str	r0, [fp, #-16]
10009bb4:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
10009bb8:	e51b2014 	ldr	r2, [fp, #-20]
10009bbc:	e1a03fc2 	asr	r3, r2, #31
10009bc0:	e1a03da3 	lsr	r3, r3, #27
10009bc4:	e0822003 	add	r2, r2, r3
10009bc8:	e202201f 	and	r2, r2, #31
10009bcc:	e0633002 	rsb	r3, r3, r2
10009bd0:	e1a02003 	mov	r2, r3
10009bd4:	e3a03001 	mov	r3, #1
10009bd8:	e1a03213 	lsl	r3, r3, r2
10009bdc:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10009be0:	e51b3010 	ldr	r3, [fp, #-16]
10009be4:	e3530000 	cmp	r3, #0
10009be8:	0a000005 	beq	10009c04 <arm_gic_ack+0x60>
10009bec:	e30e0ec8 	movw	r0, #61128	; 0xeec8
10009bf0:	e3410001 	movt	r0, #4097	; 0x1001
10009bf4:	e30e1f8c 	movw	r1, #61324	; 0xef8c
10009bf8:	e3411001 	movt	r1, #4097	; 0x1001
10009bfc:	e3a0204c 	mov	r2, #76	; 0x4c
10009c00:	ebfff270 	bl	100065c8 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
10009c04:	e51b0014 	ldr	r0, [fp, #-20]
10009c08:	e3082404 	movw	r2, #33796	; 0x8404
10009c0c:	e3412002 	movt	r2, #4098	; 0x1002
10009c10:	e51b3010 	ldr	r3, [fp, #-16]
10009c14:	e1a01003 	mov	r1, r3
10009c18:	e1a03101 	lsl	r3, r1, #2
10009c1c:	e1a01003 	mov	r1, r3
10009c20:	e1a03101 	lsl	r3, r1, #2
10009c24:	e0613003 	rsb	r3, r1, r3
10009c28:	e0823003 	add	r3, r2, r3
10009c2c:	e5933000 	ldr	r3, [r3]
10009c30:	e0633000 	rsb	r3, r3, r0
10009c34:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10009c38:	e51b3014 	ldr	r3, [fp, #-20]
10009c3c:	e3530000 	cmp	r3, #0
10009c40:	aa000005 	bge	10009c5c <arm_gic_ack+0xb8>
10009c44:	e30e0ee0 	movw	r0, #61152	; 0xeee0
10009c48:	e3410001 	movt	r0, #4097	; 0x1001
10009c4c:	e30e1f8c 	movw	r1, #61324	; 0xef8c
10009c50:	e3411001 	movt	r1, #4097	; 0x1001
10009c54:	e3a0204f 	mov	r2, #79	; 0x4f
10009c58:	ebfff25a 	bl	100065c8 <rt_assert_handler>

    GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
10009c5c:	e3082404 	movw	r2, #33796	; 0x8404
10009c60:	e3412002 	movt	r2, #4098	; 0x1002
10009c64:	e51b3010 	ldr	r3, [fp, #-16]
10009c68:	e1a01003 	mov	r1, r3
10009c6c:	e1a03101 	lsl	r3, r1, #2
10009c70:	e1a01003 	mov	r1, r3
10009c74:	e1a03101 	lsl	r3, r1, #2
10009c78:	e0613003 	rsb	r3, r1, r3
10009c7c:	e0823003 	add	r3, r2, r3
10009c80:	e5932004 	ldr	r2, [r3, #4]
10009c84:	e51b3014 	ldr	r3, [fp, #-20]
10009c88:	e283101f 	add	r1, r3, #31
10009c8c:	e3530000 	cmp	r3, #0
10009c90:	b1a03001 	movlt	r3, r1
10009c94:	a1a03003 	movge	r3, r3
10009c98:	e1a032c3 	asr	r3, r3, #5
10009c9c:	e1a03103 	lsl	r3, r3, #2
10009ca0:	e0823003 	add	r3, r2, r3
10009ca4:	e2833d06 	add	r3, r3, #384	; 0x180
10009ca8:	e1a02003 	mov	r2, r3
10009cac:	e51b3008 	ldr	r3, [fp, #-8]
10009cb0:	e5823000 	str	r3, [r2]
    GIC_CPU_EOI(_gic_table[index].cpu_hw_base) = irq;
10009cb4:	e3082404 	movw	r2, #33796	; 0x8404
10009cb8:	e3412002 	movt	r2, #4098	; 0x1002
10009cbc:	e51b3010 	ldr	r3, [fp, #-16]
10009cc0:	e1a01003 	mov	r1, r3
10009cc4:	e1a03101 	lsl	r3, r1, #2
10009cc8:	e1a01003 	mov	r1, r3
10009ccc:	e1a03101 	lsl	r3, r1, #2
10009cd0:	e0613003 	rsb	r3, r1, r3
10009cd4:	e0823003 	add	r3, r2, r3
10009cd8:	e2833008 	add	r3, r3, #8
10009cdc:	e5933000 	ldr	r3, [r3]
10009ce0:	e2833010 	add	r3, r3, #16
10009ce4:	e1a02003 	mov	r2, r3
10009ce8:	e51b3014 	ldr	r3, [fp, #-20]
10009cec:	e5823000 	str	r3, [r2]
    GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
10009cf0:	e3082404 	movw	r2, #33796	; 0x8404
10009cf4:	e3412002 	movt	r2, #4098	; 0x1002
10009cf8:	e51b3010 	ldr	r3, [fp, #-16]
10009cfc:	e1a01003 	mov	r1, r3
10009d00:	e1a03101 	lsl	r3, r1, #2
10009d04:	e1a01003 	mov	r1, r3
10009d08:	e1a03101 	lsl	r3, r1, #2
10009d0c:	e0613003 	rsb	r3, r1, r3
10009d10:	e0823003 	add	r3, r2, r3
10009d14:	e5932004 	ldr	r2, [r3, #4]
10009d18:	e51b3014 	ldr	r3, [fp, #-20]
10009d1c:	e283101f 	add	r1, r3, #31
10009d20:	e3530000 	cmp	r3, #0
10009d24:	b1a03001 	movlt	r3, r1
10009d28:	a1a03003 	movge	r3, r3
10009d2c:	e1a032c3 	asr	r3, r3, #5
10009d30:	e1a03103 	lsl	r3, r3, #2
10009d34:	e0823003 	add	r3, r2, r3
10009d38:	e2833c01 	add	r3, r3, #256	; 0x100
10009d3c:	e1a02003 	mov	r2, r3
10009d40:	e51b3008 	ldr	r3, [fp, #-8]
10009d44:	e5823000 	str	r3, [r2]
}
10009d48:	e24bd004 	sub	sp, fp, #4
10009d4c:	e8bd8800 	pop	{fp, pc}

10009d50 <arm_gic_mask>:

void arm_gic_mask(rt_uint32_t index, int irq)
{
10009d50:	e92d4800 	push	{fp, lr}
10009d54:	e28db004 	add	fp, sp, #4
10009d58:	e24dd010 	sub	sp, sp, #16
10009d5c:	e50b0010 	str	r0, [fp, #-16]
10009d60:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
10009d64:	e51b2014 	ldr	r2, [fp, #-20]
10009d68:	e1a03fc2 	asr	r3, r2, #31
10009d6c:	e1a03da3 	lsr	r3, r3, #27
10009d70:	e0822003 	add	r2, r2, r3
10009d74:	e202201f 	and	r2, r2, #31
10009d78:	e0633002 	rsb	r3, r3, r2
10009d7c:	e1a02003 	mov	r2, r3
10009d80:	e3a03001 	mov	r3, #1
10009d84:	e1a03213 	lsl	r3, r3, r2
10009d88:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10009d8c:	e51b3010 	ldr	r3, [fp, #-16]
10009d90:	e3530000 	cmp	r3, #0
10009d94:	0a000005 	beq	10009db0 <arm_gic_mask+0x60>
10009d98:	e30e0ec8 	movw	r0, #61128	; 0xeec8
10009d9c:	e3410001 	movt	r0, #4097	; 0x1001
10009da0:	e30e1f98 	movw	r1, #61336	; 0xef98
10009da4:	e3411001 	movt	r1, #4097	; 0x1001
10009da8:	e3a0205a 	mov	r2, #90	; 0x5a
10009dac:	ebfff205 	bl	100065c8 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
10009db0:	e51b0014 	ldr	r0, [fp, #-20]
10009db4:	e3082404 	movw	r2, #33796	; 0x8404
10009db8:	e3412002 	movt	r2, #4098	; 0x1002
10009dbc:	e51b3010 	ldr	r3, [fp, #-16]
10009dc0:	e1a01003 	mov	r1, r3
10009dc4:	e1a03101 	lsl	r3, r1, #2
10009dc8:	e1a01003 	mov	r1, r3
10009dcc:	e1a03101 	lsl	r3, r1, #2
10009dd0:	e0613003 	rsb	r3, r1, r3
10009dd4:	e0823003 	add	r3, r2, r3
10009dd8:	e5933000 	ldr	r3, [r3]
10009ddc:	e0633000 	rsb	r3, r3, r0
10009de0:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10009de4:	e51b3014 	ldr	r3, [fp, #-20]
10009de8:	e3530000 	cmp	r3, #0
10009dec:	aa000005 	bge	10009e08 <arm_gic_mask+0xb8>
10009df0:	e30e0ee0 	movw	r0, #61152	; 0xeee0
10009df4:	e3410001 	movt	r0, #4097	; 0x1001
10009df8:	e30e1f98 	movw	r1, #61336	; 0xef98
10009dfc:	e3411001 	movt	r1, #4097	; 0x1001
10009e00:	e3a0205d 	mov	r2, #93	; 0x5d
10009e04:	ebfff1ef 	bl	100065c8 <rt_assert_handler>

    GIC_DIST_ENABLE_CLEAR(_gic_table[index].dist_hw_base, irq) = mask;
10009e08:	e3082404 	movw	r2, #33796	; 0x8404
10009e0c:	e3412002 	movt	r2, #4098	; 0x1002
10009e10:	e51b3010 	ldr	r3, [fp, #-16]
10009e14:	e1a01003 	mov	r1, r3
10009e18:	e1a03101 	lsl	r3, r1, #2
10009e1c:	e1a01003 	mov	r1, r3
10009e20:	e1a03101 	lsl	r3, r1, #2
10009e24:	e0613003 	rsb	r3, r1, r3
10009e28:	e0823003 	add	r3, r2, r3
10009e2c:	e5932004 	ldr	r2, [r3, #4]
10009e30:	e51b3014 	ldr	r3, [fp, #-20]
10009e34:	e283101f 	add	r1, r3, #31
10009e38:	e3530000 	cmp	r3, #0
10009e3c:	b1a03001 	movlt	r3, r1
10009e40:	a1a03003 	movge	r3, r3
10009e44:	e1a032c3 	asr	r3, r3, #5
10009e48:	e1a03103 	lsl	r3, r3, #2
10009e4c:	e0823003 	add	r3, r2, r3
10009e50:	e2833d06 	add	r3, r3, #384	; 0x180
10009e54:	e1a02003 	mov	r2, r3
10009e58:	e51b3008 	ldr	r3, [fp, #-8]
10009e5c:	e5823000 	str	r3, [r2]
}
10009e60:	e24bd004 	sub	sp, fp, #4
10009e64:	e8bd8800 	pop	{fp, pc}

10009e68 <arm_gic_set_cpu>:

void arm_gic_set_cpu(rt_uint32_t index, int irq, unsigned int cpumask)
{
10009e68:	e92d4800 	push	{fp, lr}
10009e6c:	e28db004 	add	fp, sp, #4
10009e70:	e24dd018 	sub	sp, sp, #24
10009e74:	e50b0010 	str	r0, [fp, #-16]
10009e78:	e50b1014 	str	r1, [fp, #-20]
10009e7c:	e50b2018 	str	r2, [fp, #-24]
    rt_uint32_t old_tgt;

    RT_ASSERT(index < ARM_GIC_MAX_NR);
10009e80:	e51b3010 	ldr	r3, [fp, #-16]
10009e84:	e3530000 	cmp	r3, #0
10009e88:	0a000005 	beq	10009ea4 <arm_gic_set_cpu+0x3c>
10009e8c:	e30e0ec8 	movw	r0, #61128	; 0xeec8
10009e90:	e3410001 	movt	r0, #4097	; 0x1001
10009e94:	e30e1fa8 	movw	r1, #61352	; 0xefa8
10009e98:	e3411001 	movt	r1, #4097	; 0x1001
10009e9c:	e3a02066 	mov	r2, #102	; 0x66
10009ea0:	ebfff1c8 	bl	100065c8 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
10009ea4:	e51b0014 	ldr	r0, [fp, #-20]
10009ea8:	e3082404 	movw	r2, #33796	; 0x8404
10009eac:	e3412002 	movt	r2, #4098	; 0x1002
10009eb0:	e51b3010 	ldr	r3, [fp, #-16]
10009eb4:	e1a01003 	mov	r1, r3
10009eb8:	e1a03101 	lsl	r3, r1, #2
10009ebc:	e1a01003 	mov	r1, r3
10009ec0:	e1a03101 	lsl	r3, r1, #2
10009ec4:	e0613003 	rsb	r3, r1, r3
10009ec8:	e0823003 	add	r3, r2, r3
10009ecc:	e5933000 	ldr	r3, [r3]
10009ed0:	e0633000 	rsb	r3, r3, r0
10009ed4:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
10009ed8:	e51b3014 	ldr	r3, [fp, #-20]
10009edc:	e3530000 	cmp	r3, #0
10009ee0:	aa000005 	bge	10009efc <arm_gic_set_cpu+0x94>
10009ee4:	e30e0ee0 	movw	r0, #61152	; 0xeee0
10009ee8:	e3410001 	movt	r0, #4097	; 0x1001
10009eec:	e30e1fa8 	movw	r1, #61352	; 0xefa8
10009ef0:	e3411001 	movt	r1, #4097	; 0x1001
10009ef4:	e3a02069 	mov	r2, #105	; 0x69
10009ef8:	ebfff1b2 	bl	100065c8 <rt_assert_handler>

    old_tgt = GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq);
10009efc:	e3082404 	movw	r2, #33796	; 0x8404
10009f00:	e3412002 	movt	r2, #4098	; 0x1002
10009f04:	e51b3010 	ldr	r3, [fp, #-16]
10009f08:	e1a01003 	mov	r1, r3
10009f0c:	e1a03101 	lsl	r3, r1, #2
10009f10:	e1a01003 	mov	r1, r3
10009f14:	e1a03101 	lsl	r3, r1, #2
10009f18:	e0613003 	rsb	r3, r1, r3
10009f1c:	e0823003 	add	r3, r2, r3
10009f20:	e5932004 	ldr	r2, [r3, #4]
10009f24:	e51b3014 	ldr	r3, [fp, #-20]
10009f28:	e2831003 	add	r1, r3, #3
10009f2c:	e3530000 	cmp	r3, #0
10009f30:	b1a03001 	movlt	r3, r1
10009f34:	a1a03003 	movge	r3, r3
10009f38:	e1a03143 	asr	r3, r3, #2
10009f3c:	e1a03103 	lsl	r3, r3, #2
10009f40:	e0823003 	add	r3, r2, r3
10009f44:	e2833b02 	add	r3, r3, #2048	; 0x800
10009f48:	e5933000 	ldr	r3, [r3]
10009f4c:	e50b3008 	str	r3, [fp, #-8]

    old_tgt &= ~(0x0FFUL << ((irq % 4)*8));
10009f50:	e51b2014 	ldr	r2, [fp, #-20]
10009f54:	e1a03fc2 	asr	r3, r2, #31
10009f58:	e1a03f23 	lsr	r3, r3, #30
10009f5c:	e0822003 	add	r2, r2, r3
10009f60:	e2022003 	and	r2, r2, #3
10009f64:	e0633002 	rsb	r3, r3, r2
10009f68:	e1a03183 	lsl	r3, r3, #3
10009f6c:	e3a020ff 	mov	r2, #255	; 0xff
10009f70:	e1a03312 	lsl	r3, r2, r3
10009f74:	e1e03003 	mvn	r3, r3
10009f78:	e51b2008 	ldr	r2, [fp, #-8]
10009f7c:	e0033002 	and	r3, r3, r2
10009f80:	e50b3008 	str	r3, [fp, #-8]
    old_tgt |=   cpumask << ((irq % 4)*8);
10009f84:	e51b2014 	ldr	r2, [fp, #-20]
10009f88:	e1a03fc2 	asr	r3, r2, #31
10009f8c:	e1a03f23 	lsr	r3, r3, #30
10009f90:	e0822003 	add	r2, r2, r3
10009f94:	e2022003 	and	r2, r2, #3
10009f98:	e0633002 	rsb	r3, r3, r2
10009f9c:	e1a03183 	lsl	r3, r3, #3
10009fa0:	e51b2018 	ldr	r2, [fp, #-24]
10009fa4:	e1a03312 	lsl	r3, r2, r3
10009fa8:	e51b2008 	ldr	r2, [fp, #-8]
10009fac:	e1823003 	orr	r3, r2, r3
10009fb0:	e50b3008 	str	r3, [fp, #-8]

    GIC_DIST_TARGET(_gic_table[index].dist_hw_base, irq) = old_tgt;
10009fb4:	e3082404 	movw	r2, #33796	; 0x8404
10009fb8:	e3412002 	movt	r2, #4098	; 0x1002
10009fbc:	e51b3010 	ldr	r3, [fp, #-16]
10009fc0:	e1a01003 	mov	r1, r3
10009fc4:	e1a03101 	lsl	r3, r1, #2
10009fc8:	e1a01003 	mov	r1, r3
10009fcc:	e1a03101 	lsl	r3, r1, #2
10009fd0:	e0613003 	rsb	r3, r1, r3
10009fd4:	e0823003 	add	r3, r2, r3
10009fd8:	e5932004 	ldr	r2, [r3, #4]
10009fdc:	e51b3014 	ldr	r3, [fp, #-20]
10009fe0:	e2831003 	add	r1, r3, #3
10009fe4:	e3530000 	cmp	r3, #0
10009fe8:	b1a03001 	movlt	r3, r1
10009fec:	a1a03003 	movge	r3, r3
10009ff0:	e1a03143 	asr	r3, r3, #2
10009ff4:	e1a03103 	lsl	r3, r3, #2
10009ff8:	e0823003 	add	r3, r2, r3
10009ffc:	e2833b02 	add	r3, r3, #2048	; 0x800
1000a000:	e1a02003 	mov	r2, r3
1000a004:	e51b3008 	ldr	r3, [fp, #-8]
1000a008:	e5823000 	str	r3, [r2]
}
1000a00c:	e24bd004 	sub	sp, fp, #4
1000a010:	e8bd8800 	pop	{fp, pc}

1000a014 <arm_gic_umask>:

void arm_gic_umask(rt_uint32_t index, int irq)
{
1000a014:	e92d4800 	push	{fp, lr}
1000a018:	e28db004 	add	fp, sp, #4
1000a01c:	e24dd010 	sub	sp, sp, #16
1000a020:	e50b0010 	str	r0, [fp, #-16]
1000a024:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t mask = 1 << (irq % 32);
1000a028:	e51b2014 	ldr	r2, [fp, #-20]
1000a02c:	e1a03fc2 	asr	r3, r2, #31
1000a030:	e1a03da3 	lsr	r3, r3, #27
1000a034:	e0822003 	add	r2, r2, r3
1000a038:	e202201f 	and	r2, r2, #31
1000a03c:	e0633002 	rsb	r3, r3, r2
1000a040:	e1a02003 	mov	r2, r3
1000a044:	e3a03001 	mov	r3, #1
1000a048:	e1a03213 	lsl	r3, r3, r2
1000a04c:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
1000a050:	e51b3010 	ldr	r3, [fp, #-16]
1000a054:	e3530000 	cmp	r3, #0
1000a058:	0a000005 	beq	1000a074 <arm_gic_umask+0x60>
1000a05c:	e30e0ec8 	movw	r0, #61128	; 0xeec8
1000a060:	e3410001 	movt	r0, #4097	; 0x1001
1000a064:	e30e1fb8 	movw	r1, #61368	; 0xefb8
1000a068:	e3411001 	movt	r1, #4097	; 0x1001
1000a06c:	e3a02077 	mov	r2, #119	; 0x77
1000a070:	ebfff154 	bl	100065c8 <rt_assert_handler>

    irq = irq - _gic_table[index].offset;
1000a074:	e51b0014 	ldr	r0, [fp, #-20]
1000a078:	e3082404 	movw	r2, #33796	; 0x8404
1000a07c:	e3412002 	movt	r2, #4098	; 0x1002
1000a080:	e51b3010 	ldr	r3, [fp, #-16]
1000a084:	e1a01003 	mov	r1, r3
1000a088:	e1a03101 	lsl	r3, r1, #2
1000a08c:	e1a01003 	mov	r1, r3
1000a090:	e1a03101 	lsl	r3, r1, #2
1000a094:	e0613003 	rsb	r3, r1, r3
1000a098:	e0823003 	add	r3, r2, r3
1000a09c:	e5933000 	ldr	r3, [r3]
1000a0a0:	e0633000 	rsb	r3, r3, r0
1000a0a4:	e50b3014 	str	r3, [fp, #-20]
    RT_ASSERT(irq >= 0);
1000a0a8:	e51b3014 	ldr	r3, [fp, #-20]
1000a0ac:	e3530000 	cmp	r3, #0
1000a0b0:	aa000005 	bge	1000a0cc <arm_gic_umask+0xb8>
1000a0b4:	e30e0ee0 	movw	r0, #61152	; 0xeee0
1000a0b8:	e3410001 	movt	r0, #4097	; 0x1001
1000a0bc:	e30e1fb8 	movw	r1, #61368	; 0xefb8
1000a0c0:	e3411001 	movt	r1, #4097	; 0x1001
1000a0c4:	e3a0207a 	mov	r2, #122	; 0x7a
1000a0c8:	ebfff13e 	bl	100065c8 <rt_assert_handler>

    GIC_DIST_ENABLE_SET(_gic_table[index].dist_hw_base, irq) = mask;
1000a0cc:	e3082404 	movw	r2, #33796	; 0x8404
1000a0d0:	e3412002 	movt	r2, #4098	; 0x1002
1000a0d4:	e51b3010 	ldr	r3, [fp, #-16]
1000a0d8:	e1a01003 	mov	r1, r3
1000a0dc:	e1a03101 	lsl	r3, r1, #2
1000a0e0:	e1a01003 	mov	r1, r3
1000a0e4:	e1a03101 	lsl	r3, r1, #2
1000a0e8:	e0613003 	rsb	r3, r1, r3
1000a0ec:	e0823003 	add	r3, r2, r3
1000a0f0:	e5932004 	ldr	r2, [r3, #4]
1000a0f4:	e51b3014 	ldr	r3, [fp, #-20]
1000a0f8:	e283101f 	add	r1, r3, #31
1000a0fc:	e3530000 	cmp	r3, #0
1000a100:	b1a03001 	movlt	r3, r1
1000a104:	a1a03003 	movge	r3, r3
1000a108:	e1a032c3 	asr	r3, r3, #5
1000a10c:	e1a03103 	lsl	r3, r3, #2
1000a110:	e0823003 	add	r3, r2, r3
1000a114:	e2833c01 	add	r3, r3, #256	; 0x100
1000a118:	e1a02003 	mov	r2, r3
1000a11c:	e51b3008 	ldr	r3, [fp, #-8]
1000a120:	e5823000 	str	r3, [r2]
}
1000a124:	e24bd004 	sub	sp, fp, #4
1000a128:	e8bd8800 	pop	{fp, pc}

1000a12c <arm_gic_dump_type>:

void arm_gic_dump_type(rt_uint32_t index)
{
1000a12c:	e92d4800 	push	{fp, lr}
1000a130:	e28db004 	add	fp, sp, #4
1000a134:	e24dd018 	sub	sp, sp, #24
1000a138:	e50b0010 	str	r0, [fp, #-16]
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
1000a13c:	e3082404 	movw	r2, #33796	; 0x8404
1000a140:	e3412002 	movt	r2, #4098	; 0x1002
1000a144:	e51b3010 	ldr	r3, [fp, #-16]
1000a148:	e1a01003 	mov	r1, r3
1000a14c:	e1a03101 	lsl	r3, r1, #2
1000a150:	e1a01003 	mov	r1, r3
1000a154:	e1a03101 	lsl	r3, r1, #2
1000a158:	e0613003 	rsb	r3, r1, r3
1000a15c:	e0823003 	add	r3, r2, r3
1000a160:	e5933004 	ldr	r3, [r3, #4]
1000a164:	e2833004 	add	r3, r3, #4
1000a168:	e5933000 	ldr	r3, [r3]
1000a16c:	e50b3008 	str	r3, [fp, #-8]
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
1000a170:	e3082404 	movw	r2, #33796	; 0x8404
1000a174:	e3412002 	movt	r2, #4098	; 0x1002
1000a178:	e51b3010 	ldr	r3, [fp, #-16]
1000a17c:	e1a01003 	mov	r1, r3
1000a180:	e1a03101 	lsl	r3, r1, #2
1000a184:	e1a01003 	mov	r1, r3
1000a188:	e1a03101 	lsl	r3, r1, #2
1000a18c:	e0613003 	rsb	r3, r1, r3
1000a190:	e0823003 	add	r3, r2, r3
1000a194:	e5933004 	ldr	r3, [r3, #4]
1000a198:	e2833efe 	add	r3, r3, #4064	; 0xfe0
1000a19c:	e2833008 	add	r3, r3, #8
1000a1a0:	e5933000 	ldr	r3, [r3]
1000a1a4:	e1a03223 	lsr	r3, r3, #4
void arm_gic_dump_type(rt_uint32_t index)
{
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
1000a1a8:	e203e00f 	and	lr, r3, #15
1000a1ac:	e3082404 	movw	r2, #33796	; 0x8404
1000a1b0:	e3412002 	movt	r2, #4098	; 0x1002
1000a1b4:	e51b3010 	ldr	r3, [fp, #-16]
1000a1b8:	e1a01003 	mov	r1, r3
1000a1bc:	e1a03101 	lsl	r3, r1, #2
1000a1c0:	e1a01003 	mov	r1, r3
1000a1c4:	e1a03101 	lsl	r3, r1, #2
1000a1c8:	e0613003 	rsb	r3, r1, r3
1000a1cc:	e0823003 	add	r3, r2, r3
1000a1d0:	e5932004 	ldr	r2, [r3, #4]
1000a1d4:	e3083410 	movw	r3, #33808	; 0x8410
1000a1d8:	e3413002 	movt	r3, #4098	; 0x1002
1000a1dc:	e593c000 	ldr	ip, [r3]
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1 << 10) ? "has" : "no",
1000a1e0:	e51b3008 	ldr	r3, [fp, #-8]
1000a1e4:	e2033b01 	and	r3, r3, #1024	; 0x400
void arm_gic_dump_type(rt_uint32_t index)
{
    unsigned int gic_type;

    gic_type = GIC_DIST_TYPE(_gic_table[index].dist_hw_base);
    rt_kprintf("GICv%d on %p, max IRQs: %d, %s security extension(%08x)\n",
1000a1e8:	e3530000 	cmp	r3, #0
1000a1ec:	0a000002 	beq	1000a1fc <arm_gic_dump_type+0xd0>
1000a1f0:	e30e3eec 	movw	r3, #61164	; 0xeeec
1000a1f4:	e3413001 	movt	r3, #4097	; 0x1001
1000a1f8:	ea000001 	b	1000a204 <arm_gic_dump_type+0xd8>
1000a1fc:	e30e3ef0 	movw	r3, #61168	; 0xeef0
1000a200:	e3413001 	movt	r3, #4097	; 0x1001
1000a204:	e58d3000 	str	r3, [sp]
1000a208:	e51b3008 	ldr	r3, [fp, #-8]
1000a20c:	e58d3004 	str	r3, [sp, #4]
1000a210:	e30e0ef4 	movw	r0, #61172	; 0xeef4
1000a214:	e3410001 	movt	r0, #4097	; 0x1001
1000a218:	e1a0100e 	mov	r1, lr
1000a21c:	e1a0300c 	mov	r3, ip
1000a220:	ebfff02b 	bl	100062d4 <rt_kprintf>
               (GIC_DIST_ICPIDR2(_gic_table[index].dist_hw_base) >> 4) & 0xf,
               _gic_table[index].dist_hw_base,
               _gic_max_irq,
               gic_type & (1 << 10) ? "has" : "no",
               gic_type);
}
1000a224:	e24bd004 	sub	sp, fp, #4
1000a228:	e8bd8800 	pop	{fp, pc}

1000a22c <arm_gic_dist_init>:

int arm_gic_dist_init(rt_uint32_t index, rt_uint32_t dist_base, int irq_start)
{
1000a22c:	e92d4800 	push	{fp, lr}
1000a230:	e28db004 	add	fp, sp, #4
1000a234:	e24dd020 	sub	sp, sp, #32
1000a238:	e50b0018 	str	r0, [fp, #-24]
1000a23c:	e50b101c 	str	r1, [fp, #-28]
1000a240:	e50b2020 	str	r2, [fp, #-32]
    unsigned int gic_type, i;
    rt_uint32_t cpumask = 1 << 0;
1000a244:	e3a03001 	mov	r3, #1
1000a248:	e50b300c 	str	r3, [fp, #-12]

    RT_ASSERT(index < ARM_GIC_MAX_NR);
1000a24c:	e51b3018 	ldr	r3, [fp, #-24]
1000a250:	e3530000 	cmp	r3, #0
1000a254:	0a000005 	beq	1000a270 <arm_gic_dist_init+0x44>
1000a258:	e30e0ec8 	movw	r0, #61128	; 0xeec8
1000a25c:	e3410001 	movt	r0, #4097	; 0x1001
1000a260:	e30e1fc8 	movw	r1, #61384	; 0xefc8
1000a264:	e3411001 	movt	r1, #4097	; 0x1001
1000a268:	e3a02091 	mov	r2, #145	; 0x91
1000a26c:	ebfff0d5 	bl	100065c8 <rt_assert_handler>

    _gic_table[index].dist_hw_base = dist_base;
1000a270:	e3082404 	movw	r2, #33796	; 0x8404
1000a274:	e3412002 	movt	r2, #4098	; 0x1002
1000a278:	e51b3018 	ldr	r3, [fp, #-24]
1000a27c:	e1a01003 	mov	r1, r3
1000a280:	e1a03101 	lsl	r3, r1, #2
1000a284:	e1a01003 	mov	r1, r3
1000a288:	e1a03101 	lsl	r3, r1, #2
1000a28c:	e0613003 	rsb	r3, r1, r3
1000a290:	e0823003 	add	r3, r2, r3
1000a294:	e51b201c 	ldr	r2, [fp, #-28]
1000a298:	e5832004 	str	r2, [r3, #4]
    _gic_table[index].offset = irq_start;
1000a29c:	e51b0020 	ldr	r0, [fp, #-32]
1000a2a0:	e3082404 	movw	r2, #33796	; 0x8404
1000a2a4:	e3412002 	movt	r2, #4098	; 0x1002
1000a2a8:	e51b3018 	ldr	r3, [fp, #-24]
1000a2ac:	e1a01003 	mov	r1, r3
1000a2b0:	e1a03101 	lsl	r3, r1, #2
1000a2b4:	e1a01003 	mov	r1, r3
1000a2b8:	e1a03101 	lsl	r3, r1, #2
1000a2bc:	e0613003 	rsb	r3, r1, r3
1000a2c0:	e0823003 	add	r3, r2, r3
1000a2c4:	e5830000 	str	r0, [r3]

    /* Find out how many interrupts are supported. */
    gic_type = GIC_DIST_TYPE(dist_base);
1000a2c8:	e51b301c 	ldr	r3, [fp, #-28]
1000a2cc:	e2833004 	add	r3, r3, #4
1000a2d0:	e5933000 	ldr	r3, [r3]
1000a2d4:	e50b3010 	str	r3, [fp, #-16]
    _gic_max_irq = ((gic_type & 0x1f) + 1) * 32;
1000a2d8:	e51b3010 	ldr	r3, [fp, #-16]
1000a2dc:	e203301f 	and	r3, r3, #31
1000a2e0:	e2833001 	add	r3, r3, #1
1000a2e4:	e1a02283 	lsl	r2, r3, #5
1000a2e8:	e3083410 	movw	r3, #33808	; 0x8410
1000a2ec:	e3413002 	movt	r3, #4098	; 0x1002
1000a2f0:	e5832000 	str	r2, [r3]
    /*
     * The GIC only supports up to 1020 interrupt sources.
     * Limit this to either the architected maximum, or the
     * platform maximum.
     */
    if (_gic_max_irq > 1020)
1000a2f4:	e3083410 	movw	r3, #33808	; 0x8410
1000a2f8:	e3413002 	movt	r3, #4098	; 0x1002
1000a2fc:	e5933000 	ldr	r3, [r3]
1000a300:	e3530fff 	cmp	r3, #1020	; 0x3fc
1000a304:	9a000003 	bls	1000a318 <arm_gic_dist_init+0xec>
        _gic_max_irq = 1020;
1000a308:	e3083410 	movw	r3, #33808	; 0x8410
1000a30c:	e3413002 	movt	r3, #4098	; 0x1002
1000a310:	e3a02fff 	mov	r2, #1020	; 0x3fc
1000a314:	e5832000 	str	r2, [r3]
    if (_gic_max_irq > ARM_GIC_NR_IRQS)
1000a318:	e3083410 	movw	r3, #33808	; 0x8410
1000a31c:	e3413002 	movt	r3, #4098	; 0x1002
1000a320:	e5933000 	ldr	r3, [r3]
1000a324:	e353005e 	cmp	r3, #94	; 0x5e
1000a328:	9a000003 	bls	1000a33c <arm_gic_dist_init+0x110>
        _gic_max_irq = ARM_GIC_NR_IRQS;
1000a32c:	e3083410 	movw	r3, #33808	; 0x8410
1000a330:	e3413002 	movt	r3, #4098	; 0x1002
1000a334:	e3a0205e 	mov	r2, #94	; 0x5e
1000a338:	e5832000 	str	r2, [r3]

    cpumask |= cpumask << 8;
1000a33c:	e51b300c 	ldr	r3, [fp, #-12]
1000a340:	e1a03403 	lsl	r3, r3, #8
1000a344:	e51b200c 	ldr	r2, [fp, #-12]
1000a348:	e1823003 	orr	r3, r2, r3
1000a34c:	e50b300c 	str	r3, [fp, #-12]
    cpumask |= cpumask << 16;
1000a350:	e51b300c 	ldr	r3, [fp, #-12]
1000a354:	e1a03803 	lsl	r3, r3, #16
1000a358:	e51b200c 	ldr	r2, [fp, #-12]
1000a35c:	e1823003 	orr	r3, r2, r3
1000a360:	e50b300c 	str	r3, [fp, #-12]

    GIC_DIST_CTRL(dist_base) = 0x0;
1000a364:	e51b301c 	ldr	r3, [fp, #-28]
1000a368:	e3a02000 	mov	r2, #0
1000a36c:	e5832000 	str	r2, [r3]

    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32; i < _gic_max_irq; i += 16)
1000a370:	e3a03020 	mov	r3, #32
1000a374:	e50b3008 	str	r3, [fp, #-8]
1000a378:	ea00000b 	b	1000a3ac <arm_gic_dist_init+0x180>
        GIC_DIST_CONFIG(dist_base, i) = 0x0;
1000a37c:	e51b3008 	ldr	r3, [fp, #-8]
1000a380:	e1a03223 	lsr	r3, r3, #4
1000a384:	e1a02103 	lsl	r2, r3, #2
1000a388:	e51b301c 	ldr	r3, [fp, #-28]
1000a38c:	e0823003 	add	r3, r2, r3
1000a390:	e2833b03 	add	r3, r3, #3072	; 0xc00
1000a394:	e1a02003 	mov	r2, r3
1000a398:	e3a03000 	mov	r3, #0
1000a39c:	e5823000 	str	r3, [r2]
    cpumask |= cpumask << 16;

    GIC_DIST_CTRL(dist_base) = 0x0;

    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32; i < _gic_max_irq; i += 16)
1000a3a0:	e51b3008 	ldr	r3, [fp, #-8]
1000a3a4:	e2833010 	add	r3, r3, #16
1000a3a8:	e50b3008 	str	r3, [fp, #-8]
1000a3ac:	e3083410 	movw	r3, #33808	; 0x8410
1000a3b0:	e3413002 	movt	r3, #4098	; 0x1002
1000a3b4:	e5933000 	ldr	r3, [r3]
1000a3b8:	e51b2008 	ldr	r2, [fp, #-8]
1000a3bc:	e1520003 	cmp	r2, r3
1000a3c0:	3affffed 	bcc	1000a37c <arm_gic_dist_init+0x150>
        GIC_DIST_CONFIG(dist_base, i) = 0x0;

    /* Set all global interrupts to this CPU only. */
    for (i = 32; i < _gic_max_irq; i += 4)
1000a3c4:	e3a03020 	mov	r3, #32
1000a3c8:	e50b3008 	str	r3, [fp, #-8]
1000a3cc:	ea00000b 	b	1000a400 <arm_gic_dist_init+0x1d4>
        GIC_DIST_TARGET(dist_base, i) = cpumask;
1000a3d0:	e51b3008 	ldr	r3, [fp, #-8]
1000a3d4:	e1a03123 	lsr	r3, r3, #2
1000a3d8:	e1a02103 	lsl	r2, r3, #2
1000a3dc:	e51b301c 	ldr	r3, [fp, #-28]
1000a3e0:	e0823003 	add	r3, r2, r3
1000a3e4:	e2833b02 	add	r3, r3, #2048	; 0x800
1000a3e8:	e1a02003 	mov	r2, r3
1000a3ec:	e51b300c 	ldr	r3, [fp, #-12]
1000a3f0:	e5823000 	str	r3, [r2]
    /* Set all global interrupts to be level triggered, active low. */
    for (i = 32; i < _gic_max_irq; i += 16)
        GIC_DIST_CONFIG(dist_base, i) = 0x0;

    /* Set all global interrupts to this CPU only. */
    for (i = 32; i < _gic_max_irq; i += 4)
1000a3f4:	e51b3008 	ldr	r3, [fp, #-8]
1000a3f8:	e2833004 	add	r3, r3, #4
1000a3fc:	e50b3008 	str	r3, [fp, #-8]
1000a400:	e3083410 	movw	r3, #33808	; 0x8410
1000a404:	e3413002 	movt	r3, #4098	; 0x1002
1000a408:	e5933000 	ldr	r3, [r3]
1000a40c:	e51b2008 	ldr	r2, [fp, #-8]
1000a410:	e1520003 	cmp	r2, r3
1000a414:	3affffed 	bcc	1000a3d0 <arm_gic_dist_init+0x1a4>
        GIC_DIST_TARGET(dist_base, i) = cpumask;

    /* Set priority on all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 4)
1000a418:	e3a03000 	mov	r3, #0
1000a41c:	e50b3008 	str	r3, [fp, #-8]
1000a420:	ea00000c 	b	1000a458 <arm_gic_dist_init+0x22c>
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0;
1000a424:	e51b3008 	ldr	r3, [fp, #-8]
1000a428:	e1a03123 	lsr	r3, r3, #2
1000a42c:	e1a02103 	lsl	r2, r3, #2
1000a430:	e51b301c 	ldr	r3, [fp, #-28]
1000a434:	e0823003 	add	r3, r2, r3
1000a438:	e2833b01 	add	r3, r3, #1024	; 0x400
1000a43c:	e1a02003 	mov	r2, r3
1000a440:	e30a30a0 	movw	r3, #41120	; 0xa0a0
1000a444:	e34a30a0 	movt	r3, #41120	; 0xa0a0
1000a448:	e5823000 	str	r3, [r2]
    /* Set all global interrupts to this CPU only. */
    for (i = 32; i < _gic_max_irq; i += 4)
        GIC_DIST_TARGET(dist_base, i) = cpumask;

    /* Set priority on all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 4)
1000a44c:	e51b3008 	ldr	r3, [fp, #-8]
1000a450:	e2833004 	add	r3, r3, #4
1000a454:	e50b3008 	str	r3, [fp, #-8]
1000a458:	e3083410 	movw	r3, #33808	; 0x8410
1000a45c:	e3413002 	movt	r3, #4098	; 0x1002
1000a460:	e5933000 	ldr	r3, [r3]
1000a464:	e51b2008 	ldr	r2, [fp, #-8]
1000a468:	e1520003 	cmp	r2, r3
1000a46c:	3affffec 	bcc	1000a424 <arm_gic_dist_init+0x1f8>
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0;

    /* Disable all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 32)
1000a470:	e3a03000 	mov	r3, #0
1000a474:	e50b3008 	str	r3, [fp, #-8]
1000a478:	ea00000b 	b	1000a4ac <arm_gic_dist_init+0x280>
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffff;
1000a47c:	e51b3008 	ldr	r3, [fp, #-8]
1000a480:	e1a032a3 	lsr	r3, r3, #5
1000a484:	e1a02103 	lsl	r2, r3, #2
1000a488:	e51b301c 	ldr	r3, [fp, #-28]
1000a48c:	e0823003 	add	r3, r2, r3
1000a490:	e2833d06 	add	r3, r3, #384	; 0x180
1000a494:	e1a02003 	mov	r2, r3
1000a498:	e3e03000 	mvn	r3, #0
1000a49c:	e5823000 	str	r3, [r2]
    /* Set priority on all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 4)
        GIC_DIST_PRI(dist_base, i) = 0xa0a0a0a0;

    /* Disable all interrupts. */
    for (i = 0; i < _gic_max_irq; i += 32)
1000a4a0:	e51b3008 	ldr	r3, [fp, #-8]
1000a4a4:	e2833020 	add	r3, r3, #32
1000a4a8:	e50b3008 	str	r3, [fp, #-8]
1000a4ac:	e3083410 	movw	r3, #33808	; 0x8410
1000a4b0:	e3413002 	movt	r3, #4098	; 0x1002
1000a4b4:	e5933000 	ldr	r3, [r3]
1000a4b8:	e51b2008 	ldr	r2, [fp, #-8]
1000a4bc:	e1520003 	cmp	r2, r3
1000a4c0:	3affffed 	bcc	1000a47c <arm_gic_dist_init+0x250>
        GIC_DIST_ENABLE_CLEAR(dist_base, i) = 0xffffffff;

    /* Set the FIQEn bit, signal FIQ for IGROUP0. */
    GIC_DIST_CTRL(dist_base) = 0x01;
1000a4c4:	e51b301c 	ldr	r3, [fp, #-28]
1000a4c8:	e3a02001 	mov	r2, #1
1000a4cc:	e5832000 	str	r2, [r3]

    return 0;
1000a4d0:	e3a03000 	mov	r3, #0
}
1000a4d4:	e1a00003 	mov	r0, r3
1000a4d8:	e24bd004 	sub	sp, fp, #4
1000a4dc:	e8bd8800 	pop	{fp, pc}

1000a4e0 <arm_gic_cpu_init>:

int arm_gic_cpu_init(rt_uint32_t index, rt_uint32_t cpu_base)
{
1000a4e0:	e92d4800 	push	{fp, lr}
1000a4e4:	e28db004 	add	fp, sp, #4
1000a4e8:	e24dd008 	sub	sp, sp, #8
1000a4ec:	e50b0008 	str	r0, [fp, #-8]
1000a4f0:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(index < ARM_GIC_MAX_NR);
1000a4f4:	e51b3008 	ldr	r3, [fp, #-8]
1000a4f8:	e3530000 	cmp	r3, #0
1000a4fc:	0a000005 	beq	1000a518 <arm_gic_cpu_init+0x38>
1000a500:	e30e0ec8 	movw	r0, #61128	; 0xeec8
1000a504:	e3410001 	movt	r0, #4097	; 0x1001
1000a508:	e30e1fdc 	movw	r1, #61404	; 0xefdc
1000a50c:	e3411001 	movt	r1, #4097	; 0x1001
1000a510:	e3a020c1 	mov	r2, #193	; 0xc1
1000a514:	ebfff02b 	bl	100065c8 <rt_assert_handler>

    _gic_table[index].cpu_hw_base = cpu_base;
1000a518:	e3082404 	movw	r2, #33796	; 0x8404
1000a51c:	e3412002 	movt	r2, #4098	; 0x1002
1000a520:	e51b3008 	ldr	r3, [fp, #-8]
1000a524:	e1a01003 	mov	r1, r3
1000a528:	e1a03101 	lsl	r3, r1, #2
1000a52c:	e1a01003 	mov	r1, r3
1000a530:	e1a03101 	lsl	r3, r1, #2
1000a534:	e0613003 	rsb	r3, r1, r3
1000a538:	e0823003 	add	r3, r2, r3
1000a53c:	e2833008 	add	r3, r3, #8
1000a540:	e51b200c 	ldr	r2, [fp, #-12]
1000a544:	e5832000 	str	r2, [r3]

    GIC_CPU_PRIMASK(cpu_base) = 0xf0;
1000a548:	e51b300c 	ldr	r3, [fp, #-12]
1000a54c:	e2833004 	add	r3, r3, #4
1000a550:	e1a02003 	mov	r2, r3
1000a554:	e3a030f0 	mov	r3, #240	; 0xf0
1000a558:	e5823000 	str	r3, [r2]
    /* Enable CPU interrupt */
    GIC_CPU_CTRL(cpu_base) = 0x01;
1000a55c:	e51b300c 	ldr	r3, [fp, #-12]
1000a560:	e3a02001 	mov	r2, #1
1000a564:	e5832000 	str	r2, [r3]

    return 0;
1000a568:	e3a03000 	mov	r3, #0
}
1000a56c:	e1a00003 	mov	r0, r3
1000a570:	e24bd004 	sub	sp, fp, #4
1000a574:	e8bd8800 	pop	{fp, pc}

1000a578 <arm_gic_set_group>:

void arm_gic_set_group(rt_uint32_t index, int vector, int group)
{
1000a578:	e92d4800 	push	{fp, lr}
1000a57c:	e28db004 	add	fp, sp, #4
1000a580:	e24dd010 	sub	sp, sp, #16
1000a584:	e50b0008 	str	r0, [fp, #-8]
1000a588:	e50b100c 	str	r1, [fp, #-12]
1000a58c:	e50b2010 	str	r2, [fp, #-16]
    /* As for GICv2, there are only group0 and group1. */
    RT_ASSERT(group <= 1);
1000a590:	e51b3010 	ldr	r3, [fp, #-16]
1000a594:	e3530001 	cmp	r3, #1
1000a598:	da000005 	ble	1000a5b4 <arm_gic_set_group+0x3c>
1000a59c:	e30e0f30 	movw	r0, #61232	; 0xef30
1000a5a0:	e3410001 	movt	r0, #4097	; 0x1001
1000a5a4:	e30e1ff0 	movw	r1, #61424	; 0xeff0
1000a5a8:	e3411001 	movt	r1, #4097	; 0x1001
1000a5ac:	e3a020cf 	mov	r2, #207	; 0xcf
1000a5b0:	ebfff004 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(vector < _gic_max_irq);
1000a5b4:	e51b200c 	ldr	r2, [fp, #-12]
1000a5b8:	e3083410 	movw	r3, #33808	; 0x8410
1000a5bc:	e3413002 	movt	r3, #4098	; 0x1002
1000a5c0:	e5933000 	ldr	r3, [r3]
1000a5c4:	e1520003 	cmp	r2, r3
1000a5c8:	3a000005 	bcc	1000a5e4 <arm_gic_set_group+0x6c>
1000a5cc:	e30e0f3c 	movw	r0, #61244	; 0xef3c
1000a5d0:	e3410001 	movt	r0, #4097	; 0x1001
1000a5d4:	e30e1ff0 	movw	r1, #61424	; 0xeff0
1000a5d8:	e3411001 	movt	r1, #4097	; 0x1001
1000a5dc:	e3a020d0 	mov	r2, #208	; 0xd0
1000a5e0:	ebffeff8 	bl	100065c8 <rt_assert_handler>

    if (group == 0)
1000a5e4:	e51b3010 	ldr	r3, [fp, #-16]
1000a5e8:	e3530000 	cmp	r3, #0
1000a5ec:	1a00002f 	bne	1000a6b0 <arm_gic_set_group+0x138>
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
1000a5f0:	e3082404 	movw	r2, #33796	; 0x8404
1000a5f4:	e3412002 	movt	r2, #4098	; 0x1002
1000a5f8:	e51b3008 	ldr	r3, [fp, #-8]
1000a5fc:	e1a01003 	mov	r1, r3
1000a600:	e1a03101 	lsl	r3, r1, #2
1000a604:	e1a01003 	mov	r1, r3
1000a608:	e1a03101 	lsl	r3, r1, #2
1000a60c:	e0613003 	rsb	r3, r1, r3
1000a610:	e0823003 	add	r3, r2, r3
1000a614:	e5932004 	ldr	r2, [r3, #4]
1000a618:	e51b300c 	ldr	r3, [fp, #-12]
1000a61c:	e283101f 	add	r1, r3, #31
1000a620:	e3530000 	cmp	r3, #0
1000a624:	b1a03001 	movlt	r3, r1
1000a628:	a1a03003 	movge	r3, r3
1000a62c:	e1a032c3 	asr	r3, r3, #5
1000a630:	e1a00003 	mov	r0, r3
                        vector) &= ~(1 << (vector % 32));
1000a634:	e1a03100 	lsl	r3, r0, #2
1000a638:	e0823003 	add	r3, r2, r3
1000a63c:	e2833080 	add	r3, r3, #128	; 0x80
1000a640:	e1a0c003 	mov	ip, r3
    RT_ASSERT(group <= 1);
    RT_ASSERT(vector < _gic_max_irq);

    if (group == 0)
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
1000a644:	e3082404 	movw	r2, #33796	; 0x8404
1000a648:	e3412002 	movt	r2, #4098	; 0x1002
1000a64c:	e51b3008 	ldr	r3, [fp, #-8]
1000a650:	e1a01003 	mov	r1, r3
1000a654:	e1a03101 	lsl	r3, r1, #2
1000a658:	e1a01003 	mov	r1, r3
1000a65c:	e1a03101 	lsl	r3, r1, #2
1000a660:	e0613003 	rsb	r3, r1, r3
1000a664:	e0823003 	add	r3, r2, r3
1000a668:	e5933004 	ldr	r3, [r3, #4]
                        vector) &= ~(1 << (vector % 32));
1000a66c:	e1a02100 	lsl	r2, r0, #2
1000a670:	e0833002 	add	r3, r3, r2
1000a674:	e2833080 	add	r3, r3, #128	; 0x80
1000a678:	e5931000 	ldr	r1, [r3]
1000a67c:	e51b200c 	ldr	r2, [fp, #-12]
1000a680:	e1a03fc2 	asr	r3, r2, #31
1000a684:	e1a03da3 	lsr	r3, r3, #27
1000a688:	e0822003 	add	r2, r2, r3
1000a68c:	e202201f 	and	r2, r2, #31
1000a690:	e0633002 	rsb	r3, r3, r2
1000a694:	e1a02003 	mov	r2, r3
1000a698:	e3a03001 	mov	r3, #1
1000a69c:	e1a03213 	lsl	r3, r3, r2
1000a6a0:	e1e03003 	mvn	r3, r3
1000a6a4:	e0033001 	and	r3, r3, r1
1000a6a8:	e58c3000 	str	r3, [ip]
1000a6ac:	ea000030 	b	1000a774 <arm_gic_set_group+0x1fc>
    }
    else if (group == 1)
1000a6b0:	e51b3010 	ldr	r3, [fp, #-16]
1000a6b4:	e3530001 	cmp	r3, #1
1000a6b8:	1a00002d 	bne	1000a774 <arm_gic_set_group+0x1fc>
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
1000a6bc:	e3082404 	movw	r2, #33796	; 0x8404
1000a6c0:	e3412002 	movt	r2, #4098	; 0x1002
1000a6c4:	e51b3008 	ldr	r3, [fp, #-8]
1000a6c8:	e1a01003 	mov	r1, r3
1000a6cc:	e1a03101 	lsl	r3, r1, #2
1000a6d0:	e1a01003 	mov	r1, r3
1000a6d4:	e1a03101 	lsl	r3, r1, #2
1000a6d8:	e0613003 	rsb	r3, r1, r3
1000a6dc:	e0823003 	add	r3, r2, r3
1000a6e0:	e5932004 	ldr	r2, [r3, #4]
1000a6e4:	e51b300c 	ldr	r3, [fp, #-12]
1000a6e8:	e283101f 	add	r1, r3, #31
1000a6ec:	e3530000 	cmp	r3, #0
1000a6f0:	b1a03001 	movlt	r3, r1
1000a6f4:	a1a03003 	movge	r3, r3
1000a6f8:	e1a032c3 	asr	r3, r3, #5
1000a6fc:	e1a00003 	mov	r0, r3
                        vector) |=  (1 << (vector % 32));
1000a700:	e1a03100 	lsl	r3, r0, #2
1000a704:	e0823003 	add	r3, r2, r3
1000a708:	e2833080 	add	r3, r3, #128	; 0x80
1000a70c:	e1a0c003 	mov	ip, r3
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
                        vector) &= ~(1 << (vector % 32));
    }
    else if (group == 1)
    {
        GIC_DIST_IGROUP(_gic_table[index].dist_hw_base,
1000a710:	e3082404 	movw	r2, #33796	; 0x8404
1000a714:	e3412002 	movt	r2, #4098	; 0x1002
1000a718:	e51b3008 	ldr	r3, [fp, #-8]
1000a71c:	e1a01003 	mov	r1, r3
1000a720:	e1a03101 	lsl	r3, r1, #2
1000a724:	e1a01003 	mov	r1, r3
1000a728:	e1a03101 	lsl	r3, r1, #2
1000a72c:	e0613003 	rsb	r3, r1, r3
1000a730:	e0823003 	add	r3, r2, r3
1000a734:	e5933004 	ldr	r3, [r3, #4]
                        vector) |=  (1 << (vector % 32));
1000a738:	e1a02100 	lsl	r2, r0, #2
1000a73c:	e0833002 	add	r3, r3, r2
1000a740:	e2833080 	add	r3, r3, #128	; 0x80
1000a744:	e5931000 	ldr	r1, [r3]
1000a748:	e51b200c 	ldr	r2, [fp, #-12]
1000a74c:	e1a03fc2 	asr	r3, r2, #31
1000a750:	e1a03da3 	lsr	r3, r3, #27
1000a754:	e0822003 	add	r2, r2, r3
1000a758:	e202201f 	and	r2, r2, #31
1000a75c:	e0633002 	rsb	r3, r3, r2
1000a760:	e1a02003 	mov	r2, r3
1000a764:	e3a03001 	mov	r3, #1
1000a768:	e1a03213 	lsl	r3, r3, r2
1000a76c:	e1813003 	orr	r3, r1, r3
1000a770:	e58c3000 	str	r3, [ip]
    }
}
1000a774:	e24bd004 	sub	sp, fp, #4
1000a778:	e8bd8800 	pop	{fp, pc}

1000a77c <arm_gic_trigger>:

void arm_gic_trigger(rt_uint32_t index, int target_cpu, int irq)
{
1000a77c:	e92d4800 	push	{fp, lr}
1000a780:	e28db004 	add	fp, sp, #4
1000a784:	e24dd018 	sub	sp, sp, #24
1000a788:	e50b0010 	str	r0, [fp, #-16]
1000a78c:	e50b1014 	str	r1, [fp, #-20]
1000a790:	e50b2018 	str	r2, [fp, #-24]
    unsigned int reg;

    RT_ASSERT(irq <= 15);
1000a794:	e51b3018 	ldr	r3, [fp, #-24]
1000a798:	e353000f 	cmp	r3, #15
1000a79c:	da000005 	ble	1000a7b8 <arm_gic_trigger+0x3c>
1000a7a0:	e30e0f54 	movw	r0, #61268	; 0xef54
1000a7a4:	e3410001 	movt	r0, #4097	; 0x1001
1000a7a8:	e30f1004 	movw	r1, #61444	; 0xf004
1000a7ac:	e3411001 	movt	r1, #4097	; 0x1001
1000a7b0:	e3a020e2 	mov	r2, #226	; 0xe2
1000a7b4:	ebffef83 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(target_cpu <= 255);
1000a7b8:	e51b3014 	ldr	r3, [fp, #-20]
1000a7bc:	e35300ff 	cmp	r3, #255	; 0xff
1000a7c0:	da000005 	ble	1000a7dc <arm_gic_trigger+0x60>
1000a7c4:	e30e0f60 	movw	r0, #61280	; 0xef60
1000a7c8:	e3410001 	movt	r0, #4097	; 0x1001
1000a7cc:	e30f1004 	movw	r1, #61444	; 0xf004
1000a7d0:	e3411001 	movt	r1, #4097	; 0x1001
1000a7d4:	e3a020e3 	mov	r2, #227	; 0xe3
1000a7d8:	ebffef7a 	bl	100065c8 <rt_assert_handler>

    reg = (target_cpu << 16) | irq;
1000a7dc:	e51b3014 	ldr	r3, [fp, #-20]
1000a7e0:	e1a02803 	lsl	r2, r3, #16
1000a7e4:	e51b3018 	ldr	r3, [fp, #-24]
1000a7e8:	e1823003 	orr	r3, r2, r3
1000a7ec:	e50b3008 	str	r3, [fp, #-8]
    GIC_DIST_SOFTINT(_gic_table[index].dist_hw_base) = reg;
1000a7f0:	e3082404 	movw	r2, #33796	; 0x8404
1000a7f4:	e3412002 	movt	r2, #4098	; 0x1002
1000a7f8:	e51b3010 	ldr	r3, [fp, #-16]
1000a7fc:	e1a01003 	mov	r1, r3
1000a800:	e1a03101 	lsl	r3, r1, #2
1000a804:	e1a01003 	mov	r1, r3
1000a808:	e1a03101 	lsl	r3, r1, #2
1000a80c:	e0613003 	rsb	r3, r1, r3
1000a810:	e0823003 	add	r3, r2, r3
1000a814:	e5933004 	ldr	r3, [r3, #4]
1000a818:	e2833c0f 	add	r3, r3, #3840	; 0xf00
1000a81c:	e1a02003 	mov	r2, r3
1000a820:	e51b3008 	ldr	r3, [fp, #-8]
1000a824:	e5823000 	str	r3, [r2]
}
1000a828:	e24bd004 	sub	sp, fp, #4
1000a82c:	e8bd8800 	pop	{fp, pc}

1000a830 <arm_gic_clear_sgi>:

void arm_gic_clear_sgi(rt_uint32_t index, int target_cpu, int irq)
{
1000a830:	e92d4800 	push	{fp, lr}
1000a834:	e28db004 	add	fp, sp, #4
1000a838:	e24dd010 	sub	sp, sp, #16
1000a83c:	e50b0008 	str	r0, [fp, #-8]
1000a840:	e50b100c 	str	r1, [fp, #-12]
1000a844:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(irq <= 15);
1000a848:	e51b3010 	ldr	r3, [fp, #-16]
1000a84c:	e353000f 	cmp	r3, #15
1000a850:	da000005 	ble	1000a86c <arm_gic_clear_sgi+0x3c>
1000a854:	e30e0f54 	movw	r0, #61268	; 0xef54
1000a858:	e3410001 	movt	r0, #4097	; 0x1001
1000a85c:	e30f1014 	movw	r1, #61460	; 0xf014
1000a860:	e3411001 	movt	r1, #4097	; 0x1001
1000a864:	e3a020eb 	mov	r2, #235	; 0xeb
1000a868:	ebffef56 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(target_cpu <= 255);
1000a86c:	e51b300c 	ldr	r3, [fp, #-12]
1000a870:	e35300ff 	cmp	r3, #255	; 0xff
1000a874:	da000005 	ble	1000a890 <arm_gic_clear_sgi+0x60>
1000a878:	e30e0f60 	movw	r0, #61280	; 0xef60
1000a87c:	e3410001 	movt	r0, #4097	; 0x1001
1000a880:	e30f1014 	movw	r1, #61460	; 0xf014
1000a884:	e3411001 	movt	r1, #4097	; 0x1001
1000a888:	e3a020ec 	mov	r2, #236	; 0xec
1000a88c:	ebffef4d 	bl	100065c8 <rt_assert_handler>

    GIC_DIST_CPENDSGI(_gic_table[index].dist_hw_base, irq) = target_cpu << (irq % 4);
1000a890:	e3082404 	movw	r2, #33796	; 0x8404
1000a894:	e3412002 	movt	r2, #4098	; 0x1002
1000a898:	e51b3008 	ldr	r3, [fp, #-8]
1000a89c:	e1a01003 	mov	r1, r3
1000a8a0:	e1a03101 	lsl	r3, r1, #2
1000a8a4:	e1a01003 	mov	r1, r3
1000a8a8:	e1a03101 	lsl	r3, r1, #2
1000a8ac:	e0613003 	rsb	r3, r1, r3
1000a8b0:	e0823003 	add	r3, r2, r3
1000a8b4:	e5932004 	ldr	r2, [r3, #4]
1000a8b8:	e51b3010 	ldr	r3, [fp, #-16]
1000a8bc:	e2831003 	add	r1, r3, #3
1000a8c0:	e3530000 	cmp	r3, #0
1000a8c4:	b1a03001 	movlt	r3, r1
1000a8c8:	a1a03003 	movge	r3, r3
1000a8cc:	e1a03143 	asr	r3, r3, #2
1000a8d0:	e1a03103 	lsl	r3, r3, #2
1000a8d4:	e0823003 	add	r3, r2, r3
1000a8d8:	e2833ef1 	add	r3, r3, #3856	; 0xf10
1000a8dc:	e1a01003 	mov	r1, r3
1000a8e0:	e51b2010 	ldr	r2, [fp, #-16]
1000a8e4:	e1a03fc2 	asr	r3, r2, #31
1000a8e8:	e1a03f23 	lsr	r3, r3, #30
1000a8ec:	e0822003 	add	r2, r2, r3
1000a8f0:	e2022003 	and	r2, r2, #3
1000a8f4:	e0633002 	rsb	r3, r3, r2
1000a8f8:	e1a02003 	mov	r2, r3
1000a8fc:	e51b300c 	ldr	r3, [fp, #-12]
1000a900:	e1a03213 	lsl	r3, r3, r2
1000a904:	e5813000 	str	r3, [r1]
}
1000a908:	e24bd004 	sub	sp, fp, #4
1000a90c:	e8bd8800 	pop	{fp, pc}

1000a910 <rt_hw_interrupt_handle>:
struct rt_irq_desc isr_table[MAX_HANDLERS];
rt_uint32_t rt_interrupt_from_thread, rt_interrupt_to_thread;
rt_uint32_t rt_thread_switch_interrupt_flag;

static void rt_hw_interrupt_handle(int vector, void *param)
{
1000a910:	e92d4800 	push	{fp, lr}
1000a914:	e28db004 	add	fp, sp, #4
1000a918:	e24dd008 	sub	sp, sp, #8
1000a91c:	e50b0008 	str	r0, [fp, #-8]
1000a920:	e50b100c 	str	r1, [fp, #-12]
    rt_kprintf("Unhandled interrupt %d occured!!!\n", vector);
1000a924:	e30f0028 	movw	r0, #61480	; 0xf028
1000a928:	e3410001 	movt	r0, #4097	; 0x1001
1000a92c:	e51b1008 	ldr	r1, [fp, #-8]
1000a930:	ebffee67 	bl	100062d4 <rt_kprintf>
}
1000a934:	e24bd004 	sub	sp, fp, #4
1000a938:	e8bd8800 	pop	{fp, pc}

1000a93c <rt_hw_vector_init>:

const unsigned int VECTOR_BASE = 0x00;
extern int system_vectors;

static void rt_hw_vector_init(void)
{
1000a93c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000a940:	e28db000 	add	fp, sp, #0
1000a944:	e24dd00c 	sub	sp, sp, #12
    int sctrl;
    unsigned int *src = (unsigned int *)&system_vectors;
1000a948:	e3003000 	movw	r3, #0
1000a94c:	e3413000 	movt	r3, #4096	; 0x1000
1000a950:	e50b3008 	str	r3, [fp, #-8]

    /* C12-C0 is only active when SCTLR.V = 0 */
    asm volatile ("mrc p15, #0, %0, c1, c0, #0"
1000a954:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
1000a958:	e50b300c 	str	r3, [fp, #-12]
                  :"=r" (sctrl));
    sctrl &= ~(1 << 13);
1000a95c:	e51b300c 	ldr	r3, [fp, #-12]
1000a960:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
1000a964:	e50b300c 	str	r3, [fp, #-12]
    asm volatile ("mcr p15, #0, %0, c1, c0, #0"
1000a968:	e51b300c 	ldr	r3, [fp, #-12]
1000a96c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
                  :
                  :"r" (sctrl));

    asm volatile ("mcr p15, #0, %0, c12, c0, #0"
1000a970:	e51b3008 	ldr	r3, [fp, #-8]
1000a974:	ee0c3f10 	mcr	15, 0, r3, cr12, cr0, {0}
                  :
                  :"r" (src));
}
1000a978:	e24bd000 	sub	sp, fp, #0
1000a97c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000a980:	e12fff1e 	bx	lr

1000a984 <rt_hw_interrupt_init>:

/**
 * This function will initialize hardware interrupt
 */
void rt_hw_interrupt_init(void)
{
1000a984:	e92d4818 	push	{r3, r4, fp, lr}
1000a988:	e28db00c 	add	fp, sp, #12
    register rt_uint32_t idx;

    /* set vector table */
    rt_hw_vector_init();
1000a98c:	ebffffea 	bl	1000a93c <rt_hw_vector_init>

    /* init exceptions table */
    rt_memset(isr_table, 0x00, sizeof(isr_table));
1000a990:	e3090eb4 	movw	r0, #40628	; 0x9eb4
1000a994:	e3410002 	movt	r0, #4098	; 0x1002
1000a998:	e3a01000 	mov	r1, #0
1000a99c:	e3002758 	movw	r2, #1880	; 0x758
1000a9a0:	ebffe85c 	bl	10004b18 <rt_memset>
    for (idx = 0; idx < MAX_HANDLERS; idx++)
1000a9a4:	e3a04000 	mov	r4, #0
1000a9a8:	ea00000a 	b	1000a9d8 <rt_hw_interrupt_init+0x54>
    {
        isr_table[idx].handler = rt_hw_interrupt_handle;
1000a9ac:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000a9b0:	e3412002 	movt	r2, #4098	; 0x1002
1000a9b4:	e1a03004 	mov	r3, r4
1000a9b8:	e1a03103 	lsl	r3, r3, #2
1000a9bc:	e1a01103 	lsl	r1, r3, #2
1000a9c0:	e0833001 	add	r3, r3, r1
1000a9c4:	e0822003 	add	r2, r2, r3
1000a9c8:	e30a3910 	movw	r3, #43280	; 0xa910
1000a9cc:	e3413000 	movt	r3, #4096	; 0x1000
1000a9d0:	e5823000 	str	r3, [r2]
    /* set vector table */
    rt_hw_vector_init();

    /* init exceptions table */
    rt_memset(isr_table, 0x00, sizeof(isr_table));
    for (idx = 0; idx < MAX_HANDLERS; idx++)
1000a9d4:	e2844001 	add	r4, r4, #1
1000a9d8:	e354005d 	cmp	r4, #93	; 0x5d
1000a9dc:	9afffff2 	bls	1000a9ac <rt_hw_interrupt_init+0x28>
    {
        isr_table[idx].handler = rt_hw_interrupt_handle;
    }

    /* initialize ARM GIC */
    arm_gic_dist_init(0, Zynq7000_GIC_DIST_BASE, 0);
1000a9e0:	e3a00000 	mov	r0, #0
1000a9e4:	e3a01a01 	mov	r1, #4096	; 0x1000
1000a9e8:	e34f18f0 	movt	r1, #63728	; 0xf8f0
1000a9ec:	e3a02000 	mov	r2, #0
1000a9f0:	ebfffe0d 	bl	1000a22c <arm_gic_dist_init>
    arm_gic_cpu_init(0, Zynq7000_GIC_CPU_BASE);
1000a9f4:	e3a00000 	mov	r0, #0
1000a9f8:	e3a01c01 	mov	r1, #256	; 0x100
1000a9fc:	e34f18f0 	movt	r1, #63728	; 0xf8f0
1000aa00:	ebfffeb6 	bl	1000a4e0 <arm_gic_cpu_init>

    /* init interrupt nest, and context in thread sp */
    rt_interrupt_nest = 0;
1000aa04:	e3093d80 	movw	r3, #40320	; 0x9d80
1000aa08:	e3413002 	movt	r3, #4098	; 0x1002
1000aa0c:	e3a02000 	mov	r2, #0
1000aa10:	e5c32000 	strb	r2, [r3]
    rt_interrupt_from_thread = 0;
1000aa14:	e3093eac 	movw	r3, #40620	; 0x9eac
1000aa18:	e3413002 	movt	r3, #4098	; 0x1002
1000aa1c:	e3a02000 	mov	r2, #0
1000aa20:	e5832000 	str	r2, [r3]
    rt_interrupt_to_thread = 0;
1000aa24:	e3093ea8 	movw	r3, #40616	; 0x9ea8
1000aa28:	e3413002 	movt	r3, #4098	; 0x1002
1000aa2c:	e3a02000 	mov	r2, #0
1000aa30:	e5832000 	str	r2, [r3]
    rt_thread_switch_interrupt_flag = 0;
1000aa34:	e3093eb0 	movw	r3, #40624	; 0x9eb0
1000aa38:	e3413002 	movt	r3, #4098	; 0x1002
1000aa3c:	e3a02000 	mov	r2, #0
1000aa40:	e5832000 	str	r2, [r3]
}
1000aa44:	e8bd8818 	pop	{r3, r4, fp, pc}

1000aa48 <rt_hw_interrupt_mask>:
/**
 * This function will mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_mask(int vector)
{
1000aa48:	e92d4800 	push	{fp, lr}
1000aa4c:	e28db004 	add	fp, sp, #4
1000aa50:	e24dd008 	sub	sp, sp, #8
1000aa54:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_mask(0, vector);
1000aa58:	e3a00000 	mov	r0, #0
1000aa5c:	e51b1008 	ldr	r1, [fp, #-8]
1000aa60:	ebfffcba 	bl	10009d50 <arm_gic_mask>
}
1000aa64:	e24bd004 	sub	sp, fp, #4
1000aa68:	e8bd8800 	pop	{fp, pc}

1000aa6c <rt_hw_interrupt_umask>:
/**
 * This function will un-mask a interrupt.
 * @param vector the interrupt number
 */
void rt_hw_interrupt_umask(int vector)
{
1000aa6c:	e92d4800 	push	{fp, lr}
1000aa70:	e28db004 	add	fp, sp, #4
1000aa74:	e24dd008 	sub	sp, sp, #8
1000aa78:	e50b0008 	str	r0, [fp, #-8]
    arm_gic_umask(0, vector);
1000aa7c:	e3a00000 	mov	r0, #0
1000aa80:	e51b1008 	ldr	r1, [fp, #-8]
1000aa84:	ebfffd62 	bl	1000a014 <arm_gic_umask>
}
1000aa88:	e24bd004 	sub	sp, fp, #4
1000aa8c:	e8bd8800 	pop	{fp, pc}

1000aa90 <rt_hw_interrupt_install>:
 * @param new_handler the interrupt service routine to be installed
 * @param old_handler the old interrupt service routine
 */
rt_isr_handler_t rt_hw_interrupt_install(int vector, rt_isr_handler_t handler,
        void *param, char *name)
{
1000aa90:	e92d4800 	push	{fp, lr}
1000aa94:	e28db004 	add	fp, sp, #4
1000aa98:	e24dd018 	sub	sp, sp, #24
1000aa9c:	e50b0010 	str	r0, [fp, #-16]
1000aaa0:	e50b1014 	str	r1, [fp, #-20]
1000aaa4:	e50b2018 	str	r2, [fp, #-24]
1000aaa8:	e50b301c 	str	r3, [fp, #-28]
    rt_isr_handler_t old_handler = RT_NULL;
1000aaac:	e3a03000 	mov	r3, #0
1000aab0:	e50b3008 	str	r3, [fp, #-8]

    if (vector < MAX_HANDLERS)
1000aab4:	e51b3010 	ldr	r3, [fp, #-16]
1000aab8:	e353005d 	cmp	r3, #93	; 0x5d
1000aabc:	ca000032 	bgt	1000ab8c <rt_hw_interrupt_install+0xfc>
    {
        old_handler = isr_table[vector].handler;
1000aac0:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000aac4:	e3412002 	movt	r2, #4098	; 0x1002
1000aac8:	e51b3010 	ldr	r3, [fp, #-16]
1000aacc:	e1a03103 	lsl	r3, r3, #2
1000aad0:	e1a01103 	lsl	r1, r3, #2
1000aad4:	e0833001 	add	r3, r3, r1
1000aad8:	e0823003 	add	r3, r2, r3
1000aadc:	e5933000 	ldr	r3, [r3]
1000aae0:	e50b3008 	str	r3, [fp, #-8]

        if (handler != RT_NULL)
1000aae4:	e51b3014 	ldr	r3, [fp, #-20]
1000aae8:	e3530000 	cmp	r3, #0
1000aaec:	0a00001d 	beq	1000ab68 <rt_hw_interrupt_install+0xd8>
        {
#ifdef RT_USING_INTERRUPT_INFO
            rt_strncpy(isr_table[vector].name, name, RT_NAME_MAX);
1000aaf0:	e51b3010 	ldr	r3, [fp, #-16]
1000aaf4:	e1a03103 	lsl	r3, r3, #2
1000aaf8:	e1a02103 	lsl	r2, r3, #2
1000aafc:	e0833002 	add	r3, r3, r2
1000ab00:	e2832008 	add	r2, r3, #8
1000ab04:	e3093eb4 	movw	r3, #40628	; 0x9eb4
1000ab08:	e3413002 	movt	r3, #4098	; 0x1002
1000ab0c:	e0823003 	add	r3, r2, r3
1000ab10:	e1a00003 	mov	r0, r3
1000ab14:	e51b101c 	ldr	r1, [fp, #-28]
1000ab18:	e3a02006 	mov	r2, #6
1000ab1c:	ebffe97e 	bl	1000511c <rt_strncpy>
#endif /* RT_USING_INTERRUPT_INFO */
            isr_table[vector].handler = handler;
1000ab20:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000ab24:	e3412002 	movt	r2, #4098	; 0x1002
1000ab28:	e51b3010 	ldr	r3, [fp, #-16]
1000ab2c:	e1a03103 	lsl	r3, r3, #2
1000ab30:	e1a01103 	lsl	r1, r3, #2
1000ab34:	e0833001 	add	r3, r3, r1
1000ab38:	e0823003 	add	r3, r2, r3
1000ab3c:	e51b2014 	ldr	r2, [fp, #-20]
1000ab40:	e5832000 	str	r2, [r3]
            isr_table[vector].param = param;
1000ab44:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000ab48:	e3412002 	movt	r2, #4098	; 0x1002
1000ab4c:	e51b3010 	ldr	r3, [fp, #-16]
1000ab50:	e1a03103 	lsl	r3, r3, #2
1000ab54:	e1a01103 	lsl	r1, r3, #2
1000ab58:	e0833001 	add	r3, r3, r1
1000ab5c:	e0823003 	add	r3, r2, r3
1000ab60:	e51b2018 	ldr	r2, [fp, #-24]
1000ab64:	e5832004 	str	r2, [r3, #4]
        }
        /* set the interrupt to this cpu */
        arm_gic_set_cpu(0, vector, 1 << rt_cpu_get_smp_id());
1000ab68:	eb000279 	bl	1000b554 <rt_cpu_get_smp_id>
1000ab6c:	e1a03000 	mov	r3, r0
1000ab70:	e1a02003 	mov	r2, r3
1000ab74:	e3a03001 	mov	r3, #1
1000ab78:	e1a03213 	lsl	r3, r3, r2
1000ab7c:	e3a00000 	mov	r0, #0
1000ab80:	e51b1010 	ldr	r1, [fp, #-16]
1000ab84:	e1a02003 	mov	r2, r3
1000ab88:	ebfffcb6 	bl	10009e68 <arm_gic_set_cpu>
    }

    return old_handler;
1000ab8c:	e51b3008 	ldr	r3, [fp, #-8]
}
1000ab90:	e1a00003 	mov	r0, r3
1000ab94:	e24bd004 	sub	sp, fp, #4
1000ab98:	e8bd8800 	pop	{fp, pc}

1000ab9c <rt_hw_interrupt_clear>:

void rt_hw_interrupt_clear(int vector)
{
1000ab9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000aba0:	e28db000 	add	fp, sp, #0
1000aba4:	e24dd00c 	sub	sp, sp, #12
1000aba8:	e50b0008 	str	r0, [fp, #-8]
    /* SGI will be cleared automatically. */
    if (vector < 16)
1000abac:	e51b3008 	ldr	r3, [fp, #-8]
1000abb0:	e353000f 	cmp	r3, #15
1000abb4:	ca000000 	bgt	1000abbc <rt_hw_interrupt_clear+0x20>
        return;
1000abb8:	e1a00000 	nop			; (mov r0, r0)
}
1000abbc:	e24bd000 	sub	sp, fp, #0
1000abc0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000abc4:	e12fff1e 	bx	lr

1000abc8 <rt_hw_cpu_dump_page_table>:
#define RW_NCNBXN      (AP_RW|DOMAIN0|NCNB|DESC_SEC|XN)
/* Read/Write without cache and write buffer */
#define RW_FAULT       (AP_RW|DOMAIN1|NCNB|DESC_SEC)

void rt_hw_cpu_dump_page_table(rt_uint32_t *ptb)
{
1000abc8:	e92d4800 	push	{fp, lr}
1000abcc:	e28db004 	add	fp, sp, #4
1000abd0:	e24dd020 	sub	sp, sp, #32
1000abd4:	e50b0018 	str	r0, [fp, #-24]
    int i;
    int fcnt = 0;
1000abd8:	e3a03000 	mov	r3, #0
1000abdc:	e50b300c 	str	r3, [fp, #-12]

    rt_kprintf("page table@%p\n", ptb);
1000abe0:	e30f0050 	movw	r0, #61520	; 0xf050
1000abe4:	e3410001 	movt	r0, #4097	; 0x1001
1000abe8:	e51b1018 	ldr	r1, [fp, #-24]
1000abec:	ebffedb8 	bl	100062d4 <rt_kprintf>
    for (i = 0; i < 1024*4; i++)
1000abf0:	e3a03000 	mov	r3, #0
1000abf4:	e50b3008 	str	r3, [fp, #-8]
1000abf8:	ea00007d 	b	1000adf4 <rt_hw_cpu_dump_page_table+0x22c>
    {
        rt_uint32_t pte1 = ptb[i];
1000abfc:	e51b3008 	ldr	r3, [fp, #-8]
1000ac00:	e1a03103 	lsl	r3, r3, #2
1000ac04:	e51b2018 	ldr	r2, [fp, #-24]
1000ac08:	e0823003 	add	r3, r2, r3
1000ac0c:	e5933000 	ldr	r3, [r3]
1000ac10:	e50b3010 	str	r3, [fp, #-16]
        if ((pte1 & 0x3) == 0)
1000ac14:	e51b3010 	ldr	r3, [fp, #-16]
1000ac18:	e2033003 	and	r3, r3, #3
1000ac1c:	e3530000 	cmp	r3, #0
1000ac20:	1a000010 	bne	1000ac68 <rt_hw_cpu_dump_page_table+0xa0>
        {
            rt_kprintf("%03x: ", i);
1000ac24:	e30f0060 	movw	r0, #61536	; 0xf060
1000ac28:	e3410001 	movt	r0, #4097	; 0x1001
1000ac2c:	e51b1008 	ldr	r1, [fp, #-8]
1000ac30:	ebffeda7 	bl	100062d4 <rt_kprintf>
            fcnt++;
1000ac34:	e51b300c 	ldr	r3, [fp, #-12]
1000ac38:	e2833001 	add	r3, r3, #1
1000ac3c:	e50b300c 	str	r3, [fp, #-12]
            if (fcnt == 16)
1000ac40:	e51b300c 	ldr	r3, [fp, #-12]
1000ac44:	e3530010 	cmp	r3, #16
1000ac48:	1a000005 	bne	1000ac64 <rt_hw_cpu_dump_page_table+0x9c>
            {
                rt_kprintf("fault\n");
1000ac4c:	e30f0068 	movw	r0, #61544	; 0xf068
1000ac50:	e3410001 	movt	r0, #4097	; 0x1001
1000ac54:	ebffed9e 	bl	100062d4 <rt_kprintf>
                fcnt = 0;
1000ac58:	e3a03000 	mov	r3, #0
1000ac5c:	e50b300c 	str	r3, [fp, #-12]
            }
            continue;
1000ac60:	ea000060 	b	1000ade8 <rt_hw_cpu_dump_page_table+0x220>
1000ac64:	ea00005f 	b	1000ade8 <rt_hw_cpu_dump_page_table+0x220>
        }
        if (fcnt != 0)
1000ac68:	e51b300c 	ldr	r3, [fp, #-12]
1000ac6c:	e3530000 	cmp	r3, #0
1000ac70:	0a000004 	beq	1000ac88 <rt_hw_cpu_dump_page_table+0xc0>
        {
            rt_kprintf("fault\n");
1000ac74:	e30f0068 	movw	r0, #61544	; 0xf068
1000ac78:	e3410001 	movt	r0, #4097	; 0x1001
1000ac7c:	ebffed94 	bl	100062d4 <rt_kprintf>
            fcnt = 0;
1000ac80:	e3a03000 	mov	r3, #0
1000ac84:	e50b300c 	str	r3, [fp, #-12]
        }

        rt_kprintf("%03x: %08x: ", i, pte1);
1000ac88:	e30f0070 	movw	r0, #61552	; 0xf070
1000ac8c:	e3410001 	movt	r0, #4097	; 0x1001
1000ac90:	e51b1008 	ldr	r1, [fp, #-8]
1000ac94:	e51b2010 	ldr	r2, [fp, #-16]
1000ac98:	ebffed8d 	bl	100062d4 <rt_kprintf>
        if ((pte1 & 0x3) == 0x3)
1000ac9c:	e51b3010 	ldr	r3, [fp, #-16]
1000aca0:	e2033003 	and	r3, r3, #3
1000aca4:	e3530003 	cmp	r3, #3
1000aca8:	1a000003 	bne	1000acbc <rt_hw_cpu_dump_page_table+0xf4>
        {
            rt_kprintf("LPAE\n");
1000acac:	e30f0080 	movw	r0, #61568	; 0xf080
1000acb0:	e3410001 	movt	r0, #4097	; 0x1001
1000acb4:	ebffed86 	bl	100062d4 <rt_kprintf>
1000acb8:	ea00004a 	b	1000ade8 <rt_hw_cpu_dump_page_table+0x220>
        }
        else if ((pte1 & 0x3) == 0x1)
1000acbc:	e51b3010 	ldr	r3, [fp, #-16]
1000acc0:	e2033003 	and	r3, r3, #3
1000acc4:	e3530001 	cmp	r3, #1
1000acc8:	1a00000b 	bne	1000acfc <rt_hw_cpu_dump_page_table+0x134>
        {
            rt_kprintf("pte,ns:%d,domain:%d\n",
                       (pte1 >> 3) & 0x1, (pte1 >> 5) & 0xf);
1000accc:	e51b3010 	ldr	r3, [fp, #-16]
1000acd0:	e1a031a3 	lsr	r3, r3, #3
        {
            rt_kprintf("LPAE\n");
        }
        else if ((pte1 & 0x3) == 0x1)
        {
            rt_kprintf("pte,ns:%d,domain:%d\n",
1000acd4:	e2032001 	and	r2, r3, #1
                       (pte1 >> 3) & 0x1, (pte1 >> 5) & 0xf);
1000acd8:	e51b3010 	ldr	r3, [fp, #-16]
1000acdc:	e1a032a3 	lsr	r3, r3, #5
        {
            rt_kprintf("LPAE\n");
        }
        else if ((pte1 & 0x3) == 0x1)
        {
            rt_kprintf("pte,ns:%d,domain:%d\n",
1000ace0:	e203300f 	and	r3, r3, #15
1000ace4:	e30f0088 	movw	r0, #61576	; 0xf088
1000ace8:	e3410001 	movt	r0, #4097	; 0x1001
1000acec:	e1a01002 	mov	r1, r2
1000acf0:	e1a02003 	mov	r2, r3
1000acf4:	ebffed76 	bl	100062d4 <rt_kprintf>
1000acf8:	ea00003a 	b	1000ade8 <rt_hw_cpu_dump_page_table+0x220>
            /*
             *rt_hw_cpu_dump_page_table_2nd((void*)((pte1 & 0xfffffc000)
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
1000acfc:	e51b3010 	ldr	r3, [fp, #-16]
1000ad00:	e2033701 	and	r3, r3, #262144	; 0x40000
1000ad04:	e3530000 	cmp	r3, #0
1000ad08:	0a000018 	beq	1000ad70 <rt_hw_cpu_dump_page_table+0x1a8>
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
                       (pte1 >> 19) & 0x1,
1000ad0c:	e51b3010 	ldr	r3, [fp, #-16]
1000ad10:	e1a039a3 	lsr	r3, r3, #19
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
1000ad14:	e2031001 	and	r1, r3, #1
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
1000ad18:	e51b3010 	ldr	r3, [fp, #-16]
1000ad1c:	e1a026a3 	lsr	r2, r3, #13
1000ad20:	e51b3010 	ldr	r3, [fp, #-16]
1000ad24:	e1a03523 	lsr	r3, r3, #10
1000ad28:	e1823003 	orr	r3, r2, r3
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
1000ad2c:	e203e00f 	and	lr, r3, #15
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
1000ad30:	e51b3010 	ldr	r3, [fp, #-16]
1000ad34:	e1a03223 	lsr	r3, r3, #4
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
1000ad38:	e203c001 	and	ip, r3, #1
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
1000ad3c:	e51b3010 	ldr	r3, [fp, #-16]
1000ad40:	e1a02523 	lsr	r2, r3, #10
1000ad44:	e51b3010 	ldr	r3, [fp, #-16]
1000ad48:	e1a03123 	lsr	r3, r3, #2
1000ad4c:	e1823003 	orr	r3, r2, r3
             *                               - 0x80000000 + 0xC0000000));
             */
        }
        else if (pte1 & (1 << 18))
        {
            rt_kprintf("super section,ns:%d,ap:%x,xn:%d,texcb:%02x\n",
1000ad50:	e203301f 	and	r3, r3, #31
1000ad54:	e58d3000 	str	r3, [sp]
1000ad58:	e30f00a0 	movw	r0, #61600	; 0xf0a0
1000ad5c:	e3410001 	movt	r0, #4097	; 0x1001
1000ad60:	e1a0200e 	mov	r2, lr
1000ad64:	e1a0300c 	mov	r3, ip
1000ad68:	ebffed59 	bl	100062d4 <rt_kprintf>
1000ad6c:	ea00001d 	b	1000ade8 <rt_hw_cpu_dump_page_table+0x220>
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
1000ad70:	e51b3010 	ldr	r3, [fp, #-16]
1000ad74:	e1a039a3 	lsr	r3, r3, #19
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
1000ad78:	e2031001 	and	r1, r3, #1
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
1000ad7c:	e51b3010 	ldr	r3, [fp, #-16]
1000ad80:	e1a026a3 	lsr	r2, r3, #13
1000ad84:	e51b3010 	ldr	r3, [fp, #-16]
1000ad88:	e1a03523 	lsr	r3, r3, #10
1000ad8c:	e1823003 	orr	r3, r2, r3
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
1000ad90:	e203e00f 	and	lr, r3, #15
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
1000ad94:	e51b3010 	ldr	r3, [fp, #-16]
1000ad98:	e1a03223 	lsr	r3, r3, #4
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
1000ad9c:	e203c001 	and	ip, r3, #1
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       (((pte1 & (0x7 << 12)) >> 10) |
1000ada0:	e51b3010 	ldr	r3, [fp, #-16]
1000ada4:	e2033a07 	and	r3, r3, #28672	; 0x7000
1000ada8:	e1a02523 	lsr	r2, r3, #10
                        ((pte1 &        0x0c) >>  2)) & 0x1f,
1000adac:	e51b3010 	ldr	r3, [fp, #-16]
1000adb0:	e203300c 	and	r3, r3, #12
1000adb4:	e1a03123 	lsr	r3, r3, #2
            rt_kprintf("section,ns:%d,ap:%x,"
                       "xn:%d,texcb:%02x,domain:%d\n",
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       (((pte1 & (0x7 << 12)) >> 10) |
1000adb8:	e1823003 	orr	r3, r2, r3
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
1000adbc:	e203201f 	and	r2, r3, #31
                       (pte1 >> 19) & 0x1,
                       ((pte1 >> 13) | (pte1 >> 10))& 0xf,
                       (pte1 >> 4) & 0x1,
                       (((pte1 & (0x7 << 12)) >> 10) |
                        ((pte1 &        0x0c) >>  2)) & 0x1f,
                       (pte1 >> 5) & 0xf);
1000adc0:	e51b3010 	ldr	r3, [fp, #-16]
1000adc4:	e1a032a3 	lsr	r3, r3, #5
                       (pte1 >> 4) & 0x1,
                       ((pte1 >> 10) | (pte1 >> 2)) & 0x1f);
        }
        else
        {
            rt_kprintf("section,ns:%d,ap:%x,"
1000adc8:	e203300f 	and	r3, r3, #15
1000adcc:	e58d2000 	str	r2, [sp]
1000add0:	e58d3004 	str	r3, [sp, #4]
1000add4:	e30f00cc 	movw	r0, #61644	; 0xf0cc
1000add8:	e3410001 	movt	r0, #4097	; 0x1001
1000addc:	e1a0200e 	mov	r2, lr
1000ade0:	e1a0300c 	mov	r3, ip
1000ade4:	ebffed3a 	bl	100062d4 <rt_kprintf>
{
    int i;
    int fcnt = 0;

    rt_kprintf("page table@%p\n", ptb);
    for (i = 0; i < 1024*4; i++)
1000ade8:	e51b3008 	ldr	r3, [fp, #-8]
1000adec:	e2833001 	add	r3, r3, #1
1000adf0:	e50b3008 	str	r3, [fp, #-8]
1000adf4:	e51b3008 	ldr	r3, [fp, #-8]
1000adf8:	e3530a01 	cmp	r3, #4096	; 0x1000
1000adfc:	baffff7e 	blt	1000abfc <rt_hw_cpu_dump_page_table+0x34>
                       (((pte1 & (0x7 << 12)) >> 10) |
                        ((pte1 &        0x0c) >>  2)) & 0x1f,
                       (pte1 >> 5) & 0xf);
        }
    }
}
1000ae00:	e24bd004 	sub	sp, fp, #4
1000ae04:	e8bd8800 	pop	{fp, pc}

1000ae08 <rt_hw_mmu_setmtt>:
volatile unsigned long MMUTable[4*1024] SECTION("mmu_tbl") __attribute__((aligned(16*1024)));
void rt_hw_mmu_setmtt(rt_uint32_t vaddrStart,
                      rt_uint32_t vaddrEnd,
                      rt_uint32_t paddrStart,
                      rt_uint32_t attr)
{
1000ae08:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ae0c:	e28db000 	add	fp, sp, #0
1000ae10:	e24dd024 	sub	sp, sp, #36	; 0x24
1000ae14:	e50b0018 	str	r0, [fp, #-24]
1000ae18:	e50b101c 	str	r1, [fp, #-28]
1000ae1c:	e50b2020 	str	r2, [fp, #-32]
1000ae20:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    volatile rt_uint32_t *pTT;
    volatile int i, nSec;
    pTT  = (rt_uint32_t *)MMUTable + (vaddrStart >> 20);
1000ae24:	e51b3018 	ldr	r3, [fp, #-24]
1000ae28:	e1a03a23 	lsr	r3, r3, #20
1000ae2c:	e1a02103 	lsl	r2, r3, #2
1000ae30:	e3043000 	movw	r3, #16384	; 0x4000
1000ae34:	e3413002 	movt	r3, #4098	; 0x1002
1000ae38:	e0823003 	add	r3, r2, r3
1000ae3c:	e50b3008 	str	r3, [fp, #-8]
    nSec = (vaddrEnd >> 20) - (vaddrStart >> 20);
1000ae40:	e51b301c 	ldr	r3, [fp, #-28]
1000ae44:	e1a02a23 	lsr	r2, r3, #20
1000ae48:	e51b3018 	ldr	r3, [fp, #-24]
1000ae4c:	e1a03a23 	lsr	r3, r3, #20
1000ae50:	e0633002 	rsb	r3, r3, r2
1000ae54:	e50b3010 	str	r3, [fp, #-16]
    for(i = 0; i <= nSec; i++)
1000ae58:	e3a03000 	mov	r3, #0
1000ae5c:	e50b300c 	str	r3, [fp, #-12]
1000ae60:	ea00000e 	b	1000aea0 <rt_hw_mmu_setmtt+0x98>
    {
        *pTT = attr | (((paddrStart >> 20) + i) << 20);
1000ae64:	e51b3020 	ldr	r3, [fp, #-32]
1000ae68:	e1a03a23 	lsr	r3, r3, #20
1000ae6c:	e51b200c 	ldr	r2, [fp, #-12]
1000ae70:	e0833002 	add	r3, r3, r2
1000ae74:	e1a02a03 	lsl	r2, r3, #20
1000ae78:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000ae7c:	e1822003 	orr	r2, r2, r3
1000ae80:	e51b3008 	ldr	r3, [fp, #-8]
1000ae84:	e5832000 	str	r2, [r3]
        pTT++;
1000ae88:	e51b3008 	ldr	r3, [fp, #-8]
1000ae8c:	e2833004 	add	r3, r3, #4
1000ae90:	e50b3008 	str	r3, [fp, #-8]
{
    volatile rt_uint32_t *pTT;
    volatile int i, nSec;
    pTT  = (rt_uint32_t *)MMUTable + (vaddrStart >> 20);
    nSec = (vaddrEnd >> 20) - (vaddrStart >> 20);
    for(i = 0; i <= nSec; i++)
1000ae94:	e51b300c 	ldr	r3, [fp, #-12]
1000ae98:	e2833001 	add	r3, r3, #1
1000ae9c:	e50b300c 	str	r3, [fp, #-12]
1000aea0:	e51b200c 	ldr	r2, [fp, #-12]
1000aea4:	e51b3010 	ldr	r3, [fp, #-16]
1000aea8:	e1520003 	cmp	r2, r3
1000aeac:	daffffec 	ble	1000ae64 <rt_hw_mmu_setmtt+0x5c>
    {
        *pTT = attr | (((paddrStart >> 20) + i) << 20);
        pTT++;
    }
}
1000aeb0:	e24bd000 	sub	sp, fp, #0
1000aeb4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000aeb8:	e12fff1e 	bx	lr

1000aebc <rt_hw_set_domain_register>:

unsigned long rt_hw_set_domain_register(unsigned long domain_val)
{
1000aebc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000aec0:	e28db000 	add	fp, sp, #0
1000aec4:	e24dd014 	sub	sp, sp, #20
1000aec8:	e50b0010 	str	r0, [fp, #-16]
    unsigned long old_domain;

    asm volatile ("mrc p15, 0, %0, c3, c0\n" : "=r" (old_domain));
1000aecc:	ee133f10 	mrc	15, 0, r3, cr3, cr0, {0}
1000aed0:	e50b3008 	str	r3, [fp, #-8]
    asm volatile ("mcr p15, 0, %0, c3, c0\n" : :"r" (domain_val) : "memory");
1000aed4:	e51b3010 	ldr	r3, [fp, #-16]
1000aed8:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}

    return old_domain;
1000aedc:	e51b3008 	ldr	r3, [fp, #-8]
}
1000aee0:	e1a00003 	mov	r0, r3
1000aee4:	e24bd000 	sub	sp, fp, #0
1000aee8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000aeec:	e12fff1e 	bx	lr

1000aef0 <rt_hw_mmu_init>:

void rt_hw_mmu_init(void)
{
1000aef0:	e92d4800 	push	{fp, lr}
1000aef4:	e28db004 	add	fp, sp, #4
    extern rt_uint32_t __text_start;
    rt_hw_cpu_dcache_disable();
1000aef8:	eb0001c9 	bl	1000b624 <rt_hw_cpu_dcache_disable>
    rt_hw_cpu_icache_disable();
1000aefc:	eb0001cf 	bl	1000b640 <rt_hw_cpu_icache_disable>
    rt_cpu_mmu_disable();
1000af00:	eb0001d2 	bl	1000b650 <rt_cpu_mmu_disable>

    /* set page table */
    /* no access to the memory below .text */
    /* 128M cached DDR memory */
    rt_hw_mmu_setmtt((rt_uint32_t)&__text_start, 0x20000000-1,
1000af04:	e3003000 	movw	r3, #0
1000af08:	e3413000 	movt	r3, #4096	; 0x1000
1000af0c:	e1a00003 	mov	r0, r3
1000af10:	e3e0120e 	mvn	r1, #-536870912	; 0xe0000000
1000af14:	e3a02000 	mov	r2, #0
1000af18:	e3412ff0 	movt	r2, #8176	; 0x1ff0
1000af1c:	e3003c0e 	movw	r3, #3086	; 0xc0e
1000af20:	ebffffb8 	bl	1000ae08 <rt_hw_mmu_setmtt>
                     0x1ff00000, RW_CB);
    /* PL region */
    rt_hw_mmu_setmtt(0x40000000, 0xBFFFFFFF, 0x40000000, RW_NCNBXN);
1000af24:	e3a00101 	mov	r0, #1073741824	; 0x40000000
1000af28:	e3e01101 	mvn	r1, #1073741824	; 0x40000000
1000af2c:	e3a02101 	mov	r2, #1073741824	; 0x40000000
1000af30:	e3003c12 	movw	r3, #3090	; 0xc12
1000af34:	ebffffb3 	bl	1000ae08 <rt_hw_mmu_setmtt>
    /* IOP registers */
    rt_hw_mmu_setmtt(0xE0000000, 0xE02FFFFF, 0xE0000000, RW_NCNBXN);
1000af38:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
1000af3c:	e30f1fff 	movw	r1, #65535	; 0xffff
1000af40:	e34e102f 	movt	r1, #57391	; 0xe02f
1000af44:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
1000af48:	e3003c12 	movw	r3, #3090	; 0xc12
1000af4c:	ebffffad 	bl	1000ae08 <rt_hw_mmu_setmtt>
    /* no access to the SMC memory(enable it if you want) */
    /* SLCR, PS and CPU private registers, note we map more memory space as the
     * entry is 1MB in size. */
    rt_hw_mmu_setmtt(0xF8000000, 0xF8FFFFFF, 0xF8000000, RW_NCNBXN);
1000af50:	e3a0033e 	mov	r0, #-134217728	; 0xf8000000
1000af54:	e3e01407 	mvn	r1, #117440512	; 0x7000000
1000af58:	e3a0233e 	mov	r2, #-134217728	; 0xf8000000
1000af5c:	e3003c12 	movw	r3, #3090	; 0xc12
1000af60:	ebffffa8 	bl	1000ae08 <rt_hw_mmu_setmtt>

    /*rt_hw_cpu_dump_page_table(MMUTable);*/

    /* become clients for all domains */
    rt_hw_set_domain_register(0x55555555);
1000af64:	e3050555 	movw	r0, #21845	; 0x5555
1000af68:	e3450555 	movt	r0, #21845	; 0x5555
1000af6c:	ebffffd2 	bl	1000aebc <rt_hw_set_domain_register>

    rt_cpu_tlb_set(MMUTable);
1000af70:	e3040000 	movw	r0, #16384	; 0x4000
1000af74:	e3410002 	movt	r0, #4098	; 0x1002
1000af78:	eb0001bf 	bl	1000b67c <rt_cpu_tlb_set>

    rt_cpu_mmu_enable();
1000af7c:	eb0001b9 	bl	1000b668 <rt_cpu_mmu_enable>

    rt_hw_cpu_icache_enable();
1000af80:	eb00017c 	bl	1000b578 <rt_hw_cpu_icache_enable>
    rt_hw_cpu_dcache_enable();
1000af84:	eb000177 	bl	1000b568 <rt_hw_cpu_dcache_enable>
}
1000af88:	e8bd8800 	pop	{fp, pc}

1000af8c <rt_hw_stack_init>:
 *
 * @return stack address
 */
rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter,
                             rt_uint8_t *stack_addr, void *texit)
{
1000af8c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000af90:	e28db000 	add	fp, sp, #0
1000af94:	e24dd01c 	sub	sp, sp, #28
1000af98:	e50b0010 	str	r0, [fp, #-16]
1000af9c:	e50b1014 	str	r1, [fp, #-20]
1000afa0:	e50b2018 	str	r2, [fp, #-24]
1000afa4:	e50b301c 	str	r3, [fp, #-28]
    rt_uint32_t *stk;

    stk      = (rt_uint32_t *)stack_addr;
1000afa8:	e51b3018 	ldr	r3, [fp, #-24]
1000afac:	e50b3008 	str	r3, [fp, #-8]
    *(stk)   = (rt_uint32_t)tentry;         /* entry point */
1000afb0:	e51b2010 	ldr	r2, [fp, #-16]
1000afb4:	e51b3008 	ldr	r3, [fp, #-8]
1000afb8:	e5832000 	str	r2, [r3]
    *(--stk) = (rt_uint32_t)texit;          /* lr */
1000afbc:	e51b3008 	ldr	r3, [fp, #-8]
1000afc0:	e2433004 	sub	r3, r3, #4
1000afc4:	e50b3008 	str	r3, [fp, #-8]
1000afc8:	e51b201c 	ldr	r2, [fp, #-28]
1000afcc:	e51b3008 	ldr	r3, [fp, #-8]
1000afd0:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r12 */
1000afd4:	e51b3008 	ldr	r3, [fp, #-8]
1000afd8:	e2433004 	sub	r3, r3, #4
1000afdc:	e50b3008 	str	r3, [fp, #-8]
1000afe0:	e51b3008 	ldr	r3, [fp, #-8]
1000afe4:	e3a02000 	mov	r2, #0
1000afe8:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r11 */
1000afec:	e51b3008 	ldr	r3, [fp, #-8]
1000aff0:	e2433004 	sub	r3, r3, #4
1000aff4:	e50b3008 	str	r3, [fp, #-8]
1000aff8:	e51b3008 	ldr	r3, [fp, #-8]
1000affc:	e3a02000 	mov	r2, #0
1000b000:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r10 */
1000b004:	e51b3008 	ldr	r3, [fp, #-8]
1000b008:	e2433004 	sub	r3, r3, #4
1000b00c:	e50b3008 	str	r3, [fp, #-8]
1000b010:	e51b3008 	ldr	r3, [fp, #-8]
1000b014:	e3a02000 	mov	r2, #0
1000b018:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r9 */
1000b01c:	e51b3008 	ldr	r3, [fp, #-8]
1000b020:	e2433004 	sub	r3, r3, #4
1000b024:	e50b3008 	str	r3, [fp, #-8]
1000b028:	e51b3008 	ldr	r3, [fp, #-8]
1000b02c:	e3a02000 	mov	r2, #0
1000b030:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r8 */
1000b034:	e51b3008 	ldr	r3, [fp, #-8]
1000b038:	e2433004 	sub	r3, r3, #4
1000b03c:	e50b3008 	str	r3, [fp, #-8]
1000b040:	e51b3008 	ldr	r3, [fp, #-8]
1000b044:	e3a02000 	mov	r2, #0
1000b048:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r7 */
1000b04c:	e51b3008 	ldr	r3, [fp, #-8]
1000b050:	e2433004 	sub	r3, r3, #4
1000b054:	e50b3008 	str	r3, [fp, #-8]
1000b058:	e51b3008 	ldr	r3, [fp, #-8]
1000b05c:	e3a02000 	mov	r2, #0
1000b060:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r6 */
1000b064:	e51b3008 	ldr	r3, [fp, #-8]
1000b068:	e2433004 	sub	r3, r3, #4
1000b06c:	e50b3008 	str	r3, [fp, #-8]
1000b070:	e51b3008 	ldr	r3, [fp, #-8]
1000b074:	e3a02000 	mov	r2, #0
1000b078:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r5 */
1000b07c:	e51b3008 	ldr	r3, [fp, #-8]
1000b080:	e2433004 	sub	r3, r3, #4
1000b084:	e50b3008 	str	r3, [fp, #-8]
1000b088:	e51b3008 	ldr	r3, [fp, #-8]
1000b08c:	e3a02000 	mov	r2, #0
1000b090:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r4 */
1000b094:	e51b3008 	ldr	r3, [fp, #-8]
1000b098:	e2433004 	sub	r3, r3, #4
1000b09c:	e50b3008 	str	r3, [fp, #-8]
1000b0a0:	e51b3008 	ldr	r3, [fp, #-8]
1000b0a4:	e3a02000 	mov	r2, #0
1000b0a8:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r3 */
1000b0ac:	e51b3008 	ldr	r3, [fp, #-8]
1000b0b0:	e2433004 	sub	r3, r3, #4
1000b0b4:	e50b3008 	str	r3, [fp, #-8]
1000b0b8:	e51b3008 	ldr	r3, [fp, #-8]
1000b0bc:	e3a02000 	mov	r2, #0
1000b0c0:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r2 */
1000b0c4:	e51b3008 	ldr	r3, [fp, #-8]
1000b0c8:	e2433004 	sub	r3, r3, #4
1000b0cc:	e50b3008 	str	r3, [fp, #-8]
1000b0d0:	e51b3008 	ldr	r3, [fp, #-8]
1000b0d4:	e3a02000 	mov	r2, #0
1000b0d8:	e5832000 	str	r2, [r3]
    *(--stk) = 0;                           /* r1 */
1000b0dc:	e51b3008 	ldr	r3, [fp, #-8]
1000b0e0:	e2433004 	sub	r3, r3, #4
1000b0e4:	e50b3008 	str	r3, [fp, #-8]
1000b0e8:	e51b3008 	ldr	r3, [fp, #-8]
1000b0ec:	e3a02000 	mov	r2, #0
1000b0f0:	e5832000 	str	r2, [r3]
    *(--stk) = (rt_uint32_t)parameter;      /* r0 : argument */
1000b0f4:	e51b3008 	ldr	r3, [fp, #-8]
1000b0f8:	e2433004 	sub	r3, r3, #4
1000b0fc:	e50b3008 	str	r3, [fp, #-8]
1000b100:	e51b2014 	ldr	r2, [fp, #-20]
1000b104:	e51b3008 	ldr	r3, [fp, #-8]
1000b108:	e5832000 	str	r2, [r3]

    /* cpsr */
    if ((rt_uint32_t)tentry & 0x01)
1000b10c:	e51b3010 	ldr	r3, [fp, #-16]
1000b110:	e2033001 	and	r3, r3, #1
1000b114:	e3530000 	cmp	r3, #0
1000b118:	0a000006 	beq	1000b138 <rt_hw_stack_init+0x1ac>
        *(--stk) = SVCMODE | 0x20;          /* thumb mode */
1000b11c:	e51b3008 	ldr	r3, [fp, #-8]
1000b120:	e2433004 	sub	r3, r3, #4
1000b124:	e50b3008 	str	r3, [fp, #-8]
1000b128:	e51b3008 	ldr	r3, [fp, #-8]
1000b12c:	e3a02033 	mov	r2, #51	; 0x33
1000b130:	e5832000 	str	r2, [r3]
1000b134:	ea000005 	b	1000b150 <rt_hw_stack_init+0x1c4>
    else
        *(--stk) = SVCMODE;                 /* arm mode   */
1000b138:	e51b3008 	ldr	r3, [fp, #-8]
1000b13c:	e2433004 	sub	r3, r3, #4
1000b140:	e50b3008 	str	r3, [fp, #-8]
1000b144:	e51b3008 	ldr	r3, [fp, #-8]
1000b148:	e3a02013 	mov	r2, #19
1000b14c:	e5832000 	str	r2, [r3]

    /* return task's current stack address */
    return (rt_uint8_t *)stk;
1000b150:	e51b3008 	ldr	r3, [fp, #-8]
}
1000b154:	e1a00003 	mov	r0, r3
1000b158:	e24bd000 	sub	sp, fp, #0
1000b15c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000b160:	e12fff1e 	bx	lr

1000b164 <rt_hw_show_register>:
 * this function will show registers of CPU
 *
 * @param regs the registers point
 */
void rt_hw_show_register (struct rt_hw_exp_stack *regs)
{
1000b164:	e92d4800 	push	{fp, lr}
1000b168:	e28db004 	add	fp, sp, #4
1000b16c:	e24dd010 	sub	sp, sp, #16
1000b170:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("Execption:\n");
1000b174:	e30f00fc 	movw	r0, #61692	; 0xf0fc
1000b178:	e3410001 	movt	r0, #4097	; 0x1001
1000b17c:	ebffec54 	bl	100062d4 <rt_kprintf>
    rt_kprintf("r00:0x%08x r01:0x%08x r02:0x%08x r03:0x%08x\n", regs->r0, regs->r1, regs->r2, regs->r3);
1000b180:	e51b3008 	ldr	r3, [fp, #-8]
1000b184:	e5931000 	ldr	r1, [r3]
1000b188:	e51b3008 	ldr	r3, [fp, #-8]
1000b18c:	e5932004 	ldr	r2, [r3, #4]
1000b190:	e51b3008 	ldr	r3, [fp, #-8]
1000b194:	e593c008 	ldr	ip, [r3, #8]
1000b198:	e51b3008 	ldr	r3, [fp, #-8]
1000b19c:	e593300c 	ldr	r3, [r3, #12]
1000b1a0:	e58d3000 	str	r3, [sp]
1000b1a4:	e30f0108 	movw	r0, #61704	; 0xf108
1000b1a8:	e3410001 	movt	r0, #4097	; 0x1001
1000b1ac:	e1a0300c 	mov	r3, ip
1000b1b0:	ebffec47 	bl	100062d4 <rt_kprintf>
    rt_kprintf("r04:0x%08x r05:0x%08x r06:0x%08x r07:0x%08x\n", regs->r4, regs->r5, regs->r6, regs->r7);
1000b1b4:	e51b3008 	ldr	r3, [fp, #-8]
1000b1b8:	e5931010 	ldr	r1, [r3, #16]
1000b1bc:	e51b3008 	ldr	r3, [fp, #-8]
1000b1c0:	e5932014 	ldr	r2, [r3, #20]
1000b1c4:	e51b3008 	ldr	r3, [fp, #-8]
1000b1c8:	e593c018 	ldr	ip, [r3, #24]
1000b1cc:	e51b3008 	ldr	r3, [fp, #-8]
1000b1d0:	e593301c 	ldr	r3, [r3, #28]
1000b1d4:	e58d3000 	str	r3, [sp]
1000b1d8:	e30f0138 	movw	r0, #61752	; 0xf138
1000b1dc:	e3410001 	movt	r0, #4097	; 0x1001
1000b1e0:	e1a0300c 	mov	r3, ip
1000b1e4:	ebffec3a 	bl	100062d4 <rt_kprintf>
    rt_kprintf("r08:0x%08x r09:0x%08x r10:0x%08x\n", regs->r8, regs->r9, regs->r10);
1000b1e8:	e51b3008 	ldr	r3, [fp, #-8]
1000b1ec:	e5931020 	ldr	r1, [r3, #32]
1000b1f0:	e51b3008 	ldr	r3, [fp, #-8]
1000b1f4:	e5932024 	ldr	r2, [r3, #36]	; 0x24
1000b1f8:	e51b3008 	ldr	r3, [fp, #-8]
1000b1fc:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1000b200:	e30f0168 	movw	r0, #61800	; 0xf168
1000b204:	e3410001 	movt	r0, #4097	; 0x1001
1000b208:	ebffec31 	bl	100062d4 <rt_kprintf>
    rt_kprintf("fp :0x%08x ip :0x%08x\n", regs->fp, regs->ip);
1000b20c:	e51b3008 	ldr	r3, [fp, #-8]
1000b210:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1000b214:	e51b3008 	ldr	r3, [fp, #-8]
1000b218:	e5933030 	ldr	r3, [r3, #48]	; 0x30
1000b21c:	e30f018c 	movw	r0, #61836	; 0xf18c
1000b220:	e3410001 	movt	r0, #4097	; 0x1001
1000b224:	e1a01002 	mov	r1, r2
1000b228:	e1a02003 	mov	r2, r3
1000b22c:	ebffec28 	bl	100062d4 <rt_kprintf>
    rt_kprintf("sp :0x%08x lr :0x%08x pc :0x%08x\n", regs->sp, regs->lr, regs->pc);
1000b230:	e51b3008 	ldr	r3, [fp, #-8]
1000b234:	e5931034 	ldr	r1, [r3, #52]	; 0x34
1000b238:	e51b3008 	ldr	r3, [fp, #-8]
1000b23c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
1000b240:	e51b3008 	ldr	r3, [fp, #-8]
1000b244:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000b248:	e30f01a4 	movw	r0, #61860	; 0xf1a4
1000b24c:	e3410001 	movt	r0, #4097	; 0x1001
1000b250:	ebffec1f 	bl	100062d4 <rt_kprintf>
    rt_kprintf("cpsr:0x%08x\n", regs->cpsr);
1000b254:	e51b3008 	ldr	r3, [fp, #-8]
1000b258:	e5933040 	ldr	r3, [r3, #64]	; 0x40
1000b25c:	e30f01c8 	movw	r0, #61896	; 0xf1c8
1000b260:	e3410001 	movt	r0, #4097	; 0x1001
1000b264:	e1a01003 	mov	r1, r3
1000b268:	ebffec19 	bl	100062d4 <rt_kprintf>
}
1000b26c:	e24bd004 	sub	sp, fp, #4
1000b270:	e8bd8800 	pop	{fp, pc}

1000b274 <rt_hw_trap_undef>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_undef(struct rt_hw_exp_stack *regs)
{
1000b274:	e92d4800 	push	{fp, lr}
1000b278:	e28db004 	add	fp, sp, #4
1000b27c:	e24dd008 	sub	sp, sp, #8
1000b280:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("undefined instruction:\n");
1000b284:	e30f01d8 	movw	r0, #61912	; 0xf1d8
1000b288:	e3410001 	movt	r0, #4097	; 0x1001
1000b28c:	ebffec10 	bl	100062d4 <rt_kprintf>
    rt_hw_show_register(regs);
1000b290:	e51b0008 	ldr	r0, [fp, #-8]
1000b294:	ebffffb2 	bl	1000b164 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
1000b298:	eb001bf9 	bl	10012284 <list_thread>
#endif
    rt_hw_cpu_shutdown();
1000b29c:	ebfff9ff 	bl	10009aa0 <rt_hw_cpu_shutdown>
}
1000b2a0:	e24bd004 	sub	sp, fp, #4
1000b2a4:	e8bd8800 	pop	{fp, pc}

1000b2a8 <rt_hw_trap_swi>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_swi(struct rt_hw_exp_stack *regs)
{
1000b2a8:	e92d4800 	push	{fp, lr}
1000b2ac:	e28db004 	add	fp, sp, #4
1000b2b0:	e24dd008 	sub	sp, sp, #8
1000b2b4:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("software interrupt:\n");
1000b2b8:	e30f01f0 	movw	r0, #61936	; 0xf1f0
1000b2bc:	e3410001 	movt	r0, #4097	; 0x1001
1000b2c0:	ebffec03 	bl	100062d4 <rt_kprintf>
    rt_hw_show_register(regs);
1000b2c4:	e51b0008 	ldr	r0, [fp, #-8]
1000b2c8:	ebffffa5 	bl	1000b164 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
1000b2cc:	eb001bec 	bl	10012284 <list_thread>
#endif
    rt_hw_cpu_shutdown();
1000b2d0:	ebfff9f2 	bl	10009aa0 <rt_hw_cpu_shutdown>
}
1000b2d4:	e24bd004 	sub	sp, fp, #4
1000b2d8:	e8bd8800 	pop	{fp, pc}

1000b2dc <rt_hw_trap_pabt>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_pabt(struct rt_hw_exp_stack *regs)
{
1000b2dc:	e92d4800 	push	{fp, lr}
1000b2e0:	e28db004 	add	fp, sp, #4
1000b2e4:	e24dd008 	sub	sp, sp, #8
1000b2e8:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("prefetch abort:\n");
1000b2ec:	e30f0208 	movw	r0, #61960	; 0xf208
1000b2f0:	e3410001 	movt	r0, #4097	; 0x1001
1000b2f4:	ebffebf6 	bl	100062d4 <rt_kprintf>
    rt_hw_show_register(regs);
1000b2f8:	e51b0008 	ldr	r0, [fp, #-8]
1000b2fc:	ebffff98 	bl	1000b164 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
1000b300:	eb001bdf 	bl	10012284 <list_thread>
#endif
    rt_hw_cpu_shutdown();
1000b304:	ebfff9e5 	bl	10009aa0 <rt_hw_cpu_shutdown>
}
1000b308:	e24bd004 	sub	sp, fp, #4
1000b30c:	e8bd8800 	pop	{fp, pc}

1000b310 <rt_hw_trap_dabt>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_dabt(struct rt_hw_exp_stack *regs)
{
1000b310:	e92d4800 	push	{fp, lr}
1000b314:	e28db004 	add	fp, sp, #4
1000b318:	e24dd008 	sub	sp, sp, #8
1000b31c:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("data abort:");
1000b320:	e30f021c 	movw	r0, #61980	; 0xf21c
1000b324:	e3410001 	movt	r0, #4097	; 0x1001
1000b328:	ebffebe9 	bl	100062d4 <rt_kprintf>
    rt_hw_show_register(regs);
1000b32c:	e51b0008 	ldr	r0, [fp, #-8]
1000b330:	ebffff8b 	bl	1000b164 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
1000b334:	eb001bd2 	bl	10012284 <list_thread>
#endif
    rt_hw_cpu_shutdown();
1000b338:	ebfff9d8 	bl	10009aa0 <rt_hw_cpu_shutdown>
}
1000b33c:	e24bd004 	sub	sp, fp, #4
1000b340:	e8bd8800 	pop	{fp, pc}

1000b344 <rt_hw_trap_resv>:
 * @param regs system registers
 *
 * @note never invoke this function in application
 */
void rt_hw_trap_resv(struct rt_hw_exp_stack *regs)
{
1000b344:	e92d4800 	push	{fp, lr}
1000b348:	e28db004 	add	fp, sp, #4
1000b34c:	e24dd008 	sub	sp, sp, #8
1000b350:	e50b0008 	str	r0, [fp, #-8]
    rt_kprintf("reserved trap:\n");
1000b354:	e30f0228 	movw	r0, #61992	; 0xf228
1000b358:	e3410001 	movt	r0, #4097	; 0x1001
1000b35c:	ebffebdc 	bl	100062d4 <rt_kprintf>
    rt_hw_show_register(regs);
1000b360:	e51b0008 	ldr	r0, [fp, #-8]
1000b364:	ebffff7e 	bl	1000b164 <rt_hw_show_register>
#ifdef RT_USING_FINSH
    list_thread();
1000b368:	eb001bc5 	bl	10012284 <list_thread>
#endif
    rt_hw_cpu_shutdown();
1000b36c:	ebfff9cb 	bl	10009aa0 <rt_hw_cpu_shutdown>
}
1000b370:	e24bd004 	sub	sp, fp, #4
1000b374:	e8bd8800 	pop	{fp, pc}

1000b378 <rt_hw_trap_irq>:

#define GIC_ACK_INTID_MASK					0x000003ff

void rt_hw_trap_irq()
{
1000b378:	e92d4800 	push	{fp, lr}
1000b37c:	e28db004 	add	fp, sp, #4
1000b380:	e24dd010 	sub	sp, sp, #16
    unsigned long ir;
    unsigned long fullir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    fullir = arm_gic_get_active_irq(0);
1000b384:	e3a00000 	mov	r0, #0
1000b388:	ebfff9d9 	bl	10009af4 <arm_gic_get_active_irq>
1000b38c:	e1a03000 	mov	r3, r0
1000b390:	e50b3008 	str	r3, [fp, #-8]
    ir = fullir & GIC_ACK_INTID_MASK;
1000b394:	e51b3008 	ldr	r3, [fp, #-8]
1000b398:	e7e93053 	ubfx	r3, r3, #0, #10
1000b39c:	e50b300c 	str	r3, [fp, #-12]

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
1000b3a0:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000b3a4:	e3412002 	movt	r2, #4098	; 0x1002
1000b3a8:	e51b300c 	ldr	r3, [fp, #-12]
1000b3ac:	e1a03103 	lsl	r3, r3, #2
1000b3b0:	e1a01103 	lsl	r1, r3, #2
1000b3b4:	e0833001 	add	r3, r3, r1
1000b3b8:	e0823003 	add	r3, r2, r3
1000b3bc:	e5933000 	ldr	r3, [r3]
1000b3c0:	e50b3010 	str	r3, [fp, #-16]
    if (isr_func)
1000b3c4:	e51b3010 	ldr	r3, [fp, #-16]
1000b3c8:	e3530000 	cmp	r3, #0
1000b3cc:	0a00000d 	beq	1000b408 <rt_hw_trap_irq+0x90>
    {
        param = isr_table[ir].param;
1000b3d0:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000b3d4:	e3412002 	movt	r2, #4098	; 0x1002
1000b3d8:	e51b300c 	ldr	r3, [fp, #-12]
1000b3dc:	e1a03103 	lsl	r3, r3, #2
1000b3e0:	e1a01103 	lsl	r1, r3, #2
1000b3e4:	e0833001 	add	r3, r3, r1
1000b3e8:	e0823003 	add	r3, r2, r3
1000b3ec:	e5933004 	ldr	r3, [r3, #4]
1000b3f0:	e50b3014 	str	r3, [fp, #-20]
        /* turn to interrupt service routine */
        isr_func(ir, param);
1000b3f4:	e51b200c 	ldr	r2, [fp, #-12]
1000b3f8:	e51b3010 	ldr	r3, [fp, #-16]
1000b3fc:	e1a00002 	mov	r0, r2
1000b400:	e51b1014 	ldr	r1, [fp, #-20]
1000b404:	e12fff33 	blx	r3
    }

    /* end of interrupt */
    arm_gic_ack(0, fullir);
1000b408:	e51b3008 	ldr	r3, [fp, #-8]
1000b40c:	e3a00000 	mov	r0, #0
1000b410:	e1a01003 	mov	r1, r3
1000b414:	ebfff9e2 	bl	10009ba4 <arm_gic_ack>
}
1000b418:	e24bd004 	sub	sp, fp, #4
1000b41c:	e8bd8800 	pop	{fp, pc}

1000b420 <rt_hw_trap_fiq>:

void rt_hw_trap_fiq()
{
1000b420:	e92d4800 	push	{fp, lr}
1000b424:	e28db004 	add	fp, sp, #4
1000b428:	e24dd010 	sub	sp, sp, #16
    unsigned long ir;
    unsigned long fullir;
    rt_isr_handler_t isr_func;
    extern struct rt_irq_desc isr_table[];

    fullir = arm_gic_get_active_irq(0);
1000b42c:	e3a00000 	mov	r0, #0
1000b430:	ebfff9af 	bl	10009af4 <arm_gic_get_active_irq>
1000b434:	e1a03000 	mov	r3, r0
1000b438:	e50b3008 	str	r3, [fp, #-8]
    ir = fullir & GIC_ACK_INTID_MASK;
1000b43c:	e51b3008 	ldr	r3, [fp, #-8]
1000b440:	e7e93053 	ubfx	r3, r3, #0, #10
1000b444:	e50b300c 	str	r3, [fp, #-12]

    /* get interrupt service routine */
    isr_func = isr_table[ir].handler;
1000b448:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000b44c:	e3412002 	movt	r2, #4098	; 0x1002
1000b450:	e51b300c 	ldr	r3, [fp, #-12]
1000b454:	e1a03103 	lsl	r3, r3, #2
1000b458:	e1a01103 	lsl	r1, r3, #2
1000b45c:	e0833001 	add	r3, r3, r1
1000b460:	e0823003 	add	r3, r2, r3
1000b464:	e5933000 	ldr	r3, [r3]
1000b468:	e50b3010 	str	r3, [fp, #-16]
    param = isr_table[ir].param;
1000b46c:	e3092eb4 	movw	r2, #40628	; 0x9eb4
1000b470:	e3412002 	movt	r2, #4098	; 0x1002
1000b474:	e51b300c 	ldr	r3, [fp, #-12]
1000b478:	e1a03103 	lsl	r3, r3, #2
1000b47c:	e1a01103 	lsl	r1, r3, #2
1000b480:	e0833001 	add	r3, r3, r1
1000b484:	e0823003 	add	r3, r2, r3
1000b488:	e5933004 	ldr	r3, [r3, #4]
1000b48c:	e50b3014 	str	r3, [fp, #-20]

    /* turn to interrupt service routine */
    isr_func(ir, param);
1000b490:	e51b200c 	ldr	r2, [fp, #-12]
1000b494:	e51b3010 	ldr	r3, [fp, #-16]
1000b498:	e1a00002 	mov	r0, r2
1000b49c:	e51b1014 	ldr	r1, [fp, #-20]
1000b4a0:	e12fff33 	blx	r3

    /* end of interrupt */
    arm_gic_ack(0, fullir);
1000b4a4:	e51b3008 	ldr	r3, [fp, #-8]
1000b4a8:	e3a00000 	mov	r0, #0
1000b4ac:	e1a01003 	mov	r1, r3
1000b4b0:	ebfff9bb 	bl	10009ba4 <arm_gic_ack>
}
1000b4b4:	e24bd004 	sub	sp, fp, #4
1000b4b8:	e8bd8800 	pop	{fp, pc}

1000b4bc <rt_hw_interrupt_disable>:
/*
 * rt_base_t rt_hw_interrupt_disable();
 */
.globl rt_hw_interrupt_disable
rt_hw_interrupt_disable:
    mrs r0, cpsr
1000b4bc:	e10f0000 	mrs	r0, CPSR
    orr r1, r0, #NOINT
1000b4c0:	e38010c0 	orr	r1, r0, #192	; 0xc0
    msr cpsr_c, r1
1000b4c4:	e121f001 	msr	CPSR_c, r1
    bx  lr
1000b4c8:	e12fff1e 	bx	lr

1000b4cc <rt_hw_interrupt_enable>:
/*
 * void rt_hw_interrupt_enable(rt_base_t level);
 */
.globl rt_hw_interrupt_enable
rt_hw_interrupt_enable:
    msr cpsr, r0
1000b4cc:	e129f000 	msr	CPSR_fc, r0
    bx  lr
1000b4d0:	e12fff1e 	bx	lr

1000b4d4 <rt_hw_context_switch>:
 * r0 --> from
 * r1 --> to
 */
.globl rt_hw_context_switch
rt_hw_context_switch:
    stmfd   sp!, {lr}       @ push pc (lr should be pushed in place of PC)
1000b4d4:	e92d4000 	stmfd	sp!, {lr}
    stmfd   sp!, {r0-r12, lr}   @ push lr & register file
1000b4d8:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

    mrs r4, cpsr
1000b4dc:	e10f4000 	mrs	r4, CPSR
    tst lr, #0x01
1000b4e0:	e31e0001 	tst	lr, #1
    beq _ARM_MODE
1000b4e4:	0a000000 	beq	1000b4ec <_ARM_MODE>
    orr r4, r4, #0x20       @ it's thumb code
1000b4e8:	e3844020 	orr	r4, r4, #32

1000b4ec <_ARM_MODE>:

_ARM_MODE:
    stmfd sp!, {r4}         @ push cpsr
1000b4ec:	e92d0010 	stmfd	sp!, {r4}

    str sp, [r0]            @ store sp in preempted tasks TCB
1000b4f0:	e580d000 	str	sp, [r0]
    ldr sp, [r1]            @ get new task stack pointer
1000b4f4:	e591d000 	ldr	sp, [r1]

    ldmfd sp!, {r4}         @ pop new task cpsr to spsr
1000b4f8:	e8bd0010 	ldmfd	sp!, {r4}
    msr spsr_cxsf, r4
1000b4fc:	e16ff004 	msr	SPSR_fsxc, r4

    ldmfd sp!, {r0-r12, lr, pc}^  @ pop new task r0-r12, lr & pc, copy spsr to cpsr
1000b500:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

1000b504 <rt_hw_context_switch_to>:
 * void rt_hw_context_switch_to(rt_uint32 to);
 * r0 --> to
 */
.globl rt_hw_context_switch_to
rt_hw_context_switch_to:
    ldr sp, [r0]            @ get new task stack pointer
1000b504:	e590d000 	ldr	sp, [r0]

    ldmfd sp!, {r4}         @ pop new task spsr
1000b508:	e8bd0010 	ldmfd	sp!, {r4}
    msr spsr_cxsf, r4
1000b50c:	e16ff004 	msr	SPSR_fsxc, r4

    bic r4, r4, #0x20       @ must be ARM mode
1000b510:	e3c44020 	bic	r4, r4, #32
    msr cpsr_cxsf, r4
1000b514:	e12ff004 	msr	CPSR_fsxc, r4

    ldmfd sp!, {r0-r12, lr, pc}^   @ pop new task r0-r12, lr & pc
1000b518:	e8fddfff 	ldm	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}^

1000b51c <rt_hw_context_switch_interrupt>:
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ldr r2, =rt_thread_switch_interrupt_flag
1000b51c:	e59f2024 	ldr	r2, [pc, #36]	; 1000b548 <_reswitch+0xc>
    ldr r3, [r2]
1000b520:	e5923000 	ldr	r3, [r2]
    cmp r3, #1
1000b524:	e3530001 	cmp	r3, #1
    beq _reswitch
1000b528:	0a000003 	beq	1000b53c <_reswitch>
    mov r3, #1              @ set rt_thread_switch_interrupt_flag to 1
1000b52c:	e3a03001 	mov	r3, #1
    str r3, [r2]
1000b530:	e5823000 	str	r3, [r2]
    ldr r2, =rt_interrupt_from_thread   @ set rt_interrupt_from_thread
1000b534:	e59f2010 	ldr	r2, [pc, #16]	; 1000b54c <_reswitch+0x10>
    str r0, [r2]
1000b538:	e5820000 	str	r0, [r2]

1000b53c <_reswitch>:
_reswitch:
    ldr r2, =rt_interrupt_to_thread     @ set rt_interrupt_to_thread
1000b53c:	e59f200c 	ldr	r2, [pc, #12]	; 1000b550 <_reswitch+0x14>
    str r1, [r2]
1000b540:	e5821000 	str	r1, [r2]
    bx  lr
1000b544:	e12fff1e 	bx	lr
.globl rt_thread_switch_interrupt_flag
.globl rt_interrupt_from_thread
.globl rt_interrupt_to_thread
.globl rt_hw_context_switch_interrupt
rt_hw_context_switch_interrupt:
    ldr r2, =rt_thread_switch_interrupt_flag
1000b548:	10029eb0 	.word	0x10029eb0
    ldr r3, [r2]
    cmp r3, #1
    beq _reswitch
    mov r3, #1              @ set rt_thread_switch_interrupt_flag to 1
    str r3, [r2]
    ldr r2, =rt_interrupt_from_thread   @ set rt_interrupt_from_thread
1000b54c:	10029eac 	.word	0x10029eac
    str r0, [r2]
_reswitch:
    ldr r2, =rt_interrupt_to_thread     @ set rt_interrupt_to_thread
1000b550:	10029ea8 	.word	0x10029ea8

1000b554 <rt_cpu_get_smp_id>:
 * 2013-07-05     Bernard      the first version
 */

.globl rt_cpu_get_smp_id
rt_cpu_get_smp_id:
    mrc     p15, #0, r0, c0, c0, #5
1000b554:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
    bx      lr
1000b558:	e12fff1e 	bx	lr

1000b55c <rt_cpu_vector_set_base>:

.globl rt_cpu_vector_set_base
rt_cpu_vector_set_base:
    mcr     p15, #0, r0, c12, c0, #0
1000b55c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
    dsb
1000b560:	f57ff04f 	dsb	sy
    bx      lr
1000b564:	e12fff1e 	bx	lr

1000b568 <rt_hw_cpu_dcache_enable>:

.globl rt_hw_cpu_dcache_enable
rt_hw_cpu_dcache_enable:
    mrc     p15, #0, r0, c1, c0, #0
1000b568:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0,  r0, #0x00000004
1000b56c:	e3800004 	orr	r0, r0, #4
    mcr     p15, #0, r0, c1, c0, #0
1000b570:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
1000b574:	e12fff1e 	bx	lr

1000b578 <rt_hw_cpu_icache_enable>:

.globl rt_hw_cpu_icache_enable
rt_hw_cpu_icache_enable:
    mrc     p15, #0, r0, c1, c0, #0
1000b578:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0,  r0, #0x00001000
1000b57c:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, #0, r0, c1, c0, #0
1000b580:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
1000b584:	e12fff1e 	bx	lr

1000b588 <_FLD_MAX_WAY>:
1000b588:	000003ff 	.word	0x000003ff

1000b58c <_FLD_MAX_IDX>:
1000b58c:	000007ff 	.word	0x000007ff

1000b590 <rt_cpu_dcache_clean_flush>:
_FLD_MAX_IDX:
   .word  0x7ff

.globl rt_cpu_dcache_clean_flush
rt_cpu_dcache_clean_flush:
    push    {r4-r11}
1000b590:	e92d0ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp}
    dmb
1000b594:	f57ff05f 	dmb	sy
    mrc     p15, #1, r0, c0, c0, #1  @ read clid register
1000b598:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ands    r3, r0, #0x7000000       @ get level of coherency
1000b59c:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    mov     r3, r3, lsr #23
1000b5a0:	e1a03ba3 	lsr	r3, r3, #23
    beq     finished
1000b5a4:	0a00001a 	beq	1000b614 <finished>
    mov     r10, #0
1000b5a8:	e3a0a000 	mov	sl, #0

1000b5ac <loop1>:
loop1:
    add     r2, r10, r10, lsr #1
1000b5ac:	e08a20aa 	add	r2, sl, sl, lsr #1
    mov     r1, r0, lsr r2
1000b5b0:	e1a01230 	lsr	r1, r0, r2
    and     r1, r1, #7
1000b5b4:	e2011007 	and	r1, r1, #7
    cmp     r1, #2
1000b5b8:	e3510002 	cmp	r1, #2
    blt     skip
1000b5bc:	ba000011 	blt	1000b608 <skip>
    mcr     p15, #2, r10, c0, c0, #0
1000b5c0:	ee40af10 	mcr	15, 2, sl, cr0, cr0, {0}
    isb
1000b5c4:	f57ff06f 	isb	sy
    mrc     p15, #1, r1, c0, c0, #0
1000b5c8:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    and     r2, r1, #7
1000b5cc:	e2012007 	and	r2, r1, #7
    add     r2, r2, #4
1000b5d0:	e2822004 	add	r2, r2, #4
    ldr     r4, _FLD_MAX_WAY
1000b5d4:	e51f4054 	ldr	r4, [pc, #-84]	; 1000b588 <_FLD_MAX_WAY>
    ands    r4, r4, r1, lsr #3
1000b5d8:	e01441a1 	ands	r4, r4, r1, lsr #3
    clz     r5, r4
1000b5dc:	e16f5f14 	clz	r5, r4
    ldr     r7, _FLD_MAX_IDX
1000b5e0:	e51f705c 	ldr	r7, [pc, #-92]	; 1000b58c <_FLD_MAX_IDX>
    ands    r7, r7, r1, lsr #13
1000b5e4:	e01776a1 	ands	r7, r7, r1, lsr #13

1000b5e8 <loop2>:
loop2:
    mov     r9, r4
1000b5e8:	e1a09004 	mov	r9, r4

1000b5ec <loop3>:
loop3:
    orr     r11, r10, r9, lsl r5
1000b5ec:	e18ab519 	orr	fp, sl, r9, lsl r5
    orr     r11, r11, r7, lsl r2
1000b5f0:	e18bb217 	orr	fp, fp, r7, lsl r2
    mcr     p15, #0, r11, c7, c14, #2
1000b5f4:	ee07bf5e 	mcr	15, 0, fp, cr7, cr14, {2}
    subs    r9, r9, #1
1000b5f8:	e2599001 	subs	r9, r9, #1
    bge     loop3
1000b5fc:	aafffffa 	bge	1000b5ec <loop3>
    subs    r7, r7, #1
1000b600:	e2577001 	subs	r7, r7, #1
    bge     loop2
1000b604:	aafffff7 	bge	1000b5e8 <loop2>

1000b608 <skip>:
skip:
    add     r10, r10, #2
1000b608:	e28aa002 	add	sl, sl, #2
    cmp     r3, r10
1000b60c:	e153000a 	cmp	r3, sl
    bgt     loop1
1000b610:	caffffe5 	bgt	1000b5ac <loop1>

1000b614 <finished>:

finished:
    dsb
1000b614:	f57ff04f 	dsb	sy
    isb
1000b618:	f57ff06f 	isb	sy
    pop     {r4-r11}
1000b61c:	e8bd0ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp}
    bx      lr
1000b620:	e12fff1e 	bx	lr

1000b624 <rt_hw_cpu_dcache_disable>:

.globl rt_hw_cpu_dcache_disable
rt_hw_cpu_dcache_disable:
    push    {r4-r11, lr}
1000b624:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bl      rt_cpu_dcache_clean_flush
1000b628:	ebffffd8 	bl	1000b590 <rt_cpu_dcache_clean_flush>
    mrc     p15, #0, r0, c1, c0, #0
1000b62c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0,  r0, #0x00000004
1000b630:	e3c00004 	bic	r0, r0, #4
    mcr     p15, #0, r0, c1, c0, #0
1000b634:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    pop     {r4-r11, lr}
1000b638:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bx      lr
1000b63c:	e12fff1e 	bx	lr

1000b640 <rt_hw_cpu_icache_disable>:

.globl rt_hw_cpu_icache_disable
rt_hw_cpu_icache_disable:
    mrc     p15, #0, r0, c1, c0, #0
1000b640:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0,  r0, #0x00001000
1000b644:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, #0, r0, c1, c0, #0
1000b648:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    bx      lr
1000b64c:	e12fff1e 	bx	lr

1000b650 <rt_cpu_mmu_disable>:

.globl rt_cpu_mmu_disable
rt_cpu_mmu_disable:
    mcr     p15, #0, r0, c8, c7, #0    @ invalidate tlb
1000b650:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    mrc     p15, #0, r0, c1, c0, #0
1000b654:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, r0, #1
1000b658:	e3c00001 	bic	r0, r0, #1
    mcr     p15, #0, r0, c1, c0, #0    @ clear mmu bit
1000b65c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dsb
1000b660:	f57ff04f 	dsb	sy
    bx      lr
1000b664:	e12fff1e 	bx	lr

1000b668 <rt_cpu_mmu_enable>:

.globl rt_cpu_mmu_enable
rt_cpu_mmu_enable:
    mrc     p15, #0, r0, c1, c0, #0
1000b668:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, r0, #0x001
1000b66c:	e3800001 	orr	r0, r0, #1
    mcr     p15, #0, r0, c1, c0, #0    @ set mmu enable bit
1000b670:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
    dsb
1000b674:	f57ff04f 	dsb	sy
    bx      lr
1000b678:	e12fff1e 	bx	lr

1000b67c <rt_cpu_tlb_set>:

.globl rt_cpu_tlb_set
rt_cpu_tlb_set:
    mcr     p15, #0, r0, c2, c0, #0
1000b67c:	ee020f10 	mcr	15, 0, r0, cr2, cr0, {0}
    dmb
1000b680:	f57ff05f 	dmb	sy
    bx      lr
1000b684:	e12fff1e 	bx	lr

1000b688 <_reset>:
.text
/* reset entry */
.globl _reset
_reset:
	/* invalidate SCU */
	ldr	r7, =0xF8F0000C
1000b688:	e59f70ac 	ldr	r7, [pc, #172]	; 1000b73c <stack_setup+0x40>
	ldr	r6, =0xFFFF
1000b68c:	e59f60ac 	ldr	r6, [pc, #172]	; 1000b740 <stack_setup+0x44>
	str	r6, [r7]
1000b690:	e5876000 	str	r6, [r7]

	/* disable MMU */
	mrc	p15, 0, r0, c1, c0, 0		/* read CP15 register 1 */
1000b694:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x1				/* clear bit 0 */
1000b698:	e3c00001 	bic	r0, r0, #1
	mcr	p15, 0, r0, c1, c0, 0		/* write value back */
1000b69c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

    /* set the cpu to SVC32 mode and disable interrupt */
    mrs     r0, cpsr
1000b6a0:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #0x1f
1000b6a4:	e3c0001f 	bic	r0, r0, #31
    orr     r0, r0, #0x13
1000b6a8:	e3800013 	orr	r0, r0, #19
    msr     cpsr_c, r0
1000b6ac:	e121f000 	msr	CPSR_c, r0

    /* setup stack */
    bl      stack_setup
1000b6b0:	eb000011 	bl	1000b6fc <stack_setup>

    /* clear .bss */
    mov     r0,#0                   /* get a zero                       */
1000b6b4:	e3a00000 	mov	r0, #0
    ldr     r1,=__bss_start         /* bss start                        */
1000b6b8:	e59f1084 	ldr	r1, [pc, #132]	; 1000b744 <stack_setup+0x48>
    ldr     r2,=__bss_end           /* bss end                          */
1000b6bc:	e59f2084 	ldr	r2, [pc, #132]	; 1000b748 <stack_setup+0x4c>

1000b6c0 <bss_loop>:

bss_loop:
    cmp     r1,r2                   /* check if data to clear           */
1000b6c0:	e1510002 	cmp	r1, r2
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
1000b6c4:	34810004 	strcc	r0, [r1], #4
    blo     bss_loop                /* loop until done                  */
1000b6c8:	3afffffc 	bcc	1000b6c0 <bss_loop>

    /* call C++ constructors of global objects                          */
    ldr     r0, =__ctors_start__
1000b6cc:	e59f0078 	ldr	r0, [pc, #120]	; 1000b74c <stack_setup+0x50>
    ldr     r1, =__ctors_end__
1000b6d0:	e59f1078 	ldr	r1, [pc, #120]	; 1000b750 <stack_setup+0x54>

1000b6d4 <ctor_loop>:

ctor_loop:
    cmp     r0, r1
1000b6d4:	e1500001 	cmp	r0, r1
    beq     ctor_end
1000b6d8:	0a000005 	beq	1000b6f4 <ctor_end>
    ldr     r2, [r0], #4
1000b6dc:	e4902004 	ldr	r2, [r0], #4
    stmfd   sp!, {r0-r1}
1000b6e0:	e92d0003 	push	{r0, r1}
    mov     lr, pc
1000b6e4:	e1a0e00f 	mov	lr, pc
    bx      r2
1000b6e8:	e12fff12 	bx	r2
    ldmfd   sp!, {r0-r1}
1000b6ec:	e8bd0003 	pop	{r0, r1}
    b       ctor_loop
1000b6f0:	eafffff7 	b	1000b6d4 <ctor_loop>

1000b6f4 <ctor_end>:
ctor_end:

    /* start RT-Thread Kernel       */
    ldr     pc, _rtthread_startup
1000b6f4:	e51ff004 	ldr	pc, [pc, #-4]	; 1000b6f8 <_rtthread_startup>

1000b6f8 <_rtthread_startup>:
1000b6f8:	10000b8c 	.word	0x10000b8c

1000b6fc <stack_setup>:

_rtthread_startup:
    .word rtthread_startup

stack_setup:
    ldr     r0, =stack_top
1000b6fc:	e59f0050 	ldr	r0, [pc, #80]	; 1000b754 <stack_setup+0x58>

    @  Set the startup stack for svc
    mov     sp, r0
1000b700:	e1a0d000 	mov	sp, r0

    @  Enter Undefined Instruction Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_UND|I_Bit|F_Bit
1000b704:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    mov     sp, r0
1000b708:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #UND_Stack_Size
1000b70c:	e2400000 	sub	r0, r0, #0

    @  Enter Abort Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_ABT|I_Bit|F_Bit
1000b710:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    mov     sp, r0
1000b714:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #ABT_Stack_Size
1000b718:	e2400000 	sub	r0, r0, #0

    @  Enter FIQ Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_FIQ|I_Bit|F_Bit
1000b71c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    mov     sp, r0
1000b720:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #FIQ_Stack_Size
1000b724:	e2400c01 	sub	r0, r0, #256	; 0x100

    @  Enter IRQ Mode and set its Stack Pointer
    msr     cpsr_c, #Mode_IRQ|I_Bit|F_Bit
1000b728:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    mov     sp, r0
1000b72c:	e1a0d000 	mov	sp, r0
    sub     r0, r0, #IRQ_Stack_Size
1000b730:	e2400c01 	sub	r0, r0, #256	; 0x100

    @  Switch back to SVC
    msr     cpsr_c, #Mode_SVC|I_Bit|F_Bit
1000b734:	e321f0d3 	msr	CPSR_c, #211	; 0xd3

    bx      lr
1000b738:	e12fff1e 	bx	lr
.text
/* reset entry */
.globl _reset
_reset:
	/* invalidate SCU */
	ldr	r7, =0xF8F0000C
1000b73c:	f8f0000c 	.word	0xf8f0000c
	ldr	r6, =0xFFFF
1000b740:	0000ffff 	.word	0x0000ffff
    /* setup stack */
    bl      stack_setup

    /* clear .bss */
    mov     r0,#0                   /* get a zero                       */
    ldr     r1,=__bss_start         /* bss start                        */
1000b744:	10020ebc 	.word	0x10020ebc
    ldr     r2,=__bss_end           /* bss end                          */
1000b748:	1002aa70 	.word	0x1002aa70
    cmp     r1,r2                   /* check if data to clear           */
    strlo   r0,[r1],#4              /* clear 4 bytes                    */
    blo     bss_loop                /* loop until done                  */

    /* call C++ constructors of global objects                          */
    ldr     r0, =__ctors_start__
1000b74c:	10020998 	.word	0x10020998
    ldr     r1, =__ctors_end__
1000b750:	10020998 	.word	0x10020998

_rtthread_startup:
    .word rtthread_startup

stack_setup:
    ldr     r0, =stack_top
1000b754:	10028c14 	.word	0x10028c14

1000b758 <clock_time_system_init>:
#include <rtthread.h>
#include <pthread.h>

struct timeval _timevalue;
void clock_time_system_init()
{
1000b758:	e92d4800 	push	{fp, lr}
1000b75c:	e28db004 	add	fp, sp, #4
1000b760:	e24dd010 	sub	sp, sp, #16
    time_t time;
    rt_tick_t tick;
    rt_device_t device;

    time = 0;
1000b764:	e3a03000 	mov	r3, #0
1000b768:	e50b3010 	str	r3, [fp, #-16]
    device = rt_device_find("rtc");
1000b76c:	e30f0238 	movw	r0, #62008	; 0xf238
1000b770:	e3410001 	movt	r0, #4097	; 0x1001
1000b774:	ebffd5e6 	bl	10000f14 <rt_device_find>
1000b778:	e50b0008 	str	r0, [fp, #-8]
    if (device != RT_NULL)
1000b77c:	e51b3008 	ldr	r3, [fp, #-8]
1000b780:	e3530000 	cmp	r3, #0
1000b784:	0a000004 	beq	1000b79c <clock_time_system_init+0x44>
    {
        /* get realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_GET_TIME, &time);
1000b788:	e24b3010 	sub	r3, fp, #16
1000b78c:	e51b0008 	ldr	r0, [fp, #-8]
1000b790:	e3a01010 	mov	r1, #16
1000b794:	e1a02003 	mov	r2, r3
1000b798:	ebffd734 	bl	10001470 <rt_device_control>
    }

    /* get tick */
    tick = rt_tick_get();
1000b79c:	ebffd518 	bl	10000c04 <rt_tick_get>
1000b7a0:	e50b000c 	str	r0, [fp, #-12]

    _timevalue.tv_usec = (tick%RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
1000b7a4:	e51b000c 	ldr	r0, [fp, #-12]
1000b7a8:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000b7ac:	e3413062 	movt	r3, #4194	; 0x1062
1000b7b0:	e0832390 	umull	r2, r3, r0, r3
1000b7b4:	e1a02323 	lsr	r2, r3, #6
1000b7b8:	e1a01002 	mov	r1, r2
1000b7bc:	e1a03101 	lsl	r3, r1, #2
1000b7c0:	e1a01003 	mov	r1, r3
1000b7c4:	e1a03281 	lsl	r3, r1, #5
1000b7c8:	e0613003 	rsb	r3, r1, r3
1000b7cc:	e0833002 	add	r3, r3, r2
1000b7d0:	e1a03183 	lsl	r3, r3, #3
1000b7d4:	e0632000 	rsb	r2, r3, r0
1000b7d8:	e1a01002 	mov	r1, r2
1000b7dc:	e1a03101 	lsl	r3, r1, #2
1000b7e0:	e1a01003 	mov	r1, r3
1000b7e4:	e1a03281 	lsl	r3, r1, #5
1000b7e8:	e0613003 	rsb	r3, r1, r3
1000b7ec:	e0833002 	add	r3, r3, r2
1000b7f0:	e1a03183 	lsl	r3, r3, #3
1000b7f4:	e1a02003 	mov	r2, r3
1000b7f8:	e30a360c 	movw	r3, #42508	; 0xa60c
1000b7fc:	e3413002 	movt	r3, #4098	; 0x1002
1000b800:	e5832004 	str	r2, [r3, #4]
    _timevalue.tv_sec = time - tick/RT_TICK_PER_SECOND - 1;
1000b804:	e51b3010 	ldr	r3, [fp, #-16]
1000b808:	e1a01003 	mov	r1, r3
1000b80c:	e51b200c 	ldr	r2, [fp, #-12]
1000b810:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000b814:	e3413062 	movt	r3, #4194	; 0x1062
1000b818:	e0832392 	umull	r2, r3, r2, r3
1000b81c:	e1a03323 	lsr	r3, r3, #6
1000b820:	e0633001 	rsb	r3, r3, r1
1000b824:	e2433001 	sub	r3, r3, #1
1000b828:	e1a02003 	mov	r2, r3
1000b82c:	e30a360c 	movw	r3, #42508	; 0xa60c
1000b830:	e3413002 	movt	r3, #4098	; 0x1002
1000b834:	e5832000 	str	r2, [r3]
}
1000b838:	e24bd004 	sub	sp, fp, #4
1000b83c:	e8bd8800 	pop	{fp, pc}

1000b840 <clock_time_to_tick>:

int clock_time_to_tick(const struct timespec *time)
{
1000b840:	e92d4800 	push	{fp, lr}
1000b844:	e28db004 	add	fp, sp, #4
1000b848:	e24dd020 	sub	sp, sp, #32
1000b84c:	e50b0020 	str	r0, [fp, #-32]
    int tick;
    int nsecond, second;
    struct timespec tp;

    RT_ASSERT(time != RT_NULL);
1000b850:	e51b3020 	ldr	r3, [fp, #-32]
1000b854:	e3530000 	cmp	r3, #0
1000b858:	1a000005 	bne	1000b874 <clock_time_to_tick+0x34>
1000b85c:	e30f023c 	movw	r0, #62012	; 0xf23c
1000b860:	e3410001 	movt	r0, #4097	; 0x1001
1000b864:	e30f124c 	movw	r1, #62028	; 0xf24c
1000b868:	e3411001 	movt	r1, #4097	; 0x1001
1000b86c:	e3a02039 	mov	r2, #57	; 0x39
1000b870:	ebffeb54 	bl	100065c8 <rt_assert_handler>

    tick = RT_WAITING_FOREVER;
1000b874:	e3e03000 	mvn	r3, #0
1000b878:	e50b3008 	str	r3, [fp, #-8]
    if (time != NULL)
1000b87c:	e51b3020 	ldr	r3, [fp, #-32]
1000b880:	e3530000 	cmp	r3, #0
1000b884:	0a000040 	beq	1000b98c <clock_time_to_tick+0x14c>
    {
        /* get current tp */
        clock_gettime(CLOCK_REALTIME, &tp);
1000b888:	e24b3018 	sub	r3, fp, #24
1000b88c:	e3a00001 	mov	r0, #1
1000b890:	e1a01003 	mov	r1, r3
1000b894:	eb00005a 	bl	1000ba04 <clock_gettime>

        if ((time->tv_nsec - tp.tv_nsec) < 0)
1000b898:	e51b3020 	ldr	r3, [fp, #-32]
1000b89c:	e5932004 	ldr	r2, [r3, #4]
1000b8a0:	e51b3014 	ldr	r3, [fp, #-20]
1000b8a4:	e0633002 	rsb	r3, r3, r2
1000b8a8:	e3530000 	cmp	r3, #0
1000b8ac:	aa00000f 	bge	1000b8f0 <clock_time_to_tick+0xb0>
        {
            nsecond = NANOSECOND_PER_SECOND - (tp.tv_nsec - time->tv_nsec);
1000b8b0:	e51b3020 	ldr	r3, [fp, #-32]
1000b8b4:	e5932004 	ldr	r2, [r3, #4]
1000b8b8:	e51b3014 	ldr	r3, [fp, #-20]
1000b8bc:	e0633002 	rsb	r3, r3, r2
1000b8c0:	e1a02003 	mov	r2, r3
1000b8c4:	e3a03cca 	mov	r3, #51712	; 0xca00
1000b8c8:	e3433b9a 	movt	r3, #15258	; 0x3b9a
1000b8cc:	e0823003 	add	r3, r2, r3
1000b8d0:	e50b300c 	str	r3, [fp, #-12]
            second  = time->tv_sec - tp.tv_sec - 1;
1000b8d4:	e51b3020 	ldr	r3, [fp, #-32]
1000b8d8:	e5932000 	ldr	r2, [r3]
1000b8dc:	e51b3018 	ldr	r3, [fp, #-24]
1000b8e0:	e0633002 	rsb	r3, r3, r2
1000b8e4:	e2433001 	sub	r3, r3, #1
1000b8e8:	e50b3010 	str	r3, [fp, #-16]
1000b8ec:	ea000009 	b	1000b918 <clock_time_to_tick+0xd8>
        }
        else
        {
            nsecond = time->tv_nsec - tp.tv_nsec;
1000b8f0:	e51b3020 	ldr	r3, [fp, #-32]
1000b8f4:	e5932004 	ldr	r2, [r3, #4]
1000b8f8:	e51b3014 	ldr	r3, [fp, #-20]
1000b8fc:	e0633002 	rsb	r3, r3, r2
1000b900:	e50b300c 	str	r3, [fp, #-12]
            second  = time->tv_sec - tp.tv_sec;
1000b904:	e51b3020 	ldr	r3, [fp, #-32]
1000b908:	e5932000 	ldr	r2, [r3]
1000b90c:	e51b3018 	ldr	r3, [fp, #-24]
1000b910:	e0633002 	rsb	r3, r3, r2
1000b914:	e50b3010 	str	r3, [fp, #-16]
        }

        tick = second * RT_TICK_PER_SECOND + nsecond * RT_TICK_PER_SECOND / NANOSECOND_PER_SECOND;
1000b918:	e51b1010 	ldr	r1, [fp, #-16]
1000b91c:	e1a02001 	mov	r2, r1
1000b920:	e1a03102 	lsl	r3, r2, #2
1000b924:	e1a02003 	mov	r2, r3
1000b928:	e1a03282 	lsl	r3, r2, #5
1000b92c:	e0623003 	rsb	r3, r2, r3
1000b930:	e0833001 	add	r3, r3, r1
1000b934:	e1a03183 	lsl	r3, r3, #3
1000b938:	e1a00003 	mov	r0, r3
1000b93c:	e51b100c 	ldr	r1, [fp, #-12]
1000b940:	e1a02001 	mov	r2, r1
1000b944:	e1a03102 	lsl	r3, r2, #2
1000b948:	e1a02003 	mov	r2, r3
1000b94c:	e1a03282 	lsl	r3, r2, #5
1000b950:	e0623003 	rsb	r3, r2, r3
1000b954:	e0833001 	add	r3, r3, r1
1000b958:	e1a03183 	lsl	r3, r3, #3
1000b95c:	e1a024a3 	lsr	r2, r3, #9
1000b960:	e3043b83 	movw	r3, #19331	; 0x4b83
1000b964:	e3403004 	movt	r3, #4
1000b968:	e0832392 	umull	r2, r3, r2, r3
1000b96c:	e1a033a3 	lsr	r3, r3, #7
1000b970:	e0803003 	add	r3, r0, r3
1000b974:	e50b3008 	str	r3, [fp, #-8]
        if (tick < 0) tick = 0;
1000b978:	e51b3008 	ldr	r3, [fp, #-8]
1000b97c:	e3530000 	cmp	r3, #0
1000b980:	aa000001 	bge	1000b98c <clock_time_to_tick+0x14c>
1000b984:	e3a03000 	mov	r3, #0
1000b988:	e50b3008 	str	r3, [fp, #-8]
    }

    return tick;
1000b98c:	e51b3008 	ldr	r3, [fp, #-8]
}
1000b990:	e1a00003 	mov	r0, r3
1000b994:	e24bd004 	sub	sp, fp, #4
1000b998:	e8bd8800 	pop	{fp, pc}

1000b99c <clock_getres>:
RTM_EXPORT(clock_time_to_tick);

int clock_getres(clockid_t clockid, struct timespec *res)
{
1000b99c:	e92d4800 	push	{fp, lr}
1000b9a0:	e28db004 	add	fp, sp, #4
1000b9a4:	e24dd008 	sub	sp, sp, #8
1000b9a8:	e50b0008 	str	r0, [fp, #-8]
1000b9ac:	e50b100c 	str	r1, [fp, #-12]
    if ((clockid != CLOCK_REALTIME) || (res == RT_NULL))
1000b9b0:	e51b3008 	ldr	r3, [fp, #-8]
1000b9b4:	e3530001 	cmp	r3, #1
1000b9b8:	1a000002 	bne	1000b9c8 <clock_getres+0x2c>
1000b9bc:	e51b300c 	ldr	r3, [fp, #-12]
1000b9c0:	e3530000 	cmp	r3, #0
1000b9c4:	1a000003 	bne	1000b9d8 <clock_getres+0x3c>
    {
        rt_set_errno(EINVAL);
1000b9c8:	e3a00016 	mov	r0, #22
1000b9cc:	ebffe41e 	bl	10004a4c <rt_set_errno>

        return -1;
1000b9d0:	e3e03000 	mvn	r3, #0
1000b9d4:	ea000007 	b	1000b9f8 <clock_getres+0x5c>
    }

    res->tv_sec = 0;
1000b9d8:	e51b300c 	ldr	r3, [fp, #-12]
1000b9dc:	e3a02000 	mov	r2, #0
1000b9e0:	e5832000 	str	r2, [r3]
    res->tv_nsec = NANOSECOND_PER_SECOND/RT_TICK_PER_SECOND;
1000b9e4:	e51b200c 	ldr	r2, [fp, #-12]
1000b9e8:	e3043240 	movw	r3, #16960	; 0x4240
1000b9ec:	e340300f 	movt	r3, #15
1000b9f0:	e5823004 	str	r3, [r2, #4]

    return 0;
1000b9f4:	e3a03000 	mov	r3, #0
}
1000b9f8:	e1a00003 	mov	r0, r3
1000b9fc:	e24bd004 	sub	sp, fp, #4
1000ba00:	e8bd8800 	pop	{fp, pc}

1000ba04 <clock_gettime>:
RTM_EXPORT(clock_getres);

int clock_gettime(clockid_t clockid, struct timespec *tp)
{
1000ba04:	e92d4800 	push	{fp, lr}
1000ba08:	e28db004 	add	fp, sp, #4
1000ba0c:	e24dd010 	sub	sp, sp, #16
1000ba10:	e50b0010 	str	r0, [fp, #-16]
1000ba14:	e50b1014 	str	r1, [fp, #-20]
    rt_tick_t tick;

    if ((clockid != CLOCK_REALTIME) || (tp == RT_NULL))
1000ba18:	e51b3010 	ldr	r3, [fp, #-16]
1000ba1c:	e3530001 	cmp	r3, #1
1000ba20:	1a000002 	bne	1000ba30 <clock_gettime+0x2c>
1000ba24:	e51b3014 	ldr	r3, [fp, #-20]
1000ba28:	e3530000 	cmp	r3, #0
1000ba2c:	1a000003 	bne	1000ba40 <clock_gettime+0x3c>
    {
        rt_set_errno(EINVAL);
1000ba30:	e3a00016 	mov	r0, #22
1000ba34:	ebffe404 	bl	10004a4c <rt_set_errno>

        return -1;
1000ba38:	e3e03000 	mvn	r3, #0
1000ba3c:	ea00002e 	b	1000bafc <clock_gettime+0xf8>
    }

    /* get tick */
    tick = rt_tick_get();
1000ba40:	ebffd46f 	bl	10000c04 <rt_tick_get>
1000ba44:	e50b0008 	str	r0, [fp, #-8]

    tp->tv_sec = _timevalue.tv_sec + tick / RT_TICK_PER_SECOND;
1000ba48:	e30a360c 	movw	r3, #42508	; 0xa60c
1000ba4c:	e3413002 	movt	r3, #4098	; 0x1002
1000ba50:	e5933000 	ldr	r3, [r3]
1000ba54:	e1a01003 	mov	r1, r3
1000ba58:	e51b2008 	ldr	r2, [fp, #-8]
1000ba5c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000ba60:	e3413062 	movt	r3, #4194	; 0x1062
1000ba64:	e0832392 	umull	r2, r3, r2, r3
1000ba68:	e1a03323 	lsr	r3, r3, #6
1000ba6c:	e0813003 	add	r3, r1, r3
1000ba70:	e1a02003 	mov	r2, r3
1000ba74:	e51b3014 	ldr	r3, [fp, #-20]
1000ba78:	e5832000 	str	r2, [r3]
    tp->tv_nsec = (_timevalue.tv_usec + (tick % RT_TICK_PER_SECOND) * NANOSECOND_PER_TICK) * 1000;
1000ba7c:	e30a360c 	movw	r3, #42508	; 0xa60c
1000ba80:	e3413002 	movt	r3, #4098	; 0x1002
1000ba84:	e5933004 	ldr	r3, [r3, #4]
1000ba88:	e1a0c003 	mov	ip, r3
1000ba8c:	e51b0008 	ldr	r0, [fp, #-8]
1000ba90:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000ba94:	e3413062 	movt	r3, #4194	; 0x1062
1000ba98:	e0832390 	umull	r2, r3, r0, r3
1000ba9c:	e1a02323 	lsr	r2, r3, #6
1000baa0:	e1a01002 	mov	r1, r2
1000baa4:	e1a03101 	lsl	r3, r1, #2
1000baa8:	e1a01003 	mov	r1, r3
1000baac:	e1a03281 	lsl	r3, r1, #5
1000bab0:	e0613003 	rsb	r3, r1, r3
1000bab4:	e0833002 	add	r3, r3, r2
1000bab8:	e1a03183 	lsl	r3, r3, #3
1000babc:	e0632000 	rsb	r2, r3, r0
1000bac0:	e3043240 	movw	r3, #16960	; 0x4240
1000bac4:	e340300f 	movt	r3, #15
1000bac8:	e0030293 	mul	r3, r3, r2
1000bacc:	e08c1003 	add	r1, ip, r3
1000bad0:	e1a02001 	mov	r2, r1
1000bad4:	e1a03102 	lsl	r3, r2, #2
1000bad8:	e1a02003 	mov	r2, r3
1000badc:	e1a03282 	lsl	r3, r2, #5
1000bae0:	e0623003 	rsb	r3, r2, r3
1000bae4:	e0833001 	add	r3, r3, r1
1000bae8:	e1a03183 	lsl	r3, r3, #3
1000baec:	e1a02003 	mov	r2, r3
1000baf0:	e51b3014 	ldr	r3, [fp, #-20]
1000baf4:	e5832004 	str	r2, [r3, #4]
    
    return 0;
1000baf8:	e3a03000 	mov	r3, #0
}
1000bafc:	e1a00003 	mov	r0, r3
1000bb00:	e24bd004 	sub	sp, fp, #4
1000bb04:	e8bd8800 	pop	{fp, pc}

1000bb08 <clock_settime>:
RTM_EXPORT(clock_gettime);

int clock_settime(clockid_t clockid, const struct timespec *tp)
{
1000bb08:	e92d4800 	push	{fp, lr}
1000bb0c:	e28db004 	add	fp, sp, #4
1000bb10:	e24dd018 	sub	sp, sp, #24
1000bb14:	e50b0018 	str	r0, [fp, #-24]
1000bb18:	e50b101c 	str	r1, [fp, #-28]
    int second;
    rt_tick_t tick;
    rt_device_t device;

    if ((clockid != CLOCK_REALTIME) || (tp == RT_NULL))
1000bb1c:	e51b3018 	ldr	r3, [fp, #-24]
1000bb20:	e3530001 	cmp	r3, #1
1000bb24:	1a000002 	bne	1000bb34 <clock_settime+0x2c>
1000bb28:	e51b301c 	ldr	r3, [fp, #-28]
1000bb2c:	e3530000 	cmp	r3, #0
1000bb30:	1a000003 	bne	1000bb44 <clock_settime+0x3c>
    {
        rt_set_errno(EINVAL);
1000bb34:	e3a00016 	mov	r0, #22
1000bb38:	ebffe3c3 	bl	10004a4c <rt_set_errno>

        return -1;
1000bb3c:	e3e03000 	mvn	r3, #0
1000bb40:	ea00003a 	b	1000bc30 <clock_settime+0x128>
    }

    /* get second */
    second = tp->tv_sec;
1000bb44:	e51b301c 	ldr	r3, [fp, #-28]
1000bb48:	e5933000 	ldr	r3, [r3]
1000bb4c:	e50b3010 	str	r3, [fp, #-16]
    /* get tick */
    tick = rt_tick_get();
1000bb50:	ebffd42b 	bl	10000c04 <rt_tick_get>
1000bb54:	e50b0008 	str	r0, [fp, #-8]

    /* update timevalue */
    _timevalue.tv_usec = MICROSECOND_PER_SECOND - (tick % RT_TICK_PER_SECOND) * MICROSECOND_PER_TICK;
1000bb58:	e51b0008 	ldr	r0, [fp, #-8]
1000bb5c:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000bb60:	e3413062 	movt	r3, #4194	; 0x1062
1000bb64:	e0832390 	umull	r2, r3, r0, r3
1000bb68:	e1a02323 	lsr	r2, r3, #6
1000bb6c:	e1a01002 	mov	r1, r2
1000bb70:	e1a03101 	lsl	r3, r1, #2
1000bb74:	e1a01003 	mov	r1, r3
1000bb78:	e1a03281 	lsl	r3, r1, #5
1000bb7c:	e0613003 	rsb	r3, r1, r3
1000bb80:	e0833002 	add	r3, r3, r2
1000bb84:	e1a03183 	lsl	r3, r3, #3
1000bb88:	e0632000 	rsb	r2, r3, r0
1000bb8c:	e1a01002 	mov	r1, r2
1000bb90:	e1a03101 	lsl	r3, r1, #2
1000bb94:	e1a01003 	mov	r1, r3
1000bb98:	e1a03281 	lsl	r3, r1, #5
1000bb9c:	e0613003 	rsb	r3, r1, r3
1000bba0:	e0833002 	add	r3, r3, r2
1000bba4:	e1a03183 	lsl	r3, r3, #3
1000bba8:	e263393d 	rsb	r3, r3, #999424	; 0xf4000
1000bbac:	e2833d09 	add	r3, r3, #576	; 0x240
1000bbb0:	e1a02003 	mov	r2, r3
1000bbb4:	e30a360c 	movw	r3, #42508	; 0xa60c
1000bbb8:	e3413002 	movt	r3, #4098	; 0x1002
1000bbbc:	e5832004 	str	r2, [r3, #4]
    _timevalue.tv_sec = second - tick/RT_TICK_PER_SECOND - 1;
1000bbc0:	e51b3010 	ldr	r3, [fp, #-16]
1000bbc4:	e1a01003 	mov	r1, r3
1000bbc8:	e51b2008 	ldr	r2, [fp, #-8]
1000bbcc:	e3043dd3 	movw	r3, #19923	; 0x4dd3
1000bbd0:	e3413062 	movt	r3, #4194	; 0x1062
1000bbd4:	e0832392 	umull	r2, r3, r2, r3
1000bbd8:	e1a03323 	lsr	r3, r3, #6
1000bbdc:	e0633001 	rsb	r3, r3, r1
1000bbe0:	e2433001 	sub	r3, r3, #1
1000bbe4:	e1a02003 	mov	r2, r3
1000bbe8:	e30a360c 	movw	r3, #42508	; 0xa60c
1000bbec:	e3413002 	movt	r3, #4098	; 0x1002
1000bbf0:	e5832000 	str	r2, [r3]

    /* update for RTC device */
    device = rt_device_find("rtc");
1000bbf4:	e30f0238 	movw	r0, #62008	; 0xf238
1000bbf8:	e3410001 	movt	r0, #4097	; 0x1001
1000bbfc:	ebffd4c4 	bl	10000f14 <rt_device_find>
1000bc00:	e50b000c 	str	r0, [fp, #-12]
    if (device != RT_NULL)
1000bc04:	e51b300c 	ldr	r3, [fp, #-12]
1000bc08:	e3530000 	cmp	r3, #0
1000bc0c:	0a000006 	beq	1000bc2c <clock_settime+0x124>
    {
        /* set realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &second);
1000bc10:	e24b3010 	sub	r3, fp, #16
1000bc14:	e51b000c 	ldr	r0, [fp, #-12]
1000bc18:	e3a01011 	mov	r1, #17
1000bc1c:	e1a02003 	mov	r2, r3
1000bc20:	ebffd612 	bl	10001470 <rt_device_control>
    }
    else
        return -1;

    return 0;
1000bc24:	e3a03000 	mov	r3, #0
1000bc28:	ea000000 	b	1000bc30 <clock_settime+0x128>
    {
        /* set realtime seconds */
        rt_device_control(device, RT_DEVICE_CTRL_RTC_SET_TIME, &second);
    }
    else
        return -1;
1000bc2c:	e3e03000 	mvn	r3, #0

    return 0;
}
1000bc30:	e1a00003 	mov	r0, r3
1000bc34:	e24bd004 	sub	sp, fp, #4
1000bc38:	e8bd8800 	pop	{fp, pc}

1000bc3c <posix_mq_system_init>:
#include "pthread_internal.h"

static mqd_t posix_mq_list = RT_NULL;
static struct rt_semaphore posix_mq_lock;
void posix_mq_system_init()
{
1000bc3c:	e92d4800 	push	{fp, lr}
1000bc40:	e28db004 	add	fp, sp, #4
    rt_sem_init(&posix_mq_lock, "pmq", 1, RT_IPC_FLAG_FIFO);
1000bc44:	e3080c18 	movw	r0, #35864	; 0x8c18
1000bc48:	e3410002 	movt	r0, #4098	; 0x1002
1000bc4c:	e30f1260 	movw	r1, #62048	; 0xf260
1000bc50:	e3411001 	movt	r1, #4097	; 0x1001
1000bc54:	e3a02001 	mov	r2, #1
1000bc58:	e3a03000 	mov	r3, #0
1000bc5c:	ebffd79b 	bl	10001ad0 <rt_sem_init>
}
1000bc60:	e8bd8800 	pop	{fp, pc}

1000bc64 <posix_mq_insert>:

rt_inline void posix_mq_insert(mqd_t pmq)
{
1000bc64:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000bc68:	e28db000 	add	fp, sp, #0
1000bc6c:	e24dd00c 	sub	sp, sp, #12
1000bc70:	e50b0008 	str	r0, [fp, #-8]
    pmq->next = posix_mq_list;
1000bc74:	e3083c14 	movw	r3, #35860	; 0x8c14
1000bc78:	e3413002 	movt	r3, #4098	; 0x1002
1000bc7c:	e5932000 	ldr	r2, [r3]
1000bc80:	e51b3008 	ldr	r3, [fp, #-8]
1000bc84:	e5832008 	str	r2, [r3, #8]
    posix_mq_list = pmq;
1000bc88:	e3083c14 	movw	r3, #35860	; 0x8c14
1000bc8c:	e3413002 	movt	r3, #4098	; 0x1002
1000bc90:	e51b2008 	ldr	r2, [fp, #-8]
1000bc94:	e5832000 	str	r2, [r3]
}
1000bc98:	e24bd000 	sub	sp, fp, #0
1000bc9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000bca0:	e12fff1e 	bx	lr

1000bca4 <posix_mq_delete>:

static void posix_mq_delete(mqd_t pmq)
{
1000bca4:	e92d4800 	push	{fp, lr}
1000bca8:	e28db004 	add	fp, sp, #4
1000bcac:	e24dd010 	sub	sp, sp, #16
1000bcb0:	e50b0010 	str	r0, [fp, #-16]
    mqd_t iter;
    if (posix_mq_list == pmq)
1000bcb4:	e3083c14 	movw	r3, #35860	; 0x8c14
1000bcb8:	e3413002 	movt	r3, #4098	; 0x1002
1000bcbc:	e5932000 	ldr	r2, [r3]
1000bcc0:	e51b3010 	ldr	r3, [fp, #-16]
1000bcc4:	e1520003 	cmp	r2, r3
1000bcc8:	1a00000b 	bne	1000bcfc <posix_mq_delete+0x58>
    {
        posix_mq_list = pmq->next;
1000bccc:	e51b3010 	ldr	r3, [fp, #-16]
1000bcd0:	e5932008 	ldr	r2, [r3, #8]
1000bcd4:	e3083c14 	movw	r3, #35860	; 0x8c14
1000bcd8:	e3413002 	movt	r3, #4098	; 0x1002
1000bcdc:	e5832000 	str	r2, [r3]

        rt_mq_delete(pmq->mq);
1000bce0:	e51b3010 	ldr	r3, [fp, #-16]
1000bce4:	e5933004 	ldr	r3, [r3, #4]
1000bce8:	e1a00003 	mov	r0, r3
1000bcec:	ebffe0aa 	bl	10003f9c <rt_mq_delete>
        rt_free(pmq);
1000bcf0:	e51b0010 	ldr	r0, [fp, #-16]
1000bcf4:	ebffed86 	bl	10007314 <rt_free>

        return;
1000bcf8:	ea000023 	b	1000bd8c <posix_mq_delete+0xe8>
    }
    for (iter = posix_mq_list; iter->next != RT_NULL; iter = iter->next)
1000bcfc:	e3083c14 	movw	r3, #35860	; 0x8c14
1000bd00:	e3413002 	movt	r3, #4098	; 0x1002
1000bd04:	e5933000 	ldr	r3, [r3]
1000bd08:	e50b3008 	str	r3, [fp, #-8]
1000bd0c:	ea00001a 	b	1000bd7c <posix_mq_delete+0xd8>
    {
        if (iter->next == pmq)
1000bd10:	e51b3008 	ldr	r3, [fp, #-8]
1000bd14:	e5932008 	ldr	r2, [r3, #8]
1000bd18:	e51b3010 	ldr	r3, [fp, #-16]
1000bd1c:	e1520003 	cmp	r2, r3
1000bd20:	1a000012 	bne	1000bd70 <posix_mq_delete+0xcc>
        {
            /* delete this mq */
            if (pmq->next != RT_NULL)
1000bd24:	e51b3010 	ldr	r3, [fp, #-16]
1000bd28:	e5933008 	ldr	r3, [r3, #8]
1000bd2c:	e3530000 	cmp	r3, #0
1000bd30:	0a000004 	beq	1000bd48 <posix_mq_delete+0xa4>
                iter->next = pmq->next;
1000bd34:	e51b3010 	ldr	r3, [fp, #-16]
1000bd38:	e5932008 	ldr	r2, [r3, #8]
1000bd3c:	e51b3008 	ldr	r3, [fp, #-8]
1000bd40:	e5832008 	str	r2, [r3, #8]
1000bd44:	ea000002 	b	1000bd54 <posix_mq_delete+0xb0>
            else
                iter->next = RT_NULL;
1000bd48:	e51b3008 	ldr	r3, [fp, #-8]
1000bd4c:	e3a02000 	mov	r2, #0
1000bd50:	e5832008 	str	r2, [r3, #8]

            /* delete RT-Thread mqueue */
            rt_mq_delete(pmq->mq);
1000bd54:	e51b3010 	ldr	r3, [fp, #-16]
1000bd58:	e5933004 	ldr	r3, [r3, #4]
1000bd5c:	e1a00003 	mov	r0, r3
1000bd60:	ebffe08d 	bl	10003f9c <rt_mq_delete>
            rt_free(pmq);
1000bd64:	e51b0010 	ldr	r0, [fp, #-16]
1000bd68:	ebffed69 	bl	10007314 <rt_free>

            return ;
1000bd6c:	ea000006 	b	1000bd8c <posix_mq_delete+0xe8>
        rt_mq_delete(pmq->mq);
        rt_free(pmq);

        return;
    }
    for (iter = posix_mq_list; iter->next != RT_NULL; iter = iter->next)
1000bd70:	e51b3008 	ldr	r3, [fp, #-8]
1000bd74:	e5933008 	ldr	r3, [r3, #8]
1000bd78:	e50b3008 	str	r3, [fp, #-8]
1000bd7c:	e51b3008 	ldr	r3, [fp, #-8]
1000bd80:	e5933008 	ldr	r3, [r3, #8]
1000bd84:	e3530000 	cmp	r3, #0
1000bd88:	1affffe0 	bne	1000bd10 <posix_mq_delete+0x6c>
            rt_free(pmq);

            return ;
        }
    }
}
1000bd8c:	e24bd004 	sub	sp, fp, #4
1000bd90:	e8bd8800 	pop	{fp, pc}

1000bd94 <posix_mq_find>:

static mqd_t posix_mq_find(const char* name)
{
1000bd94:	e92d4800 	push	{fp, lr}
1000bd98:	e28db004 	add	fp, sp, #4
1000bd9c:	e24dd010 	sub	sp, sp, #16
1000bda0:	e50b0010 	str	r0, [fp, #-16]
    mqd_t iter;
    rt_object_t object;

    for (iter = posix_mq_list; iter != RT_NULL; iter = iter->next)
1000bda4:	e3083c14 	movw	r3, #35860	; 0x8c14
1000bda8:	e3413002 	movt	r3, #4098	; 0x1002
1000bdac:	e5933000 	ldr	r3, [r3]
1000bdb0:	e50b3008 	str	r3, [fp, #-8]
1000bdb4:	ea00000f 	b	1000bdf8 <posix_mq_find+0x64>
    {
        object = (rt_object_t)(iter->mq);
1000bdb8:	e51b3008 	ldr	r3, [fp, #-8]
1000bdbc:	e5933004 	ldr	r3, [r3, #4]
1000bdc0:	e50b300c 	str	r3, [fp, #-12]

        if (strncmp(object->name, name, RT_NAME_MAX) == 0)
1000bdc4:	e51b300c 	ldr	r3, [fp, #-12]
1000bdc8:	e1a00003 	mov	r0, r3
1000bdcc:	e51b1010 	ldr	r1, [fp, #-16]
1000bdd0:	e3a02006 	mov	r2, #6
1000bdd4:	fa0047bc 	blx	1001dccc <strncmp>
1000bdd8:	e1a03000 	mov	r3, r0
1000bddc:	e3530000 	cmp	r3, #0
1000bde0:	1a000001 	bne	1000bdec <posix_mq_find+0x58>
        {
            return iter;
1000bde4:	e51b3008 	ldr	r3, [fp, #-8]
1000bde8:	ea000006 	b	1000be08 <posix_mq_find+0x74>
static mqd_t posix_mq_find(const char* name)
{
    mqd_t iter;
    rt_object_t object;

    for (iter = posix_mq_list; iter != RT_NULL; iter = iter->next)
1000bdec:	e51b3008 	ldr	r3, [fp, #-8]
1000bdf0:	e5933008 	ldr	r3, [r3, #8]
1000bdf4:	e50b3008 	str	r3, [fp, #-8]
1000bdf8:	e51b3008 	ldr	r3, [fp, #-8]
1000bdfc:	e3530000 	cmp	r3, #0
1000be00:	1affffec 	bne	1000bdb8 <posix_mq_find+0x24>
        {
            return iter;
        }
    }

    return RT_NULL;
1000be04:	e3a03000 	mov	r3, #0
}
1000be08:	e1a00003 	mov	r0, r3
1000be0c:	e24bd004 	sub	sp, fp, #4
1000be10:	e8bd8800 	pop	{fp, pc}

1000be14 <mq_setattr>:

int mq_setattr(mqd_t                 mqdes,
               const struct mq_attr *mqstat,
               struct mq_attr       *omqstat)
{
1000be14:	e92d4800 	push	{fp, lr}
1000be18:	e28db004 	add	fp, sp, #4
1000be1c:	e24dd010 	sub	sp, sp, #16
1000be20:	e50b0008 	str	r0, [fp, #-8]
1000be24:	e50b100c 	str	r1, [fp, #-12]
1000be28:	e50b2010 	str	r2, [fp, #-16]
    rt_set_errno(-RT_ERROR);
1000be2c:	e3e00000 	mvn	r0, #0
1000be30:	ebffe305 	bl	10004a4c <rt_set_errno>

    return -1;
1000be34:	e3e03000 	mvn	r3, #0
}
1000be38:	e1a00003 	mov	r0, r3
1000be3c:	e24bd004 	sub	sp, fp, #4
1000be40:	e8bd8800 	pop	{fp, pc}

1000be44 <mq_getattr>:
RTM_EXPORT(mq_setattr);

int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat)
{
1000be44:	e92d4800 	push	{fp, lr}
1000be48:	e28db004 	add	fp, sp, #4
1000be4c:	e24dd008 	sub	sp, sp, #8
1000be50:	e50b0008 	str	r0, [fp, #-8]
1000be54:	e50b100c 	str	r1, [fp, #-12]
    if ((mqdes == RT_NULL) || mqstat == RT_NULL)
1000be58:	e51b3008 	ldr	r3, [fp, #-8]
1000be5c:	e3530000 	cmp	r3, #0
1000be60:	0a000002 	beq	1000be70 <mq_getattr+0x2c>
1000be64:	e51b300c 	ldr	r3, [fp, #-12]
1000be68:	e3530000 	cmp	r3, #0
1000be6c:	1a000003 	bne	1000be80 <mq_getattr+0x3c>
    {
        rt_set_errno(EBADF);
1000be70:	e3a00009 	mov	r0, #9
1000be74:	ebffe2f4 	bl	10004a4c <rt_set_errno>

        return -1;
1000be78:	e3e03000 	mvn	r3, #0
1000be7c:	ea000012 	b	1000becc <mq_getattr+0x88>
    }

    mqstat->mq_maxmsg = mqdes->mq->max_msgs;
1000be80:	e51b3008 	ldr	r3, [fp, #-8]
1000be84:	e5933004 	ldr	r3, [r3, #4]
1000be88:	e1d331be 	ldrh	r3, [r3, #30]
1000be8c:	e1a02003 	mov	r2, r3
1000be90:	e51b300c 	ldr	r3, [fp, #-12]
1000be94:	e5832004 	str	r2, [r3, #4]
    mqstat->mq_msgsize = mqdes->mq->msg_size;
1000be98:	e51b3008 	ldr	r3, [fp, #-8]
1000be9c:	e5933004 	ldr	r3, [r3, #4]
1000bea0:	e1d331bc 	ldrh	r3, [r3, #28]
1000bea4:	e1a02003 	mov	r2, r3
1000bea8:	e51b300c 	ldr	r3, [fp, #-12]
1000beac:	e5832008 	str	r2, [r3, #8]
    mqstat->mq_curmsgs = 0;
1000beb0:	e51b300c 	ldr	r3, [fp, #-12]
1000beb4:	e3a02000 	mov	r2, #0
1000beb8:	e583200c 	str	r2, [r3, #12]
    mqstat->mq_flags = 0;
1000bebc:	e51b300c 	ldr	r3, [fp, #-12]
1000bec0:	e3a02000 	mov	r2, #0
1000bec4:	e5832000 	str	r2, [r3]

    return 0;
1000bec8:	e3a03000 	mov	r3, #0
}
1000becc:	e1a00003 	mov	r0, r3
1000bed0:	e24bd004 	sub	sp, fp, #4
1000bed4:	e8bd8800 	pop	{fp, pc}

1000bed8 <mq_open>:
RTM_EXPORT(mq_getattr);

mqd_t mq_open(const char *name, int oflag, ...)
{
1000bed8:	e92d000e 	push	{r1, r2, r3}
1000bedc:	e92d4800 	push	{fp, lr}
1000bee0:	e28db004 	add	fp, sp, #4
1000bee4:	e24dd01c 	sub	sp, sp, #28
1000bee8:	e50b001c 	str	r0, [fp, #-28]
    mqd_t mqdes;
    va_list arg;
    mode_t mode;
    struct mq_attr *attr = RT_NULL;
1000beec:	e3a03000 	mov	r3, #0
1000bef0:	e50b3010 	str	r3, [fp, #-16]

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
1000bef4:	e3080c18 	movw	r0, #35864	; 0x8c18
1000bef8:	e3410002 	movt	r0, #4098	; 0x1002
1000befc:	e3e01000 	mvn	r1, #0
1000bf00:	ebffd789 	bl	10001d2c <rt_sem_take>

    mqdes = RT_NULL;
1000bf04:	e3a03000 	mov	r3, #0
1000bf08:	e50b300c 	str	r3, [fp, #-12]
    if (oflag & O_CREAT)
1000bf0c:	e59b3004 	ldr	r3, [fp, #4]
1000bf10:	e2033c01 	and	r3, r3, #256	; 0x100
1000bf14:	e3530000 	cmp	r3, #0
1000bf18:	0a00003d 	beq	1000c014 <mq_open+0x13c>
    {
        va_start(arg, oflag);
1000bf1c:	e28b3008 	add	r3, fp, #8
1000bf20:	e50b3018 	str	r3, [fp, #-24]
        mode = (mode_t)va_arg(arg, unsigned int);
1000bf24:	e51b3018 	ldr	r3, [fp, #-24]
1000bf28:	e2832004 	add	r2, r3, #4
1000bf2c:	e50b2018 	str	r2, [fp, #-24]
1000bf30:	e5933000 	ldr	r3, [r3]
1000bf34:	e50b3014 	str	r3, [fp, #-20]
        mode = mode;
        attr = (struct mq_attr *)va_arg(arg, struct mq_attr *);
1000bf38:	e51b3018 	ldr	r3, [fp, #-24]
1000bf3c:	e2832004 	add	r2, r3, #4
1000bf40:	e50b2018 	str	r2, [fp, #-24]
1000bf44:	e5933000 	ldr	r3, [r3]
1000bf48:	e50b3010 	str	r3, [fp, #-16]
        va_end(arg);

        if (oflag & O_EXCL)
1000bf4c:	e59b3004 	ldr	r3, [fp, #4]
1000bf50:	e2033c02 	and	r3, r3, #512	; 0x200
1000bf54:	e3530000 	cmp	r3, #0
1000bf58:	0a000007 	beq	1000bf7c <mq_open+0xa4>
        {
            if (posix_mq_find(name) != RT_NULL)
1000bf5c:	e51b001c 	ldr	r0, [fp, #-28]
1000bf60:	ebffff8b 	bl	1000bd94 <posix_mq_find>
1000bf64:	e1a03000 	mov	r3, r0
1000bf68:	e3530000 	cmp	r3, #0
1000bf6c:	0a000002 	beq	1000bf7c <mq_open+0xa4>
            {
                rt_set_errno(EEXIST);
1000bf70:	e3a00011 	mov	r0, #17
1000bf74:	ebffe2b4 	bl	10004a4c <rt_set_errno>
                goto __return;
1000bf78:	ea00003a 	b	1000c068 <mq_open+0x190>
            }
        }
        mqdes = (mqd_t) rt_malloc (sizeof(struct mqdes));
1000bf7c:	e3a0000c 	mov	r0, #12
1000bf80:	ebffeac8 	bl	10006aa8 <rt_malloc>
1000bf84:	e50b000c 	str	r0, [fp, #-12]
        if (mqdes == RT_NULL)
1000bf88:	e51b300c 	ldr	r3, [fp, #-12]
1000bf8c:	e3530000 	cmp	r3, #0
1000bf90:	1a000002 	bne	1000bfa0 <mq_open+0xc8>
        {
            rt_set_errno(ENFILE);
1000bf94:	e3a00017 	mov	r0, #23
1000bf98:	ebffe2ab 	bl	10004a4c <rt_set_errno>
            goto __return;
1000bf9c:	ea000031 	b	1000c068 <mq_open+0x190>
        }

        /* create RT-Thread message queue */
        mqdes->mq = rt_mq_create(name, attr->mq_msgsize, attr->mq_maxmsg, RT_IPC_FLAG_FIFO);
1000bfa0:	e51b3010 	ldr	r3, [fp, #-16]
1000bfa4:	e5933008 	ldr	r3, [r3, #8]
1000bfa8:	e1a02003 	mov	r2, r3
1000bfac:	e51b3010 	ldr	r3, [fp, #-16]
1000bfb0:	e5933004 	ldr	r3, [r3, #4]
1000bfb4:	e51b001c 	ldr	r0, [fp, #-28]
1000bfb8:	e1a01002 	mov	r1, r2
1000bfbc:	e1a02003 	mov	r2, r3
1000bfc0:	e3a03000 	mov	r3, #0
1000bfc4:	ebffdf85 	bl	10003de0 <rt_mq_create>
1000bfc8:	e1a02000 	mov	r2, r0
1000bfcc:	e51b300c 	ldr	r3, [fp, #-12]
1000bfd0:	e5832004 	str	r2, [r3, #4]
        if (mqdes->mq == RT_NULL) /* create failed */
1000bfd4:	e51b300c 	ldr	r3, [fp, #-12]
1000bfd8:	e5933004 	ldr	r3, [r3, #4]
1000bfdc:	e3530000 	cmp	r3, #0
1000bfe0:	1a000002 	bne	1000bff0 <mq_open+0x118>
        {
            rt_set_errno(ENFILE);
1000bfe4:	e3a00017 	mov	r0, #23
1000bfe8:	ebffe297 	bl	10004a4c <rt_set_errno>
            goto __return;
1000bfec:	ea00001d 	b	1000c068 <mq_open+0x190>
        }
        /* initialize reference count */
        mqdes->refcount = 1;
1000bff0:	e51b300c 	ldr	r3, [fp, #-12]
1000bff4:	e3a02001 	mov	r2, #1
1000bff8:	e1c320b0 	strh	r2, [r3]
        mqdes->unlinked = 0;
1000bffc:	e51b300c 	ldr	r3, [fp, #-12]
1000c000:	e3a02000 	mov	r2, #0
1000c004:	e1c320b2 	strh	r2, [r3, #2]

        /* insert mq to posix mq list */
        posix_mq_insert(mqdes);
1000c008:	e51b000c 	ldr	r0, [fp, #-12]
1000c00c:	ebffff14 	bl	1000bc64 <posix_mq_insert>
1000c010:	ea00000f 	b	1000c054 <mq_open+0x17c>
    }
    else
    {
        /* find mqueue */
        mqdes = posix_mq_find(name);
1000c014:	e51b001c 	ldr	r0, [fp, #-28]
1000c018:	ebffff5d 	bl	1000bd94 <posix_mq_find>
1000c01c:	e50b000c 	str	r0, [fp, #-12]
        if (mqdes != RT_NULL)
1000c020:	e51b300c 	ldr	r3, [fp, #-12]
1000c024:	e3530000 	cmp	r3, #0
1000c028:	0a000006 	beq	1000c048 <mq_open+0x170>
        {
            mqdes->refcount ++; /* increase reference count */
1000c02c:	e51b300c 	ldr	r3, [fp, #-12]
1000c030:	e1d330b0 	ldrh	r3, [r3]
1000c034:	e2833001 	add	r3, r3, #1
1000c038:	e6ff2073 	uxth	r2, r3
1000c03c:	e51b300c 	ldr	r3, [fp, #-12]
1000c040:	e1c320b0 	strh	r2, [r3]
1000c044:	ea000002 	b	1000c054 <mq_open+0x17c>
        }
        else
        {
            rt_set_errno(ENOENT);
1000c048:	e3a00002 	mov	r0, #2
1000c04c:	ebffe27e 	bl	10004a4c <rt_set_errno>
            goto __return;
1000c050:	ea000004 	b	1000c068 <mq_open+0x190>
        }
    }
    rt_sem_release(&posix_mq_lock);
1000c054:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c058:	e3410002 	movt	r0, #4098	; 0x1002
1000c05c:	ebffd7c6 	bl	10001f7c <rt_sem_release>

    return mqdes;
1000c060:	e51b300c 	ldr	r3, [fp, #-12]
1000c064:	ea000010 	b	1000c0ac <mq_open+0x1d4>

__return:
    /* release lock */
    rt_sem_release(&posix_mq_lock);
1000c068:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c06c:	e3410002 	movt	r0, #4098	; 0x1002
1000c070:	ebffd7c1 	bl	10001f7c <rt_sem_release>

    /* release allocated memory */
    if (mqdes != RT_NULL)
1000c074:	e51b300c 	ldr	r3, [fp, #-12]
1000c078:	e3530000 	cmp	r3, #0
1000c07c:	0a000009 	beq	1000c0a8 <mq_open+0x1d0>
    {
        if (mqdes->mq != RT_NULL)
1000c080:	e51b300c 	ldr	r3, [fp, #-12]
1000c084:	e5933004 	ldr	r3, [r3, #4]
1000c088:	e3530000 	cmp	r3, #0
1000c08c:	0a000003 	beq	1000c0a0 <mq_open+0x1c8>
        {
            /* delete RT-Thread message queue */
            rt_mq_delete(mqdes->mq);
1000c090:	e51b300c 	ldr	r3, [fp, #-12]
1000c094:	e5933004 	ldr	r3, [r3, #4]
1000c098:	e1a00003 	mov	r0, r3
1000c09c:	ebffdfbe 	bl	10003f9c <rt_mq_delete>
        }
        rt_free(mqdes);
1000c0a0:	e51b000c 	ldr	r0, [fp, #-12]
1000c0a4:	ebffec9a 	bl	10007314 <rt_free>
    }
    return RT_NULL;
1000c0a8:	e3a03000 	mov	r3, #0
}
1000c0ac:	e1a00003 	mov	r0, r3
1000c0b0:	e24bd004 	sub	sp, fp, #4
1000c0b4:	e8bd4800 	pop	{fp, lr}
1000c0b8:	e28dd00c 	add	sp, sp, #12
1000c0bc:	e12fff1e 	bx	lr

1000c0c0 <mq_receive>:
RTM_EXPORT(mq_open);

ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio)
{
1000c0c0:	e92d4800 	push	{fp, lr}
1000c0c4:	e28db004 	add	fp, sp, #4
1000c0c8:	e24dd018 	sub	sp, sp, #24
1000c0cc:	e50b0010 	str	r0, [fp, #-16]
1000c0d0:	e50b1014 	str	r1, [fp, #-20]
1000c0d4:	e50b2018 	str	r2, [fp, #-24]
1000c0d8:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result;

    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
1000c0dc:	e51b3010 	ldr	r3, [fp, #-16]
1000c0e0:	e3530000 	cmp	r3, #0
1000c0e4:	0a000002 	beq	1000c0f4 <mq_receive+0x34>
1000c0e8:	e51b3014 	ldr	r3, [fp, #-20]
1000c0ec:	e3530000 	cmp	r3, #0
1000c0f0:	1a000003 	bne	1000c104 <mq_receive+0x44>
    {
        rt_set_errno(EINVAL);
1000c0f4:	e3a00016 	mov	r0, #22
1000c0f8:	ebffe253 	bl	10004a4c <rt_set_errno>

        return -1;
1000c0fc:	e3e03000 	mvn	r3, #0
1000c100:	ea00000f 	b	1000c144 <mq_receive+0x84>
    }

    result = rt_mq_recv(mqdes->mq, msg_ptr, msg_len, RT_WAITING_FOREVER);
1000c104:	e51b3010 	ldr	r3, [fp, #-16]
1000c108:	e5933004 	ldr	r3, [r3, #4]
1000c10c:	e1a00003 	mov	r0, r3
1000c110:	e51b1014 	ldr	r1, [fp, #-20]
1000c114:	e51b2018 	ldr	r2, [fp, #-24]
1000c118:	e3e03000 	mvn	r3, #0
1000c11c:	ebffe0d0 	bl	10004464 <rt_mq_recv>
1000c120:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1000c124:	e51b3008 	ldr	r3, [fp, #-8]
1000c128:	e3530000 	cmp	r3, #0
1000c12c:	1a000001 	bne	1000c138 <mq_receive+0x78>
        return msg_len;
1000c130:	e51b3018 	ldr	r3, [fp, #-24]
1000c134:	ea000002 	b	1000c144 <mq_receive+0x84>

    rt_set_errno(EBADF);
1000c138:	e3a00009 	mov	r0, #9
1000c13c:	ebffe242 	bl	10004a4c <rt_set_errno>
    return -1;
1000c140:	e3e03000 	mvn	r3, #0
}
1000c144:	e1a00003 	mov	r0, r3
1000c148:	e24bd004 	sub	sp, fp, #4
1000c14c:	e8bd8800 	pop	{fp, pc}

1000c150 <mq_send>:
RTM_EXPORT(mq_receive);

int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio)
{
1000c150:	e92d4800 	push	{fp, lr}
1000c154:	e28db004 	add	fp, sp, #4
1000c158:	e24dd018 	sub	sp, sp, #24
1000c15c:	e50b0010 	str	r0, [fp, #-16]
1000c160:	e50b1014 	str	r1, [fp, #-20]
1000c164:	e50b2018 	str	r2, [fp, #-24]
1000c168:	e50b301c 	str	r3, [fp, #-28]
    rt_err_t result;

    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
1000c16c:	e51b3010 	ldr	r3, [fp, #-16]
1000c170:	e3530000 	cmp	r3, #0
1000c174:	0a000002 	beq	1000c184 <mq_send+0x34>
1000c178:	e51b3014 	ldr	r3, [fp, #-20]
1000c17c:	e3530000 	cmp	r3, #0
1000c180:	1a000003 	bne	1000c194 <mq_send+0x44>
    {
        rt_set_errno(EINVAL);
1000c184:	e3a00016 	mov	r0, #22
1000c188:	ebffe22f 	bl	10004a4c <rt_set_errno>

        return -1;
1000c18c:	e3e03000 	mvn	r3, #0
1000c190:	ea00000e 	b	1000c1d0 <mq_send+0x80>
    }

    result = rt_mq_send(mqdes->mq, (void*)msg_ptr, msg_len);
1000c194:	e51b3010 	ldr	r3, [fp, #-16]
1000c198:	e5933004 	ldr	r3, [r3, #4]
1000c19c:	e1a00003 	mov	r0, r3
1000c1a0:	e51b1014 	ldr	r1, [fp, #-20]
1000c1a4:	e51b2018 	ldr	r2, [fp, #-24]
1000c1a8:	ebffdfaa 	bl	10004058 <rt_mq_send>
1000c1ac:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1000c1b0:	e51b3008 	ldr	r3, [fp, #-8]
1000c1b4:	e3530000 	cmp	r3, #0
1000c1b8:	1a000001 	bne	1000c1c4 <mq_send+0x74>
        return 0;
1000c1bc:	e3a03000 	mov	r3, #0
1000c1c0:	ea000002 	b	1000c1d0 <mq_send+0x80>

    rt_set_errno(EBADF);
1000c1c4:	e3a00009 	mov	r0, #9
1000c1c8:	ebffe21f 	bl	10004a4c <rt_set_errno>

    return -1;
1000c1cc:	e3e03000 	mvn	r3, #0
}
1000c1d0:	e1a00003 	mov	r0, r3
1000c1d4:	e24bd004 	sub	sp, fp, #4
1000c1d8:	e8bd8800 	pop	{fp, pc}

1000c1dc <mq_timedreceive>:
ssize_t mq_timedreceive(mqd_t                  mqdes,
                        char                  *msg_ptr,
                        size_t                 msg_len,
                        unsigned              *msg_prio,
                        const struct timespec *abs_timeout)
{
1000c1dc:	e92d4800 	push	{fp, lr}
1000c1e0:	e28db004 	add	fp, sp, #4
1000c1e4:	e24dd018 	sub	sp, sp, #24
1000c1e8:	e50b0010 	str	r0, [fp, #-16]
1000c1ec:	e50b1014 	str	r1, [fp, #-20]
1000c1f0:	e50b2018 	str	r2, [fp, #-24]
1000c1f4:	e50b301c 	str	r3, [fp, #-28]
    int tick;
    rt_err_t result;

    /* parameters check */
    if ((mqdes == RT_NULL) || (msg_ptr == RT_NULL))
1000c1f8:	e51b3010 	ldr	r3, [fp, #-16]
1000c1fc:	e3530000 	cmp	r3, #0
1000c200:	0a000002 	beq	1000c210 <mq_timedreceive+0x34>
1000c204:	e51b3014 	ldr	r3, [fp, #-20]
1000c208:	e3530000 	cmp	r3, #0
1000c20c:	1a000003 	bne	1000c220 <mq_timedreceive+0x44>
    {
        rt_set_errno(EINVAL);
1000c210:	e3a00016 	mov	r0, #22
1000c214:	ebffe20c 	bl	10004a4c <rt_set_errno>

        return -1;
1000c218:	e3e03000 	mvn	r3, #0
1000c21c:	ea000018 	b	1000c284 <mq_timedreceive+0xa8>
    }

    tick = clock_time_to_tick(abs_timeout);
1000c220:	e59b0004 	ldr	r0, [fp, #4]
1000c224:	ebfffd85 	bl	1000b840 <clock_time_to_tick>
1000c228:	e50b0008 	str	r0, [fp, #-8]

    result = rt_mq_recv(mqdes->mq, msg_ptr, msg_len, tick);
1000c22c:	e51b3010 	ldr	r3, [fp, #-16]
1000c230:	e5933004 	ldr	r3, [r3, #4]
1000c234:	e1a00003 	mov	r0, r3
1000c238:	e51b1014 	ldr	r1, [fp, #-20]
1000c23c:	e51b2018 	ldr	r2, [fp, #-24]
1000c240:	e51b3008 	ldr	r3, [fp, #-8]
1000c244:	ebffe086 	bl	10004464 <rt_mq_recv>
1000c248:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
1000c24c:	e51b300c 	ldr	r3, [fp, #-12]
1000c250:	e3530000 	cmp	r3, #0
1000c254:	1a000001 	bne	1000c260 <mq_timedreceive+0x84>
        return msg_len;
1000c258:	e51b3018 	ldr	r3, [fp, #-24]
1000c25c:	ea000008 	b	1000c284 <mq_timedreceive+0xa8>

    if (result == -RT_ETIMEOUT)
1000c260:	e51b300c 	ldr	r3, [fp, #-12]
1000c264:	e3730002 	cmn	r3, #2
1000c268:	1a000002 	bne	1000c278 <mq_timedreceive+0x9c>
        rt_set_errno(ETIMEDOUT);
1000c26c:	e3a00074 	mov	r0, #116	; 0x74
1000c270:	ebffe1f5 	bl	10004a4c <rt_set_errno>
1000c274:	ea000001 	b	1000c280 <mq_timedreceive+0xa4>
    else
        rt_set_errno(EBADMSG);
1000c278:	e3a0004d 	mov	r0, #77	; 0x4d
1000c27c:	ebffe1f2 	bl	10004a4c <rt_set_errno>

    return -1;
1000c280:	e3e03000 	mvn	r3, #0
}
1000c284:	e1a00003 	mov	r0, r3
1000c288:	e24bd004 	sub	sp, fp, #4
1000c28c:	e8bd8800 	pop	{fp, pc}

1000c290 <mq_timedsend>:
int mq_timedsend(mqd_t                  mqdes,
                 const char            *msg_ptr,
                 size_t                 msg_len,
                 unsigned               msg_prio,
                 const struct timespec *abs_timeout)
{
1000c290:	e92d4800 	push	{fp, lr}
1000c294:	e28db004 	add	fp, sp, #4
1000c298:	e24dd010 	sub	sp, sp, #16
1000c29c:	e50b0008 	str	r0, [fp, #-8]
1000c2a0:	e50b100c 	str	r1, [fp, #-12]
1000c2a4:	e50b2010 	str	r2, [fp, #-16]
1000c2a8:	e50b3014 	str	r3, [fp, #-20]
    /* RT-Thread does not support timed send */
    return mq_send(mqdes, msg_ptr, msg_len, msg_prio);
1000c2ac:	e51b0008 	ldr	r0, [fp, #-8]
1000c2b0:	e51b100c 	ldr	r1, [fp, #-12]
1000c2b4:	e51b2010 	ldr	r2, [fp, #-16]
1000c2b8:	e51b3014 	ldr	r3, [fp, #-20]
1000c2bc:	ebffffa3 	bl	1000c150 <mq_send>
1000c2c0:	e1a03000 	mov	r3, r0
}
1000c2c4:	e1a00003 	mov	r0, r3
1000c2c8:	e24bd004 	sub	sp, fp, #4
1000c2cc:	e8bd8800 	pop	{fp, pc}

1000c2d0 <mq_notify>:
RTM_EXPORT(mq_timedsend);

int mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
1000c2d0:	e92d4800 	push	{fp, lr}
1000c2d4:	e28db004 	add	fp, sp, #4
1000c2d8:	e24dd008 	sub	sp, sp, #8
1000c2dc:	e50b0008 	str	r0, [fp, #-8]
1000c2e0:	e50b100c 	str	r1, [fp, #-12]
    rt_set_errno(-RT_ERROR);
1000c2e4:	e3e00000 	mvn	r0, #0
1000c2e8:	ebffe1d7 	bl	10004a4c <rt_set_errno>

    return -1;
1000c2ec:	e3e03000 	mvn	r3, #0
}
1000c2f0:	e1a00003 	mov	r0, r3
1000c2f4:	e24bd004 	sub	sp, fp, #4
1000c2f8:	e8bd8800 	pop	{fp, pc}

1000c2fc <mq_close>:
RTM_EXPORT(mq_notify);

int mq_close(mqd_t mqdes)
{
1000c2fc:	e92d4800 	push	{fp, lr}
1000c300:	e28db004 	add	fp, sp, #4
1000c304:	e24dd008 	sub	sp, sp, #8
1000c308:	e50b0008 	str	r0, [fp, #-8]
    if (mqdes == RT_NULL)
1000c30c:	e51b3008 	ldr	r3, [fp, #-8]
1000c310:	e3530000 	cmp	r3, #0
1000c314:	1a000003 	bne	1000c328 <mq_close+0x2c>
    {
        rt_set_errno(EINVAL);
1000c318:	e3a00016 	mov	r0, #22
1000c31c:	ebffe1ca 	bl	10004a4c <rt_set_errno>

        return -1;
1000c320:	e3e03000 	mvn	r3, #0
1000c324:	ea000017 	b	1000c388 <mq_close+0x8c>
    }

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
1000c328:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c32c:	e3410002 	movt	r0, #4098	; 0x1002
1000c330:	e3e01000 	mvn	r1, #0
1000c334:	ebffd67c 	bl	10001d2c <rt_sem_take>
    mqdes->refcount --;
1000c338:	e51b3008 	ldr	r3, [fp, #-8]
1000c33c:	e1d330b0 	ldrh	r3, [r3]
1000c340:	e2433001 	sub	r3, r3, #1
1000c344:	e6ff2073 	uxth	r2, r3
1000c348:	e51b3008 	ldr	r3, [fp, #-8]
1000c34c:	e1c320b0 	strh	r2, [r3]
    if (mqdes->refcount == 0)
1000c350:	e51b3008 	ldr	r3, [fp, #-8]
1000c354:	e1d330b0 	ldrh	r3, [r3]
1000c358:	e3530000 	cmp	r3, #0
1000c35c:	1a000005 	bne	1000c378 <mq_close+0x7c>
    {
        /* delete from posix mqueue list */
        if (mqdes->unlinked)
1000c360:	e51b3008 	ldr	r3, [fp, #-8]
1000c364:	e1d330b2 	ldrh	r3, [r3, #2]
1000c368:	e3530000 	cmp	r3, #0
1000c36c:	0a000001 	beq	1000c378 <mq_close+0x7c>
            posix_mq_delete(mqdes);
1000c370:	e51b0008 	ldr	r0, [fp, #-8]
1000c374:	ebfffe4a 	bl	1000bca4 <posix_mq_delete>
    }
    rt_sem_release(&posix_mq_lock);
1000c378:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c37c:	e3410002 	movt	r0, #4098	; 0x1002
1000c380:	ebffd6fd 	bl	10001f7c <rt_sem_release>

    return 0;
1000c384:	e3a03000 	mov	r3, #0
}
1000c388:	e1a00003 	mov	r0, r3
1000c38c:	e24bd004 	sub	sp, fp, #4
1000c390:	e8bd8800 	pop	{fp, pc}

1000c394 <mq_unlink>:
RTM_EXPORT(mq_close);

int mq_unlink(const char *name)
{
1000c394:	e92d4800 	push	{fp, lr}
1000c398:	e28db004 	add	fp, sp, #4
1000c39c:	e24dd010 	sub	sp, sp, #16
1000c3a0:	e50b0010 	str	r0, [fp, #-16]
    mqd_t pmq;

    /* lock posix mqueue list */
    rt_sem_take(&posix_mq_lock, RT_WAITING_FOREVER);
1000c3a4:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c3a8:	e3410002 	movt	r0, #4098	; 0x1002
1000c3ac:	e3e01000 	mvn	r1, #0
1000c3b0:	ebffd65d 	bl	10001d2c <rt_sem_take>
    pmq = posix_mq_find(name);
1000c3b4:	e51b0010 	ldr	r0, [fp, #-16]
1000c3b8:	ebfffe75 	bl	1000bd94 <posix_mq_find>
1000c3bc:	e50b0008 	str	r0, [fp, #-8]
    if (pmq != RT_NULL)
1000c3c0:	e51b3008 	ldr	r3, [fp, #-8]
1000c3c4:	e3530000 	cmp	r3, #0
1000c3c8:	0a00000d 	beq	1000c404 <mq_unlink+0x70>
    {
        pmq->unlinked = 1;
1000c3cc:	e51b3008 	ldr	r3, [fp, #-8]
1000c3d0:	e3a02001 	mov	r2, #1
1000c3d4:	e1c320b2 	strh	r2, [r3, #2]
        if (pmq->refcount == 0)
1000c3d8:	e51b3008 	ldr	r3, [fp, #-8]
1000c3dc:	e1d330b0 	ldrh	r3, [r3]
1000c3e0:	e3530000 	cmp	r3, #0
1000c3e4:	1a000001 	bne	1000c3f0 <mq_unlink+0x5c>
        {
            /* remove this mqueue */
            posix_mq_delete(pmq);
1000c3e8:	e51b0008 	ldr	r0, [fp, #-8]
1000c3ec:	ebfffe2c 	bl	1000bca4 <posix_mq_delete>
        }
        rt_sem_release(&posix_mq_lock);
1000c3f0:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c3f4:	e3410002 	movt	r0, #4098	; 0x1002
1000c3f8:	ebffd6df 	bl	10001f7c <rt_sem_release>

        return 0;
1000c3fc:	e3a03000 	mov	r3, #0
1000c400:	ea000005 	b	1000c41c <mq_unlink+0x88>
    }
    rt_sem_release(&posix_mq_lock);
1000c404:	e3080c18 	movw	r0, #35864	; 0x8c18
1000c408:	e3410002 	movt	r0, #4098	; 0x1002
1000c40c:	ebffd6da 	bl	10001f7c <rt_sem_release>

    /* no this entry */
    rt_set_errno(ENOENT);
1000c410:	e3a00002 	mov	r0, #2
1000c414:	ebffe18c 	bl	10004a4c <rt_set_errno>

    return -1;
1000c418:	e3e03000 	mvn	r3, #0
}
1000c41c:	e1a00003 	mov	r0, r3
1000c420:	e24bd004 	sub	sp, fp, #4
1000c424:	e8bd8800 	pop	{fp, pc}

1000c428 <_pthread_get_data>:
    void** tls; /* thread-local storage area */
};
typedef struct _pthread_data _pthread_data_t;

rt_inline _pthread_data_t *_pthread_get_data(pthread_t thread)
{
1000c428:	e92d4800 	push	{fp, lr}
1000c42c:	e28db004 	add	fp, sp, #4
1000c430:	e24dd010 	sub	sp, sp, #16
1000c434:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    RT_ASSERT(thread != RT_NULL);
1000c438:	e51b3010 	ldr	r3, [fp, #-16]
1000c43c:	e3530000 	cmp	r3, #0
1000c440:	1a000005 	bne	1000c45c <_pthread_get_data+0x34>
1000c444:	e30f0264 	movw	r0, #62052	; 0xf264
1000c448:	e3410001 	movt	r0, #4097	; 0x1001
1000c44c:	e30f12ec 	movw	r1, #62188	; 0xf2ec
1000c450:	e3411001 	movt	r1, #4097	; 0x1001
1000c454:	e3a0204c 	mov	r2, #76	; 0x4c
1000c458:	ebffe85a 	bl	100065c8 <rt_assert_handler>

    ptd = (_pthread_data_t *)thread->user_data;
1000c45c:	e51b3010 	ldr	r3, [fp, #-16]
1000c460:	e5933074 	ldr	r3, [r3, #116]	; 0x74
1000c464:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000c468:	e51b3008 	ldr	r3, [fp, #-8]
1000c46c:	e3530000 	cmp	r3, #0
1000c470:	1a000005 	bne	1000c48c <_pthread_get_data+0x64>
1000c474:	e30f0278 	movw	r0, #62072	; 0xf278
1000c478:	e3410001 	movt	r0, #4097	; 0x1001
1000c47c:	e30f12ec 	movw	r1, #62188	; 0xf2ec
1000c480:	e3411001 	movt	r1, #4097	; 0x1001
1000c484:	e3a0204f 	mov	r2, #79	; 0x4f
1000c488:	ebffe84e 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(ptd->magic == PTHREAD_MAGIC);
1000c48c:	e51b3008 	ldr	r3, [fp, #-8]
1000c490:	e5932000 	ldr	r2, [r3]
1000c494:	e3063873 	movw	r3, #26739	; 0x6873
1000c498:	e3473074 	movt	r3, #28788	; 0x7074
1000c49c:	e1520003 	cmp	r2, r3
1000c4a0:	0a000005 	beq	1000c4bc <_pthread_get_data+0x94>
1000c4a4:	e30f0288 	movw	r0, #62088	; 0xf288
1000c4a8:	e3410001 	movt	r0, #4097	; 0x1001
1000c4ac:	e30f12ec 	movw	r1, #62188	; 0xf2ec
1000c4b0:	e3411001 	movt	r1, #4097	; 0x1001
1000c4b4:	e3a02050 	mov	r2, #80	; 0x50
1000c4b8:	ebffe842 	bl	100065c8 <rt_assert_handler>

    return ptd;
1000c4bc:	e51b3008 	ldr	r3, [fp, #-8]
}
1000c4c0:	e1a00003 	mov	r0, r3
1000c4c4:	e24bd004 	sub	sp, fp, #4
1000c4c8:	e8bd8800 	pop	{fp, pc}

1000c4cc <pthread_system_init>:
#include <pthread.h>
#include <sched.h>
#include "pthread_internal.h"

int pthread_system_init(void)
{
1000c4cc:	e92d4800 	push	{fp, lr}
1000c4d0:	e28db004 	add	fp, sp, #4
    /* initialize clock and time */
    clock_time_system_init();
1000c4d4:	ebfffc9f 	bl	1000b758 <clock_time_system_init>

    /* initialize key area */
    pthread_key_system_init();
1000c4d8:	eb0004c6 	bl	1000d7f8 <pthread_key_system_init>
    /* initialize posix mqueue */
    posix_mq_system_init();
1000c4dc:	ebfffdd6 	bl	1000bc3c <posix_mq_system_init>
    /* initialize posix semaphore */
    posix_sem_system_init();
1000c4e0:	eb000571 	bl	1000daac <posix_sem_system_init>

    return 0;
1000c4e4:	e3a03000 	mov	r3, #0
}
1000c4e8:	e1a00003 	mov	r0, r3
1000c4ec:	e8bd8800 	pop	{fp, pc}

1000c4f0 <_pthread_cleanup>:

static void _pthread_cleanup(rt_thread_t tid)
{
1000c4f0:	e92d4800 	push	{fp, lr}
1000c4f4:	e28db004 	add	fp, sp, #4
1000c4f8:	e24dd010 	sub	sp, sp, #16
1000c4fc:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    ptd = _pthread_get_data(tid);
1000c500:	e51b0010 	ldr	r0, [fp, #-16]
1000c504:	ebffffc7 	bl	1000c428 <_pthread_get_data>
1000c508:	e50b0008 	str	r0, [fp, #-8]

    /* clear cleanup function */
    tid->cleanup = RT_NULL;
1000c50c:	e51b3010 	ldr	r3, [fp, #-16]
1000c510:	e3a02000 	mov	r2, #0
1000c514:	e5832070 	str	r2, [r3, #112]	; 0x70
    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
1000c518:	e51b3008 	ldr	r3, [fp, #-8]
1000c51c:	e5d3300b 	ldrb	r3, [r3, #11]
1000c520:	e3530000 	cmp	r3, #0
1000c524:	1a000004 	bne	1000c53c <_pthread_cleanup+0x4c>
    {
        rt_sem_release(ptd->joinable_sem);
1000c528:	e51b3008 	ldr	r3, [fp, #-8]
1000c52c:	e5933020 	ldr	r3, [r3, #32]
1000c530:	e1a00003 	mov	r0, r3
1000c534:	ebffd690 	bl	10001f7c <rt_sem_release>
1000c538:	ea000001 	b	1000c544 <_pthread_cleanup+0x54>
    }
    else
    {
        /* release pthread resource */
        pthread_detach(tid);
1000c53c:	e51b0010 	ldr	r0, [fp, #-16]
1000c540:	eb0000f9 	bl	1000c92c <pthread_detach>
    }
}
1000c544:	e24bd004 	sub	sp, fp, #4
1000c548:	e8bd8800 	pop	{fp, pc}

1000c54c <pthread_entry_stub>:

static void pthread_entry_stub(void *parameter)
{
1000c54c:	e92d4800 	push	{fp, lr}
1000c550:	e28db004 	add	fp, sp, #4
1000c554:	e24dd010 	sub	sp, sp, #16
1000c558:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    void *value;

    ptd = (_pthread_data_t*)parameter;
1000c55c:	e51b3010 	ldr	r3, [fp, #-16]
1000c560:	e50b3008 	str	r3, [fp, #-8]

    /* execute pthread entry */
    value = ptd->thread_entry(ptd->thread_parameter);
1000c564:	e51b3008 	ldr	r3, [fp, #-8]
1000c568:	e5933014 	ldr	r3, [r3, #20]
1000c56c:	e51b2008 	ldr	r2, [fp, #-8]
1000c570:	e5922018 	ldr	r2, [r2, #24]
1000c574:	e1a00002 	mov	r0, r2
1000c578:	e12fff33 	blx	r3
1000c57c:	e50b000c 	str	r0, [fp, #-12]
    /* set value */
    ptd->return_value = value;
1000c580:	e51b3008 	ldr	r3, [fp, #-8]
1000c584:	e51b200c 	ldr	r2, [fp, #-12]
1000c588:	e583201c 	str	r2, [r3, #28]
}
1000c58c:	e24bd004 	sub	sp, fp, #4
1000c590:	e8bd8800 	pop	{fp, pc}

1000c594 <pthread_create>:

int pthread_create(pthread_t            *tid,
                   const pthread_attr_t *attr, 
                   void *(*start) (void *), void *parameter)
{
1000c594:	e92d4800 	push	{fp, lr}
1000c598:	e28db004 	add	fp, sp, #4
1000c59c:	e24dd038 	sub	sp, sp, #56	; 0x38
1000c5a0:	e50b0020 	str	r0, [fp, #-32]
1000c5a4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1000c5a8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
1000c5ac:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    char name[RT_NAME_MAX];
    static rt_uint16_t pthread_number = 0;
    _pthread_data_t *ptd;

    /* tid shall be provided */
    RT_ASSERT(tid != RT_NULL);
1000c5b0:	e51b3020 	ldr	r3, [fp, #-32]
1000c5b4:	e3530000 	cmp	r3, #0
1000c5b8:	1a000005 	bne	1000c5d4 <pthread_create+0x40>
1000c5bc:	e30f02a4 	movw	r0, #62116	; 0xf2a4
1000c5c0:	e3410001 	movt	r0, #4097	; 0x1001
1000c5c4:	e30f1300 	movw	r1, #62208	; 0xf300
1000c5c8:	e3411001 	movt	r1, #4097	; 0x1001
1000c5cc:	e3a02055 	mov	r2, #85	; 0x55
1000c5d0:	ebffe7fc 	bl	100065c8 <rt_assert_handler>

    /* allocate posix thread data */
    ptd = (_pthread_data_t*)rt_malloc(sizeof(_pthread_data_t));
1000c5d4:	e3a00030 	mov	r0, #48	; 0x30
1000c5d8:	ebffe932 	bl	10006aa8 <rt_malloc>
1000c5dc:	e50b000c 	str	r0, [fp, #-12]
    if (ptd == RT_NULL)
1000c5e0:	e51b300c 	ldr	r3, [fp, #-12]
1000c5e4:	e3530000 	cmp	r3, #0
1000c5e8:	1a000001 	bne	1000c5f4 <pthread_create+0x60>
        return ENOMEM;
1000c5ec:	e3a0300c 	mov	r3, #12
1000c5f0:	ea0000ca 	b	1000c920 <pthread_create+0x38c>
    /* clean posix thread data memory */
    rt_memset(ptd, 0, sizeof(_pthread_data_t));
1000c5f4:	e51b000c 	ldr	r0, [fp, #-12]
1000c5f8:	e3a01000 	mov	r1, #0
1000c5fc:	e3a02030 	mov	r2, #48	; 0x30
1000c600:	ebffe144 	bl	10004b18 <rt_memset>
    ptd->canceled = 0;
1000c604:	e51b300c 	ldr	r3, [fp, #-12]
1000c608:	e3a02000 	mov	r2, #0
1000c60c:	e5c32026 	strb	r2, [r3, #38]	; 0x26
    ptd->cancelstate = PTHREAD_CANCEL_DISABLE;
1000c610:	e51b300c 	ldr	r3, [fp, #-12]
1000c614:	e3a02003 	mov	r2, #3
1000c618:	e5c32024 	strb	r2, [r3, #36]	; 0x24
    ptd->canceltype = PTHREAD_CANCEL_DEFERRED;
1000c61c:	e51b300c 	ldr	r3, [fp, #-12]
1000c620:	e3a02002 	mov	r2, #2
1000c624:	e5c32025 	strb	r2, [r3, #37]	; 0x25
    ptd->magic = PTHREAD_MAGIC;
1000c628:	e51b200c 	ldr	r2, [fp, #-12]
1000c62c:	e3063873 	movw	r3, #26739	; 0x6873
1000c630:	e3473074 	movt	r3, #28788	; 0x7074
1000c634:	e5823000 	str	r3, [r2]

    if (attr != RT_NULL)
1000c638:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000c63c:	e3530000 	cmp	r3, #0
1000c640:	0a000005 	beq	1000c65c <pthread_create+0xc8>
        ptd->attr = *attr;
1000c644:	e51b300c 	ldr	r3, [fp, #-12]
1000c648:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1000c64c:	e2833004 	add	r3, r3, #4
1000c650:	e8920007 	ldm	r2, {r0, r1, r2}
1000c654:	e8830007 	stm	r3, {r0, r1, r2}
1000c658:	ea000003 	b	1000c66c <pthread_create+0xd8>
    else 
    {
        /* use default attribute */
        pthread_attr_init(&ptd->attr);
1000c65c:	e51b300c 	ldr	r3, [fp, #-12]
1000c660:	e2833004 	add	r3, r3, #4
1000c664:	e1a00003 	mov	r0, r3
1000c668:	eb0002b1 	bl	1000d134 <pthread_attr_init>
    }

    rt_snprintf(name, sizeof(name), "pth%02d", pthread_number ++);
1000c66c:	e3083c34 	movw	r3, #35892	; 0x8c34
1000c670:	e3413002 	movt	r3, #4098	; 0x1002
1000c674:	e1d320b0 	ldrh	r2, [r3]
1000c678:	e2823001 	add	r3, r2, #1
1000c67c:	e6ff1073 	uxth	r1, r3
1000c680:	e3083c34 	movw	r3, #35892	; 0x8c34
1000c684:	e3413002 	movt	r3, #4098	; 0x1002
1000c688:	e1c310b0 	strh	r1, [r3]
1000c68c:	e1a0c002 	mov	ip, r2
1000c690:	e24b3018 	sub	r3, fp, #24
1000c694:	e1a00003 	mov	r0, r3
1000c698:	e3a01006 	mov	r1, #6
1000c69c:	e30f22b4 	movw	r2, #62132	; 0xf2b4
1000c6a0:	e3412001 	movt	r2, #4097	; 0x1001
1000c6a4:	e1a0300c 	mov	r3, ip
1000c6a8:	ebffe6a1 	bl	10006134 <rt_snprintf>
    if (ptd->attr.stack_base == 0)
1000c6ac:	e51b300c 	ldr	r3, [fp, #-12]
1000c6b0:	e5933004 	ldr	r3, [r3, #4]
1000c6b4:	e3530000 	cmp	r3, #0
1000c6b8:	1a000005 	bne	1000c6d4 <pthread_create+0x140>
    {
        stack = (void*)rt_malloc(ptd->attr.stack_size);
1000c6bc:	e51b300c 	ldr	r3, [fp, #-12]
1000c6c0:	e1d330b8 	ldrh	r3, [r3, #8]
1000c6c4:	e1a00003 	mov	r0, r3
1000c6c8:	ebffe8f6 	bl	10006aa8 <rt_malloc>
1000c6cc:	e50b0008 	str	r0, [fp, #-8]
1000c6d0:	ea000002 	b	1000c6e0 <pthread_create+0x14c>
    }
    else
        stack = (void*)(ptd->attr.stack_base);
1000c6d4:	e51b300c 	ldr	r3, [fp, #-12]
1000c6d8:	e5933004 	ldr	r3, [r3, #4]
1000c6dc:	e50b3008 	str	r3, [fp, #-8]

    if (stack == RT_NULL) 
1000c6e0:	e51b3008 	ldr	r3, [fp, #-8]
1000c6e4:	e3530000 	cmp	r3, #0
1000c6e8:	1a000003 	bne	1000c6fc <pthread_create+0x168>
    {
        rt_free(ptd);
1000c6ec:	e51b000c 	ldr	r0, [fp, #-12]
1000c6f0:	ebffeb07 	bl	10007314 <rt_free>

        return ENOMEM;
1000c6f4:	e3a0300c 	mov	r3, #12
1000c6f8:	ea000088 	b	1000c920 <pthread_create+0x38c>
    }

    /* pthread is a static thread object */
    ptd->tid = (rt_thread_t) rt_malloc(sizeof(struct rt_thread));
1000c6fc:	e3a00078 	mov	r0, #120	; 0x78
1000c700:	ebffe8e8 	bl	10006aa8 <rt_malloc>
1000c704:	e1a02000 	mov	r2, r0
1000c708:	e51b300c 	ldr	r3, [fp, #-12]
1000c70c:	e5832010 	str	r2, [r3, #16]
    if (ptd->tid == RT_NULL)
1000c710:	e51b300c 	ldr	r3, [fp, #-12]
1000c714:	e5933010 	ldr	r3, [r3, #16]
1000c718:	e3530000 	cmp	r3, #0
1000c71c:	1a000009 	bne	1000c748 <pthread_create+0x1b4>
    {
        if (ptd->attr.stack_base == 0)
1000c720:	e51b300c 	ldr	r3, [fp, #-12]
1000c724:	e5933004 	ldr	r3, [r3, #4]
1000c728:	e3530000 	cmp	r3, #0
1000c72c:	1a000001 	bne	1000c738 <pthread_create+0x1a4>
            rt_free(stack);
1000c730:	e51b0008 	ldr	r0, [fp, #-8]
1000c734:	ebffeaf6 	bl	10007314 <rt_free>
        rt_free(ptd);
1000c738:	e51b000c 	ldr	r0, [fp, #-12]
1000c73c:	ebffeaf4 	bl	10007314 <rt_free>

        return ENOMEM;
1000c740:	e3a0300c 	mov	r3, #12
1000c744:	ea000075 	b	1000c920 <pthread_create+0x38c>
    }

    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
1000c748:	e51b300c 	ldr	r3, [fp, #-12]
1000c74c:	e5d3300b 	ldrb	r3, [r3, #11]
1000c750:	e3530000 	cmp	r3, #0
1000c754:	1a000015 	bne	1000c7b0 <pthread_create+0x21c>
    {
        ptd->joinable_sem = rt_sem_create(name, 0, RT_IPC_FLAG_FIFO);
1000c758:	e24b3018 	sub	r3, fp, #24
1000c75c:	e1a00003 	mov	r0, r3
1000c760:	e3a01000 	mov	r1, #0
1000c764:	e3a02000 	mov	r2, #0
1000c768:	ebffd513 	bl	10001bbc <rt_sem_create>
1000c76c:	e1a02000 	mov	r2, r0
1000c770:	e51b300c 	ldr	r3, [fp, #-12]
1000c774:	e5832020 	str	r2, [r3, #32]
        if (ptd->joinable_sem == RT_NULL)
1000c778:	e51b300c 	ldr	r3, [fp, #-12]
1000c77c:	e5933020 	ldr	r3, [r3, #32]
1000c780:	e3530000 	cmp	r3, #0
1000c784:	1a00000c 	bne	1000c7bc <pthread_create+0x228>
        {
            if (ptd->attr.stack_base != 0)
1000c788:	e51b300c 	ldr	r3, [fp, #-12]
1000c78c:	e5933004 	ldr	r3, [r3, #4]
1000c790:	e3530000 	cmp	r3, #0
1000c794:	0a000001 	beq	1000c7a0 <pthread_create+0x20c>
                rt_free(stack);
1000c798:	e51b0008 	ldr	r0, [fp, #-8]
1000c79c:	ebffeadc 	bl	10007314 <rt_free>
            rt_free(ptd);
1000c7a0:	e51b000c 	ldr	r0, [fp, #-12]
1000c7a4:	ebffeada 	bl	10007314 <rt_free>

            return ENOMEM;
1000c7a8:	e3a0300c 	mov	r3, #12
1000c7ac:	ea00005b 	b	1000c920 <pthread_create+0x38c>
        }
    }
    else
        ptd->joinable_sem = RT_NULL;
1000c7b0:	e51b300c 	ldr	r3, [fp, #-12]
1000c7b4:	e3a02000 	mov	r2, #0
1000c7b8:	e5832020 	str	r2, [r3, #32]

    /* set parameter */
    ptd->thread_entry = start;
1000c7bc:	e51b300c 	ldr	r3, [fp, #-12]
1000c7c0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1000c7c4:	e5832014 	str	r2, [r3, #20]
    ptd->thread_parameter = parameter;
1000c7c8:	e51b300c 	ldr	r3, [fp, #-12]
1000c7cc:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
1000c7d0:	e5832018 	str	r2, [r3, #24]

    /* initial this pthread to system */
    if (rt_thread_init(ptd->tid, name, pthread_entry_stub, ptd, 
1000c7d4:	e51b300c 	ldr	r3, [fp, #-12]
1000c7d8:	e5930010 	ldr	r0, [r3, #16]
        stack, ptd->attr.stack_size, 
1000c7dc:	e51b300c 	ldr	r3, [fp, #-12]
1000c7e0:	e1d330b8 	ldrh	r3, [r3, #8]
    /* set parameter */
    ptd->thread_entry = start;
    ptd->thread_parameter = parameter;

    /* initial this pthread to system */
    if (rt_thread_init(ptd->tid, name, pthread_entry_stub, ptd, 
1000c7e4:	e1a0c003 	mov	ip, r3
1000c7e8:	e51b300c 	ldr	r3, [fp, #-12]
1000c7ec:	e5d3300a 	ldrb	r3, [r3, #10]
1000c7f0:	e24b1018 	sub	r1, fp, #24
1000c7f4:	e51b2008 	ldr	r2, [fp, #-8]
1000c7f8:	e58d2000 	str	r2, [sp]
1000c7fc:	e58dc004 	str	ip, [sp, #4]
1000c800:	e58d3008 	str	r3, [sp, #8]
1000c804:	e3a03005 	mov	r3, #5
1000c808:	e58d300c 	str	r3, [sp, #12]
1000c80c:	e30c254c 	movw	r2, #50508	; 0xc54c
1000c810:	e3412000 	movt	r2, #4096	; 0x1000
1000c814:	e51b300c 	ldr	r3, [fp, #-12]
1000c818:	ebffefbc 	bl	10008710 <rt_thread_init>
1000c81c:	e1a03000 	mov	r3, r0
1000c820:	e3530000 	cmp	r3, #0
1000c824:	0a000011 	beq	1000c870 <pthread_create+0x2dc>
        stack, ptd->attr.stack_size, 
        ptd->attr.priority, 5) != RT_EOK)
    {
        if (ptd->attr.stack_base == 0)
1000c828:	e51b300c 	ldr	r3, [fp, #-12]
1000c82c:	e5933004 	ldr	r3, [r3, #4]
1000c830:	e3530000 	cmp	r3, #0
1000c834:	1a000001 	bne	1000c840 <pthread_create+0x2ac>
            rt_free(stack);
1000c838:	e51b0008 	ldr	r0, [fp, #-8]
1000c83c:	ebffeab4 	bl	10007314 <rt_free>
        if (ptd->joinable_sem != RT_NULL)
1000c840:	e51b300c 	ldr	r3, [fp, #-12]
1000c844:	e5933020 	ldr	r3, [r3, #32]
1000c848:	e3530000 	cmp	r3, #0
1000c84c:	0a000003 	beq	1000c860 <pthread_create+0x2cc>
            rt_sem_delete(ptd->joinable_sem);
1000c850:	e51b300c 	ldr	r3, [fp, #-12]
1000c854:	e5933020 	ldr	r3, [r3, #32]
1000c858:	e1a00003 	mov	r0, r3
1000c85c:	ebffd507 	bl	10001c80 <rt_sem_delete>
        rt_free(ptd);
1000c860:	e51b000c 	ldr	r0, [fp, #-12]
1000c864:	ebffeaaa 	bl	10007314 <rt_free>

        return EINVAL;
1000c868:	e3a03016 	mov	r3, #22
1000c86c:	ea00002b 	b	1000c920 <pthread_create+0x38c>
    }

    /* set pthread id */
    *tid = ptd->tid;
1000c870:	e51b300c 	ldr	r3, [fp, #-12]
1000c874:	e5932010 	ldr	r2, [r3, #16]
1000c878:	e51b3020 	ldr	r3, [fp, #-32]
1000c87c:	e5832000 	str	r2, [r3]

    /* set pthread cleanup function and ptd data */
    (*tid)->cleanup = _pthread_cleanup;
1000c880:	e51b3020 	ldr	r3, [fp, #-32]
1000c884:	e5932000 	ldr	r2, [r3]
1000c888:	e30c34f0 	movw	r3, #50416	; 0xc4f0
1000c88c:	e3413000 	movt	r3, #4096	; 0x1000
1000c890:	e5823070 	str	r3, [r2, #112]	; 0x70
    (*tid)->user_data = (rt_uint32_t)ptd;
1000c894:	e51b3020 	ldr	r3, [fp, #-32]
1000c898:	e5933000 	ldr	r3, [r3]
1000c89c:	e51b200c 	ldr	r2, [fp, #-12]
1000c8a0:	e5832074 	str	r2, [r3, #116]	; 0x74

    /* start thread */
    result = rt_thread_startup(*tid);
1000c8a4:	e51b3020 	ldr	r3, [fp, #-32]
1000c8a8:	e5933000 	ldr	r3, [r3]
1000c8ac:	e1a00003 	mov	r0, r3
1000c8b0:	ebffefcd 	bl	100087ec <rt_thread_startup>
1000c8b4:	e50b0010 	str	r0, [fp, #-16]
    if (result == RT_EOK)
1000c8b8:	e51b3010 	ldr	r3, [fp, #-16]
1000c8bc:	e3530000 	cmp	r3, #0
1000c8c0:	1a000001 	bne	1000c8cc <pthread_create+0x338>
        return 0;
1000c8c4:	e3a03000 	mov	r3, #0
1000c8c8:	ea000014 	b	1000c920 <pthread_create+0x38c>

    /* start thread failed */
    rt_thread_detach(ptd->tid);
1000c8cc:	e51b300c 	ldr	r3, [fp, #-12]
1000c8d0:	e5933010 	ldr	r3, [r3, #16]
1000c8d4:	e1a00003 	mov	r0, r3
1000c8d8:	ebffeff4 	bl	100088b0 <rt_thread_detach>
    if (ptd->attr.stack_base == 0)
1000c8dc:	e51b300c 	ldr	r3, [fp, #-12]
1000c8e0:	e5933004 	ldr	r3, [r3, #4]
1000c8e4:	e3530000 	cmp	r3, #0
1000c8e8:	1a000001 	bne	1000c8f4 <pthread_create+0x360>
        rt_free(stack);
1000c8ec:	e51b0008 	ldr	r0, [fp, #-8]
1000c8f0:	ebffea87 	bl	10007314 <rt_free>
    if (ptd->joinable_sem != RT_NULL)
1000c8f4:	e51b300c 	ldr	r3, [fp, #-12]
1000c8f8:	e5933020 	ldr	r3, [r3, #32]
1000c8fc:	e3530000 	cmp	r3, #0
1000c900:	0a000003 	beq	1000c914 <pthread_create+0x380>
        rt_sem_delete(ptd->joinable_sem);
1000c904:	e51b300c 	ldr	r3, [fp, #-12]
1000c908:	e5933020 	ldr	r3, [r3, #32]
1000c90c:	e1a00003 	mov	r0, r3
1000c910:	ebffd4da 	bl	10001c80 <rt_sem_delete>

    rt_free(ptd);
1000c914:	e51b000c 	ldr	r0, [fp, #-12]
1000c918:	ebffea7d 	bl	10007314 <rt_free>

    return EINVAL;
1000c91c:	e3a03016 	mov	r3, #22
}
1000c920:	e1a00003 	mov	r0, r3
1000c924:	e24bd004 	sub	sp, fp, #4
1000c928:	e8bd8800 	pop	{fp, pc}

1000c92c <pthread_detach>:
RTM_EXPORT(pthread_create);

int pthread_detach(pthread_t thread)
{
1000c92c:	e92d4800 	push	{fp, lr}
1000c930:	e28db004 	add	fp, sp, #4
1000c934:	e24dd010 	sub	sp, sp, #16
1000c938:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t* ptd;

    ptd = _pthread_get_data(thread);
1000c93c:	e51b0010 	ldr	r0, [fp, #-16]
1000c940:	ebfffeb8 	bl	1000c428 <_pthread_get_data>
1000c944:	e50b0008 	str	r0, [fp, #-8]

    if (thread->stat == RT_THREAD_CLOSE)
1000c948:	e51b3010 	ldr	r3, [fp, #-16]
1000c94c:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
1000c950:	e3530004 	cmp	r3, #4
1000c954:	1a000023 	bne	1000c9e8 <pthread_detach+0xbc>
    {
        /* delete joinable semaphore */
        if (ptd->joinable_sem != RT_NULL)
1000c958:	e51b3008 	ldr	r3, [fp, #-8]
1000c95c:	e5933020 	ldr	r3, [r3, #32]
1000c960:	e3530000 	cmp	r3, #0
1000c964:	0a000003 	beq	1000c978 <pthread_detach+0x4c>
            rt_sem_delete(ptd->joinable_sem);
1000c968:	e51b3008 	ldr	r3, [fp, #-8]
1000c96c:	e5933020 	ldr	r3, [r3, #32]
1000c970:	e1a00003 	mov	r0, r3
1000c974:	ebffd4c1 	bl	10001c80 <rt_sem_delete>
        /* detach thread object */
        rt_thread_detach(ptd->tid);
1000c978:	e51b3008 	ldr	r3, [fp, #-8]
1000c97c:	e5933010 	ldr	r3, [r3, #16]
1000c980:	e1a00003 	mov	r0, r3
1000c984:	ebffefc9 	bl	100088b0 <rt_thread_detach>

        /* release thread resource */
        if (ptd->attr.stack_base == RT_NULL)
1000c988:	e51b3008 	ldr	r3, [fp, #-8]
1000c98c:	e5933004 	ldr	r3, [r3, #4]
1000c990:	e3530000 	cmp	r3, #0
1000c994:	1a000004 	bne	1000c9ac <pthread_detach+0x80>
        {
            /* release thread allocated stack */
            rt_free(ptd->tid->stack_addr);
1000c998:	e51b3008 	ldr	r3, [fp, #-8]
1000c99c:	e5933010 	ldr	r3, [r3, #16]
1000c9a0:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1000c9a4:	e1a00003 	mov	r0, r3
1000c9a8:	ebffea59 	bl	10007314 <rt_free>

        /*
         * if this thread create the local thread data,
         * delete it
         */
        if (ptd->tls != RT_NULL)
1000c9ac:	e51b3008 	ldr	r3, [fp, #-8]
1000c9b0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000c9b4:	e3530000 	cmp	r3, #0
1000c9b8:	0a000003 	beq	1000c9cc <pthread_detach+0xa0>
            rt_free(ptd->tls);
1000c9bc:	e51b3008 	ldr	r3, [fp, #-8]
1000c9c0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000c9c4:	e1a00003 	mov	r0, r3
1000c9c8:	ebffea51 	bl	10007314 <rt_free>
        rt_free(ptd->tid);
1000c9cc:	e51b3008 	ldr	r3, [fp, #-8]
1000c9d0:	e5933010 	ldr	r3, [r3, #16]
1000c9d4:	e1a00003 	mov	r0, r3
1000c9d8:	ebffea4d 	bl	10007314 <rt_free>
        rt_free(ptd);
1000c9dc:	e51b0008 	ldr	r0, [fp, #-8]
1000c9e0:	ebffea4b 	bl	10007314 <rt_free>
1000c9e4:	ea00000b 	b	1000ca18 <pthread_detach+0xec>
    }
    else
    {
        rt_enter_critical();
1000c9e8:	ebffee2e 	bl	100082a8 <rt_enter_critical>
        /* change to detach state */
        ptd->attr.detachstate = PTHREAD_CREATE_DETACHED;
1000c9ec:	e51b3008 	ldr	r3, [fp, #-8]
1000c9f0:	e3a02001 	mov	r2, #1
1000c9f4:	e5c3200b 	strb	r2, [r3, #11]

        /* detach joinable semaphore */
        rt_sem_delete(ptd->joinable_sem);
1000c9f8:	e51b3008 	ldr	r3, [fp, #-8]
1000c9fc:	e5933020 	ldr	r3, [r3, #32]
1000ca00:	e1a00003 	mov	r0, r3
1000ca04:	ebffd49d 	bl	10001c80 <rt_sem_delete>
        ptd->joinable_sem = RT_NULL;
1000ca08:	e51b3008 	ldr	r3, [fp, #-8]
1000ca0c:	e3a02000 	mov	r2, #0
1000ca10:	e5832020 	str	r2, [r3, #32]
        rt_exit_critical();
1000ca14:	ebffee35 	bl	100082f0 <rt_exit_critical>
    }

    return 0;
1000ca18:	e3a03000 	mov	r3, #0
}
1000ca1c:	e1a00003 	mov	r0, r3
1000ca20:	e24bd004 	sub	sp, fp, #4
1000ca24:	e8bd8800 	pop	{fp, pc}

1000ca28 <pthread_join>:
RTM_EXPORT(pthread_detach);

int pthread_join (pthread_t thread, void **value_ptr)
{
1000ca28:	e92d4800 	push	{fp, lr}
1000ca2c:	e28db004 	add	fp, sp, #4
1000ca30:	e24dd010 	sub	sp, sp, #16
1000ca34:	e50b0010 	str	r0, [fp, #-16]
1000ca38:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t* ptd;
    rt_err_t result;

    if (thread == rt_thread_self())
1000ca3c:	ebffef61 	bl	100087c8 <rt_thread_self>
1000ca40:	e1a02000 	mov	r2, r0
1000ca44:	e51b3010 	ldr	r3, [fp, #-16]
1000ca48:	e1520003 	cmp	r2, r3
1000ca4c:	1a000001 	bne	1000ca58 <pthread_join+0x30>
    {
        /* join self */
        return EDEADLK;
1000ca50:	e3a0302d 	mov	r3, #45	; 0x2d
1000ca54:	ea00001d 	b	1000cad0 <pthread_join+0xa8>
    }

    ptd = _pthread_get_data(thread);
1000ca58:	e51b0010 	ldr	r0, [fp, #-16]
1000ca5c:	ebfffe71 	bl	1000c428 <_pthread_get_data>
1000ca60:	e50b0008 	str	r0, [fp, #-8]
    if (ptd->attr.detachstate == PTHREAD_CREATE_DETACHED)
1000ca64:	e51b3008 	ldr	r3, [fp, #-8]
1000ca68:	e5d3300b 	ldrb	r3, [r3, #11]
1000ca6c:	e3530001 	cmp	r3, #1
1000ca70:	1a000001 	bne	1000ca7c <pthread_join+0x54>
        return EINVAL; /* join on a detached pthread */
1000ca74:	e3a03016 	mov	r3, #22
1000ca78:	ea000014 	b	1000cad0 <pthread_join+0xa8>

    result = rt_sem_take(ptd->joinable_sem, RT_WAITING_FOREVER);
1000ca7c:	e51b3008 	ldr	r3, [fp, #-8]
1000ca80:	e5933020 	ldr	r3, [r3, #32]
1000ca84:	e1a00003 	mov	r0, r3
1000ca88:	e3e01000 	mvn	r1, #0
1000ca8c:	ebffd4a6 	bl	10001d2c <rt_sem_take>
1000ca90:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
1000ca94:	e51b300c 	ldr	r3, [fp, #-12]
1000ca98:	e3530000 	cmp	r3, #0
1000ca9c:	1a00000a 	bne	1000cacc <pthread_join+0xa4>
    {
        /* get return value */
        if (value_ptr != RT_NULL)
1000caa0:	e51b3014 	ldr	r3, [fp, #-20]
1000caa4:	e3530000 	cmp	r3, #0
1000caa8:	0a000003 	beq	1000cabc <pthread_join+0x94>
            *value_ptr = ptd->return_value;
1000caac:	e51b3008 	ldr	r3, [fp, #-8]
1000cab0:	e593201c 	ldr	r2, [r3, #28]
1000cab4:	e51b3014 	ldr	r3, [fp, #-20]
1000cab8:	e5832000 	str	r2, [r3]

        /* release resource */
        pthread_detach(thread);
1000cabc:	e51b0010 	ldr	r0, [fp, #-16]
1000cac0:	ebffff99 	bl	1000c92c <pthread_detach>
    }
    else
        return ESRCH;
    
    return 0;
1000cac4:	e3a03000 	mov	r3, #0
1000cac8:	ea000000 	b	1000cad0 <pthread_join+0xa8>

        /* release resource */
        pthread_detach(thread);
    }
    else
        return ESRCH;
1000cacc:	e3a03003 	mov	r3, #3
    
    return 0;
}
1000cad0:	e1a00003 	mov	r0, r3
1000cad4:	e24bd004 	sub	sp, fp, #4
1000cad8:	e8bd8800 	pop	{fp, pc}

1000cadc <pthread_exit>:
RTM_EXPORT(pthread_join);

void pthread_exit (void *value)
{
1000cadc:	e92d4800 	push	{fp, lr}
1000cae0:	e28db004 	add	fp, sp, #4
1000cae4:	e24dd018 	sub	sp, sp, #24
1000cae8:	e50b0018 	str	r0, [fp, #-24]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;
    extern _pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

    ptd = _pthread_get_data(rt_thread_self());
1000caec:	ebffef35 	bl	100087c8 <rt_thread_self>
1000caf0:	e1a03000 	mov	r3, r0
1000caf4:	e1a00003 	mov	r0, r3
1000caf8:	ebfffe4a 	bl	1000c428 <_pthread_get_data>
1000cafc:	e50b000c 	str	r0, [fp, #-12]

    rt_enter_critical();
1000cb00:	ebffede8 	bl	100082a8 <rt_enter_critical>
    /* disable cancel */
    ptd->cancelstate = PTHREAD_CANCEL_DISABLE;
1000cb04:	e51b300c 	ldr	r3, [fp, #-12]
1000cb08:	e3a02003 	mov	r2, #3
1000cb0c:	e5c32024 	strb	r2, [r3, #36]	; 0x24
    /* set return value */
    ptd->return_value = value;
1000cb10:	e51b300c 	ldr	r3, [fp, #-12]
1000cb14:	e51b2018 	ldr	r2, [fp, #-24]
1000cb18:	e583201c 	str	r2, [r3, #28]
    rt_exit_critical();
1000cb1c:	ebffedf3 	bl	100082f0 <rt_exit_critical>

    /* invoke pushed cleanup */
    while (ptd->cleanup != RT_NULL)
1000cb20:	ea00000e 	b	1000cb60 <pthread_exit+0x84>
    {
        cleanup = ptd->cleanup;
1000cb24:	e51b300c 	ldr	r3, [fp, #-12]
1000cb28:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1000cb2c:	e50b3010 	str	r3, [fp, #-16]
        ptd->cleanup = cleanup->next;
1000cb30:	e51b3010 	ldr	r3, [fp, #-16]
1000cb34:	e5932008 	ldr	r2, [r3, #8]
1000cb38:	e51b300c 	ldr	r3, [fp, #-12]
1000cb3c:	e5832028 	str	r2, [r3, #40]	; 0x28

        cleanup->cleanup_func(cleanup->parameter);
1000cb40:	e51b3010 	ldr	r3, [fp, #-16]
1000cb44:	e5933000 	ldr	r3, [r3]
1000cb48:	e51b2010 	ldr	r2, [fp, #-16]
1000cb4c:	e5922004 	ldr	r2, [r2, #4]
1000cb50:	e1a00002 	mov	r0, r2
1000cb54:	e12fff33 	blx	r3
        /* release this cleanup function */
        rt_free(cleanup);
1000cb58:	e51b0010 	ldr	r0, [fp, #-16]
1000cb5c:	ebffe9ec 	bl	10007314 <rt_free>
    /* set return value */
    ptd->return_value = value;
    rt_exit_critical();

    /* invoke pushed cleanup */
    while (ptd->cleanup != RT_NULL)
1000cb60:	e51b300c 	ldr	r3, [fp, #-12]
1000cb64:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1000cb68:	e3530000 	cmp	r3, #0
1000cb6c:	1affffec 	bne	1000cb24 <pthread_exit+0x48>
        /* release this cleanup function */
        rt_free(cleanup);
    }

    /* destruct thread local key */
    if (ptd->tls != RT_NULL)
1000cb70:	e51b300c 	ldr	r3, [fp, #-12]
1000cb74:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000cb78:	e3530000 	cmp	r3, #0
1000cb7c:	0a000027 	beq	1000cc20 <pthread_exit+0x144>
    {
        void *data;
        rt_uint32_t index;
        
        for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1000cb80:	e3a03000 	mov	r3, #0
1000cb84:	e50b3008 	str	r3, [fp, #-8]
1000cb88:	ea00001a 	b	1000cbf8 <pthread_exit+0x11c>
        {
            if (_thread_keys[index].is_used)
1000cb8c:	e30a3614 	movw	r3, #42516	; 0xa614
1000cb90:	e3413002 	movt	r3, #4098	; 0x1002
1000cb94:	e51b2008 	ldr	r2, [fp, #-8]
1000cb98:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1000cb9c:	e3530000 	cmp	r3, #0
1000cba0:	0a000011 	beq	1000cbec <pthread_exit+0x110>
            {
                data = ptd->tls[index];
1000cba4:	e51b300c 	ldr	r3, [fp, #-12]
1000cba8:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1000cbac:	e51b3008 	ldr	r3, [fp, #-8]
1000cbb0:	e1a03103 	lsl	r3, r3, #2
1000cbb4:	e0823003 	add	r3, r2, r3
1000cbb8:	e5933000 	ldr	r3, [r3]
1000cbbc:	e50b3014 	str	r3, [fp, #-20]
                if (data)
1000cbc0:	e51b3014 	ldr	r3, [fp, #-20]
1000cbc4:	e3530000 	cmp	r3, #0
1000cbc8:	0a000007 	beq	1000cbec <pthread_exit+0x110>
                    _thread_keys[index].destructor(data);
1000cbcc:	e30a2614 	movw	r2, #42516	; 0xa614
1000cbd0:	e3412002 	movt	r2, #4098	; 0x1002
1000cbd4:	e51b3008 	ldr	r3, [fp, #-8]
1000cbd8:	e1a03183 	lsl	r3, r3, #3
1000cbdc:	e0823003 	add	r3, r2, r3
1000cbe0:	e5933004 	ldr	r3, [r3, #4]
1000cbe4:	e51b0014 	ldr	r0, [fp, #-20]
1000cbe8:	e12fff33 	blx	r3
    if (ptd->tls != RT_NULL)
    {
        void *data;
        rt_uint32_t index;
        
        for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1000cbec:	e51b3008 	ldr	r3, [fp, #-8]
1000cbf0:	e2833001 	add	r3, r3, #1
1000cbf4:	e50b3008 	str	r3, [fp, #-8]
1000cbf8:	e51b3008 	ldr	r3, [fp, #-8]
1000cbfc:	e3530007 	cmp	r3, #7
1000cc00:	9affffe1 	bls	1000cb8c <pthread_exit+0xb0>
                    _thread_keys[index].destructor(data);
            }
        }

        /* release tls area */
        rt_free(ptd->tls);
1000cc04:	e51b300c 	ldr	r3, [fp, #-12]
1000cc08:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000cc0c:	e1a00003 	mov	r0, r3
1000cc10:	ebffe9bf 	bl	10007314 <rt_free>
        ptd->tls = RT_NULL;
1000cc14:	e51b300c 	ldr	r3, [fp, #-12]
1000cc18:	e3a02000 	mov	r2, #0
1000cc1c:	e583202c 	str	r2, [r3, #44]	; 0x2c
    }

    if (ptd->attr.detachstate == PTHREAD_CREATE_JOINABLE)
1000cc20:	e51b300c 	ldr	r3, [fp, #-12]
1000cc24:	e5d3300b 	ldrb	r3, [r3, #11]
1000cc28:	e3530000 	cmp	r3, #0
1000cc2c:	1a000003 	bne	1000cc40 <pthread_exit+0x164>
    {
        /* release the joinable pthread */
        rt_sem_release(ptd->joinable_sem);
1000cc30:	e51b300c 	ldr	r3, [fp, #-12]
1000cc34:	e5933020 	ldr	r3, [r3, #32]
1000cc38:	e1a00003 	mov	r0, r3
1000cc3c:	ebffd4ce 	bl	10001f7c <rt_sem_release>
    }

    /* detach thread */
    rt_thread_detach(ptd->tid);
1000cc40:	e51b300c 	ldr	r3, [fp, #-12]
1000cc44:	e5933010 	ldr	r3, [r3, #16]
1000cc48:	e1a00003 	mov	r0, r3
1000cc4c:	ebffef17 	bl	100088b0 <rt_thread_detach>
    /* reschedule thread */
    rt_schedule();
1000cc50:	ebffeced 	bl	1000800c <rt_schedule>
}
1000cc54:	e24bd004 	sub	sp, fp, #4
1000cc58:	e8bd8800 	pop	{fp, pc}

1000cc5c <pthread_once>:
RTM_EXPORT(pthread_exit);

int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))
{
1000cc5c:	e92d4800 	push	{fp, lr}
1000cc60:	e28db004 	add	fp, sp, #4
1000cc64:	e24dd008 	sub	sp, sp, #8
1000cc68:	e50b0008 	str	r0, [fp, #-8]
1000cc6c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(once_control != RT_NULL);
1000cc70:	e51b3008 	ldr	r3, [fp, #-8]
1000cc74:	e3530000 	cmp	r3, #0
1000cc78:	1a000005 	bne	1000cc94 <pthread_once+0x38>
1000cc7c:	e30f02bc 	movw	r0, #62140	; 0xf2bc
1000cc80:	e3410001 	movt	r0, #4097	; 0x1001
1000cc84:	e30f1310 	movw	r1, #62224	; 0xf310
1000cc88:	e3411001 	movt	r1, #4097	; 0x1001
1000cc8c:	e300214a 	movw	r2, #330	; 0x14a
1000cc90:	ebffe64c 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(init_routine != RT_NULL);
1000cc94:	e51b300c 	ldr	r3, [fp, #-12]
1000cc98:	e3530000 	cmp	r3, #0
1000cc9c:	1a000005 	bne	1000ccb8 <pthread_once+0x5c>
1000cca0:	e30f02d4 	movw	r0, #62164	; 0xf2d4
1000cca4:	e3410001 	movt	r0, #4097	; 0x1001
1000cca8:	e30f1310 	movw	r1, #62224	; 0xf310
1000ccac:	e3411001 	movt	r1, #4097	; 0x1001
1000ccb0:	e300214b 	movw	r2, #331	; 0x14b
1000ccb4:	ebffe643 	bl	100065c8 <rt_assert_handler>

    rt_enter_critical();
1000ccb8:	ebffed7a 	bl	100082a8 <rt_enter_critical>
    if (!(*once_control))
1000ccbc:	e51b3008 	ldr	r3, [fp, #-8]
1000ccc0:	e5933000 	ldr	r3, [r3]
1000ccc4:	e3530000 	cmp	r3, #0
1000ccc8:	1a000005 	bne	1000cce4 <pthread_once+0x88>
    {
        /* call routine once */
        *once_control = 1;
1000cccc:	e51b3008 	ldr	r3, [fp, #-8]
1000ccd0:	e3a02001 	mov	r2, #1
1000ccd4:	e5832000 	str	r2, [r3]
        rt_exit_critical();
1000ccd8:	ebffed84 	bl	100082f0 <rt_exit_critical>

        init_routine();
1000ccdc:	e51b300c 	ldr	r3, [fp, #-12]
1000cce0:	e12fff33 	blx	r3
    }
    rt_exit_critical();
1000cce4:	ebffed81 	bl	100082f0 <rt_exit_critical>

    return 0;
1000cce8:	e3a03000 	mov	r3, #0
}
1000ccec:	e1a00003 	mov	r0, r3
1000ccf0:	e24bd004 	sub	sp, fp, #4
1000ccf4:	e8bd8800 	pop	{fp, pc}

1000ccf8 <pthread_atfork>:
RTM_EXPORT(pthread_once);

int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))
{
1000ccf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ccfc:	e28db000 	add	fp, sp, #0
1000cd00:	e24dd014 	sub	sp, sp, #20
1000cd04:	e50b0008 	str	r0, [fp, #-8]
1000cd08:	e50b100c 	str	r1, [fp, #-12]
1000cd0c:	e50b2010 	str	r2, [fp, #-16]
    return EOPNOTSUPP;
1000cd10:	e3a0305f 	mov	r3, #95	; 0x5f
}
1000cd14:	e1a00003 	mov	r0, r3
1000cd18:	e24bd000 	sub	sp, fp, #0
1000cd1c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000cd20:	e12fff1e 	bx	lr

1000cd24 <pthread_kill>:
RTM_EXPORT(pthread_atfork);

int pthread_kill(pthread_t thread, int sig)
{
1000cd24:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000cd28:	e28db000 	add	fp, sp, #0
1000cd2c:	e24dd00c 	sub	sp, sp, #12
1000cd30:	e50b0008 	str	r0, [fp, #-8]
1000cd34:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
1000cd38:	e3a0305f 	mov	r3, #95	; 0x5f
}
1000cd3c:	e1a00003 	mov	r0, r3
1000cd40:	e24bd000 	sub	sp, fp, #0
1000cd44:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000cd48:	e12fff1e 	bx	lr

1000cd4c <pthread_cleanup_pop>:
RTM_EXPORT(pthread_kill);

void pthread_cleanup_pop(int execute)
{
1000cd4c:	e92d4800 	push	{fp, lr}
1000cd50:	e28db004 	add	fp, sp, #4
1000cd54:	e24dd010 	sub	sp, sp, #16
1000cd58:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1000cd5c:	ebffee99 	bl	100087c8 <rt_thread_self>
1000cd60:	e1a03000 	mov	r3, r0
1000cd64:	e1a00003 	mov	r0, r3
1000cd68:	ebfffdae 	bl	1000c428 <_pthread_get_data>
1000cd6c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000cd70:	e51b3008 	ldr	r3, [fp, #-8]
1000cd74:	e3530000 	cmp	r3, #0
1000cd78:	1a000005 	bne	1000cd94 <pthread_cleanup_pop+0x48>
1000cd7c:	e30f0278 	movw	r0, #62072	; 0xf278
1000cd80:	e3410001 	movt	r0, #4097	; 0x1001
1000cd84:	e30f1320 	movw	r1, #62240	; 0xf320
1000cd88:	e3411001 	movt	r1, #4097	; 0x1001
1000cd8c:	e300216f 	movw	r2, #367	; 0x16f
1000cd90:	ebffe60c 	bl	100065c8 <rt_assert_handler>

    if (execute)
1000cd94:	e51b3010 	ldr	r3, [fp, #-16]
1000cd98:	e3530000 	cmp	r3, #0
1000cd9c:	0a000016 	beq	1000cdfc <pthread_cleanup_pop+0xb0>
    {
        rt_enter_critical();
1000cda0:	ebffed40 	bl	100082a8 <rt_enter_critical>
        cleanup = ptd->cleanup;
1000cda4:	e51b3008 	ldr	r3, [fp, #-8]
1000cda8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
1000cdac:	e50b300c 	str	r3, [fp, #-12]
        if (cleanup)
1000cdb0:	e51b300c 	ldr	r3, [fp, #-12]
1000cdb4:	e3530000 	cmp	r3, #0
1000cdb8:	0a000003 	beq	1000cdcc <pthread_cleanup_pop+0x80>
            ptd->cleanup = cleanup->next;
1000cdbc:	e51b300c 	ldr	r3, [fp, #-12]
1000cdc0:	e5932008 	ldr	r2, [r3, #8]
1000cdc4:	e51b3008 	ldr	r3, [fp, #-8]
1000cdc8:	e5832028 	str	r2, [r3, #40]	; 0x28
        rt_exit_critical();
1000cdcc:	ebffed47 	bl	100082f0 <rt_exit_critical>

        if (cleanup)
1000cdd0:	e51b300c 	ldr	r3, [fp, #-12]
1000cdd4:	e3530000 	cmp	r3, #0
1000cdd8:	0a000007 	beq	1000cdfc <pthread_cleanup_pop+0xb0>
        {
            cleanup->cleanup_func(cleanup->parameter);
1000cddc:	e51b300c 	ldr	r3, [fp, #-12]
1000cde0:	e5933000 	ldr	r3, [r3]
1000cde4:	e51b200c 	ldr	r2, [fp, #-12]
1000cde8:	e5922004 	ldr	r2, [r2, #4]
1000cdec:	e1a00002 	mov	r0, r2
1000cdf0:	e12fff33 	blx	r3

            rt_free(cleanup);
1000cdf4:	e51b000c 	ldr	r0, [fp, #-12]
1000cdf8:	ebffe945 	bl	10007314 <rt_free>
        }
    }
}
1000cdfc:	e24bd004 	sub	sp, fp, #4
1000ce00:	e8bd8800 	pop	{fp, pc}

1000ce04 <pthread_cleanup_push>:
RTM_EXPORT(pthread_cleanup_pop);

void pthread_cleanup_push(void (*routine)(void*), void *arg)
{
1000ce04:	e92d4800 	push	{fp, lr}
1000ce08:	e28db004 	add	fp, sp, #4
1000ce0c:	e24dd010 	sub	sp, sp, #16
1000ce10:	e50b0010 	str	r0, [fp, #-16]
1000ce14:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;
    _pthread_cleanup_t *cleanup;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1000ce18:	ebffee6a 	bl	100087c8 <rt_thread_self>
1000ce1c:	e1a03000 	mov	r3, r0
1000ce20:	e1a00003 	mov	r0, r3
1000ce24:	ebfffd7f 	bl	1000c428 <_pthread_get_data>
1000ce28:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000ce2c:	e51b3008 	ldr	r3, [fp, #-8]
1000ce30:	e3530000 	cmp	r3, #0
1000ce34:	1a000005 	bne	1000ce50 <pthread_cleanup_push+0x4c>
1000ce38:	e30f0278 	movw	r0, #62072	; 0xf278
1000ce3c:	e3410001 	movt	r0, #4097	; 0x1001
1000ce40:	e30f1334 	movw	r1, #62260	; 0xf334
1000ce44:	e3411001 	movt	r1, #4097	; 0x1001
1000ce48:	e300218a 	movw	r2, #394	; 0x18a
1000ce4c:	ebffe5dd 	bl	100065c8 <rt_assert_handler>

    cleanup = (_pthread_cleanup_t *)rt_malloc(sizeof(_pthread_cleanup_t));
1000ce50:	e3a0000c 	mov	r0, #12
1000ce54:	ebffe713 	bl	10006aa8 <rt_malloc>
1000ce58:	e50b000c 	str	r0, [fp, #-12]
    if (cleanup != RT_NULL)
1000ce5c:	e51b300c 	ldr	r3, [fp, #-12]
1000ce60:	e3530000 	cmp	r3, #0
1000ce64:	0a00000e 	beq	1000cea4 <pthread_cleanup_push+0xa0>
    {
        cleanup->cleanup_func = routine;
1000ce68:	e51b300c 	ldr	r3, [fp, #-12]
1000ce6c:	e51b2010 	ldr	r2, [fp, #-16]
1000ce70:	e5832000 	str	r2, [r3]
        cleanup->parameter = arg;
1000ce74:	e51b300c 	ldr	r3, [fp, #-12]
1000ce78:	e51b2014 	ldr	r2, [fp, #-20]
1000ce7c:	e5832004 	str	r2, [r3, #4]

        rt_enter_critical();
1000ce80:	ebffed08 	bl	100082a8 <rt_enter_critical>
        cleanup->next = ptd->cleanup;
1000ce84:	e51b3008 	ldr	r3, [fp, #-8]
1000ce88:	e5932028 	ldr	r2, [r3, #40]	; 0x28
1000ce8c:	e51b300c 	ldr	r3, [fp, #-12]
1000ce90:	e5832008 	str	r2, [r3, #8]
        ptd->cleanup = cleanup;
1000ce94:	e51b3008 	ldr	r3, [fp, #-8]
1000ce98:	e51b200c 	ldr	r2, [fp, #-12]
1000ce9c:	e5832028 	str	r2, [r3, #40]	; 0x28
        rt_exit_critical();
1000cea0:	ebffed12 	bl	100082f0 <rt_exit_critical>
    }
}
1000cea4:	e24bd004 	sub	sp, fp, #4
1000cea8:	e8bd8800 	pop	{fp, pc}

1000ceac <pthread_setcancelstate>:
 * The pthread_cancel(), pthread_setcancelstate(), and pthread_setcanceltype()
 * functions are defined to be async-cancel safe.
 */

int pthread_setcancelstate(int state, int *oldstate)
{
1000ceac:	e92d4800 	push	{fp, lr}
1000ceb0:	e28db004 	add	fp, sp, #4
1000ceb4:	e24dd010 	sub	sp, sp, #16
1000ceb8:	e50b0010 	str	r0, [fp, #-16]
1000cebc:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1000cec0:	ebffee40 	bl	100087c8 <rt_thread_self>
1000cec4:	e1a03000 	mov	r3, r0
1000cec8:	e1a00003 	mov	r0, r3
1000cecc:	ebfffd55 	bl	1000c428 <_pthread_get_data>
1000ced0:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000ced4:	e51b3008 	ldr	r3, [fp, #-8]
1000ced8:	e3530000 	cmp	r3, #0
1000cedc:	1a000005 	bne	1000cef8 <pthread_setcancelstate+0x4c>
1000cee0:	e30f0278 	movw	r0, #62072	; 0xf278
1000cee4:	e3410001 	movt	r0, #4097	; 0x1001
1000cee8:	e30f134c 	movw	r1, #62284	; 0xf34c
1000ceec:	e3411001 	movt	r1, #4097	; 0x1001
1000cef0:	e3a02f6f 	mov	r2, #444	; 0x1bc
1000cef4:	ebffe5b3 	bl	100065c8 <rt_assert_handler>

    if ((state == PTHREAD_CANCEL_ENABLE) || (state == PTHREAD_CANCEL_DISABLE))
1000cef8:	e51b3010 	ldr	r3, [fp, #-16]
1000cefc:	e3530001 	cmp	r3, #1
1000cf00:	0a000002 	beq	1000cf10 <pthread_setcancelstate+0x64>
1000cf04:	e51b3010 	ldr	r3, [fp, #-16]
1000cf08:	e3530003 	cmp	r3, #3
1000cf0c:	1a00000d 	bne	1000cf48 <pthread_setcancelstate+0x9c>
    {
        if (oldstate)
1000cf10:	e51b3014 	ldr	r3, [fp, #-20]
1000cf14:	e3530000 	cmp	r3, #0
1000cf18:	0a000004 	beq	1000cf30 <pthread_setcancelstate+0x84>
            *oldstate = ptd->cancelstate;
1000cf1c:	e51b3008 	ldr	r3, [fp, #-8]
1000cf20:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
1000cf24:	e1a02003 	mov	r2, r3
1000cf28:	e51b3014 	ldr	r3, [fp, #-20]
1000cf2c:	e5832000 	str	r2, [r3]
        ptd->cancelstate = state;
1000cf30:	e51b3010 	ldr	r3, [fp, #-16]
1000cf34:	e6ef2073 	uxtb	r2, r3
1000cf38:	e51b3008 	ldr	r3, [fp, #-8]
1000cf3c:	e5c32024 	strb	r2, [r3, #36]	; 0x24

        return 0;
1000cf40:	e3a03000 	mov	r3, #0
1000cf44:	ea000000 	b	1000cf4c <pthread_setcancelstate+0xa0>
    }

    return EINVAL;
1000cf48:	e3a03016 	mov	r3, #22
}
1000cf4c:	e1a00003 	mov	r0, r3
1000cf50:	e24bd004 	sub	sp, fp, #4
1000cf54:	e8bd8800 	pop	{fp, pc}

1000cf58 <pthread_setcanceltype>:
RTM_EXPORT(pthread_setcancelstate);

int pthread_setcanceltype(int type, int *oldtype)
{
1000cf58:	e92d4800 	push	{fp, lr}
1000cf5c:	e28db004 	add	fp, sp, #4
1000cf60:	e24dd010 	sub	sp, sp, #16
1000cf64:	e50b0010 	str	r0, [fp, #-16]
1000cf68:	e50b1014 	str	r1, [fp, #-20]
    _pthread_data_t *ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1000cf6c:	ebffee15 	bl	100087c8 <rt_thread_self>
1000cf70:	e1a03000 	mov	r3, r0
1000cf74:	e1a00003 	mov	r0, r3
1000cf78:	ebfffd2a 	bl	1000c428 <_pthread_get_data>
1000cf7c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000cf80:	e51b3008 	ldr	r3, [fp, #-8]
1000cf84:	e3530000 	cmp	r3, #0
1000cf88:	1a000005 	bne	1000cfa4 <pthread_setcanceltype+0x4c>
1000cf8c:	e30f0278 	movw	r0, #62072	; 0xf278
1000cf90:	e3410001 	movt	r0, #4097	; 0x1001
1000cf94:	e30f1364 	movw	r1, #62308	; 0xf364
1000cf98:	e3411001 	movt	r1, #4097	; 0x1001
1000cf9c:	e30021d1 	movw	r2, #465	; 0x1d1
1000cfa0:	ebffe588 	bl	100065c8 <rt_assert_handler>

    if ((type != PTHREAD_CANCEL_DEFERRED) && (type != PTHREAD_CANCEL_ASYNCHRONOUS)) 
1000cfa4:	e51b3010 	ldr	r3, [fp, #-16]
1000cfa8:	e3530002 	cmp	r3, #2
1000cfac:	0a000004 	beq	1000cfc4 <pthread_setcanceltype+0x6c>
1000cfb0:	e51b3010 	ldr	r3, [fp, #-16]
1000cfb4:	e3530000 	cmp	r3, #0
1000cfb8:	0a000001 	beq	1000cfc4 <pthread_setcanceltype+0x6c>
        return EINVAL;
1000cfbc:	e3a03016 	mov	r3, #22
1000cfc0:	ea00000d 	b	1000cffc <pthread_setcanceltype+0xa4>

    if (oldtype)
1000cfc4:	e51b3014 	ldr	r3, [fp, #-20]
1000cfc8:	e3530000 	cmp	r3, #0
1000cfcc:	0a000005 	beq	1000cfe8 <pthread_setcanceltype+0x90>
        *oldtype = ptd->canceltype;
1000cfd0:	e51b3008 	ldr	r3, [fp, #-8]
1000cfd4:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
1000cfd8:	e6ef3073 	uxtb	r3, r3
1000cfdc:	e1a02003 	mov	r2, r3
1000cfe0:	e51b3014 	ldr	r3, [fp, #-20]
1000cfe4:	e5832000 	str	r2, [r3]
    ptd->canceltype = type;
1000cfe8:	e51b3010 	ldr	r3, [fp, #-16]
1000cfec:	e6ef2073 	uxtb	r2, r3
1000cff0:	e51b3008 	ldr	r3, [fp, #-8]
1000cff4:	e5c32025 	strb	r2, [r3, #37]	; 0x25

    return 0;
1000cff8:	e3a03000 	mov	r3, #0
}
1000cffc:	e1a00003 	mov	r0, r3
1000d000:	e24bd004 	sub	sp, fp, #4
1000d004:	e8bd8800 	pop	{fp, pc}

1000d008 <pthread_testcancel>:
RTM_EXPORT(pthread_setcanceltype);

void pthread_testcancel(void)
{
1000d008:	e92d4800 	push	{fp, lr}
1000d00c:	e28db004 	add	fp, sp, #4
1000d010:	e24dd008 	sub	sp, sp, #8
    int cancel=0;
1000d014:	e3a03000 	mov	r3, #0
1000d018:	e50b3008 	str	r3, [fp, #-8]
    _pthread_data_t* ptd;

    /* get posix thread data */
    ptd = _pthread_get_data(rt_thread_self());
1000d01c:	ebffede9 	bl	100087c8 <rt_thread_self>
1000d020:	e1a03000 	mov	r3, r0
1000d024:	e1a00003 	mov	r0, r3
1000d028:	ebfffcfe 	bl	1000c428 <_pthread_get_data>
1000d02c:	e50b000c 	str	r0, [fp, #-12]
    RT_ASSERT(ptd != RT_NULL);
1000d030:	e51b300c 	ldr	r3, [fp, #-12]
1000d034:	e3530000 	cmp	r3, #0
1000d038:	1a000005 	bne	1000d054 <pthread_testcancel+0x4c>
1000d03c:	e30f0278 	movw	r0, #62072	; 0xf278
1000d040:	e3410001 	movt	r0, #4097	; 0x1001
1000d044:	e30f137c 	movw	r1, #62332	; 0xf37c
1000d048:	e3411001 	movt	r1, #4097	; 0x1001
1000d04c:	e30021e5 	movw	r2, #485	; 0x1e5
1000d050:	ebffe55c 	bl	100065c8 <rt_assert_handler>

    if (ptd->cancelstate == PTHREAD_CANCEL_ENABLE)
1000d054:	e51b300c 	ldr	r3, [fp, #-12]
1000d058:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
1000d05c:	e3530001 	cmp	r3, #1
1000d060:	1a000003 	bne	1000d074 <pthread_testcancel+0x6c>
        cancel = ptd->canceled;
1000d064:	e51b300c 	ldr	r3, [fp, #-12]
1000d068:	e5d33026 	ldrb	r3, [r3, #38]	; 0x26
1000d06c:	e6ef3073 	uxtb	r3, r3
1000d070:	e50b3008 	str	r3, [fp, #-8]
    if (cancel)
1000d074:	e51b3008 	ldr	r3, [fp, #-8]
1000d078:	e3530000 	cmp	r3, #0
1000d07c:	0a000001 	beq	1000d088 <pthread_testcancel+0x80>
        pthread_exit((void*)PTHREAD_CANCELED);
1000d080:	e3a00004 	mov	r0, #4
1000d084:	ebfffe94 	bl	1000cadc <pthread_exit>
}
1000d088:	e24bd004 	sub	sp, fp, #4
1000d08c:	e8bd8800 	pop	{fp, pc}

1000d090 <pthread_cancel>:
RTM_EXPORT(pthread_testcancel);

int pthread_cancel(pthread_t thread)
{
1000d090:	e92d4800 	push	{fp, lr}
1000d094:	e28db004 	add	fp, sp, #4
1000d098:	e24dd010 	sub	sp, sp, #16
1000d09c:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;

    /* cancel self */
    if (thread == rt_thread_self())
1000d0a0:	ebffedc8 	bl	100087c8 <rt_thread_self>
1000d0a4:	e1a02000 	mov	r2, r0
1000d0a8:	e51b3010 	ldr	r3, [fp, #-16]
1000d0ac:	e1520003 	cmp	r2, r3
1000d0b0:	1a000001 	bne	1000d0bc <pthread_cancel+0x2c>
        return 0;
1000d0b4:	e3a03000 	mov	r3, #0
1000d0b8:	ea00001a 	b	1000d128 <pthread_cancel+0x98>

    /* get posix thread data */
    ptd = _pthread_get_data(thread);
1000d0bc:	e51b0010 	ldr	r0, [fp, #-16]
1000d0c0:	ebfffcd8 	bl	1000c428 <_pthread_get_data>
1000d0c4:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000d0c8:	e51b3008 	ldr	r3, [fp, #-8]
1000d0cc:	e3530000 	cmp	r3, #0
1000d0d0:	1a000005 	bne	1000d0ec <pthread_cancel+0x5c>
1000d0d4:	e30f0278 	movw	r0, #62072	; 0xf278
1000d0d8:	e3410001 	movt	r0, #4097	; 0x1001
1000d0dc:	e30f1390 	movw	r1, #62352	; 0xf390
1000d0e0:	e3411001 	movt	r1, #4097	; 0x1001
1000d0e4:	e3a02f7e 	mov	r2, #504	; 0x1f8
1000d0e8:	ebffe536 	bl	100065c8 <rt_assert_handler>

    /* set canceled */
    if (ptd->cancelstate == PTHREAD_CANCEL_ENABLE)
1000d0ec:	e51b3008 	ldr	r3, [fp, #-8]
1000d0f0:	e5d33024 	ldrb	r3, [r3, #36]	; 0x24
1000d0f4:	e3530001 	cmp	r3, #1
1000d0f8:	1a000009 	bne	1000d124 <pthread_cancel+0x94>
    {
        ptd->canceled = 1;
1000d0fc:	e51b3008 	ldr	r3, [fp, #-8]
1000d100:	e3a02001 	mov	r2, #1
1000d104:	e5c32026 	strb	r2, [r3, #38]	; 0x26
        if (ptd->canceltype == PTHREAD_CANCEL_ASYNCHRONOUS)
1000d108:	e51b3008 	ldr	r3, [fp, #-8]
1000d10c:	e5d33025 	ldrb	r3, [r3, #37]	; 0x25
1000d110:	e6ef3073 	uxtb	r3, r3
1000d114:	e3530000 	cmp	r3, #0
1000d118:	1a000001 	bne	1000d124 <pthread_cancel+0x94>
             * this thread will be removed from scheduler list
             * and because there is a cleanup function in the
             * thread (pthread_cleanup), it will move to defunct
             * thread list and wait for handling in idle thread.
             */
            rt_thread_detach(thread);
1000d11c:	e51b0010 	ldr	r0, [fp, #-16]
1000d120:	ebffede2 	bl	100088b0 <rt_thread_detach>
        }
    }

    return 0;
1000d124:	e3a03000 	mov	r3, #0
}
1000d128:	e1a00003 	mov	r0, r3
1000d12c:	e24bd004 	sub	sp, fp, #4
1000d130:	e8bd8800 	pop	{fp, pc}

1000d134 <pthread_attr_init>:
    SCHED_FIFO,                 /* scheduler policy */
    PTHREAD_INHERIT_SCHED       /* Inherit parent prio/policy */
};

int pthread_attr_init(pthread_attr_t *attr)
{
1000d134:	e92d4800 	push	{fp, lr}
1000d138:	e28db004 	add	fp, sp, #4
1000d13c:	e24dd008 	sub	sp, sp, #8
1000d140:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(attr != RT_NULL);
1000d144:	e51b3008 	ldr	r3, [fp, #-8]
1000d148:	e3530000 	cmp	r3, #0
1000d14c:	1a000005 	bne	1000d168 <pthread_attr_init+0x34>
1000d150:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d154:	e3410001 	movt	r0, #4097	; 0x1001
1000d158:	e30f13d0 	movw	r1, #62416	; 0xf3d0
1000d15c:	e3411001 	movt	r1, #4097	; 0x1001
1000d160:	e3a0202d 	mov	r2, #45	; 0x2d
1000d164:	ebffe517 	bl	100065c8 <rt_assert_handler>

    *attr = pthread_default_attr;
1000d168:	e51b2008 	ldr	r2, [fp, #-8]
1000d16c:	e30f33a0 	movw	r3, #62368	; 0xf3a0
1000d170:	e3413001 	movt	r3, #4097	; 0x1001
1000d174:	e1a0c002 	mov	ip, r2
1000d178:	e8930007 	ldm	r3, {r0, r1, r2}
1000d17c:	e88c0007 	stm	ip, {r0, r1, r2}

    return 0;
1000d180:	e3a03000 	mov	r3, #0
}
1000d184:	e1a00003 	mov	r0, r3
1000d188:	e24bd004 	sub	sp, fp, #4
1000d18c:	e8bd8800 	pop	{fp, pc}

1000d190 <pthread_attr_destroy>:
RTM_EXPORT(pthread_attr_init);

int pthread_attr_destroy(pthread_attr_t *attr)
{
1000d190:	e92d4800 	push	{fp, lr}
1000d194:	e28db004 	add	fp, sp, #4
1000d198:	e24dd008 	sub	sp, sp, #8
1000d19c:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(attr != RT_NULL);
1000d1a0:	e51b3008 	ldr	r3, [fp, #-8]
1000d1a4:	e3530000 	cmp	r3, #0
1000d1a8:	1a000005 	bne	1000d1c4 <pthread_attr_destroy+0x34>
1000d1ac:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d1b0:	e3410001 	movt	r0, #4097	; 0x1001
1000d1b4:	e30f13e4 	movw	r1, #62436	; 0xf3e4
1000d1b8:	e3411001 	movt	r1, #4097	; 0x1001
1000d1bc:	e3a02037 	mov	r2, #55	; 0x37
1000d1c0:	ebffe500 	bl	100065c8 <rt_assert_handler>

    memset(attr, 0, sizeof(pthread_attr_t));
1000d1c4:	e51b0008 	ldr	r0, [fp, #-8]
1000d1c8:	e3a01000 	mov	r1, #0
1000d1cc:	e3a0200c 	mov	r2, #12
1000d1d0:	fa0041c1 	blx	1001d8dc <memset>

    return 0;
1000d1d4:	e3a03000 	mov	r3, #0
}
1000d1d8:	e1a00003 	mov	r0, r3
1000d1dc:	e24bd004 	sub	sp, fp, #4
1000d1e0:	e8bd8800 	pop	{fp, pc}

1000d1e4 <pthread_attr_setdetachstate>:
RTM_EXPORT(pthread_attr_destroy);

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
1000d1e4:	e92d4800 	push	{fp, lr}
1000d1e8:	e28db004 	add	fp, sp, #4
1000d1ec:	e24dd008 	sub	sp, sp, #8
1000d1f0:	e50b0008 	str	r0, [fp, #-8]
1000d1f4:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d1f8:	e51b3008 	ldr	r3, [fp, #-8]
1000d1fc:	e3530000 	cmp	r3, #0
1000d200:	1a000005 	bne	1000d21c <pthread_attr_setdetachstate+0x38>
1000d204:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d208:	e3410001 	movt	r0, #4097	; 0x1001
1000d20c:	e30f13fc 	movw	r1, #62460	; 0xf3fc
1000d210:	e3411001 	movt	r1, #4097	; 0x1001
1000d214:	e3a02041 	mov	r2, #65	; 0x41
1000d218:	ebffe4ea 	bl	100065c8 <rt_assert_handler>

    if (state != PTHREAD_CREATE_JOINABLE && state != PTHREAD_CREATE_DETACHED)
1000d21c:	e51b300c 	ldr	r3, [fp, #-12]
1000d220:	e3530000 	cmp	r3, #0
1000d224:	0a000004 	beq	1000d23c <pthread_attr_setdetachstate+0x58>
1000d228:	e51b300c 	ldr	r3, [fp, #-12]
1000d22c:	e3530001 	cmp	r3, #1
1000d230:	0a000001 	beq	1000d23c <pthread_attr_setdetachstate+0x58>
        return EINVAL;
1000d234:	e3a03016 	mov	r3, #22
1000d238:	ea000004 	b	1000d250 <pthread_attr_setdetachstate+0x6c>

    attr->detachstate = state;
1000d23c:	e51b300c 	ldr	r3, [fp, #-12]
1000d240:	e6ef2073 	uxtb	r2, r3
1000d244:	e51b3008 	ldr	r3, [fp, #-8]
1000d248:	e5c32007 	strb	r2, [r3, #7]

    return 0;
1000d24c:	e3a03000 	mov	r3, #0
}
1000d250:	e1a00003 	mov	r0, r3
1000d254:	e24bd004 	sub	sp, fp, #4
1000d258:	e8bd8800 	pop	{fp, pc}

1000d25c <pthread_attr_getdetachstate>:
RTM_EXPORT(pthread_attr_setdetachstate);

int pthread_attr_getdetachstate(pthread_attr_t const *attr, int *state)
{
1000d25c:	e92d4800 	push	{fp, lr}
1000d260:	e28db004 	add	fp, sp, #4
1000d264:	e24dd008 	sub	sp, sp, #8
1000d268:	e50b0008 	str	r0, [fp, #-8]
1000d26c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d270:	e51b3008 	ldr	r3, [fp, #-8]
1000d274:	e3530000 	cmp	r3, #0
1000d278:	1a000005 	bne	1000d294 <pthread_attr_getdetachstate+0x38>
1000d27c:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d280:	e3410001 	movt	r0, #4097	; 0x1001
1000d284:	e30f1418 	movw	r1, #62488	; 0xf418
1000d288:	e3411001 	movt	r1, #4097	; 0x1001
1000d28c:	e3a0204e 	mov	r2, #78	; 0x4e
1000d290:	ebffe4cc 	bl	100065c8 <rt_assert_handler>

    *state = (int)attr->detachstate;
1000d294:	e51b3008 	ldr	r3, [fp, #-8]
1000d298:	e5d33007 	ldrb	r3, [r3, #7]
1000d29c:	e1a02003 	mov	r2, r3
1000d2a0:	e51b300c 	ldr	r3, [fp, #-12]
1000d2a4:	e5832000 	str	r2, [r3]

    return 0;
1000d2a8:	e3a03000 	mov	r3, #0
}
1000d2ac:	e1a00003 	mov	r0, r3
1000d2b0:	e24bd004 	sub	sp, fp, #4
1000d2b4:	e8bd8800 	pop	{fp, pc}

1000d2b8 <pthread_attr_setschedpolicy>:
RTM_EXPORT(pthread_attr_getdetachstate);

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
1000d2b8:	e92d4800 	push	{fp, lr}
1000d2bc:	e28db004 	add	fp, sp, #4
1000d2c0:	e24dd008 	sub	sp, sp, #8
1000d2c4:	e50b0008 	str	r0, [fp, #-8]
1000d2c8:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d2cc:	e51b3008 	ldr	r3, [fp, #-8]
1000d2d0:	e3530000 	cmp	r3, #0
1000d2d4:	1a000005 	bne	1000d2f0 <pthread_attr_setschedpolicy+0x38>
1000d2d8:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d2dc:	e3410001 	movt	r0, #4097	; 0x1001
1000d2e0:	e30f1434 	movw	r1, #62516	; 0xf434
1000d2e4:	e3411001 	movt	r1, #4097	; 0x1001
1000d2e8:	e3a02058 	mov	r2, #88	; 0x58
1000d2ec:	ebffe4b5 	bl	100065c8 <rt_assert_handler>

    attr->policy = policy;
1000d2f0:	e51b300c 	ldr	r3, [fp, #-12]
1000d2f4:	e6ef2073 	uxtb	r2, r3
1000d2f8:	e51b3008 	ldr	r3, [fp, #-8]
1000d2fc:	e5c32008 	strb	r2, [r3, #8]

    return 0;
1000d300:	e3a03000 	mov	r3, #0
}
1000d304:	e1a00003 	mov	r0, r3
1000d308:	e24bd004 	sub	sp, fp, #4
1000d30c:	e8bd8800 	pop	{fp, pc}

1000d310 <pthread_attr_getschedpolicy>:
RTM_EXPORT(pthread_attr_setschedpolicy);

int pthread_attr_getschedpolicy(pthread_attr_t const *attr, int *policy)
{
1000d310:	e92d4800 	push	{fp, lr}
1000d314:	e28db004 	add	fp, sp, #4
1000d318:	e24dd008 	sub	sp, sp, #8
1000d31c:	e50b0008 	str	r0, [fp, #-8]
1000d320:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d324:	e51b3008 	ldr	r3, [fp, #-8]
1000d328:	e3530000 	cmp	r3, #0
1000d32c:	1a000005 	bne	1000d348 <pthread_attr_getschedpolicy+0x38>
1000d330:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d334:	e3410001 	movt	r0, #4097	; 0x1001
1000d338:	e30f1450 	movw	r1, #62544	; 0xf450
1000d33c:	e3411001 	movt	r1, #4097	; 0x1001
1000d340:	e3a02062 	mov	r2, #98	; 0x62
1000d344:	ebffe49f 	bl	100065c8 <rt_assert_handler>

    *policy = (int)attr->policy;
1000d348:	e51b3008 	ldr	r3, [fp, #-8]
1000d34c:	e5d33008 	ldrb	r3, [r3, #8]
1000d350:	e1a02003 	mov	r2, r3
1000d354:	e51b300c 	ldr	r3, [fp, #-12]
1000d358:	e5832000 	str	r2, [r3]

    return 0;
1000d35c:	e3a03000 	mov	r3, #0
}
1000d360:	e1a00003 	mov	r0, r3
1000d364:	e24bd004 	sub	sp, fp, #4
1000d368:	e8bd8800 	pop	{fp, pc}

1000d36c <pthread_attr_setschedparam>:
RTM_EXPORT(pthread_attr_getschedpolicy);

int pthread_attr_setschedparam(pthread_attr_t           *attr,
                               struct sched_param const *param)
{
1000d36c:	e92d4800 	push	{fp, lr}
1000d370:	e28db004 	add	fp, sp, #4
1000d374:	e24dd008 	sub	sp, sp, #8
1000d378:	e50b0008 	str	r0, [fp, #-8]
1000d37c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d380:	e51b3008 	ldr	r3, [fp, #-8]
1000d384:	e3530000 	cmp	r3, #0
1000d388:	1a000005 	bne	1000d3a4 <pthread_attr_setschedparam+0x38>
1000d38c:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d390:	e3410001 	movt	r0, #4097	; 0x1001
1000d394:	e30f146c 	movw	r1, #62572	; 0xf46c
1000d398:	e3411001 	movt	r1, #4097	; 0x1001
1000d39c:	e3a0206d 	mov	r2, #109	; 0x6d
1000d3a0:	ebffe488 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(param != RT_NULL);
1000d3a4:	e51b300c 	ldr	r3, [fp, #-12]
1000d3a8:	e3530000 	cmp	r3, #0
1000d3ac:	1a000005 	bne	1000d3c8 <pthread_attr_setschedparam+0x5c>
1000d3b0:	e30f03bc 	movw	r0, #62396	; 0xf3bc
1000d3b4:	e3410001 	movt	r0, #4097	; 0x1001
1000d3b8:	e30f146c 	movw	r1, #62572	; 0xf46c
1000d3bc:	e3411001 	movt	r1, #4097	; 0x1001
1000d3c0:	e3a0206e 	mov	r2, #110	; 0x6e
1000d3c4:	ebffe47f 	bl	100065c8 <rt_assert_handler>

    attr->priority = param->sched_priority;
1000d3c8:	e51b300c 	ldr	r3, [fp, #-12]
1000d3cc:	e5933000 	ldr	r3, [r3]
1000d3d0:	e6ef2073 	uxtb	r2, r3
1000d3d4:	e51b3008 	ldr	r3, [fp, #-8]
1000d3d8:	e5c32006 	strb	r2, [r3, #6]

    return 0;
1000d3dc:	e3a03000 	mov	r3, #0
}
1000d3e0:	e1a00003 	mov	r0, r3
1000d3e4:	e24bd004 	sub	sp, fp, #4
1000d3e8:	e8bd8800 	pop	{fp, pc}

1000d3ec <pthread_attr_getschedparam>:
RTM_EXPORT(pthread_attr_setschedparam);

int pthread_attr_getschedparam(pthread_attr_t const *attr,
                               struct sched_param   *param)
{
1000d3ec:	e92d4800 	push	{fp, lr}
1000d3f0:	e28db004 	add	fp, sp, #4
1000d3f4:	e24dd008 	sub	sp, sp, #8
1000d3f8:	e50b0008 	str	r0, [fp, #-8]
1000d3fc:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d400:	e51b3008 	ldr	r3, [fp, #-8]
1000d404:	e3530000 	cmp	r3, #0
1000d408:	1a000005 	bne	1000d424 <pthread_attr_getschedparam+0x38>
1000d40c:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d410:	e3410001 	movt	r0, #4097	; 0x1001
1000d414:	e30f1488 	movw	r1, #62600	; 0xf488
1000d418:	e3411001 	movt	r1, #4097	; 0x1001
1000d41c:	e3a02079 	mov	r2, #121	; 0x79
1000d420:	ebffe468 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(param != RT_NULL);
1000d424:	e51b300c 	ldr	r3, [fp, #-12]
1000d428:	e3530000 	cmp	r3, #0
1000d42c:	1a000005 	bne	1000d448 <pthread_attr_getschedparam+0x5c>
1000d430:	e30f03bc 	movw	r0, #62396	; 0xf3bc
1000d434:	e3410001 	movt	r0, #4097	; 0x1001
1000d438:	e30f1488 	movw	r1, #62600	; 0xf488
1000d43c:	e3411001 	movt	r1, #4097	; 0x1001
1000d440:	e3a0207a 	mov	r2, #122	; 0x7a
1000d444:	ebffe45f 	bl	100065c8 <rt_assert_handler>

    param->sched_priority = attr->priority;
1000d448:	e51b3008 	ldr	r3, [fp, #-8]
1000d44c:	e5d33006 	ldrb	r3, [r3, #6]
1000d450:	e1a02003 	mov	r2, r3
1000d454:	e51b300c 	ldr	r3, [fp, #-12]
1000d458:	e5832000 	str	r2, [r3]

    return 0;
1000d45c:	e3a03000 	mov	r3, #0
}
1000d460:	e1a00003 	mov	r0, r3
1000d464:	e24bd004 	sub	sp, fp, #4
1000d468:	e8bd8800 	pop	{fp, pc}

1000d46c <pthread_attr_setstacksize>:
RTM_EXPORT(pthread_attr_getschedparam);

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stack_size)
{
1000d46c:	e92d4800 	push	{fp, lr}
1000d470:	e28db004 	add	fp, sp, #4
1000d474:	e24dd008 	sub	sp, sp, #8
1000d478:	e50b0008 	str	r0, [fp, #-8]
1000d47c:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d480:	e51b3008 	ldr	r3, [fp, #-8]
1000d484:	e3530000 	cmp	r3, #0
1000d488:	1a000005 	bne	1000d4a4 <pthread_attr_setstacksize+0x38>
1000d48c:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d490:	e3410001 	movt	r0, #4097	; 0x1001
1000d494:	e30f14a4 	movw	r1, #62628	; 0xf4a4
1000d498:	e3411001 	movt	r1, #4097	; 0x1001
1000d49c:	e3a02084 	mov	r2, #132	; 0x84
1000d4a0:	ebffe448 	bl	100065c8 <rt_assert_handler>

    attr->stack_size = stack_size;
1000d4a4:	e51b300c 	ldr	r3, [fp, #-12]
1000d4a8:	e6ff2073 	uxth	r2, r3
1000d4ac:	e51b3008 	ldr	r3, [fp, #-8]
1000d4b0:	e1c320b4 	strh	r2, [r3, #4]

    return 0;
1000d4b4:	e3a03000 	mov	r3, #0
}
1000d4b8:	e1a00003 	mov	r0, r3
1000d4bc:	e24bd004 	sub	sp, fp, #4
1000d4c0:	e8bd8800 	pop	{fp, pc}

1000d4c4 <pthread_attr_getstacksize>:
RTM_EXPORT(pthread_attr_setstacksize);

int pthread_attr_getstacksize(pthread_attr_t const *attr, size_t *stack_size)
{
1000d4c4:	e92d4800 	push	{fp, lr}
1000d4c8:	e28db004 	add	fp, sp, #4
1000d4cc:	e24dd008 	sub	sp, sp, #8
1000d4d0:	e50b0008 	str	r0, [fp, #-8]
1000d4d4:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d4d8:	e51b3008 	ldr	r3, [fp, #-8]
1000d4dc:	e3530000 	cmp	r3, #0
1000d4e0:	1a000005 	bne	1000d4fc <pthread_attr_getstacksize+0x38>
1000d4e4:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d4e8:	e3410001 	movt	r0, #4097	; 0x1001
1000d4ec:	e30f14c0 	movw	r1, #62656	; 0xf4c0
1000d4f0:	e3411001 	movt	r1, #4097	; 0x1001
1000d4f4:	e3a0208e 	mov	r2, #142	; 0x8e
1000d4f8:	ebffe432 	bl	100065c8 <rt_assert_handler>

    *stack_size = attr->stack_size;
1000d4fc:	e51b3008 	ldr	r3, [fp, #-8]
1000d500:	e1d330b4 	ldrh	r3, [r3, #4]
1000d504:	e1a02003 	mov	r2, r3
1000d508:	e51b300c 	ldr	r3, [fp, #-12]
1000d50c:	e5832000 	str	r2, [r3]

    return 0;
1000d510:	e3a03000 	mov	r3, #0
}
1000d514:	e1a00003 	mov	r0, r3
1000d518:	e24bd004 	sub	sp, fp, #4
1000d51c:	e8bd8800 	pop	{fp, pc}

1000d520 <pthread_attr_setstackaddr>:
RTM_EXPORT(pthread_attr_getstacksize);

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack_addr)
{
1000d520:	e92d4800 	push	{fp, lr}
1000d524:	e28db004 	add	fp, sp, #4
1000d528:	e24dd008 	sub	sp, sp, #8
1000d52c:	e50b0008 	str	r0, [fp, #-8]
1000d530:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d534:	e51b3008 	ldr	r3, [fp, #-8]
1000d538:	e3530000 	cmp	r3, #0
1000d53c:	1a000005 	bne	1000d558 <pthread_attr_setstackaddr+0x38>
1000d540:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d544:	e3410001 	movt	r0, #4097	; 0x1001
1000d548:	e30f14dc 	movw	r1, #62684	; 0xf4dc
1000d54c:	e3411001 	movt	r1, #4097	; 0x1001
1000d550:	e3a02098 	mov	r2, #152	; 0x98
1000d554:	ebffe41b 	bl	100065c8 <rt_assert_handler>

    return EOPNOTSUPP;
1000d558:	e3a0305f 	mov	r3, #95	; 0x5f
}
1000d55c:	e1a00003 	mov	r0, r3
1000d560:	e24bd004 	sub	sp, fp, #4
1000d564:	e8bd8800 	pop	{fp, pc}

1000d568 <pthread_attr_getstackaddr>:
RTM_EXPORT(pthread_attr_setstackaddr);

int pthread_attr_getstackaddr(pthread_attr_t const *attr, void **stack_addr)
{
1000d568:	e92d4800 	push	{fp, lr}
1000d56c:	e28db004 	add	fp, sp, #4
1000d570:	e24dd008 	sub	sp, sp, #8
1000d574:	e50b0008 	str	r0, [fp, #-8]
1000d578:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(attr != RT_NULL);
1000d57c:	e51b3008 	ldr	r3, [fp, #-8]
1000d580:	e3530000 	cmp	r3, #0
1000d584:	1a000005 	bne	1000d5a0 <pthread_attr_getstackaddr+0x38>
1000d588:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d58c:	e3410001 	movt	r0, #4097	; 0x1001
1000d590:	e30f14f8 	movw	r1, #62712	; 0xf4f8
1000d594:	e3411001 	movt	r1, #4097	; 0x1001
1000d598:	e3a020a0 	mov	r2, #160	; 0xa0
1000d59c:	ebffe409 	bl	100065c8 <rt_assert_handler>

    return EOPNOTSUPP;
1000d5a0:	e3a0305f 	mov	r3, #95	; 0x5f
}
1000d5a4:	e1a00003 	mov	r0, r3
1000d5a8:	e24bd004 	sub	sp, fp, #4
1000d5ac:	e8bd8800 	pop	{fp, pc}

1000d5b0 <pthread_attr_setstack>:
RTM_EXPORT(pthread_attr_getstackaddr);

int pthread_attr_setstack(pthread_attr_t *attr,
                          void           *stack_base,
                          size_t          stack_size)
{
1000d5b0:	e92d4800 	push	{fp, lr}
1000d5b4:	e28db004 	add	fp, sp, #4
1000d5b8:	e24dd010 	sub	sp, sp, #16
1000d5bc:	e50b0008 	str	r0, [fp, #-8]
1000d5c0:	e50b100c 	str	r1, [fp, #-12]
1000d5c4:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(attr != RT_NULL);
1000d5c8:	e51b3008 	ldr	r3, [fp, #-8]
1000d5cc:	e3530000 	cmp	r3, #0
1000d5d0:	1a000005 	bne	1000d5ec <pthread_attr_setstack+0x3c>
1000d5d4:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d5d8:	e3410001 	movt	r0, #4097	; 0x1001
1000d5dc:	e30f1514 	movw	r1, #62740	; 0xf514
1000d5e0:	e3411001 	movt	r1, #4097	; 0x1001
1000d5e4:	e3a020aa 	mov	r2, #170	; 0xaa
1000d5e8:	ebffe3f6 	bl	100065c8 <rt_assert_handler>

    attr->stack_base = stack_base;
1000d5ec:	e51b3008 	ldr	r3, [fp, #-8]
1000d5f0:	e51b200c 	ldr	r2, [fp, #-12]
1000d5f4:	e5832000 	str	r2, [r3]
    attr->stack_size = RT_ALIGN_DOWN(stack_size, RT_ALIGN_SIZE);
1000d5f8:	e51b3010 	ldr	r3, [fp, #-16]
1000d5fc:	e6ff3073 	uxth	r3, r3
1000d600:	e3c33003 	bic	r3, r3, #3
1000d604:	e6ff2073 	uxth	r2, r3
1000d608:	e51b3008 	ldr	r3, [fp, #-8]
1000d60c:	e1c320b4 	strh	r2, [r3, #4]

    return 0;
1000d610:	e3a03000 	mov	r3, #0
}
1000d614:	e1a00003 	mov	r0, r3
1000d618:	e24bd004 	sub	sp, fp, #4
1000d61c:	e8bd8800 	pop	{fp, pc}

1000d620 <pthread_attr_getstack>:
RTM_EXPORT(pthread_attr_setstack);

int pthread_attr_getstack(pthread_attr_t const *attr,
                          void                **stack_base,
                          size_t               *stack_size)
{
1000d620:	e92d4800 	push	{fp, lr}
1000d624:	e28db004 	add	fp, sp, #4
1000d628:	e24dd010 	sub	sp, sp, #16
1000d62c:	e50b0008 	str	r0, [fp, #-8]
1000d630:	e50b100c 	str	r1, [fp, #-12]
1000d634:	e50b2010 	str	r2, [fp, #-16]
    RT_ASSERT(attr != RT_NULL);
1000d638:	e51b3008 	ldr	r3, [fp, #-8]
1000d63c:	e3530000 	cmp	r3, #0
1000d640:	1a000005 	bne	1000d65c <pthread_attr_getstack+0x3c>
1000d644:	e30f03ac 	movw	r0, #62380	; 0xf3ac
1000d648:	e3410001 	movt	r0, #4097	; 0x1001
1000d64c:	e30f152c 	movw	r1, #62764	; 0xf52c
1000d650:	e3411001 	movt	r1, #4097	; 0x1001
1000d654:	e3a020b7 	mov	r2, #183	; 0xb7
1000d658:	ebffe3da 	bl	100065c8 <rt_assert_handler>

    *stack_base = attr->stack_base;
1000d65c:	e51b3008 	ldr	r3, [fp, #-8]
1000d660:	e5932000 	ldr	r2, [r3]
1000d664:	e51b300c 	ldr	r3, [fp, #-12]
1000d668:	e5832000 	str	r2, [r3]
    *stack_size = attr->stack_size;
1000d66c:	e51b3008 	ldr	r3, [fp, #-8]
1000d670:	e1d330b4 	ldrh	r3, [r3, #4]
1000d674:	e1a02003 	mov	r2, r3
1000d678:	e51b3010 	ldr	r3, [fp, #-16]
1000d67c:	e5832000 	str	r2, [r3]

    return 0;
1000d680:	e3a03000 	mov	r3, #0
}
1000d684:	e1a00003 	mov	r0, r3
1000d688:	e24bd004 	sub	sp, fp, #4
1000d68c:	e8bd8800 	pop	{fp, pc}

1000d690 <pthread_attr_setguardsize>:
RTM_EXPORT(pthread_attr_getstack);

int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guard_size)
{
1000d690:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000d694:	e28db000 	add	fp, sp, #0
1000d698:	e24dd00c 	sub	sp, sp, #12
1000d69c:	e50b0008 	str	r0, [fp, #-8]
1000d6a0:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
1000d6a4:	e3a0305f 	mov	r3, #95	; 0x5f
}
1000d6a8:	e1a00003 	mov	r0, r3
1000d6ac:	e24bd000 	sub	sp, fp, #0
1000d6b0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000d6b4:	e12fff1e 	bx	lr

1000d6b8 <pthread_attr_getguardsize>:

int pthread_attr_getguardsize(pthread_attr_t const *attr, size_t *guard_size)
{
1000d6b8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000d6bc:	e28db000 	add	fp, sp, #0
1000d6c0:	e24dd00c 	sub	sp, sp, #12
1000d6c4:	e50b0008 	str	r0, [fp, #-8]
1000d6c8:	e50b100c 	str	r1, [fp, #-12]
    return EOPNOTSUPP;
1000d6cc:	e3a0305f 	mov	r3, #95	; 0x5f
}
1000d6d0:	e1a00003 	mov	r0, r3
1000d6d4:	e24bd000 	sub	sp, fp, #0
1000d6d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000d6dc:	e12fff1e 	bx	lr

1000d6e0 <pthread_attr_setscope>:
RTM_EXPORT(pthread_attr_getguardsize);

int pthread_attr_setscope(pthread_attr_t *attr, int scope)
{
1000d6e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000d6e4:	e28db000 	add	fp, sp, #0
1000d6e8:	e24dd00c 	sub	sp, sp, #12
1000d6ec:	e50b0008 	str	r0, [fp, #-8]
1000d6f0:	e50b100c 	str	r1, [fp, #-12]
    if (scope == PTHREAD_SCOPE_SYSTEM)
1000d6f4:	e51b300c 	ldr	r3, [fp, #-12]
1000d6f8:	e3530001 	cmp	r3, #1
1000d6fc:	1a000001 	bne	1000d708 <pthread_attr_setscope+0x28>
        return 0;
1000d700:	e3a03000 	mov	r3, #0
1000d704:	ea000005 	b	1000d720 <pthread_attr_setscope+0x40>
    if (scope == PTHREAD_SCOPE_PROCESS)
1000d708:	e51b300c 	ldr	r3, [fp, #-12]
1000d70c:	e3530000 	cmp	r3, #0
1000d710:	1a000001 	bne	1000d71c <pthread_attr_setscope+0x3c>
        return EOPNOTSUPP;
1000d714:	e3a0305f 	mov	r3, #95	; 0x5f
1000d718:	ea000000 	b	1000d720 <pthread_attr_setscope+0x40>

    return EINVAL;
1000d71c:	e3a03016 	mov	r3, #22
}
1000d720:	e1a00003 	mov	r0, r3
1000d724:	e24bd000 	sub	sp, fp, #0
1000d728:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000d72c:	e12fff1e 	bx	lr

1000d730 <pthread_attr_getscope>:
RTM_EXPORT(pthread_attr_setscope);

int pthread_attr_getscope(pthread_attr_t const *attr)
{
1000d730:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000d734:	e28db000 	add	fp, sp, #0
1000d738:	e24dd00c 	sub	sp, sp, #12
1000d73c:	e50b0008 	str	r0, [fp, #-8]
    return PTHREAD_SCOPE_SYSTEM;
1000d740:	e3a03001 	mov	r3, #1
}
1000d744:	e1a00003 	mov	r0, r3
1000d748:	e24bd000 	sub	sp, fp, #0
1000d74c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000d750:	e12fff1e 	bx	lr

1000d754 <_pthread_get_data>:
    void** tls; /* thread-local storage area */
};
typedef struct _pthread_data _pthread_data_t;

rt_inline _pthread_data_t *_pthread_get_data(pthread_t thread)
{
1000d754:	e92d4800 	push	{fp, lr}
1000d758:	e28db004 	add	fp, sp, #4
1000d75c:	e24dd010 	sub	sp, sp, #16
1000d760:	e50b0010 	str	r0, [fp, #-16]
    _pthread_data_t *ptd;
    RT_ASSERT(thread != RT_NULL);
1000d764:	e51b3010 	ldr	r3, [fp, #-16]
1000d768:	e3530000 	cmp	r3, #0
1000d76c:	1a000005 	bne	1000d788 <_pthread_get_data+0x34>
1000d770:	e30f0544 	movw	r0, #62788	; 0xf544
1000d774:	e3410001 	movt	r0, #4097	; 0x1001
1000d778:	e30f15a4 	movw	r1, #62884	; 0xf5a4
1000d77c:	e3411001 	movt	r1, #4097	; 0x1001
1000d780:	e3a0204c 	mov	r2, #76	; 0x4c
1000d784:	ebffe38f 	bl	100065c8 <rt_assert_handler>

    ptd = (_pthread_data_t *)thread->user_data;
1000d788:	e51b3010 	ldr	r3, [fp, #-16]
1000d78c:	e5933074 	ldr	r3, [r3, #116]	; 0x74
1000d790:	e50b3008 	str	r3, [fp, #-8]
    RT_ASSERT(ptd != RT_NULL);
1000d794:	e51b3008 	ldr	r3, [fp, #-8]
1000d798:	e3530000 	cmp	r3, #0
1000d79c:	1a000005 	bne	1000d7b8 <_pthread_get_data+0x64>
1000d7a0:	e30f0558 	movw	r0, #62808	; 0xf558
1000d7a4:	e3410001 	movt	r0, #4097	; 0x1001
1000d7a8:	e30f15a4 	movw	r1, #62884	; 0xf5a4
1000d7ac:	e3411001 	movt	r1, #4097	; 0x1001
1000d7b0:	e3a0204f 	mov	r2, #79	; 0x4f
1000d7b4:	ebffe383 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(ptd->magic == PTHREAD_MAGIC);
1000d7b8:	e51b3008 	ldr	r3, [fp, #-8]
1000d7bc:	e5932000 	ldr	r2, [r3]
1000d7c0:	e3063873 	movw	r3, #26739	; 0x6873
1000d7c4:	e3473074 	movt	r3, #28788	; 0x7074
1000d7c8:	e1520003 	cmp	r2, r3
1000d7cc:	0a000005 	beq	1000d7e8 <_pthread_get_data+0x94>
1000d7d0:	e30f0568 	movw	r0, #62824	; 0xf568
1000d7d4:	e3410001 	movt	r0, #4097	; 0x1001
1000d7d8:	e30f15a4 	movw	r1, #62884	; 0xf5a4
1000d7dc:	e3411001 	movt	r1, #4097	; 0x1001
1000d7e0:	e3a02050 	mov	r2, #80	; 0x50
1000d7e4:	ebffe377 	bl	100065c8 <rt_assert_handler>

    return ptd;
1000d7e8:	e51b3008 	ldr	r3, [fp, #-8]
}
1000d7ec:	e1a00003 	mov	r0, r3
1000d7f0:	e24bd004 	sub	sp, fp, #4
1000d7f4:	e8bd8800 	pop	{fp, pc}

1000d7f8 <pthread_key_system_init>:
#include "pthread_internal.h"

_pthread_key_data_t _thread_keys[PTHREAD_KEY_MAX];

void pthread_key_system_init()
{
1000d7f8:	e92d4800 	push	{fp, lr}
1000d7fc:	e28db004 	add	fp, sp, #4
    rt_memset(&_thread_keys[0], 0, sizeof(_thread_keys));
1000d800:	e30a0614 	movw	r0, #42516	; 0xa614
1000d804:	e3410002 	movt	r0, #4098	; 0x1002
1000d808:	e3a01000 	mov	r1, #0
1000d80c:	e3a02040 	mov	r2, #64	; 0x40
1000d810:	ebffdcc0 	bl	10004b18 <rt_memset>
}
1000d814:	e8bd8800 	pop	{fp, pc}

1000d818 <pthread_getspecific>:

void *pthread_getspecific(pthread_key_t key)
{
1000d818:	e92d4800 	push	{fp, lr}
1000d81c:	e28db004 	add	fp, sp, #4
1000d820:	e24dd010 	sub	sp, sp, #16
1000d824:	e50b0010 	str	r0, [fp, #-16]
    struct _pthread_data* ptd;

    ptd = _pthread_get_data(rt_thread_self());
1000d828:	ebffebe6 	bl	100087c8 <rt_thread_self>
1000d82c:	e1a03000 	mov	r3, r0
1000d830:	e1a00003 	mov	r0, r3
1000d834:	ebffffc6 	bl	1000d754 <_pthread_get_data>
1000d838:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != NULL);
1000d83c:	e51b3008 	ldr	r3, [fp, #-8]
1000d840:	e3530000 	cmp	r3, #0
1000d844:	1a000005 	bne	1000d860 <pthread_getspecific+0x48>
1000d848:	e30f0584 	movw	r0, #62852	; 0xf584
1000d84c:	e3410001 	movt	r0, #4097	; 0x1001
1000d850:	e30f1590 	movw	r1, #62864	; 0xf590
1000d854:	e3411001 	movt	r1, #4097	; 0x1001
1000d858:	e3a02028 	mov	r2, #40	; 0x28
1000d85c:	ebffe359 	bl	100065c8 <rt_assert_handler>

    if (ptd->tls == NULL)
1000d860:	e51b3008 	ldr	r3, [fp, #-8]
1000d864:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000d868:	e3530000 	cmp	r3, #0
1000d86c:	1a000001 	bne	1000d878 <pthread_getspecific+0x60>
        return NULL;
1000d870:	e3a03000 	mov	r3, #0
1000d874:	ea000010 	b	1000d8bc <pthread_getspecific+0xa4>

    if ((key < PTHREAD_KEY_MAX) && (_thread_keys[key].is_used))
1000d878:	e51b3010 	ldr	r3, [fp, #-16]
1000d87c:	e3530007 	cmp	r3, #7
1000d880:	ca00000c 	bgt	1000d8b8 <pthread_getspecific+0xa0>
1000d884:	e30a3614 	movw	r3, #42516	; 0xa614
1000d888:	e3413002 	movt	r3, #4098	; 0x1002
1000d88c:	e51b2010 	ldr	r2, [fp, #-16]
1000d890:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1000d894:	e3530000 	cmp	r3, #0
1000d898:	0a000006 	beq	1000d8b8 <pthread_getspecific+0xa0>
        return ptd->tls[key];
1000d89c:	e51b3008 	ldr	r3, [fp, #-8]
1000d8a0:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1000d8a4:	e51b3010 	ldr	r3, [fp, #-16]
1000d8a8:	e1a03103 	lsl	r3, r3, #2
1000d8ac:	e0823003 	add	r3, r2, r3
1000d8b0:	e5933000 	ldr	r3, [r3]
1000d8b4:	ea000000 	b	1000d8bc <pthread_getspecific+0xa4>

    return NULL;
1000d8b8:	e3a03000 	mov	r3, #0
}
1000d8bc:	e1a00003 	mov	r0, r3
1000d8c0:	e24bd004 	sub	sp, fp, #4
1000d8c4:	e8bd8800 	pop	{fp, pc}

1000d8c8 <pthread_setspecific>:
RTM_EXPORT(pthread_getspecific);

int pthread_setspecific(pthread_key_t key, const void *value)
{
1000d8c8:	e92d4800 	push	{fp, lr}
1000d8cc:	e28db004 	add	fp, sp, #4
1000d8d0:	e24dd010 	sub	sp, sp, #16
1000d8d4:	e50b0010 	str	r0, [fp, #-16]
1000d8d8:	e50b1014 	str	r1, [fp, #-20]
    struct _pthread_data* ptd;

    ptd = _pthread_get_data(rt_thread_self());
1000d8dc:	ebffebb9 	bl	100087c8 <rt_thread_self>
1000d8e0:	e1a03000 	mov	r3, r0
1000d8e4:	e1a00003 	mov	r0, r3
1000d8e8:	ebffff99 	bl	1000d754 <_pthread_get_data>
1000d8ec:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(ptd != NULL);
1000d8f0:	e51b3008 	ldr	r3, [fp, #-8]
1000d8f4:	e3530000 	cmp	r3, #0
1000d8f8:	1a000005 	bne	1000d914 <pthread_setspecific+0x4c>
1000d8fc:	e30f0584 	movw	r0, #62852	; 0xf584
1000d900:	e3410001 	movt	r0, #4097	; 0x1001
1000d904:	e30f15b8 	movw	r1, #62904	; 0xf5b8
1000d908:	e3411001 	movt	r1, #4097	; 0x1001
1000d90c:	e3a02039 	mov	r2, #57	; 0x39
1000d910:	ebffe32c 	bl	100065c8 <rt_assert_handler>

    /* check tls area */
    if (ptd->tls == NULL)
1000d914:	e51b3008 	ldr	r3, [fp, #-8]
1000d918:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000d91c:	e3530000 	cmp	r3, #0
1000d920:	1a000004 	bne	1000d938 <pthread_setspecific+0x70>
    {
        ptd->tls = (void**)rt_malloc(sizeof(void*) * PTHREAD_KEY_MAX);
1000d924:	e3a00020 	mov	r0, #32
1000d928:	ebffe45e 	bl	10006aa8 <rt_malloc>
1000d92c:	e1a02000 	mov	r2, r0
1000d930:	e51b3008 	ldr	r3, [fp, #-8]
1000d934:	e583202c 	str	r2, [r3, #44]	; 0x2c
    }

    if ((key < PTHREAD_KEY_MAX) && _thread_keys[key].is_used)
1000d938:	e51b3010 	ldr	r3, [fp, #-16]
1000d93c:	e3530007 	cmp	r3, #7
1000d940:	ca00000e 	bgt	1000d980 <pthread_setspecific+0xb8>
1000d944:	e30a3614 	movw	r3, #42516	; 0xa614
1000d948:	e3413002 	movt	r3, #4098	; 0x1002
1000d94c:	e51b2010 	ldr	r2, [fp, #-16]
1000d950:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1000d954:	e3530000 	cmp	r3, #0
1000d958:	0a000008 	beq	1000d980 <pthread_setspecific+0xb8>
    {
        ptd->tls[key] = (void *)value;
1000d95c:	e51b3008 	ldr	r3, [fp, #-8]
1000d960:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
1000d964:	e51b3010 	ldr	r3, [fp, #-16]
1000d968:	e1a03103 	lsl	r3, r3, #2
1000d96c:	e0823003 	add	r3, r2, r3
1000d970:	e51b2014 	ldr	r2, [fp, #-20]
1000d974:	e5832000 	str	r2, [r3]

        return 0;
1000d978:	e3a03000 	mov	r3, #0
1000d97c:	ea000000 	b	1000d984 <pthread_setspecific+0xbc>
    }

    return EINVAL;
1000d980:	e3a03016 	mov	r3, #22
}
1000d984:	e1a00003 	mov	r0, r3
1000d988:	e24bd004 	sub	sp, fp, #4
1000d98c:	e8bd8800 	pop	{fp, pc}

1000d990 <pthread_key_create>:
RTM_EXPORT(pthread_setspecific);

int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
1000d990:	e92d4800 	push	{fp, lr}
1000d994:	e28db004 	add	fp, sp, #4
1000d998:	e24dd010 	sub	sp, sp, #16
1000d99c:	e50b0010 	str	r0, [fp, #-16]
1000d9a0:	e50b1014 	str	r1, [fp, #-20]
    rt_uint32_t index;

    rt_enter_critical();
1000d9a4:	ebffea3f 	bl	100082a8 <rt_enter_critical>
    for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1000d9a8:	e3a03000 	mov	r3, #0
1000d9ac:	e50b3008 	str	r3, [fp, #-8]
1000d9b0:	ea00001a 	b	1000da20 <pthread_key_create+0x90>
    {
        if (_thread_keys[index].is_used == 0)
1000d9b4:	e30a3614 	movw	r3, #42516	; 0xa614
1000d9b8:	e3413002 	movt	r3, #4098	; 0x1002
1000d9bc:	e51b2008 	ldr	r2, [fp, #-8]
1000d9c0:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1000d9c4:	e3530000 	cmp	r3, #0
1000d9c8:	1a000011 	bne	1000da14 <pthread_key_create+0x84>
        {
            _thread_keys[index].is_used = 1;
1000d9cc:	e30a3614 	movw	r3, #42516	; 0xa614
1000d9d0:	e3413002 	movt	r3, #4098	; 0x1002
1000d9d4:	e51b2008 	ldr	r2, [fp, #-8]
1000d9d8:	e3a01001 	mov	r1, #1
1000d9dc:	e7831182 	str	r1, [r3, r2, lsl #3]
            _thread_keys[index].destructor = destructor;
1000d9e0:	e30a2614 	movw	r2, #42516	; 0xa614
1000d9e4:	e3412002 	movt	r2, #4098	; 0x1002
1000d9e8:	e51b3008 	ldr	r3, [fp, #-8]
1000d9ec:	e1a03183 	lsl	r3, r3, #3
1000d9f0:	e0823003 	add	r3, r2, r3
1000d9f4:	e51b2014 	ldr	r2, [fp, #-20]
1000d9f8:	e5832004 	str	r2, [r3, #4]

            *key = index;
1000d9fc:	e51b2008 	ldr	r2, [fp, #-8]
1000da00:	e51b3010 	ldr	r3, [fp, #-16]
1000da04:	e5832000 	str	r2, [r3]

            rt_exit_critical();
1000da08:	ebffea38 	bl	100082f0 <rt_exit_critical>

            return 0;
1000da0c:	e3a03000 	mov	r3, #0
1000da10:	ea000007 	b	1000da34 <pthread_key_create+0xa4>
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
    rt_uint32_t index;

    rt_enter_critical();
    for (index = 0; index < PTHREAD_KEY_MAX; index ++)
1000da14:	e51b3008 	ldr	r3, [fp, #-8]
1000da18:	e2833001 	add	r3, r3, #1
1000da1c:	e50b3008 	str	r3, [fp, #-8]
1000da20:	e51b3008 	ldr	r3, [fp, #-8]
1000da24:	e3530007 	cmp	r3, #7
1000da28:	9affffe1 	bls	1000d9b4 <pthread_key_create+0x24>

            return 0;
        }
    }

    rt_exit_critical();
1000da2c:	ebffea2f 	bl	100082f0 <rt_exit_critical>

    return EAGAIN;
1000da30:	e3a0300b 	mov	r3, #11
}
1000da34:	e1a00003 	mov	r0, r3
1000da38:	e24bd004 	sub	sp, fp, #4
1000da3c:	e8bd8800 	pop	{fp, pc}

1000da40 <pthread_key_delete>:
RTM_EXPORT(pthread_key_create);

int pthread_key_delete(pthread_key_t key)
{
1000da40:	e92d4800 	push	{fp, lr}
1000da44:	e28db004 	add	fp, sp, #4
1000da48:	e24dd008 	sub	sp, sp, #8
1000da4c:	e50b0008 	str	r0, [fp, #-8]
    if (key >= PTHREAD_KEY_MAX)
1000da50:	e51b3008 	ldr	r3, [fp, #-8]
1000da54:	e3530007 	cmp	r3, #7
1000da58:	da000001 	ble	1000da64 <pthread_key_delete+0x24>
        return EINVAL;
1000da5c:	e3a03016 	mov	r3, #22
1000da60:	ea00000e 	b	1000daa0 <pthread_key_delete+0x60>

    rt_enter_critical();
1000da64:	ebffea0f 	bl	100082a8 <rt_enter_critical>
    _thread_keys[key].is_used = 0;
1000da68:	e30a3614 	movw	r3, #42516	; 0xa614
1000da6c:	e3413002 	movt	r3, #4098	; 0x1002
1000da70:	e51b2008 	ldr	r2, [fp, #-8]
1000da74:	e3a01000 	mov	r1, #0
1000da78:	e7831182 	str	r1, [r3, r2, lsl #3]
    _thread_keys[key].destructor = 0;
1000da7c:	e30a2614 	movw	r2, #42516	; 0xa614
1000da80:	e3412002 	movt	r2, #4098	; 0x1002
1000da84:	e51b3008 	ldr	r3, [fp, #-8]
1000da88:	e1a03183 	lsl	r3, r3, #3
1000da8c:	e0823003 	add	r3, r2, r3
1000da90:	e3a02000 	mov	r2, #0
1000da94:	e5832004 	str	r2, [r3, #4]
    rt_exit_critical();
1000da98:	ebffea14 	bl	100082f0 <rt_exit_critical>

    return 0;
1000da9c:	e3a03000 	mov	r3, #0
}
1000daa0:	e1a00003 	mov	r0, r3
1000daa4:	e24bd004 	sub	sp, fp, #4
1000daa8:	e8bd8800 	pop	{fp, pc}

1000daac <posix_sem_system_init>:
#include "pthread_internal.h"

static sem_t *posix_sem_list = RT_NULL;
static struct rt_semaphore posix_sem_lock;
void posix_sem_system_init()
{
1000daac:	e92d4800 	push	{fp, lr}
1000dab0:	e28db004 	add	fp, sp, #4
    rt_sem_init(&posix_sem_lock, "psem", 1, RT_IPC_FLAG_FIFO);
1000dab4:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dab8:	e3410002 	movt	r0, #4098	; 0x1002
1000dabc:	e30f15cc 	movw	r1, #62924	; 0xf5cc
1000dac0:	e3411001 	movt	r1, #4097	; 0x1001
1000dac4:	e3a02001 	mov	r2, #1
1000dac8:	e3a03000 	mov	r3, #0
1000dacc:	ebffcfff 	bl	10001ad0 <rt_sem_init>
}
1000dad0:	e8bd8800 	pop	{fp, pc}

1000dad4 <posix_sem_insert>:

rt_inline void posix_sem_insert(sem_t *psem)
{
1000dad4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000dad8:	e28db000 	add	fp, sp, #0
1000dadc:	e24dd00c 	sub	sp, sp, #12
1000dae0:	e50b0008 	str	r0, [fp, #-8]
    psem->next = posix_sem_list;
1000dae4:	e3083c38 	movw	r3, #35896	; 0x8c38
1000dae8:	e3413002 	movt	r3, #4098	; 0x1002
1000daec:	e5932000 	ldr	r2, [r3]
1000daf0:	e51b3008 	ldr	r3, [fp, #-8]
1000daf4:	e5832008 	str	r2, [r3, #8]
    posix_sem_list = psem;
1000daf8:	e3083c38 	movw	r3, #35896	; 0x8c38
1000dafc:	e3413002 	movt	r3, #4098	; 0x1002
1000db00:	e51b2008 	ldr	r2, [fp, #-8]
1000db04:	e5832000 	str	r2, [r3]
}
1000db08:	e24bd000 	sub	sp, fp, #0
1000db0c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000db10:	e12fff1e 	bx	lr

1000db14 <posix_sem_delete>:

static void posix_sem_delete(sem_t *psem)
{
1000db14:	e92d4800 	push	{fp, lr}
1000db18:	e28db004 	add	fp, sp, #4
1000db1c:	e24dd010 	sub	sp, sp, #16
1000db20:	e50b0010 	str	r0, [fp, #-16]
    sem_t *iter;
    if (posix_sem_list == psem)
1000db24:	e3083c38 	movw	r3, #35896	; 0x8c38
1000db28:	e3413002 	movt	r3, #4098	; 0x1002
1000db2c:	e5932000 	ldr	r2, [r3]
1000db30:	e51b3010 	ldr	r3, [fp, #-16]
1000db34:	e1520003 	cmp	r2, r3
1000db38:	1a00000b 	bne	1000db6c <posix_sem_delete+0x58>
    {
        posix_sem_list = psem->next;
1000db3c:	e51b3010 	ldr	r3, [fp, #-16]
1000db40:	e5932008 	ldr	r2, [r3, #8]
1000db44:	e3083c38 	movw	r3, #35896	; 0x8c38
1000db48:	e3413002 	movt	r3, #4098	; 0x1002
1000db4c:	e5832000 	str	r2, [r3]

        rt_sem_delete(psem->sem);
1000db50:	e51b3010 	ldr	r3, [fp, #-16]
1000db54:	e5933004 	ldr	r3, [r3, #4]
1000db58:	e1a00003 	mov	r0, r3
1000db5c:	ebffd047 	bl	10001c80 <rt_sem_delete>
        rt_free(psem);
1000db60:	e51b0010 	ldr	r0, [fp, #-16]
1000db64:	ebffe5ea 	bl	10007314 <rt_free>

        return;
1000db68:	ea000023 	b	1000dbfc <posix_sem_delete+0xe8>
    }
    for (iter = posix_sem_list; iter->next != RT_NULL; iter = iter->next)
1000db6c:	e3083c38 	movw	r3, #35896	; 0x8c38
1000db70:	e3413002 	movt	r3, #4098	; 0x1002
1000db74:	e5933000 	ldr	r3, [r3]
1000db78:	e50b3008 	str	r3, [fp, #-8]
1000db7c:	ea00001a 	b	1000dbec <posix_sem_delete+0xd8>
    {
        if (iter->next == psem)
1000db80:	e51b3008 	ldr	r3, [fp, #-8]
1000db84:	e5932008 	ldr	r2, [r3, #8]
1000db88:	e51b3010 	ldr	r3, [fp, #-16]
1000db8c:	e1520003 	cmp	r2, r3
1000db90:	1a000012 	bne	1000dbe0 <posix_sem_delete+0xcc>
        {
            /* delete this mq */
            if (psem->next != RT_NULL)
1000db94:	e51b3010 	ldr	r3, [fp, #-16]
1000db98:	e5933008 	ldr	r3, [r3, #8]
1000db9c:	e3530000 	cmp	r3, #0
1000dba0:	0a000004 	beq	1000dbb8 <posix_sem_delete+0xa4>
                iter->next = psem->next;
1000dba4:	e51b3010 	ldr	r3, [fp, #-16]
1000dba8:	e5932008 	ldr	r2, [r3, #8]
1000dbac:	e51b3008 	ldr	r3, [fp, #-8]
1000dbb0:	e5832008 	str	r2, [r3, #8]
1000dbb4:	ea000002 	b	1000dbc4 <posix_sem_delete+0xb0>
            else
                iter->next = RT_NULL;
1000dbb8:	e51b3008 	ldr	r3, [fp, #-8]
1000dbbc:	e3a02000 	mov	r2, #0
1000dbc0:	e5832008 	str	r2, [r3, #8]

            /* delete RT-Thread mqueue */
            rt_sem_delete(psem->sem);
1000dbc4:	e51b3010 	ldr	r3, [fp, #-16]
1000dbc8:	e5933004 	ldr	r3, [r3, #4]
1000dbcc:	e1a00003 	mov	r0, r3
1000dbd0:	ebffd02a 	bl	10001c80 <rt_sem_delete>
            rt_free(psem);
1000dbd4:	e51b0010 	ldr	r0, [fp, #-16]
1000dbd8:	ebffe5cd 	bl	10007314 <rt_free>

            return ;
1000dbdc:	ea000006 	b	1000dbfc <posix_sem_delete+0xe8>
        rt_sem_delete(psem->sem);
        rt_free(psem);

        return;
    }
    for (iter = posix_sem_list; iter->next != RT_NULL; iter = iter->next)
1000dbe0:	e51b3008 	ldr	r3, [fp, #-8]
1000dbe4:	e5933008 	ldr	r3, [r3, #8]
1000dbe8:	e50b3008 	str	r3, [fp, #-8]
1000dbec:	e51b3008 	ldr	r3, [fp, #-8]
1000dbf0:	e5933008 	ldr	r3, [r3, #8]
1000dbf4:	e3530000 	cmp	r3, #0
1000dbf8:	1affffe0 	bne	1000db80 <posix_sem_delete+0x6c>
            rt_free(psem);

            return ;
        }
    }
}
1000dbfc:	e24bd004 	sub	sp, fp, #4
1000dc00:	e8bd8800 	pop	{fp, pc}

1000dc04 <posix_sem_find>:

static sem_t *posix_sem_find(const char* name)
{
1000dc04:	e92d4800 	push	{fp, lr}
1000dc08:	e28db004 	add	fp, sp, #4
1000dc0c:	e24dd010 	sub	sp, sp, #16
1000dc10:	e50b0010 	str	r0, [fp, #-16]
    sem_t *iter;
    rt_object_t object;

    for (iter = posix_sem_list; iter != RT_NULL; iter = iter->next)
1000dc14:	e3083c38 	movw	r3, #35896	; 0x8c38
1000dc18:	e3413002 	movt	r3, #4098	; 0x1002
1000dc1c:	e5933000 	ldr	r3, [r3]
1000dc20:	e50b3008 	str	r3, [fp, #-8]
1000dc24:	ea00000f 	b	1000dc68 <posix_sem_find+0x64>
    {
        object = (rt_object_t)&(iter->sem);
1000dc28:	e51b3008 	ldr	r3, [fp, #-8]
1000dc2c:	e2833004 	add	r3, r3, #4
1000dc30:	e50b300c 	str	r3, [fp, #-12]

        if (strncmp(object->name, name, RT_NAME_MAX) == 0)
1000dc34:	e51b300c 	ldr	r3, [fp, #-12]
1000dc38:	e1a00003 	mov	r0, r3
1000dc3c:	e51b1010 	ldr	r1, [fp, #-16]
1000dc40:	e3a02006 	mov	r2, #6
1000dc44:	fa004020 	blx	1001dccc <strncmp>
1000dc48:	e1a03000 	mov	r3, r0
1000dc4c:	e3530000 	cmp	r3, #0
1000dc50:	1a000001 	bne	1000dc5c <posix_sem_find+0x58>
        {
            return iter;
1000dc54:	e51b3008 	ldr	r3, [fp, #-8]
1000dc58:	ea000006 	b	1000dc78 <posix_sem_find+0x74>
static sem_t *posix_sem_find(const char* name)
{
    sem_t *iter;
    rt_object_t object;

    for (iter = posix_sem_list; iter != RT_NULL; iter = iter->next)
1000dc5c:	e51b3008 	ldr	r3, [fp, #-8]
1000dc60:	e5933008 	ldr	r3, [r3, #8]
1000dc64:	e50b3008 	str	r3, [fp, #-8]
1000dc68:	e51b3008 	ldr	r3, [fp, #-8]
1000dc6c:	e3530000 	cmp	r3, #0
1000dc70:	1affffec 	bne	1000dc28 <posix_sem_find+0x24>
        {
            return iter;
        }
    }
    
    return RT_NULL;
1000dc74:	e3a03000 	mov	r3, #0
}
1000dc78:	e1a00003 	mov	r0, r3
1000dc7c:	e24bd004 	sub	sp, fp, #4
1000dc80:	e8bd8800 	pop	{fp, pc}

1000dc84 <sem_close>:

int sem_close(sem_t *sem)
{
1000dc84:	e92d4800 	push	{fp, lr}
1000dc88:	e28db004 	add	fp, sp, #4
1000dc8c:	e24dd008 	sub	sp, sp, #8
1000dc90:	e50b0008 	str	r0, [fp, #-8]
    if (sem == RT_NULL)
1000dc94:	e51b3008 	ldr	r3, [fp, #-8]
1000dc98:	e3530000 	cmp	r3, #0
1000dc9c:	1a000003 	bne	1000dcb0 <sem_close+0x2c>
    {
        rt_set_errno(EINVAL);
1000dca0:	e3a00016 	mov	r0, #22
1000dca4:	ebffdb68 	bl	10004a4c <rt_set_errno>

        return -1;
1000dca8:	e3e03000 	mvn	r3, #0
1000dcac:	ea000019 	b	1000dd18 <sem_close+0x94>
    }

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1000dcb0:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dcb4:	e3410002 	movt	r0, #4098	; 0x1002
1000dcb8:	e3e01000 	mvn	r1, #0
1000dcbc:	ebffd01a 	bl	10001d2c <rt_sem_take>
    sem->refcount --;
1000dcc0:	e51b3008 	ldr	r3, [fp, #-8]
1000dcc4:	e1d330b0 	ldrh	r3, [r3]
1000dcc8:	e2433001 	sub	r3, r3, #1
1000dccc:	e6ff2073 	uxth	r2, r3
1000dcd0:	e51b3008 	ldr	r3, [fp, #-8]
1000dcd4:	e1c320b0 	strh	r2, [r3]
    if (sem->refcount == 0)
1000dcd8:	e51b3008 	ldr	r3, [fp, #-8]
1000dcdc:	e1d330b0 	ldrh	r3, [r3]
1000dce0:	e3530000 	cmp	r3, #0
1000dce4:	1a000007 	bne	1000dd08 <sem_close+0x84>
    {
        /* delete from posix semaphore list */
        if (sem->unlinked)
1000dce8:	e51b3008 	ldr	r3, [fp, #-8]
1000dcec:	e5d33002 	ldrb	r3, [r3, #2]
1000dcf0:	e3530000 	cmp	r3, #0
1000dcf4:	0a000001 	beq	1000dd00 <sem_close+0x7c>
            posix_sem_delete(sem);
1000dcf8:	e51b0008 	ldr	r0, [fp, #-8]
1000dcfc:	ebffff84 	bl	1000db14 <posix_sem_delete>
        sem = RT_NULL;
1000dd00:	e3a03000 	mov	r3, #0
1000dd04:	e50b3008 	str	r3, [fp, #-8]
    }
    rt_sem_release(&posix_sem_lock);
1000dd08:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dd0c:	e3410002 	movt	r0, #4098	; 0x1002
1000dd10:	ebffd099 	bl	10001f7c <rt_sem_release>

    return 0;
1000dd14:	e3a03000 	mov	r3, #0
}
1000dd18:	e1a00003 	mov	r0, r3
1000dd1c:	e24bd004 	sub	sp, fp, #4
1000dd20:	e8bd8800 	pop	{fp, pc}

1000dd24 <sem_destroy>:
RTM_EXPORT(sem_close);

int sem_destroy(sem_t *sem)
{
1000dd24:	e92d4800 	push	{fp, lr}
1000dd28:	e28db004 	add	fp, sp, #4
1000dd2c:	e24dd010 	sub	sp, sp, #16
1000dd30:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if ((!sem) || !(sem->unamed))
1000dd34:	e51b3010 	ldr	r3, [fp, #-16]
1000dd38:	e3530000 	cmp	r3, #0
1000dd3c:	0a000003 	beq	1000dd50 <sem_destroy+0x2c>
1000dd40:	e51b3010 	ldr	r3, [fp, #-16]
1000dd44:	e5d33003 	ldrb	r3, [r3, #3]
1000dd48:	e3530000 	cmp	r3, #0
1000dd4c:	1a000003 	bne	1000dd60 <sem_destroy+0x3c>
    {
        rt_set_errno(EINVAL);
1000dd50:	e3a00016 	mov	r0, #22
1000dd54:	ebffdb3c 	bl	10004a4c <rt_set_errno>

        return -1;
1000dd58:	e3e03000 	mvn	r3, #0
1000dd5c:	ea000018 	b	1000ddc4 <sem_destroy+0xa0>
    }

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1000dd60:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dd64:	e3410002 	movt	r0, #4098	; 0x1002
1000dd68:	e3e01000 	mvn	r1, #0
1000dd6c:	ebffcfee 	bl	10001d2c <rt_sem_take>
    result = rt_sem_trytake(sem->sem);
1000dd70:	e51b3010 	ldr	r3, [fp, #-16]
1000dd74:	e5933004 	ldr	r3, [r3, #4]
1000dd78:	e1a00003 	mov	r0, r3
1000dd7c:	ebffd073 	bl	10001f50 <rt_sem_trytake>
1000dd80:	e50b0008 	str	r0, [fp, #-8]
    if (result != RT_EOK)
1000dd84:	e51b3008 	ldr	r3, [fp, #-8]
1000dd88:	e3530000 	cmp	r3, #0
1000dd8c:	0a000006 	beq	1000ddac <sem_destroy+0x88>
    {
        rt_sem_release(&posix_sem_lock);
1000dd90:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dd94:	e3410002 	movt	r0, #4098	; 0x1002
1000dd98:	ebffd077 	bl	10001f7c <rt_sem_release>
        rt_set_errno(EBUSY);
1000dd9c:	e3a00010 	mov	r0, #16
1000dda0:	ebffdb29 	bl	10004a4c <rt_set_errno>

        return -1;
1000dda4:	e3e03000 	mvn	r3, #0
1000dda8:	ea000005 	b	1000ddc4 <sem_destroy+0xa0>
    }

    /* destroy an unamed posix semaphore */
    posix_sem_delete(sem);
1000ddac:	e51b0010 	ldr	r0, [fp, #-16]
1000ddb0:	ebffff57 	bl	1000db14 <posix_sem_delete>
    rt_sem_release(&posix_sem_lock);
1000ddb4:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000ddb8:	e3410002 	movt	r0, #4098	; 0x1002
1000ddbc:	ebffd06e 	bl	10001f7c <rt_sem_release>

    return 0;
1000ddc0:	e3a03000 	mov	r3, #0
}
1000ddc4:	e1a00003 	mov	r0, r3
1000ddc8:	e24bd004 	sub	sp, fp, #4
1000ddcc:	e8bd8800 	pop	{fp, pc}

1000ddd0 <sem_unlink>:
RTM_EXPORT(sem_destroy);

int sem_unlink(const char *name)
{
1000ddd0:	e92d4800 	push	{fp, lr}
1000ddd4:	e28db004 	add	fp, sp, #4
1000ddd8:	e24dd010 	sub	sp, sp, #16
1000dddc:	e50b0010 	str	r0, [fp, #-16]
    sem_t *psem;

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1000dde0:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dde4:	e3410002 	movt	r0, #4098	; 0x1002
1000dde8:	e3e01000 	mvn	r1, #0
1000ddec:	ebffcfce 	bl	10001d2c <rt_sem_take>
    psem = posix_sem_find(name);
1000ddf0:	e51b0010 	ldr	r0, [fp, #-16]
1000ddf4:	ebffff82 	bl	1000dc04 <posix_sem_find>
1000ddf8:	e50b0008 	str	r0, [fp, #-8]
    if (psem != RT_NULL)
1000ddfc:	e51b3008 	ldr	r3, [fp, #-8]
1000de00:	e3530000 	cmp	r3, #0
1000de04:	0a00000d 	beq	1000de40 <sem_unlink+0x70>
    {
        psem->unlinked = 1;
1000de08:	e51b3008 	ldr	r3, [fp, #-8]
1000de0c:	e3a02001 	mov	r2, #1
1000de10:	e5c32002 	strb	r2, [r3, #2]
        if (psem->refcount == 0)
1000de14:	e51b3008 	ldr	r3, [fp, #-8]
1000de18:	e1d330b0 	ldrh	r3, [r3]
1000de1c:	e3530000 	cmp	r3, #0
1000de20:	1a000001 	bne	1000de2c <sem_unlink+0x5c>
        {
            /* remove this semaphore */
            posix_sem_delete(psem);
1000de24:	e51b0008 	ldr	r0, [fp, #-8]
1000de28:	ebffff39 	bl	1000db14 <posix_sem_delete>
        }
        rt_sem_release(&posix_sem_lock);
1000de2c:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000de30:	e3410002 	movt	r0, #4098	; 0x1002
1000de34:	ebffd050 	bl	10001f7c <rt_sem_release>

        return 0;
1000de38:	e3a03000 	mov	r3, #0
1000de3c:	ea000005 	b	1000de58 <sem_unlink+0x88>
    }
    rt_sem_release(&posix_sem_lock);
1000de40:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000de44:	e3410002 	movt	r0, #4098	; 0x1002
1000de48:	ebffd04b 	bl	10001f7c <rt_sem_release>

    /* no this entry */
    rt_set_errno(ENOENT);
1000de4c:	e3a00002 	mov	r0, #2
1000de50:	ebffdafd 	bl	10004a4c <rt_set_errno>

    return -1;
1000de54:	e3e03000 	mvn	r3, #0
}
1000de58:	e1a00003 	mov	r0, r3
1000de5c:	e24bd004 	sub	sp, fp, #4
1000de60:	e8bd8800 	pop	{fp, pc}

1000de64 <sem_getvalue>:
RTM_EXPORT(sem_unlink);

int sem_getvalue(sem_t *sem, int *sval)
{
1000de64:	e92d4800 	push	{fp, lr}
1000de68:	e28db004 	add	fp, sp, #4
1000de6c:	e24dd008 	sub	sp, sp, #8
1000de70:	e50b0008 	str	r0, [fp, #-8]
1000de74:	e50b100c 	str	r1, [fp, #-12]
    if (!sem || !sval)
1000de78:	e51b3008 	ldr	r3, [fp, #-8]
1000de7c:	e3530000 	cmp	r3, #0
1000de80:	0a000002 	beq	1000de90 <sem_getvalue+0x2c>
1000de84:	e51b300c 	ldr	r3, [fp, #-12]
1000de88:	e3530000 	cmp	r3, #0
1000de8c:	1a000003 	bne	1000dea0 <sem_getvalue+0x3c>
    {
        rt_set_errno(EINVAL);
1000de90:	e3a00016 	mov	r0, #22
1000de94:	ebffdaec 	bl	10004a4c <rt_set_errno>

        return -1;
1000de98:	e3e03000 	mvn	r3, #0
1000de9c:	ea000006 	b	1000debc <sem_getvalue+0x58>
    }
    *sval = sem->sem->value;
1000dea0:	e51b3008 	ldr	r3, [fp, #-8]
1000dea4:	e5933004 	ldr	r3, [r3, #4]
1000dea8:	e1d331b8 	ldrh	r3, [r3, #24]
1000deac:	e1a02003 	mov	r2, r3
1000deb0:	e51b300c 	ldr	r3, [fp, #-12]
1000deb4:	e5832000 	str	r2, [r3]

    return 0;
1000deb8:	e3a03000 	mov	r3, #0
}
1000debc:	e1a00003 	mov	r0, r3
1000dec0:	e24bd004 	sub	sp, fp, #4
1000dec4:	e8bd8800 	pop	{fp, pc}

1000dec8 <sem_init>:
RTM_EXPORT(sem_getvalue);

int sem_init(sem_t *sem, int pshared, unsigned int value)
{
1000dec8:	e92d4800 	push	{fp, lr}
1000decc:	e28db004 	add	fp, sp, #4
1000ded0:	e24dd018 	sub	sp, sp, #24
1000ded4:	e50b0010 	str	r0, [fp, #-16]
1000ded8:	e50b1014 	str	r1, [fp, #-20]
1000dedc:	e50b2018 	str	r2, [fp, #-24]
    char name[RT_NAME_MAX];
    static rt_uint16_t psem_number = 0;

    if (sem == RT_NULL)
1000dee0:	e51b3010 	ldr	r3, [fp, #-16]
1000dee4:	e3530000 	cmp	r3, #0
1000dee8:	1a000003 	bne	1000defc <sem_init+0x34>
    {
        rt_set_errno(EINVAL);
1000deec:	e3a00016 	mov	r0, #22
1000def0:	ebffdad5 	bl	10004a4c <rt_set_errno>

        return -1;
1000def4:	e3e03000 	mvn	r3, #0
1000def8:	ea000031 	b	1000dfc4 <sem_init+0xfc>
    }

    rt_snprintf(name, sizeof(name), "psem%02d", psem_number++);
1000defc:	e3083c58 	movw	r3, #35928	; 0x8c58
1000df00:	e3413002 	movt	r3, #4098	; 0x1002
1000df04:	e1d320b0 	ldrh	r2, [r3]
1000df08:	e2823001 	add	r3, r2, #1
1000df0c:	e6ff1073 	uxth	r1, r3
1000df10:	e3083c58 	movw	r3, #35928	; 0x8c58
1000df14:	e3413002 	movt	r3, #4098	; 0x1002
1000df18:	e1c310b0 	strh	r1, [r3]
1000df1c:	e1a0c002 	mov	ip, r2
1000df20:	e24b300c 	sub	r3, fp, #12
1000df24:	e1a00003 	mov	r0, r3
1000df28:	e3a01006 	mov	r1, #6
1000df2c:	e30f25d4 	movw	r2, #62932	; 0xf5d4
1000df30:	e3412001 	movt	r2, #4097	; 0x1001
1000df34:	e1a0300c 	mov	r3, ip
1000df38:	ebffe07d 	bl	10006134 <rt_snprintf>
    sem->sem = rt_sem_create(name, value, RT_IPC_FLAG_FIFO);
1000df3c:	e24b300c 	sub	r3, fp, #12
1000df40:	e1a00003 	mov	r0, r3
1000df44:	e51b1018 	ldr	r1, [fp, #-24]
1000df48:	e3a02000 	mov	r2, #0
1000df4c:	ebffcf1a 	bl	10001bbc <rt_sem_create>
1000df50:	e1a02000 	mov	r2, r0
1000df54:	e51b3010 	ldr	r3, [fp, #-16]
1000df58:	e5832004 	str	r2, [r3, #4]
    if (sem == RT_NULL)
1000df5c:	e51b3010 	ldr	r3, [fp, #-16]
1000df60:	e3530000 	cmp	r3, #0
1000df64:	1a000003 	bne	1000df78 <sem_init+0xb0>
    {
        rt_set_errno(ENOMEM);
1000df68:	e3a0000c 	mov	r0, #12
1000df6c:	ebffdab6 	bl	10004a4c <rt_set_errno>

        return -1;
1000df70:	e3e03000 	mvn	r3, #0
1000df74:	ea000012 	b	1000dfc4 <sem_init+0xfc>
    }

    /* initialize posix semaphore */
    sem->refcount = 1;
1000df78:	e51b3010 	ldr	r3, [fp, #-16]
1000df7c:	e3a02001 	mov	r2, #1
1000df80:	e1c320b0 	strh	r2, [r3]
    sem->unlinked = 0;
1000df84:	e51b3010 	ldr	r3, [fp, #-16]
1000df88:	e3a02000 	mov	r2, #0
1000df8c:	e5c32002 	strb	r2, [r3, #2]
    sem->unamed = 1;
1000df90:	e51b3010 	ldr	r3, [fp, #-16]
1000df94:	e3a02001 	mov	r2, #1
1000df98:	e5c32003 	strb	r2, [r3, #3]
    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1000df9c:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dfa0:	e3410002 	movt	r0, #4098	; 0x1002
1000dfa4:	e3e01000 	mvn	r1, #0
1000dfa8:	ebffcf5f 	bl	10001d2c <rt_sem_take>
    posix_sem_insert(sem);
1000dfac:	e51b0010 	ldr	r0, [fp, #-16]
1000dfb0:	ebfffec7 	bl	1000dad4 <posix_sem_insert>
    rt_sem_release(&posix_sem_lock);
1000dfb4:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dfb8:	e3410002 	movt	r0, #4098	; 0x1002
1000dfbc:	ebffcfee 	bl	10001f7c <rt_sem_release>

    return 0;
1000dfc0:	e3a03000 	mov	r3, #0
}
1000dfc4:	e1a00003 	mov	r0, r3
1000dfc8:	e24bd004 	sub	sp, fp, #4
1000dfcc:	e8bd8800 	pop	{fp, pc}

1000dfd0 <sem_open>:
RTM_EXPORT(sem_init);

sem_t *sem_open(const char *name, int oflag, ...)
{
1000dfd0:	e92d000e 	push	{r1, r2, r3}
1000dfd4:	e92d4800 	push	{fp, lr}
1000dfd8:	e28db004 	add	fp, sp, #4
1000dfdc:	e24dd01c 	sub	sp, sp, #28
1000dfe0:	e50b001c 	str	r0, [fp, #-28]
    sem_t* sem;
    va_list arg;
    mode_t mode;
    unsigned int value;

    sem = RT_NULL;
1000dfe4:	e3a03000 	mov	r3, #0
1000dfe8:	e50b300c 	str	r3, [fp, #-12]

    /* lock posix semaphore list */
    rt_sem_take(&posix_sem_lock, RT_WAITING_FOREVER);
1000dfec:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000dff0:	e3410002 	movt	r0, #4098	; 0x1002
1000dff4:	e3e01000 	mvn	r1, #0
1000dff8:	ebffcf4b 	bl	10001d2c <rt_sem_take>
    if (oflag & O_CREAT)
1000dffc:	e59b3004 	ldr	r3, [fp, #4]
1000e000:	e2033c01 	and	r3, r3, #256	; 0x100
1000e004:	e3530000 	cmp	r3, #0
1000e008:	0a00003a 	beq	1000e0f8 <sem_open+0x128>
    {
        va_start(arg, oflag);
1000e00c:	e28b3008 	add	r3, fp, #8
1000e010:	e50b3018 	str	r3, [fp, #-24]
        mode = (mode_t) va_arg( arg, unsigned int); mode = mode;
1000e014:	e51b3018 	ldr	r3, [fp, #-24]
1000e018:	e2832004 	add	r2, r3, #4
1000e01c:	e50b2018 	str	r2, [fp, #-24]
1000e020:	e5933000 	ldr	r3, [r3]
1000e024:	e50b3010 	str	r3, [fp, #-16]
        value = va_arg( arg, unsigned int);
1000e028:	e51b3018 	ldr	r3, [fp, #-24]
1000e02c:	e2832004 	add	r2, r3, #4
1000e030:	e50b2018 	str	r2, [fp, #-24]
1000e034:	e5933000 	ldr	r3, [r3]
1000e038:	e50b3014 	str	r3, [fp, #-20]
        va_end(arg);

        if (oflag & O_EXCL)
1000e03c:	e59b3004 	ldr	r3, [fp, #4]
1000e040:	e2033c02 	and	r3, r3, #512	; 0x200
1000e044:	e3530000 	cmp	r3, #0
1000e048:	0a000007 	beq	1000e06c <sem_open+0x9c>
        {
            if (posix_sem_find(name) != RT_NULL)
1000e04c:	e51b001c 	ldr	r0, [fp, #-28]
1000e050:	ebfffeeb 	bl	1000dc04 <posix_sem_find>
1000e054:	e1a03000 	mov	r3, r0
1000e058:	e3530000 	cmp	r3, #0
1000e05c:	0a000002 	beq	1000e06c <sem_open+0x9c>
            {
                rt_set_errno(EEXIST);
1000e060:	e3a00011 	mov	r0, #17
1000e064:	ebffda78 	bl	10004a4c <rt_set_errno>
                goto __return;
1000e068:	ea000037 	b	1000e14c <sem_open+0x17c>
            }
        }
        sem = (sem_t*) rt_malloc (sizeof(struct posix_sem));
1000e06c:	e3a0000c 	mov	r0, #12
1000e070:	ebffe28c 	bl	10006aa8 <rt_malloc>
1000e074:	e50b000c 	str	r0, [fp, #-12]
        if (sem == RT_NULL)
1000e078:	e51b300c 	ldr	r3, [fp, #-12]
1000e07c:	e3530000 	cmp	r3, #0
1000e080:	1a000002 	bne	1000e090 <sem_open+0xc0>
        {
            rt_set_errno(ENFILE);
1000e084:	e3a00017 	mov	r0, #23
1000e088:	ebffda6f 	bl	10004a4c <rt_set_errno>
            goto __return;
1000e08c:	ea00002e 	b	1000e14c <sem_open+0x17c>
        }

        /* create RT-Thread semaphore */
        sem->sem = rt_sem_create(name, value, RT_IPC_FLAG_FIFO);
1000e090:	e51b001c 	ldr	r0, [fp, #-28]
1000e094:	e51b1014 	ldr	r1, [fp, #-20]
1000e098:	e3a02000 	mov	r2, #0
1000e09c:	ebffcec6 	bl	10001bbc <rt_sem_create>
1000e0a0:	e1a02000 	mov	r2, r0
1000e0a4:	e51b300c 	ldr	r3, [fp, #-12]
1000e0a8:	e5832004 	str	r2, [r3, #4]
        if (sem->sem == RT_NULL) /* create failed */
1000e0ac:	e51b300c 	ldr	r3, [fp, #-12]
1000e0b0:	e5933004 	ldr	r3, [r3, #4]
1000e0b4:	e3530000 	cmp	r3, #0
1000e0b8:	1a000002 	bne	1000e0c8 <sem_open+0xf8>
        {
            rt_set_errno(ENFILE);
1000e0bc:	e3a00017 	mov	r0, #23
1000e0c0:	ebffda61 	bl	10004a4c <rt_set_errno>
            goto __return;
1000e0c4:	ea000020 	b	1000e14c <sem_open+0x17c>
        }
        /* initialize reference count */
        sem->refcount = 1;
1000e0c8:	e51b300c 	ldr	r3, [fp, #-12]
1000e0cc:	e3a02001 	mov	r2, #1
1000e0d0:	e1c320b0 	strh	r2, [r3]
        sem->unlinked = 0;
1000e0d4:	e51b300c 	ldr	r3, [fp, #-12]
1000e0d8:	e3a02000 	mov	r2, #0
1000e0dc:	e5c32002 	strb	r2, [r3, #2]
        sem->unamed = 0;
1000e0e0:	e51b300c 	ldr	r3, [fp, #-12]
1000e0e4:	e3a02000 	mov	r2, #0
1000e0e8:	e5c32003 	strb	r2, [r3, #3]

        /* insert semaphore to posix semaphore list */
        posix_sem_insert(sem);
1000e0ec:	e51b000c 	ldr	r0, [fp, #-12]
1000e0f0:	ebfffe77 	bl	1000dad4 <posix_sem_insert>
1000e0f4:	ea00000f 	b	1000e138 <sem_open+0x168>
    }
    else
    {
        /* find semaphore */
        sem = posix_sem_find(name);
1000e0f8:	e51b001c 	ldr	r0, [fp, #-28]
1000e0fc:	ebfffec0 	bl	1000dc04 <posix_sem_find>
1000e100:	e50b000c 	str	r0, [fp, #-12]
        if (sem != RT_NULL)
1000e104:	e51b300c 	ldr	r3, [fp, #-12]
1000e108:	e3530000 	cmp	r3, #0
1000e10c:	0a000006 	beq	1000e12c <sem_open+0x15c>
        {
            sem->refcount ++; /* increase reference count */
1000e110:	e51b300c 	ldr	r3, [fp, #-12]
1000e114:	e1d330b0 	ldrh	r3, [r3]
1000e118:	e2833001 	add	r3, r3, #1
1000e11c:	e6ff2073 	uxth	r2, r3
1000e120:	e51b300c 	ldr	r3, [fp, #-12]
1000e124:	e1c320b0 	strh	r2, [r3]
1000e128:	ea000002 	b	1000e138 <sem_open+0x168>
        }
        else
        {
            rt_set_errno(ENOENT);
1000e12c:	e3a00002 	mov	r0, #2
1000e130:	ebffda45 	bl	10004a4c <rt_set_errno>
            goto __return;
1000e134:	ea000004 	b	1000e14c <sem_open+0x17c>
        }
    }
    rt_sem_release(&posix_sem_lock);
1000e138:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000e13c:	e3410002 	movt	r0, #4098	; 0x1002
1000e140:	ebffcf8d 	bl	10001f7c <rt_sem_release>

    return sem;
1000e144:	e51b300c 	ldr	r3, [fp, #-12]
1000e148:	ea000010 	b	1000e190 <sem_open+0x1c0>

__return:
    /* release lock */
    rt_sem_release(&posix_sem_lock);
1000e14c:	e3080c3c 	movw	r0, #35900	; 0x8c3c
1000e150:	e3410002 	movt	r0, #4098	; 0x1002
1000e154:	ebffcf88 	bl	10001f7c <rt_sem_release>

    /* release allocated memory */
    if (sem != RT_NULL)
1000e158:	e51b300c 	ldr	r3, [fp, #-12]
1000e15c:	e3530000 	cmp	r3, #0
1000e160:	0a000009 	beq	1000e18c <sem_open+0x1bc>
    {
        /* delete RT-Thread semaphore */
        if (sem->sem != RT_NULL)
1000e164:	e51b300c 	ldr	r3, [fp, #-12]
1000e168:	e5933004 	ldr	r3, [r3, #4]
1000e16c:	e3530000 	cmp	r3, #0
1000e170:	0a000003 	beq	1000e184 <sem_open+0x1b4>
            rt_sem_delete(sem->sem);
1000e174:	e51b300c 	ldr	r3, [fp, #-12]
1000e178:	e5933004 	ldr	r3, [r3, #4]
1000e17c:	e1a00003 	mov	r0, r3
1000e180:	ebffcebe 	bl	10001c80 <rt_sem_delete>
        rt_free(sem);
1000e184:	e51b000c 	ldr	r0, [fp, #-12]
1000e188:	ebffe461 	bl	10007314 <rt_free>
    }

    return RT_NULL;
1000e18c:	e3a03000 	mov	r3, #0
}
1000e190:	e1a00003 	mov	r0, r3
1000e194:	e24bd004 	sub	sp, fp, #4
1000e198:	e8bd4800 	pop	{fp, lr}
1000e19c:	e28dd00c 	add	sp, sp, #12
1000e1a0:	e12fff1e 	bx	lr

1000e1a4 <sem_post>:
RTM_EXPORT(sem_open);

int sem_post(sem_t *sem)
{
1000e1a4:	e92d4800 	push	{fp, lr}
1000e1a8:	e28db004 	add	fp, sp, #4
1000e1ac:	e24dd010 	sub	sp, sp, #16
1000e1b0:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
1000e1b4:	e51b3010 	ldr	r3, [fp, #-16]
1000e1b8:	e3530000 	cmp	r3, #0
1000e1bc:	1a000003 	bne	1000e1d0 <sem_post+0x2c>
    {
        rt_set_errno(EINVAL);
1000e1c0:	e3a00016 	mov	r0, #22
1000e1c4:	ebffda20 	bl	10004a4c <rt_set_errno>

        return -1;
1000e1c8:	e3e03000 	mvn	r3, #0
1000e1cc:	ea00000c 	b	1000e204 <sem_post+0x60>
    }

    result = rt_sem_release(sem->sem);
1000e1d0:	e51b3010 	ldr	r3, [fp, #-16]
1000e1d4:	e5933004 	ldr	r3, [r3, #4]
1000e1d8:	e1a00003 	mov	r0, r3
1000e1dc:	ebffcf66 	bl	10001f7c <rt_sem_release>
1000e1e0:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1000e1e4:	e51b3008 	ldr	r3, [fp, #-8]
1000e1e8:	e3530000 	cmp	r3, #0
1000e1ec:	1a000001 	bne	1000e1f8 <sem_post+0x54>
        return 0;
1000e1f0:	e3a03000 	mov	r3, #0
1000e1f4:	ea000002 	b	1000e204 <sem_post+0x60>

    rt_set_errno(EINVAL);
1000e1f8:	e3a00016 	mov	r0, #22
1000e1fc:	ebffda12 	bl	10004a4c <rt_set_errno>

    return -1;
1000e200:	e3e03000 	mvn	r3, #0
}
1000e204:	e1a00003 	mov	r0, r3
1000e208:	e24bd004 	sub	sp, fp, #4
1000e20c:	e8bd8800 	pop	{fp, pc}

1000e210 <sem_timedwait>:
RTM_EXPORT(sem_post);

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout)
{
1000e210:	e92d4800 	push	{fp, lr}
1000e214:	e28db004 	add	fp, sp, #4
1000e218:	e24dd010 	sub	sp, sp, #16
1000e21c:	e50b0010 	str	r0, [fp, #-16]
1000e220:	e50b1014 	str	r1, [fp, #-20]
    rt_err_t result;
    rt_int32_t tick;

    if (!sem || !abs_timeout)
1000e224:	e51b3010 	ldr	r3, [fp, #-16]
1000e228:	e3530000 	cmp	r3, #0
1000e22c:	0a000002 	beq	1000e23c <sem_timedwait+0x2c>
1000e230:	e51b3014 	ldr	r3, [fp, #-20]
1000e234:	e3530000 	cmp	r3, #0
1000e238:	1a000001 	bne	1000e244 <sem_timedwait+0x34>
        return EINVAL;
1000e23c:	e3a03016 	mov	r3, #22
1000e240:	ea000017 	b	1000e2a4 <sem_timedwait+0x94>

    /* calculate os tick */
    tick = clock_time_to_tick(abs_timeout);
1000e244:	e51b0014 	ldr	r0, [fp, #-20]
1000e248:	ebfff57c 	bl	1000b840 <clock_time_to_tick>
1000e24c:	e50b0008 	str	r0, [fp, #-8]
    
    result = rt_sem_take(sem->sem, tick);
1000e250:	e51b3010 	ldr	r3, [fp, #-16]
1000e254:	e5933004 	ldr	r3, [r3, #4]
1000e258:	e1a00003 	mov	r0, r3
1000e25c:	e51b1008 	ldr	r1, [fp, #-8]
1000e260:	ebffceb1 	bl	10001d2c <rt_sem_take>
1000e264:	e50b000c 	str	r0, [fp, #-12]
    if (result == -RT_ETIMEOUT)
1000e268:	e51b300c 	ldr	r3, [fp, #-12]
1000e26c:	e3730002 	cmn	r3, #2
1000e270:	1a000003 	bne	1000e284 <sem_timedwait+0x74>
    {
        rt_set_errno(ETIMEDOUT);
1000e274:	e3a00074 	mov	r0, #116	; 0x74
1000e278:	ebffd9f3 	bl	10004a4c <rt_set_errno>

        return -1;
1000e27c:	e3e03000 	mvn	r3, #0
1000e280:	ea000007 	b	1000e2a4 <sem_timedwait+0x94>
    }
    if (result == RT_EOK)
1000e284:	e51b300c 	ldr	r3, [fp, #-12]
1000e288:	e3530000 	cmp	r3, #0
1000e28c:	1a000001 	bne	1000e298 <sem_timedwait+0x88>
        return 0;
1000e290:	e3a03000 	mov	r3, #0
1000e294:	ea000002 	b	1000e2a4 <sem_timedwait+0x94>

    rt_set_errno(EINTR);
1000e298:	e3a00004 	mov	r0, #4
1000e29c:	ebffd9ea 	bl	10004a4c <rt_set_errno>

    return -1;
1000e2a0:	e3e03000 	mvn	r3, #0
}
1000e2a4:	e1a00003 	mov	r0, r3
1000e2a8:	e24bd004 	sub	sp, fp, #4
1000e2ac:	e8bd8800 	pop	{fp, pc}

1000e2b0 <sem_trywait>:
RTM_EXPORT(sem_timedwait);

int sem_trywait(sem_t *sem)
{
1000e2b0:	e92d4800 	push	{fp, lr}
1000e2b4:	e28db004 	add	fp, sp, #4
1000e2b8:	e24dd010 	sub	sp, sp, #16
1000e2bc:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
1000e2c0:	e51b3010 	ldr	r3, [fp, #-16]
1000e2c4:	e3530000 	cmp	r3, #0
1000e2c8:	1a000003 	bne	1000e2dc <sem_trywait+0x2c>
    {
        rt_set_errno(EINVAL);
1000e2cc:	e3a00016 	mov	r0, #22
1000e2d0:	ebffd9dd 	bl	10004a4c <rt_set_errno>

        return -1;
1000e2d4:	e3e03000 	mvn	r3, #0
1000e2d8:	ea000014 	b	1000e330 <sem_trywait+0x80>
    }

    result = rt_sem_take(sem->sem, RT_WAITING_FOREVER);
1000e2dc:	e51b3010 	ldr	r3, [fp, #-16]
1000e2e0:	e5933004 	ldr	r3, [r3, #4]
1000e2e4:	e1a00003 	mov	r0, r3
1000e2e8:	e3e01000 	mvn	r1, #0
1000e2ec:	ebffce8e 	bl	10001d2c <rt_sem_take>
1000e2f0:	e50b0008 	str	r0, [fp, #-8]
    if (result == -RT_ETIMEOUT)
1000e2f4:	e51b3008 	ldr	r3, [fp, #-8]
1000e2f8:	e3730002 	cmn	r3, #2
1000e2fc:	1a000003 	bne	1000e310 <sem_trywait+0x60>
    {
        rt_set_errno(EAGAIN);
1000e300:	e3a0000b 	mov	r0, #11
1000e304:	ebffd9d0 	bl	10004a4c <rt_set_errno>

        return -1;
1000e308:	e3e03000 	mvn	r3, #0
1000e30c:	ea000007 	b	1000e330 <sem_trywait+0x80>
    }
    if (result == RT_EOK)
1000e310:	e51b3008 	ldr	r3, [fp, #-8]
1000e314:	e3530000 	cmp	r3, #0
1000e318:	1a000001 	bne	1000e324 <sem_trywait+0x74>
        return 0;
1000e31c:	e3a03000 	mov	r3, #0
1000e320:	ea000002 	b	1000e330 <sem_trywait+0x80>

    rt_set_errno(EINTR);
1000e324:	e3a00004 	mov	r0, #4
1000e328:	ebffd9c7 	bl	10004a4c <rt_set_errno>

    return -1;
1000e32c:	e3e03000 	mvn	r3, #0
}
1000e330:	e1a00003 	mov	r0, r3
1000e334:	e24bd004 	sub	sp, fp, #4
1000e338:	e8bd8800 	pop	{fp, pc}

1000e33c <sem_wait>:
RTM_EXPORT(sem_trywait);

int sem_wait(sem_t *sem)
{
1000e33c:	e92d4800 	push	{fp, lr}
1000e340:	e28db004 	add	fp, sp, #4
1000e344:	e24dd010 	sub	sp, sp, #16
1000e348:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result;

    if (!sem)
1000e34c:	e51b3010 	ldr	r3, [fp, #-16]
1000e350:	e3530000 	cmp	r3, #0
1000e354:	1a000003 	bne	1000e368 <sem_wait+0x2c>
    {
        rt_set_errno(EINVAL);
1000e358:	e3a00016 	mov	r0, #22
1000e35c:	ebffd9ba 	bl	10004a4c <rt_set_errno>

        return -1;
1000e360:	e3e03000 	mvn	r3, #0
1000e364:	ea00000d 	b	1000e3a0 <sem_wait+0x64>
    }

    result = rt_sem_take(sem->sem, RT_WAITING_FOREVER);
1000e368:	e51b3010 	ldr	r3, [fp, #-16]
1000e36c:	e5933004 	ldr	r3, [r3, #4]
1000e370:	e1a00003 	mov	r0, r3
1000e374:	e3e01000 	mvn	r1, #0
1000e378:	ebffce6b 	bl	10001d2c <rt_sem_take>
1000e37c:	e50b0008 	str	r0, [fp, #-8]
    if (result == RT_EOK)
1000e380:	e51b3008 	ldr	r3, [fp, #-8]
1000e384:	e3530000 	cmp	r3, #0
1000e388:	1a000001 	bne	1000e394 <sem_wait+0x58>
        return 0;
1000e38c:	e3a03000 	mov	r3, #0
1000e390:	ea000002 	b	1000e3a0 <sem_wait+0x64>

    rt_set_errno(EINTR);
1000e394:	e3a00004 	mov	r0, #4
1000e398:	ebffd9ab 	bl	10004a4c <rt_set_errno>

    return -1;
1000e39c:	e3e03000 	mvn	r3, #0
}
1000e3a0:	e1a00003 	mov	r0, r3
1000e3a4:	e24bd004 	sub	sp, fp, #4
1000e3a8:	e8bd8800 	pop	{fp, pc}

1000e3ac <libc_system_init>:
#endif

#endif

int libc_system_init(void)
{
1000e3ac:	e92d4800 	push	{fp, lr}
1000e3b0:	e28db004 	add	fp, sp, #4
        fd = fd;
    }
#endif

    /* set PATH and HOME */
    putenv("PATH=/bin");
1000e3b4:	e30f05e0 	movw	r0, #62944	; 0xf5e0
1000e3b8:	e3410001 	movt	r0, #4097	; 0x1001
1000e3bc:	fa003d6f 	blx	1001d980 <putenv>
    putenv("HOME=/home");
1000e3c0:	e30f05ec 	movw	r0, #62956	; 0xf5ec
1000e3c4:	e3410001 	movt	r0, #4097	; 0x1001
1000e3c8:	fa003d6c 	blx	1001d980 <putenv>

#ifdef RT_USING_PTHREADS
    pthread_system_init();
1000e3cc:	ebfff83e 	bl	1000c4cc <pthread_system_init>
#endif

    return 0;
1000e3d0:	e3a03000 	mov	r3, #0
}
1000e3d4:	e1a00003 	mov	r0, r3
1000e3d8:	e8bd8800 	pop	{fp, pc}

1000e3dc <_close_r>:

/* Reentrant versions of system calls.  */

int
_close_r(struct _reent *ptr, int fd)
{
1000e3dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e3e0:	e28db000 	add	fp, sp, #0
1000e3e4:	e24dd00c 	sub	sp, sp, #12
1000e3e8:	e50b0008 	str	r0, [fp, #-8]
1000e3ec:	e50b100c 	str	r1, [fp, #-12]
#ifndef RT_USING_DFS
	return 0;
1000e3f0:	e3a03000 	mov	r3, #0
#else
	return close(fd);
#endif
}
1000e3f4:	e1a00003 	mov	r0, r3
1000e3f8:	e24bd000 	sub	sp, fp, #0
1000e3fc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e400:	e12fff1e 	bx	lr

1000e404 <_execve_r>:

int
_execve_r(struct _reent *ptr, const char * name, char *const *argv, char *const *env)
{
1000e404:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e408:	e28db000 	add	fp, sp, #0
1000e40c:	e24dd014 	sub	sp, sp, #20
1000e410:	e50b0008 	str	r0, [fp, #-8]
1000e414:	e50b100c 	str	r1, [fp, #-12]
1000e418:	e50b2010 	str	r2, [fp, #-16]
1000e41c:	e50b3014 	str	r3, [fp, #-20]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e420:	e51b3008 	ldr	r3, [fp, #-8]
1000e424:	e3a02086 	mov	r2, #134	; 0x86
1000e428:	e5832000 	str	r2, [r3]
	return -1;
1000e42c:	e3e03000 	mvn	r3, #0
}
1000e430:	e1a00003 	mov	r0, r3
1000e434:	e24bd000 	sub	sp, fp, #0
1000e438:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e43c:	e12fff1e 	bx	lr

1000e440 <_fcntl_r>:

int
_fcntl_r(struct _reent *ptr, int fd, int cmd, int arg)
{
1000e440:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e444:	e28db000 	add	fp, sp, #0
1000e448:	e24dd014 	sub	sp, sp, #20
1000e44c:	e50b0008 	str	r0, [fp, #-8]
1000e450:	e50b100c 	str	r1, [fp, #-12]
1000e454:	e50b2010 	str	r2, [fp, #-16]
1000e458:	e50b3014 	str	r3, [fp, #-20]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e45c:	e51b3008 	ldr	r3, [fp, #-8]
1000e460:	e3a02086 	mov	r2, #134	; 0x86
1000e464:	e5832000 	str	r2, [r3]
	return -1;
1000e468:	e3e03000 	mvn	r3, #0
}
1000e46c:	e1a00003 	mov	r0, r3
1000e470:	e24bd000 	sub	sp, fp, #0
1000e474:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e478:	e12fff1e 	bx	lr

1000e47c <_fork_r>:

int
_fork_r(struct _reent *ptr)
{
1000e47c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e480:	e28db000 	add	fp, sp, #0
1000e484:	e24dd00c 	sub	sp, sp, #12
1000e488:	e50b0008 	str	r0, [fp, #-8]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e48c:	e51b3008 	ldr	r3, [fp, #-8]
1000e490:	e3a02086 	mov	r2, #134	; 0x86
1000e494:	e5832000 	str	r2, [r3]
	return -1;
1000e498:	e3e03000 	mvn	r3, #0
}
1000e49c:	e1a00003 	mov	r0, r3
1000e4a0:	e24bd000 	sub	sp, fp, #0
1000e4a4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e4a8:	e12fff1e 	bx	lr

1000e4ac <_fstat_r>:

int
_fstat_r(struct _reent *ptr, int fd, struct stat *pstat)
{
1000e4ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e4b0:	e28db000 	add	fp, sp, #0
1000e4b4:	e24dd014 	sub	sp, sp, #20
1000e4b8:	e50b0008 	str	r0, [fp, #-8]
1000e4bc:	e50b100c 	str	r1, [fp, #-12]
1000e4c0:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e4c4:	e51b3008 	ldr	r3, [fp, #-8]
1000e4c8:	e3a02086 	mov	r2, #134	; 0x86
1000e4cc:	e5832000 	str	r2, [r3]
	return -1;
1000e4d0:	e3e03000 	mvn	r3, #0
}
1000e4d4:	e1a00003 	mov	r0, r3
1000e4d8:	e24bd000 	sub	sp, fp, #0
1000e4dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e4e0:	e12fff1e 	bx	lr

1000e4e4 <_getpid_r>:

int
_getpid_r(struct _reent *ptr)
{
1000e4e4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e4e8:	e28db000 	add	fp, sp, #0
1000e4ec:	e24dd00c 	sub	sp, sp, #12
1000e4f0:	e50b0008 	str	r0, [fp, #-8]
	return 0;
1000e4f4:	e3a03000 	mov	r3, #0
}
1000e4f8:	e1a00003 	mov	r0, r3
1000e4fc:	e24bd000 	sub	sp, fp, #0
1000e500:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e504:	e12fff1e 	bx	lr

1000e508 <_isatty_r>:

int
_isatty_r(struct _reent *ptr, int fd)
{
1000e508:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e50c:	e28db000 	add	fp, sp, #0
1000e510:	e24dd00c 	sub	sp, sp, #12
1000e514:	e50b0008 	str	r0, [fp, #-8]
1000e518:	e50b100c 	str	r1, [fp, #-12]
	if (fd >=0 && fd < 3) return 1;
1000e51c:	e51b300c 	ldr	r3, [fp, #-12]
1000e520:	e3530000 	cmp	r3, #0
1000e524:	ba000004 	blt	1000e53c <_isatty_r+0x34>
1000e528:	e51b300c 	ldr	r3, [fp, #-12]
1000e52c:	e3530002 	cmp	r3, #2
1000e530:	ca000001 	bgt	1000e53c <_isatty_r+0x34>
1000e534:	e3a03001 	mov	r3, #1
1000e538:	ea000003 	b	1000e54c <_isatty_r+0x44>

	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e53c:	e51b3008 	ldr	r3, [fp, #-8]
1000e540:	e3a02086 	mov	r2, #134	; 0x86
1000e544:	e5832000 	str	r2, [r3]
	return -1;
1000e548:	e3e03000 	mvn	r3, #0
}
1000e54c:	e1a00003 	mov	r0, r3
1000e550:	e24bd000 	sub	sp, fp, #0
1000e554:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e558:	e12fff1e 	bx	lr

1000e55c <_kill_r>:

int
_kill_r(struct _reent *ptr, int pid, int sig)
{
1000e55c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e560:	e28db000 	add	fp, sp, #0
1000e564:	e24dd014 	sub	sp, sp, #20
1000e568:	e50b0008 	str	r0, [fp, #-8]
1000e56c:	e50b100c 	str	r1, [fp, #-12]
1000e570:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e574:	e51b3008 	ldr	r3, [fp, #-8]
1000e578:	e3a02086 	mov	r2, #134	; 0x86
1000e57c:	e5832000 	str	r2, [r3]
	return -1;
1000e580:	e3e03000 	mvn	r3, #0
}
1000e584:	e1a00003 	mov	r0, r3
1000e588:	e24bd000 	sub	sp, fp, #0
1000e58c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e590:	e12fff1e 	bx	lr

1000e594 <_link_r>:

int
_link_r(struct _reent *ptr, const char *old, const char *new)
{
1000e594:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e598:	e28db000 	add	fp, sp, #0
1000e59c:	e24dd014 	sub	sp, sp, #20
1000e5a0:	e50b0008 	str	r0, [fp, #-8]
1000e5a4:	e50b100c 	str	r1, [fp, #-12]
1000e5a8:	e50b2010 	str	r2, [fp, #-16]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e5ac:	e51b3008 	ldr	r3, [fp, #-8]
1000e5b0:	e3a02086 	mov	r2, #134	; 0x86
1000e5b4:	e5832000 	str	r2, [r3]
	return -1;
1000e5b8:	e3e03000 	mvn	r3, #0
}
1000e5bc:	e1a00003 	mov	r0, r3
1000e5c0:	e24bd000 	sub	sp, fp, #0
1000e5c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e5c8:	e12fff1e 	bx	lr

1000e5cc <_lseek_r>:

_off_t
_lseek_r(struct _reent *ptr, int fd, _off_t pos, int whence)
{
1000e5cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e5d0:	e28db000 	add	fp, sp, #0
1000e5d4:	e24dd014 	sub	sp, sp, #20
1000e5d8:	e50b0008 	str	r0, [fp, #-8]
1000e5dc:	e50b100c 	str	r1, [fp, #-12]
1000e5e0:	e50b2010 	str	r2, [fp, #-16]
1000e5e4:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
1000e5e8:	e3a03000 	mov	r3, #0
	_off_t rc;

	rc = lseek(fd, pos, whence);
	return rc;
#endif
}
1000e5ec:	e1a00003 	mov	r0, r3
1000e5f0:	e24bd000 	sub	sp, fp, #0
1000e5f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e5f8:	e12fff1e 	bx	lr

1000e5fc <_mkdir_r>:

int
_mkdir_r(struct _reent *ptr, const char *name, int mode)
{
1000e5fc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e600:	e28db000 	add	fp, sp, #0
1000e604:	e24dd014 	sub	sp, sp, #20
1000e608:	e50b0008 	str	r0, [fp, #-8]
1000e60c:	e50b100c 	str	r1, [fp, #-12]
1000e610:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
1000e614:	e3a03000 	mov	r3, #0
	int rc;

	rc = mkdir(name, mode);
	return rc;
#endif
}
1000e618:	e1a00003 	mov	r0, r3
1000e61c:	e24bd000 	sub	sp, fp, #0
1000e620:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e624:	e12fff1e 	bx	lr

1000e628 <_open_r>:

int
_open_r(struct _reent *ptr, const char *file, int flags, int mode)
{
1000e628:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e62c:	e28db000 	add	fp, sp, #0
1000e630:	e24dd014 	sub	sp, sp, #20
1000e634:	e50b0008 	str	r0, [fp, #-8]
1000e638:	e50b100c 	str	r1, [fp, #-12]
1000e63c:	e50b2010 	str	r2, [fp, #-16]
1000e640:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
1000e644:	e3a03000 	mov	r3, #0
	int rc;

	rc = open(file, flags, mode);
	return rc;
#endif
}
1000e648:	e1a00003 	mov	r0, r3
1000e64c:	e24bd000 	sub	sp, fp, #0
1000e650:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e654:	e12fff1e 	bx	lr

1000e658 <_read_r>:

_ssize_t 
_read_r(struct _reent *ptr, int fd, void *buf, size_t nbytes)
{
1000e658:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e65c:	e28db000 	add	fp, sp, #0
1000e660:	e24dd014 	sub	sp, sp, #20
1000e664:	e50b0008 	str	r0, [fp, #-8]
1000e668:	e50b100c 	str	r1, [fp, #-12]
1000e66c:	e50b2010 	str	r2, [fp, #-16]
1000e670:	e50b3014 	str	r3, [fp, #-20]
#ifndef RT_USING_DFS
	return 0;
1000e674:	e3a03000 	mov	r3, #0
	_ssize_t rc;

	rc = read(fd, buf, nbytes);
	return rc;
#endif
}
1000e678:	e1a00003 	mov	r0, r3
1000e67c:	e24bd000 	sub	sp, fp, #0
1000e680:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e684:	e12fff1e 	bx	lr

1000e688 <_rename_r>:

int
_rename_r(struct _reent *ptr, const char *old, const char *new)
{
1000e688:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e68c:	e28db000 	add	fp, sp, #0
1000e690:	e24dd014 	sub	sp, sp, #20
1000e694:	e50b0008 	str	r0, [fp, #-8]
1000e698:	e50b100c 	str	r1, [fp, #-12]
1000e69c:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
1000e6a0:	e3a03000 	mov	r3, #0
	int rc;

	rc = rename(old, new);
	return rc;
#endif
}
1000e6a4:	e1a00003 	mov	r0, r3
1000e6a8:	e24bd000 	sub	sp, fp, #0
1000e6ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e6b0:	e12fff1e 	bx	lr

1000e6b4 <_sbrk_r>:

void *
_sbrk_r(struct _reent *ptr, ptrdiff_t incr)
{
1000e6b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e6b8:	e28db000 	add	fp, sp, #0
1000e6bc:	e24dd00c 	sub	sp, sp, #12
1000e6c0:	e50b0008 	str	r0, [fp, #-8]
1000e6c4:	e50b100c 	str	r1, [fp, #-12]
	/* no use this routine to get memory */
	return RT_NULL;
1000e6c8:	e3a03000 	mov	r3, #0
}
1000e6cc:	e1a00003 	mov	r0, r3
1000e6d0:	e24bd000 	sub	sp, fp, #0
1000e6d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e6d8:	e12fff1e 	bx	lr

1000e6dc <_stat_r>:

int
_stat_r(struct _reent *ptr, const char *file, struct stat *pstat)
{
1000e6dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e6e0:	e28db000 	add	fp, sp, #0
1000e6e4:	e24dd014 	sub	sp, sp, #20
1000e6e8:	e50b0008 	str	r0, [fp, #-8]
1000e6ec:	e50b100c 	str	r1, [fp, #-12]
1000e6f0:	e50b2010 	str	r2, [fp, #-16]
#ifndef RT_USING_DFS
	return 0;
1000e6f4:	e3a03000 	mov	r3, #0
	int rc;

	rc = stat(file, pstat);
	return rc;
#endif
}
1000e6f8:	e1a00003 	mov	r0, r3
1000e6fc:	e24bd000 	sub	sp, fp, #0
1000e700:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e704:	e12fff1e 	bx	lr

1000e708 <_times_r>:

_CLOCK_T_
_times_r(struct _reent *ptr, struct tms *ptms)
{
1000e708:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e70c:	e28db000 	add	fp, sp, #0
1000e710:	e24dd00c 	sub	sp, sp, #12
1000e714:	e50b0008 	str	r0, [fp, #-8]
1000e718:	e50b100c 	str	r1, [fp, #-12]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e71c:	e51b3008 	ldr	r3, [fp, #-8]
1000e720:	e3a02086 	mov	r2, #134	; 0x86
1000e724:	e5832000 	str	r2, [r3]
	return -1;
1000e728:	e3e03000 	mvn	r3, #0
}
1000e72c:	e1a00003 	mov	r0, r3
1000e730:	e24bd000 	sub	sp, fp, #0
1000e734:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e738:	e12fff1e 	bx	lr

1000e73c <_unlink_r>:

int
_unlink_r(struct _reent *ptr, const char *file)
{
1000e73c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e740:	e28db000 	add	fp, sp, #0
1000e744:	e24dd00c 	sub	sp, sp, #12
1000e748:	e50b0008 	str	r0, [fp, #-8]
1000e74c:	e50b100c 	str	r1, [fp, #-12]
#ifndef RT_USING_DFS
	return 0;
1000e750:	e3a03000 	mov	r3, #0
	int rc;

	rc = unlink(file);
	return rc;
#endif
}
1000e754:	e1a00003 	mov	r0, r3
1000e758:	e24bd000 	sub	sp, fp, #0
1000e75c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e760:	e12fff1e 	bx	lr

1000e764 <_wait_r>:

int
_wait_r(struct _reent *ptr, int *status)
{
1000e764:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e768:	e28db000 	add	fp, sp, #0
1000e76c:	e24dd00c 	sub	sp, sp, #12
1000e770:	e50b0008 	str	r0, [fp, #-8]
1000e774:	e50b100c 	str	r1, [fp, #-12]
	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e778:	e51b3008 	ldr	r3, [fp, #-8]
1000e77c:	e3a02086 	mov	r2, #134	; 0x86
1000e780:	e5832000 	str	r2, [r3]
	return -1;
1000e784:	e3e03000 	mvn	r3, #0
}
1000e788:	e1a00003 	mov	r0, r3
1000e78c:	e24bd000 	sub	sp, fp, #0
1000e790:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000e794:	e12fff1e 	bx	lr

1000e798 <_write_r>:

#ifdef RT_USING_DEVICE
_ssize_t
_write_r(struct _reent *ptr, int fd, const void *buf, size_t nbytes)
{
1000e798:	e92d4800 	push	{fp, lr}
1000e79c:	e28db004 	add	fp, sp, #4
1000e7a0:	e24dd018 	sub	sp, sp, #24
1000e7a4:	e50b0010 	str	r0, [fp, #-16]
1000e7a8:	e50b1014 	str	r1, [fp, #-20]
1000e7ac:	e50b2018 	str	r2, [fp, #-24]
1000e7b0:	e50b301c 	str	r3, [fp, #-28]
	if (fd < 3)
1000e7b4:	e51b3014 	ldr	r3, [fp, #-20]
1000e7b8:	e3530002 	cmp	r3, #2
1000e7bc:	ca00000b 	bgt	1000e7f0 <_write_r+0x58>
	{
#ifdef RT_USING_CONSOLE
		rt_device_t console_device;
		extern rt_device_t rt_console_get_device(void);

		console_device = rt_console_get_device();
1000e7c0:	ebffde90 	bl	10006208 <rt_console_get_device>
1000e7c4:	e50b0008 	str	r0, [fp, #-8]
		if (console_device != 0) rt_device_write(console_device, 0, buf, nbytes);
1000e7c8:	e51b3008 	ldr	r3, [fp, #-8]
1000e7cc:	e3530000 	cmp	r3, #0
1000e7d0:	0a000004 	beq	1000e7e8 <_write_r+0x50>
1000e7d4:	e51b0008 	ldr	r0, [fp, #-8]
1000e7d8:	e3a01000 	mov	r1, #0
1000e7dc:	e51b2018 	ldr	r2, [fp, #-24]
1000e7e0:	e51b301c 	ldr	r3, [fp, #-28]
1000e7e4:	ebffcaf6 	bl	100013c4 <rt_device_write>
		return nbytes;
1000e7e8:	e51b301c 	ldr	r3, [fp, #-28]
1000e7ec:	ea000000 	b	1000e7f4 <_write_r+0x5c>
	    _ssize_t rc;

	    rc = write(fd, buf, nbytes);
	    return rc;
#else
        return 0;
1000e7f0:	e3a03000 	mov	r3, #0
#endif
	}
}
1000e7f4:	e1a00003 	mov	r0, r3
1000e7f8:	e24bd004 	sub	sp, fp, #4
1000e7fc:	e8bd8800 	pop	{fp, pc}

1000e800 <_gettimeofday_r>:
#else
/* POSIX thread provides clock_gettime function */
#include <time.h>
int
_gettimeofday_r(struct _reent *ptr, struct timeval *__tp, void *__tzp)
{
1000e800:	e92d4800 	push	{fp, lr}
1000e804:	e28db004 	add	fp, sp, #4
1000e808:	e24dd018 	sub	sp, sp, #24
1000e80c:	e50b0010 	str	r0, [fp, #-16]
1000e810:	e50b1014 	str	r1, [fp, #-20]
1000e814:	e50b2018 	str	r2, [fp, #-24]
	struct timespec tp;

	if (clock_gettime(CLOCK_REALTIME, &tp) == 0)
1000e818:	e24b300c 	sub	r3, fp, #12
1000e81c:	e3a00001 	mov	r0, #1
1000e820:	e1a01003 	mov	r1, r3
1000e824:	ebfff476 	bl	1000ba04 <clock_gettime>
1000e828:	e1a03000 	mov	r3, r0
1000e82c:	e3530000 	cmp	r3, #0
1000e830:	1a000013 	bne	1000e884 <_gettimeofday_r+0x84>
	{
		if (__tp != RT_NULL)
1000e834:	e51b3014 	ldr	r3, [fp, #-20]
1000e838:	e3530000 	cmp	r3, #0
1000e83c:	0a00000e 	beq	1000e87c <_gettimeofday_r+0x7c>
		{
			__tp->tv_sec  = tp.tv_sec;
1000e840:	e51b200c 	ldr	r2, [fp, #-12]
1000e844:	e51b3014 	ldr	r3, [fp, #-20]
1000e848:	e5832000 	str	r2, [r3]
			__tp->tv_usec = tp.tv_nsec * 1000UL;
1000e84c:	e51b3008 	ldr	r3, [fp, #-8]
1000e850:	e1a01003 	mov	r1, r3
1000e854:	e1a02001 	mov	r2, r1
1000e858:	e1a03102 	lsl	r3, r2, #2
1000e85c:	e1a02003 	mov	r2, r3
1000e860:	e1a03282 	lsl	r3, r2, #5
1000e864:	e0623003 	rsb	r3, r2, r3
1000e868:	e0833001 	add	r3, r3, r1
1000e86c:	e1a03183 	lsl	r3, r3, #3
1000e870:	e1a02003 	mov	r2, r3
1000e874:	e51b3014 	ldr	r3, [fp, #-20]
1000e878:	e5832004 	str	r2, [r3, #4]
		}

		return tp.tv_sec;
1000e87c:	e51b300c 	ldr	r3, [fp, #-12]
1000e880:	ea000003 	b	1000e894 <_gettimeofday_r+0x94>
	}

	/* return "not supported" */
	ptr->_errno = ENOTSUP;
1000e884:	e51b3010 	ldr	r3, [fp, #-16]
1000e888:	e3a02086 	mov	r2, #134	; 0x86
1000e88c:	e5832000 	str	r2, [r3]
	return -1;
1000e890:	e3e03000 	mvn	r3, #0
}
1000e894:	e1a00003 	mov	r0, r3
1000e898:	e24bd004 	sub	sp, fp, #4
1000e89c:	e8bd8800 	pop	{fp, pc}

1000e8a0 <_malloc_r>:
#endif

/* Memory routine */
void *
_malloc_r (struct _reent *ptr, size_t size)
{
1000e8a0:	e92d4800 	push	{fp, lr}
1000e8a4:	e28db004 	add	fp, sp, #4
1000e8a8:	e24dd010 	sub	sp, sp, #16
1000e8ac:	e50b0010 	str	r0, [fp, #-16]
1000e8b0:	e50b1014 	str	r1, [fp, #-20]
	void* result;

	result = (void*)rt_malloc (size);
1000e8b4:	e51b0014 	ldr	r0, [fp, #-20]
1000e8b8:	ebffe07a 	bl	10006aa8 <rt_malloc>
1000e8bc:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
1000e8c0:	e51b3008 	ldr	r3, [fp, #-8]
1000e8c4:	e3530000 	cmp	r3, #0
1000e8c8:	1a000002 	bne	1000e8d8 <_malloc_r+0x38>
	{
		ptr->_errno = ENOMEM;
1000e8cc:	e51b3010 	ldr	r3, [fp, #-16]
1000e8d0:	e3a0200c 	mov	r2, #12
1000e8d4:	e5832000 	str	r2, [r3]
	}

	return result;
1000e8d8:	e51b3008 	ldr	r3, [fp, #-8]
}
1000e8dc:	e1a00003 	mov	r0, r3
1000e8e0:	e24bd004 	sub	sp, fp, #4
1000e8e4:	e8bd8800 	pop	{fp, pc}

1000e8e8 <_realloc_r>:

void *
_realloc_r (struct _reent *ptr, void *old, size_t newlen)
{
1000e8e8:	e92d4800 	push	{fp, lr}
1000e8ec:	e28db004 	add	fp, sp, #4
1000e8f0:	e24dd018 	sub	sp, sp, #24
1000e8f4:	e50b0010 	str	r0, [fp, #-16]
1000e8f8:	e50b1014 	str	r1, [fp, #-20]
1000e8fc:	e50b2018 	str	r2, [fp, #-24]
	void* result;

	result = (void*)rt_realloc (old, newlen);
1000e900:	e51b0014 	ldr	r0, [fp, #-20]
1000e904:	e51b1018 	ldr	r1, [fp, #-24]
1000e908:	ebffe1a4 	bl	10006fa0 <rt_realloc>
1000e90c:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
1000e910:	e51b3008 	ldr	r3, [fp, #-8]
1000e914:	e3530000 	cmp	r3, #0
1000e918:	1a000002 	bne	1000e928 <_realloc_r+0x40>
	{
		ptr->_errno = ENOMEM;
1000e91c:	e51b3010 	ldr	r3, [fp, #-16]
1000e920:	e3a0200c 	mov	r2, #12
1000e924:	e5832000 	str	r2, [r3]
	}

	return result;
1000e928:	e51b3008 	ldr	r3, [fp, #-8]
}
1000e92c:	e1a00003 	mov	r0, r3
1000e930:	e24bd004 	sub	sp, fp, #4
1000e934:	e8bd8800 	pop	{fp, pc}

1000e938 <_calloc_r>:

void *_calloc_r (struct _reent *ptr, size_t size, size_t len)
{
1000e938:	e92d4800 	push	{fp, lr}
1000e93c:	e28db004 	add	fp, sp, #4
1000e940:	e24dd018 	sub	sp, sp, #24
1000e944:	e50b0010 	str	r0, [fp, #-16]
1000e948:	e50b1014 	str	r1, [fp, #-20]
1000e94c:	e50b2018 	str	r2, [fp, #-24]
	void* result;

	result = (void*)rt_calloc (size, len);
1000e950:	e51b0014 	ldr	r0, [fp, #-20]
1000e954:	e51b1018 	ldr	r1, [fp, #-24]
1000e958:	ebffe241 	bl	10007264 <rt_calloc>
1000e95c:	e50b0008 	str	r0, [fp, #-8]
	if (result == RT_NULL)
1000e960:	e51b3008 	ldr	r3, [fp, #-8]
1000e964:	e3530000 	cmp	r3, #0
1000e968:	1a000002 	bne	1000e978 <_calloc_r+0x40>
	{
		ptr->_errno = ENOMEM;
1000e96c:	e51b3010 	ldr	r3, [fp, #-16]
1000e970:	e3a0200c 	mov	r2, #12
1000e974:	e5832000 	str	r2, [r3]
	}

	return result;
1000e978:	e51b3008 	ldr	r3, [fp, #-8]
}
1000e97c:	e1a00003 	mov	r0, r3
1000e980:	e24bd004 	sub	sp, fp, #4
1000e984:	e8bd8800 	pop	{fp, pc}

1000e988 <_free_r>:

void 
_free_r (struct _reent *ptr, void *addr)
{
1000e988:	e92d4800 	push	{fp, lr}
1000e98c:	e28db004 	add	fp, sp, #4
1000e990:	e24dd008 	sub	sp, sp, #8
1000e994:	e50b0008 	str	r0, [fp, #-8]
1000e998:	e50b100c 	str	r1, [fp, #-12]
	rt_free (addr);
1000e99c:	e51b000c 	ldr	r0, [fp, #-12]
1000e9a0:	ebffe25b 	bl	10007314 <rt_free>
}
1000e9a4:	e24bd004 	sub	sp, fp, #4
1000e9a8:	e8bd8800 	pop	{fp, pc}

1000e9ac <_exit>:

void
_exit (int status)
{
1000e9ac:	e92d4800 	push	{fp, lr}
1000e9b0:	e28db004 	add	fp, sp, #4
1000e9b4:	e24dd008 	sub	sp, sp, #8
1000e9b8:	e50b0008 	str	r0, [fp, #-8]
		/* re-schedule */
		rt_schedule();
	}
#endif
	
	rt_kprintf("thread:%s exit with %d\n", rt_thread_self()->name, status);
1000e9bc:	ebffe781 	bl	100087c8 <rt_thread_self>
1000e9c0:	e1a03000 	mov	r3, r0
1000e9c4:	e30f05f8 	movw	r0, #62968	; 0xf5f8
1000e9c8:	e3410001 	movt	r0, #4097	; 0x1001
1000e9cc:	e1a01003 	mov	r1, r3
1000e9d0:	e51b2008 	ldr	r2, [fp, #-8]
1000e9d4:	ebffde3e 	bl	100062d4 <rt_kprintf>
	RT_ASSERT(0);
1000e9d8:	e30f0610 	movw	r0, #62992	; 0xf610
1000e9dc:	e3410001 	movt	r0, #4097	; 0x1001
1000e9e0:	e30f1614 	movw	r1, #62996	; 0xf614
1000e9e4:	e3411001 	movt	r1, #4097	; 0x1001
1000e9e8:	e30021b2 	movw	r2, #434	; 0x1b2
1000e9ec:	ebffdef5 	bl	100065c8 <rt_assert_handler>

	while (1);
1000e9f0:	eafffffe 	b	1000e9f0 <_exit+0x44>

1000e9f4 <_system>:
}

void 
_system(const char *s)
{
1000e9f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000e9f8:	e28db000 	add	fp, sp, #0
1000e9fc:	e24dd00c 	sub	sp, sp, #12
1000ea00:	e50b0008 	str	r0, [fp, #-8]
    /* not support this call */
    return;
1000ea04:	e1a00000 	nop			; (mov r0, r0)
}
1000ea08:	e24bd000 	sub	sp, fp, #0
1000ea0c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ea10:	e12fff1e 	bx	lr

1000ea14 <__libc_init_array>:

void __libc_init_array(void)
{
1000ea14:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ea18:	e28db000 	add	fp, sp, #0
	/* we not use __libc init_aray to initialize C++ objects */
}
1000ea1c:	e24bd000 	sub	sp, fp, #0
1000ea20:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ea24:	e12fff1e 	bx	lr

1000ea28 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
1000ea28:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ea2c:	e28db000 	add	fp, sp, #0
1000ea30:	e24dd00c 	sub	sp, sp, #12
1000ea34:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
1000ea38:	e51b3008 	ldr	r3, [fp, #-8]
1000ea3c:	e51b2008 	ldr	r2, [fp, #-8]
1000ea40:	e5832004 	str	r2, [r3, #4]
1000ea44:	e51b3008 	ldr	r3, [fp, #-8]
1000ea48:	e5932004 	ldr	r2, [r3, #4]
1000ea4c:	e51b3008 	ldr	r3, [fp, #-8]
1000ea50:	e5832000 	str	r2, [r3]
}
1000ea54:	e24bd000 	sub	sp, fp, #0
1000ea58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ea5c:	e12fff1e 	bx	lr

1000ea60 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
1000ea60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ea64:	e28db000 	add	fp, sp, #0
1000ea68:	e24dd00c 	sub	sp, sp, #12
1000ea6c:	e50b0008 	str	r0, [fp, #-8]
1000ea70:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
1000ea74:	e51b3008 	ldr	r3, [fp, #-8]
1000ea78:	e5933004 	ldr	r3, [r3, #4]
1000ea7c:	e51b200c 	ldr	r2, [fp, #-12]
1000ea80:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
1000ea84:	e51b3008 	ldr	r3, [fp, #-8]
1000ea88:	e5932004 	ldr	r2, [r3, #4]
1000ea8c:	e51b300c 	ldr	r3, [fp, #-12]
1000ea90:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
1000ea94:	e51b3008 	ldr	r3, [fp, #-8]
1000ea98:	e51b200c 	ldr	r2, [fp, #-12]
1000ea9c:	e5832004 	str	r2, [r3, #4]
    n->next = l;
1000eaa0:	e51b300c 	ldr	r3, [fp, #-12]
1000eaa4:	e51b2008 	ldr	r2, [fp, #-8]
1000eaa8:	e5832000 	str	r2, [r3]
}
1000eaac:	e24bd000 	sub	sp, fp, #0
1000eab0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000eab4:	e12fff1e 	bx	lr

1000eab8 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
1000eab8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000eabc:	e28db000 	add	fp, sp, #0
1000eac0:	e24dd00c 	sub	sp, sp, #12
1000eac4:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
1000eac8:	e51b3008 	ldr	r3, [fp, #-8]
1000eacc:	e5932000 	ldr	r2, [r3]
1000ead0:	e51b3008 	ldr	r3, [fp, #-8]
1000ead4:	e1520003 	cmp	r2, r3
1000ead8:	03a03001 	moveq	r3, #1
1000eadc:	13a03000 	movne	r3, #0
1000eae0:	e6ef3073 	uxtb	r3, r3
}
1000eae4:	e1a00003 	mov	r0, r3
1000eae8:	e24bd000 	sub	sp, fp, #0
1000eaec:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000eaf0:	e12fff1e 	bx	lr

1000eaf4 <rt_completion_init>:

#define RT_COMPLETED    1
#define RT_UNCOMPLETED  0

void rt_completion_init(struct rt_completion *completion)
{
1000eaf4:	e92d4800 	push	{fp, lr}
1000eaf8:	e28db004 	add	fp, sp, #4
1000eafc:	e24dd010 	sub	sp, sp, #16
1000eb00:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
1000eb04:	e51b3010 	ldr	r3, [fp, #-16]
1000eb08:	e3530000 	cmp	r3, #0
1000eb0c:	1a000005 	bne	1000eb28 <rt_completion_init+0x34>
1000eb10:	e30f061c 	movw	r0, #63004	; 0xf61c
1000eb14:	e3410001 	movt	r0, #4097	; 0x1001
1000eb18:	e30f168c 	movw	r1, #63116	; 0xf68c
1000eb1c:	e3411001 	movt	r1, #4097	; 0x1001
1000eb20:	e3a02023 	mov	r2, #35	; 0x23
1000eb24:	ebffdea7 	bl	100065c8 <rt_assert_handler>

    level = rt_hw_interrupt_disable();
1000eb28:	ebfff263 	bl	1000b4bc <rt_hw_interrupt_disable>
1000eb2c:	e50b0008 	str	r0, [fp, #-8]
    completion->flag = RT_UNCOMPLETED;
1000eb30:	e51b3010 	ldr	r3, [fp, #-16]
1000eb34:	e3a02000 	mov	r2, #0
1000eb38:	e5832000 	str	r2, [r3]
    rt_list_init(&completion->suspended_list);
1000eb3c:	e51b3010 	ldr	r3, [fp, #-16]
1000eb40:	e2833004 	add	r3, r3, #4
1000eb44:	e1a00003 	mov	r0, r3
1000eb48:	ebffffb6 	bl	1000ea28 <rt_list_init>
    rt_hw_interrupt_enable(level);
1000eb4c:	e51b0008 	ldr	r0, [fp, #-8]
1000eb50:	ebfff25d 	bl	1000b4cc <rt_hw_interrupt_enable>
}
1000eb54:	e24bd004 	sub	sp, fp, #4
1000eb58:	e8bd8800 	pop	{fp, pc}

1000eb5c <rt_completion_wait>:
RTM_EXPORT(rt_completion_init);

rt_err_t rt_completion_wait(struct rt_completion *completion,
                            rt_int32_t            timeout)
{
1000eb5c:	e92d4800 	push	{fp, lr}
1000eb60:	e28db004 	add	fp, sp, #4
1000eb64:	e24dd018 	sub	sp, sp, #24
1000eb68:	e50b0018 	str	r0, [fp, #-24]
1000eb6c:	e50b101c 	str	r1, [fp, #-28]
    rt_err_t result;
    rt_base_t level;
    rt_thread_t thread;
    RT_ASSERT(completion != RT_NULL);
1000eb70:	e51b3018 	ldr	r3, [fp, #-24]
1000eb74:	e3530000 	cmp	r3, #0
1000eb78:	1a000005 	bne	1000eb94 <rt_completion_wait+0x38>
1000eb7c:	e30f061c 	movw	r0, #63004	; 0xf61c
1000eb80:	e3410001 	movt	r0, #4097	; 0x1001
1000eb84:	e30f16a0 	movw	r1, #63136	; 0xf6a0
1000eb88:	e3411001 	movt	r1, #4097	; 0x1001
1000eb8c:	e3a02032 	mov	r2, #50	; 0x32
1000eb90:	ebffde8c 	bl	100065c8 <rt_assert_handler>

    result = RT_EOK;
1000eb94:	e3a03000 	mov	r3, #0
1000eb98:	e50b3008 	str	r3, [fp, #-8]
    thread = rt_thread_self();
1000eb9c:	ebffe709 	bl	100087c8 <rt_thread_self>
1000eba0:	e50b0010 	str	r0, [fp, #-16]

    level = rt_hw_interrupt_disable();
1000eba4:	ebfff244 	bl	1000b4bc <rt_hw_interrupt_disable>
1000eba8:	e50b000c 	str	r0, [fp, #-12]
    if (completion->flag != RT_COMPLETED)
1000ebac:	e51b3018 	ldr	r3, [fp, #-24]
1000ebb0:	e5933000 	ldr	r3, [r3]
1000ebb4:	e3530001 	cmp	r3, #1
1000ebb8:	0a000047 	beq	1000ecdc <rt_completion_wait+0x180>
    {
        /* only one thread can suspend on complete */
        RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
1000ebbc:	e51b3018 	ldr	r3, [fp, #-24]
1000ebc0:	e2833004 	add	r3, r3, #4
1000ebc4:	e1a00003 	mov	r0, r3
1000ebc8:	ebffffba 	bl	1000eab8 <rt_list_isempty>
1000ebcc:	e1a03000 	mov	r3, r0
1000ebd0:	e3530000 	cmp	r3, #0
1000ebd4:	1a000005 	bne	1000ebf0 <rt_completion_wait+0x94>
1000ebd8:	e30f0634 	movw	r0, #63028	; 0xf634
1000ebdc:	e3410001 	movt	r0, #4097	; 0x1001
1000ebe0:	e30f16a0 	movw	r1, #63136	; 0xf6a0
1000ebe4:	e3411001 	movt	r1, #4097	; 0x1001
1000ebe8:	e3a0203b 	mov	r2, #59	; 0x3b
1000ebec:	ebffde75 	bl	100065c8 <rt_assert_handler>

        if (timeout == 0)
1000ebf0:	e51b301c 	ldr	r3, [fp, #-28]
1000ebf4:	e3530000 	cmp	r3, #0
1000ebf8:	1a000002 	bne	1000ec08 <rt_completion_wait+0xac>
        {
            result = -RT_ETIMEOUT;
1000ebfc:	e3e03001 	mvn	r3, #1
1000ec00:	e50b3008 	str	r3, [fp, #-8]
            goto __exit;
1000ec04:	ea000037 	b	1000ece8 <rt_completion_wait+0x18c>
        }
        else
        {
            /* reset thread error number */
            thread->error = RT_EOK;
1000ec08:	e51b3010 	ldr	r3, [fp, #-16]
1000ec0c:	e3a02000 	mov	r2, #0
1000ec10:	e583202c 	str	r2, [r3, #44]	; 0x2c

            /* suspend thread */
            rt_thread_suspend(thread);
1000ec14:	e51b0010 	ldr	r0, [fp, #-16]
1000ec18:	ebffe84c 	bl	10008d50 <rt_thread_suspend>
            /* add to suspended list */
            rt_list_insert_before(&(completion->suspended_list),
1000ec1c:	e51b3018 	ldr	r3, [fp, #-24]
1000ec20:	e2832004 	add	r2, r3, #4
1000ec24:	e51b3010 	ldr	r3, [fp, #-16]
1000ec28:	e2833010 	add	r3, r3, #16
1000ec2c:	e1a00002 	mov	r0, r2
1000ec30:	e1a01003 	mov	r1, r3
1000ec34:	ebffff89 	bl	1000ea60 <rt_list_insert_before>
                                  &(thread->tlist));

            /* current context checking */
            RT_DEBUG_NOT_IN_INTERRUPT;
1000ec38:	ebfff21f 	bl	1000b4bc <rt_hw_interrupt_disable>
1000ec3c:	e50b0014 	str	r0, [fp, #-20]
1000ec40:	ebffd75e 	bl	100049c0 <rt_interrupt_get_nest>
1000ec44:	e1a03000 	mov	r3, r0
1000ec48:	e3530000 	cmp	r3, #0
1000ec4c:	0a00000a 	beq	1000ec7c <rt_completion_wait+0x120>
1000ec50:	e30f0664 	movw	r0, #63076	; 0xf664
1000ec54:	e3410001 	movt	r0, #4097	; 0x1001
1000ec58:	e30f16a0 	movw	r1, #63136	; 0xf6a0
1000ec5c:	e3411001 	movt	r1, #4097	; 0x1001
1000ec60:	ebffdd9b 	bl	100062d4 <rt_kprintf>
1000ec64:	e30f0688 	movw	r0, #63112	; 0xf688
1000ec68:	e3410001 	movt	r0, #4097	; 0x1001
1000ec6c:	e30f16a0 	movw	r1, #63136	; 0xf6a0
1000ec70:	e3411001 	movt	r1, #4097	; 0x1001
1000ec74:	e3a0204e 	mov	r2, #78	; 0x4e
1000ec78:	ebffde52 	bl	100065c8 <rt_assert_handler>
1000ec7c:	e51b0014 	ldr	r0, [fp, #-20]
1000ec80:	ebfff211 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* start timer */
            if (timeout > 0)
1000ec84:	e51b301c 	ldr	r3, [fp, #-28]
1000ec88:	e3530000 	cmp	r3, #0
1000ec8c:	da00000a 	ble	1000ecbc <rt_completion_wait+0x160>
            {
                /* reset the timeout of thread timer and start it */
                rt_timer_control(&(thread->thread_timer),
1000ec90:	e51b3010 	ldr	r3, [fp, #-16]
1000ec94:	e2832048 	add	r2, r3, #72	; 0x48
1000ec98:	e24b301c 	sub	r3, fp, #28
1000ec9c:	e1a00002 	mov	r0, r2
1000eca0:	e3a01000 	mov	r1, #0
1000eca4:	e1a02003 	mov	r2, r3
1000eca8:	ebffead7 	bl	1000980c <rt_timer_control>
                                 RT_TIMER_CTRL_SET_TIME,
                                 &timeout);
                rt_timer_start(&(thread->thread_timer));
1000ecac:	e51b3010 	ldr	r3, [fp, #-16]
1000ecb0:	e2833048 	add	r3, r3, #72	; 0x48
1000ecb4:	e1a00003 	mov	r0, r3
1000ecb8:	ebffe9dd 	bl	10009434 <rt_timer_start>
            }
            /* enable interrupt */
            rt_hw_interrupt_enable(level);
1000ecbc:	e51b000c 	ldr	r0, [fp, #-12]
1000ecc0:	ebfff201 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* do schedule */
            rt_schedule();
1000ecc4:	ebffe4d0 	bl	1000800c <rt_schedule>

            /* thread is waked up */
            result = thread->error;
1000ecc8:	e51b3010 	ldr	r3, [fp, #-16]
1000eccc:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000ecd0:	e50b3008 	str	r3, [fp, #-8]

            level = rt_hw_interrupt_disable();
1000ecd4:	ebfff1f8 	bl	1000b4bc <rt_hw_interrupt_disable>
1000ecd8:	e50b000c 	str	r0, [fp, #-12]
        }
    }
    /* clean completed flag */
    completion->flag = RT_UNCOMPLETED;
1000ecdc:	e51b3018 	ldr	r3, [fp, #-24]
1000ece0:	e3a02000 	mov	r2, #0
1000ece4:	e5832000 	str	r2, [r3]

__exit:
    rt_hw_interrupt_enable(level);
1000ece8:	e51b000c 	ldr	r0, [fp, #-12]
1000ecec:	ebfff1f6 	bl	1000b4cc <rt_hw_interrupt_enable>

    return result;
1000ecf0:	e51b3008 	ldr	r3, [fp, #-8]
}
1000ecf4:	e1a00003 	mov	r0, r3
1000ecf8:	e24bd004 	sub	sp, fp, #4
1000ecfc:	e8bd8800 	pop	{fp, pc}

1000ed00 <rt_completion_done>:
RTM_EXPORT(rt_completion_wait);

void rt_completion_done(struct rt_completion *completion)
{
1000ed00:	e92d4800 	push	{fp, lr}
1000ed04:	e28db004 	add	fp, sp, #4
1000ed08:	e24dd010 	sub	sp, sp, #16
1000ed0c:	e50b0010 	str	r0, [fp, #-16]
    rt_base_t level;
    RT_ASSERT(completion != RT_NULL);
1000ed10:	e51b3010 	ldr	r3, [fp, #-16]
1000ed14:	e3530000 	cmp	r3, #0
1000ed18:	1a000005 	bne	1000ed34 <rt_completion_done+0x34>
1000ed1c:	e30f061c 	movw	r0, #63004	; 0xf61c
1000ed20:	e3410001 	movt	r0, #4097	; 0x1001
1000ed24:	e30f16b4 	movw	r1, #63156	; 0xf6b4
1000ed28:	e3411001 	movt	r1, #4097	; 0x1001
1000ed2c:	e3a02072 	mov	r2, #114	; 0x72
1000ed30:	ebffde24 	bl	100065c8 <rt_assert_handler>

    if (completion->flag == RT_COMPLETED)
1000ed34:	e51b3010 	ldr	r3, [fp, #-16]
1000ed38:	e5933000 	ldr	r3, [r3]
1000ed3c:	e3530001 	cmp	r3, #1
1000ed40:	1a000000 	bne	1000ed48 <rt_completion_done+0x48>
        return;
1000ed44:	ea000017 	b	1000eda8 <rt_completion_done+0xa8>

    level = rt_hw_interrupt_disable();
1000ed48:	ebfff1db 	bl	1000b4bc <rt_hw_interrupt_disable>
1000ed4c:	e50b0008 	str	r0, [fp, #-8]
    completion->flag = RT_COMPLETED;
1000ed50:	e51b3010 	ldr	r3, [fp, #-16]
1000ed54:	e3a02001 	mov	r2, #1
1000ed58:	e5832000 	str	r2, [r3]

    if (!rt_list_isempty(&(completion->suspended_list)))
1000ed5c:	e51b3010 	ldr	r3, [fp, #-16]
1000ed60:	e2833004 	add	r3, r3, #4
1000ed64:	e1a00003 	mov	r0, r3
1000ed68:	ebffff52 	bl	1000eab8 <rt_list_isempty>
1000ed6c:	e1a03000 	mov	r3, r0
1000ed70:	e3530000 	cmp	r3, #0
1000ed74:	1a000009 	bne	1000eda0 <rt_completion_done+0xa0>
    {
        /* there is one thread in suspended list */
        struct rt_thread *thread;

        /* get thread entry */
        thread = rt_list_entry(completion->suspended_list.next,
1000ed78:	e51b3010 	ldr	r3, [fp, #-16]
1000ed7c:	e5933004 	ldr	r3, [r3, #4]
1000ed80:	e2433010 	sub	r3, r3, #16
1000ed84:	e50b300c 	str	r3, [fp, #-12]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
1000ed88:	e51b000c 	ldr	r0, [fp, #-12]
1000ed8c:	ebffe813 	bl	10008de0 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
1000ed90:	e51b0008 	ldr	r0, [fp, #-8]
1000ed94:	ebfff1cc 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
1000ed98:	ebffe49b 	bl	1000800c <rt_schedule>
1000ed9c:	ea000001 	b	1000eda8 <rt_completion_done+0xa8>
    }
    else
    {
        rt_hw_interrupt_enable(level);
1000eda0:	e51b0008 	ldr	r0, [fp, #-8]
1000eda4:	ebfff1c8 	bl	1000b4cc <rt_hw_interrupt_enable>
    }
}
1000eda8:	e24bd004 	sub	sp, fp, #4
1000edac:	e8bd8800 	pop	{fp, pc}

1000edb0 <rt_list_init>:
 * @brief initialize a list
 *
 * @param l list to be initialized
 */
rt_inline void rt_list_init(rt_list_t *l)
{
1000edb0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000edb4:	e28db000 	add	fp, sp, #0
1000edb8:	e24dd00c 	sub	sp, sp, #12
1000edbc:	e50b0008 	str	r0, [fp, #-8]
    l->next = l->prev = l;
1000edc0:	e51b3008 	ldr	r3, [fp, #-8]
1000edc4:	e51b2008 	ldr	r2, [fp, #-8]
1000edc8:	e5832004 	str	r2, [r3, #4]
1000edcc:	e51b3008 	ldr	r3, [fp, #-8]
1000edd0:	e5932004 	ldr	r2, [r3, #4]
1000edd4:	e51b3008 	ldr	r3, [fp, #-8]
1000edd8:	e5832000 	str	r2, [r3]
}
1000eddc:	e24bd000 	sub	sp, fp, #0
1000ede0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ede4:	e12fff1e 	bx	lr

1000ede8 <rt_list_insert_before>:
 *
 * @param n new node to be inserted
 * @param l list to insert it
 */
rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
1000ede8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000edec:	e28db000 	add	fp, sp, #0
1000edf0:	e24dd00c 	sub	sp, sp, #12
1000edf4:	e50b0008 	str	r0, [fp, #-8]
1000edf8:	e50b100c 	str	r1, [fp, #-12]
    l->prev->next = n;
1000edfc:	e51b3008 	ldr	r3, [fp, #-8]
1000ee00:	e5933004 	ldr	r3, [r3, #4]
1000ee04:	e51b200c 	ldr	r2, [fp, #-12]
1000ee08:	e5832000 	str	r2, [r3]
    n->prev = l->prev;
1000ee0c:	e51b3008 	ldr	r3, [fp, #-8]
1000ee10:	e5932004 	ldr	r2, [r3, #4]
1000ee14:	e51b300c 	ldr	r3, [fp, #-12]
1000ee18:	e5832004 	str	r2, [r3, #4]

    l->prev = n;
1000ee1c:	e51b3008 	ldr	r3, [fp, #-8]
1000ee20:	e51b200c 	ldr	r2, [fp, #-12]
1000ee24:	e5832004 	str	r2, [r3, #4]
    n->next = l;
1000ee28:	e51b300c 	ldr	r3, [fp, #-12]
1000ee2c:	e51b2008 	ldr	r2, [fp, #-8]
1000ee30:	e5832000 	str	r2, [r3]
}
1000ee34:	e24bd000 	sub	sp, fp, #0
1000ee38:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ee3c:	e12fff1e 	bx	lr

1000ee40 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
1000ee40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1000ee44:	e28db000 	add	fp, sp, #0
1000ee48:	e24dd00c 	sub	sp, sp, #12
1000ee4c:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
1000ee50:	e51b3008 	ldr	r3, [fp, #-8]
1000ee54:	e5932000 	ldr	r2, [r3]
1000ee58:	e51b3008 	ldr	r3, [fp, #-8]
1000ee5c:	e1520003 	cmp	r2, r3
1000ee60:	03a03001 	moveq	r3, #1
1000ee64:	13a03000 	movne	r3, #0
1000ee68:	e6ef3073 	uxtb	r3, r3
}
1000ee6c:	e1a00003 	mov	r0, r3
1000ee70:	e24bd000 	sub	sp, fp, #0
1000ee74:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1000ee78:	e12fff1e 	bx	lr

1000ee7c <rt_data_queue_init>:
rt_err_t
rt_data_queue_init(struct rt_data_queue *queue,
                   rt_uint16_t size,
                   rt_uint16_t lwm,
                   void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
{
1000ee7c:	e92d4800 	push	{fp, lr}
1000ee80:	e28db004 	add	fp, sp, #4
1000ee84:	e24dd010 	sub	sp, sp, #16
1000ee88:	e50b0008 	str	r0, [fp, #-8]
1000ee8c:	e50b3010 	str	r3, [fp, #-16]
1000ee90:	e14b10ba 	strh	r1, [fp, #-10]
1000ee94:	e14b20bc 	strh	r2, [fp, #-12]
    RT_ASSERT(queue != RT_NULL);
1000ee98:	e51b3008 	ldr	r3, [fp, #-8]
1000ee9c:	e3530000 	cmp	r3, #0
1000eea0:	1a000005 	bne	1000eebc <rt_data_queue_init+0x40>
1000eea4:	e30f06c8 	movw	r0, #63176	; 0xf6c8
1000eea8:	e3410001 	movt	r0, #4097	; 0x1001
1000eeac:	e30f1728 	movw	r1, #63272	; 0xf728
1000eeb0:	e3411001 	movt	r1, #4097	; 0x1001
1000eeb4:	e3a02029 	mov	r2, #41	; 0x29
1000eeb8:	ebffddc2 	bl	100065c8 <rt_assert_handler>

    queue->evt_notify = evt_notify;
1000eebc:	e51b3008 	ldr	r3, [fp, #-8]
1000eec0:	e51b2010 	ldr	r2, [fp, #-16]
1000eec4:	e5832020 	str	r2, [r3, #32]

    queue->size = size;
1000eec8:	e51b3008 	ldr	r3, [fp, #-8]
1000eecc:	e15b20ba 	ldrh	r2, [fp, #-10]
1000eed0:	e1c320b0 	strh	r2, [r3]
    queue->lwm = lwm;
1000eed4:	e51b3008 	ldr	r3, [fp, #-8]
1000eed8:	e15b20bc 	ldrh	r2, [fp, #-12]
1000eedc:	e1c320b2 	strh	r2, [r3, #2]
    queue->waiting_lwm = RT_FALSE;
1000eee0:	e51b3008 	ldr	r3, [fp, #-8]
1000eee4:	e3a02000 	mov	r2, #0
1000eee8:	e5832004 	str	r2, [r3, #4]

    queue->get_index = 0;
1000eeec:	e51b3008 	ldr	r3, [fp, #-8]
1000eef0:	e3a02000 	mov	r2, #0
1000eef4:	e1c320b8 	strh	r2, [r3, #8]
    queue->put_index = 0;
1000eef8:	e51b3008 	ldr	r3, [fp, #-8]
1000eefc:	e3a02000 	mov	r2, #0
1000ef00:	e1c320ba 	strh	r2, [r3, #10]

    rt_list_init(&(queue->suspended_push_list));
1000ef04:	e51b3008 	ldr	r3, [fp, #-8]
1000ef08:	e2833010 	add	r3, r3, #16
1000ef0c:	e1a00003 	mov	r0, r3
1000ef10:	ebffffa6 	bl	1000edb0 <rt_list_init>
    rt_list_init(&(queue->suspended_pop_list));
1000ef14:	e51b3008 	ldr	r3, [fp, #-8]
1000ef18:	e2833018 	add	r3, r3, #24
1000ef1c:	e1a00003 	mov	r0, r3
1000ef20:	ebffffa2 	bl	1000edb0 <rt_list_init>

    queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
1000ef24:	e15b30ba 	ldrh	r3, [fp, #-10]
1000ef28:	e1a03183 	lsl	r3, r3, #3
1000ef2c:	e1a00003 	mov	r0, r3
1000ef30:	ebffdedc 	bl	10006aa8 <rt_malloc>
1000ef34:	e1a02000 	mov	r2, r0
1000ef38:	e51b3008 	ldr	r3, [fp, #-8]
1000ef3c:	e583200c 	str	r2, [r3, #12]
    if (queue->queue == RT_NULL)
1000ef40:	e51b3008 	ldr	r3, [fp, #-8]
1000ef44:	e593300c 	ldr	r3, [r3, #12]
1000ef48:	e3530000 	cmp	r3, #0
1000ef4c:	1a000001 	bne	1000ef58 <rt_data_queue_init+0xdc>
    {
        return -RT_ENOMEM;
1000ef50:	e3e03004 	mvn	r3, #4
1000ef54:	ea000000 	b	1000ef5c <rt_data_queue_init+0xe0>
    }

    return RT_EOK;
1000ef58:	e3a03000 	mov	r3, #0
}
1000ef5c:	e1a00003 	mov	r0, r3
1000ef60:	e24bd004 	sub	sp, fp, #4
1000ef64:	e8bd8800 	pop	{fp, pc}

1000ef68 <rt_data_queue_push>:

rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
                            const void *data_ptr,
                            rt_size_t data_size,
                            rt_int32_t timeout)
{
1000ef68:	e92d4800 	push	{fp, lr}
1000ef6c:	e28db004 	add	fp, sp, #4
1000ef70:	e24dd028 	sub	sp, sp, #40	; 0x28
1000ef74:	e50b0020 	str	r0, [fp, #-32]
1000ef78:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1000ef7c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
1000ef80:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    rt_uint16_t mask;
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    
    RT_ASSERT(queue != RT_NULL);
1000ef84:	e51b3020 	ldr	r3, [fp, #-32]
1000ef88:	e3530000 	cmp	r3, #0
1000ef8c:	1a000005 	bne	1000efa8 <rt_data_queue_push+0x40>
1000ef90:	e30f06c8 	movw	r0, #63176	; 0xf6c8
1000ef94:	e3410001 	movt	r0, #4097	; 0x1001
1000ef98:	e30f173c 	movw	r1, #63292	; 0xf73c
1000ef9c:	e3411001 	movt	r1, #4097	; 0x1001
1000efa0:	e3a0204b 	mov	r2, #75	; 0x4b
1000efa4:	ebffdd87 	bl	100065c8 <rt_assert_handler>

    result = RT_EOK;
1000efa8:	e3a03000 	mov	r3, #0
1000efac:	e50b300c 	str	r3, [fp, #-12]
    thread = rt_thread_self();
1000efb0:	ebffe604 	bl	100087c8 <rt_thread_self>
1000efb4:	e50b0010 	str	r0, [fp, #-16]
    mask = queue->size - 1;
1000efb8:	e51b3020 	ldr	r3, [fp, #-32]
1000efbc:	e1d330b0 	ldrh	r3, [r3]
1000efc0:	e2433001 	sub	r3, r3, #1
1000efc4:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

    level = rt_hw_interrupt_disable();
1000efc8:	ebfff13b 	bl	1000b4bc <rt_hw_interrupt_disable>
1000efcc:	e1a03000 	mov	r3, r0
1000efd0:	e50b3008 	str	r3, [fp, #-8]
    while (queue->put_index - queue->get_index == queue->size)
1000efd4:	ea000043 	b	1000f0e8 <rt_data_queue_push+0x180>
    {
        queue->waiting_lwm = RT_TRUE;
1000efd8:	e51b3020 	ldr	r3, [fp, #-32]
1000efdc:	e3a02001 	mov	r2, #1
1000efe0:	e5832004 	str	r2, [r3, #4]

        /* queue is full */
        if (timeout == 0)
1000efe4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1000efe8:	e3530000 	cmp	r3, #0
1000efec:	1a000002 	bne	1000effc <rt_data_queue_push+0x94>
        {
            result = -RT_ETIMEOUT;
1000eff0:	e3e03001 	mvn	r3, #1
1000eff4:	e50b300c 	str	r3, [fp, #-12]

            goto __exit;
1000eff8:	ea000073 	b	1000f1cc <rt_data_queue_push+0x264>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
1000effc:	ebfff12e 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f000:	e50b0018 	str	r0, [fp, #-24]
1000f004:	ebffd66d 	bl	100049c0 <rt_interrupt_get_nest>
1000f008:	e1a03000 	mov	r3, r0
1000f00c:	e3530000 	cmp	r3, #0
1000f010:	0a00000a 	beq	1000f040 <rt_data_queue_push+0xd8>
1000f014:	e30f06dc 	movw	r0, #63196	; 0xf6dc
1000f018:	e3410001 	movt	r0, #4097	; 0x1001
1000f01c:	e30f173c 	movw	r1, #63292	; 0xf73c
1000f020:	e3411001 	movt	r1, #4097	; 0x1001
1000f024:	ebffdcaa 	bl	100062d4 <rt_kprintf>
1000f028:	e30f0700 	movw	r0, #63232	; 0xf700
1000f02c:	e3410001 	movt	r0, #4097	; 0x1001
1000f030:	e30f173c 	movw	r1, #63292	; 0xf73c
1000f034:	e3411001 	movt	r1, #4097	; 0x1001
1000f038:	e3a0205f 	mov	r2, #95	; 0x5f
1000f03c:	ebffdd61 	bl	100065c8 <rt_assert_handler>
1000f040:	e51b0018 	ldr	r0, [fp, #-24]
1000f044:	ebfff120 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
1000f048:	e51b3010 	ldr	r3, [fp, #-16]
1000f04c:	e3a02000 	mov	r2, #0
1000f050:	e583202c 	str	r2, [r3, #44]	; 0x2c
        
        /* suspend thread on the push list */
        rt_thread_suspend(thread);
1000f054:	e51b0010 	ldr	r0, [fp, #-16]
1000f058:	ebffe73c 	bl	10008d50 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
1000f05c:	e51b3020 	ldr	r3, [fp, #-32]
1000f060:	e2832010 	add	r2, r3, #16
1000f064:	e51b3010 	ldr	r3, [fp, #-16]
1000f068:	e2833010 	add	r3, r3, #16
1000f06c:	e1a00002 	mov	r0, r2
1000f070:	e1a01003 	mov	r1, r3
1000f074:	ebffff5b 	bl	1000ede8 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
1000f078:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1000f07c:	e3530000 	cmp	r3, #0
1000f080:	da00000a 	ble	1000f0b0 <rt_data_queue_push+0x148>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
1000f084:	e51b3010 	ldr	r3, [fp, #-16]
1000f088:	e2832048 	add	r2, r3, #72	; 0x48
1000f08c:	e24b302c 	sub	r3, fp, #44	; 0x2c
1000f090:	e1a00002 	mov	r0, r2
1000f094:	e3a01000 	mov	r1, #0
1000f098:	e1a02003 	mov	r2, r3
1000f09c:	ebffe9da 	bl	1000980c <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
1000f0a0:	e51b3010 	ldr	r3, [fp, #-16]
1000f0a4:	e2833048 	add	r3, r3, #72	; 0x48
1000f0a8:	e1a00003 	mov	r0, r3
1000f0ac:	ebffe8e0 	bl	10009434 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
1000f0b0:	e51b3008 	ldr	r3, [fp, #-8]
1000f0b4:	e1a00003 	mov	r0, r3
1000f0b8:	ebfff103 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
1000f0bc:	ebffe3d2 	bl	1000800c <rt_schedule>

        /* thread is waked up */
        result = thread->error;
1000f0c0:	e51b3010 	ldr	r3, [fp, #-16]
1000f0c4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000f0c8:	e50b300c 	str	r3, [fp, #-12]
        level = rt_hw_interrupt_disable();
1000f0cc:	ebfff0fa 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f0d0:	e1a03000 	mov	r3, r0
1000f0d4:	e50b3008 	str	r3, [fp, #-8]
        if (result != RT_EOK) goto __exit;
1000f0d8:	e51b300c 	ldr	r3, [fp, #-12]
1000f0dc:	e3530000 	cmp	r3, #0
1000f0e0:	0a000000 	beq	1000f0e8 <rt_data_queue_push+0x180>
1000f0e4:	ea000038 	b	1000f1cc <rt_data_queue_push+0x264>
    result = RT_EOK;
    thread = rt_thread_self();
    mask = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->put_index - queue->get_index == queue->size)
1000f0e8:	e51b3020 	ldr	r3, [fp, #-32]
1000f0ec:	e1d330ba 	ldrh	r3, [r3, #10]
1000f0f0:	e1a02003 	mov	r2, r3
1000f0f4:	e51b3020 	ldr	r3, [fp, #-32]
1000f0f8:	e1d330b8 	ldrh	r3, [r3, #8]
1000f0fc:	e0633002 	rsb	r3, r3, r2
1000f100:	e51b2020 	ldr	r2, [fp, #-32]
1000f104:	e1d220b0 	ldrh	r2, [r2]
1000f108:	e1530002 	cmp	r3, r2
1000f10c:	0affffb1 	beq	1000efd8 <rt_data_queue_push+0x70>
        result = thread->error;
        level = rt_hw_interrupt_disable();
        if (result != RT_EOK) goto __exit;
    }

    queue->queue[queue->put_index & mask].data_ptr  = data_ptr;
1000f110:	e51b3020 	ldr	r3, [fp, #-32]
1000f114:	e593200c 	ldr	r2, [r3, #12]
1000f118:	e51b3020 	ldr	r3, [fp, #-32]
1000f11c:	e1d310ba 	ldrh	r1, [r3, #10]
1000f120:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
1000f124:	e0033001 	and	r3, r3, r1
1000f128:	e6ff3073 	uxth	r3, r3
1000f12c:	e1a03183 	lsl	r3, r3, #3
1000f130:	e0823003 	add	r3, r2, r3
1000f134:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1000f138:	e5832000 	str	r2, [r3]
    queue->queue[queue->put_index & mask].data_size = data_size;
1000f13c:	e51b3020 	ldr	r3, [fp, #-32]
1000f140:	e593200c 	ldr	r2, [r3, #12]
1000f144:	e51b3020 	ldr	r3, [fp, #-32]
1000f148:	e1d310ba 	ldrh	r1, [r3, #10]
1000f14c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
1000f150:	e0033001 	and	r3, r3, r1
1000f154:	e6ff3073 	uxth	r3, r3
1000f158:	e1a03183 	lsl	r3, r3, #3
1000f15c:	e0823003 	add	r3, r2, r3
1000f160:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1000f164:	e5832004 	str	r2, [r3, #4]
    queue->put_index += 1;
1000f168:	e51b3020 	ldr	r3, [fp, #-32]
1000f16c:	e1d330ba 	ldrh	r3, [r3, #10]
1000f170:	e2833001 	add	r3, r3, #1
1000f174:	e6ff2073 	uxth	r2, r3
1000f178:	e51b3020 	ldr	r3, [fp, #-32]
1000f17c:	e1c320ba 	strh	r2, [r3, #10]

    if (!rt_list_isempty(&(queue->suspended_pop_list)))
1000f180:	e51b3020 	ldr	r3, [fp, #-32]
1000f184:	e2833018 	add	r3, r3, #24
1000f188:	e1a00003 	mov	r0, r3
1000f18c:	ebffff2b 	bl	1000ee40 <rt_list_isempty>
1000f190:	e1a03000 	mov	r3, r0
1000f194:	e3530000 	cmp	r3, #0
1000f198:	1a00000b 	bne	1000f1cc <rt_data_queue_push+0x264>
    {
        /* there is at least one thread in suspended list */

        /* get thread entry */
        thread = rt_list_entry(queue->suspended_pop_list.next,
1000f19c:	e51b3020 	ldr	r3, [fp, #-32]
1000f1a0:	e5933018 	ldr	r3, [r3, #24]
1000f1a4:	e2433010 	sub	r3, r3, #16
1000f1a8:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);

        /* resume it */
        rt_thread_resume(thread);
1000f1ac:	e51b0010 	ldr	r0, [fp, #-16]
1000f1b0:	ebffe70a 	bl	10008de0 <rt_thread_resume>
        rt_hw_interrupt_enable(level);
1000f1b4:	e51b3008 	ldr	r3, [fp, #-8]
1000f1b8:	e1a00003 	mov	r0, r3
1000f1bc:	ebfff0c2 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* perform a schedule */
        rt_schedule();
1000f1c0:	ebffe391 	bl	1000800c <rt_schedule>

        return result;
1000f1c4:	e51b300c 	ldr	r3, [fp, #-12]
1000f1c8:	ea00000f 	b	1000f20c <rt_data_queue_push+0x2a4>
    }

__exit:
    rt_hw_interrupt_enable(level);
1000f1cc:	e51b3008 	ldr	r3, [fp, #-8]
1000f1d0:	e1a00003 	mov	r0, r3
1000f1d4:	ebfff0bc 	bl	1000b4cc <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
1000f1d8:	e51b300c 	ldr	r3, [fp, #-12]
1000f1dc:	e3530000 	cmp	r3, #0
1000f1e0:	1a000008 	bne	1000f208 <rt_data_queue_push+0x2a0>
1000f1e4:	e51b3020 	ldr	r3, [fp, #-32]
1000f1e8:	e5933020 	ldr	r3, [r3, #32]
1000f1ec:	e3530000 	cmp	r3, #0
1000f1f0:	0a000004 	beq	1000f208 <rt_data_queue_push+0x2a0>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
1000f1f4:	e51b3020 	ldr	r3, [fp, #-32]
1000f1f8:	e5933020 	ldr	r3, [r3, #32]
1000f1fc:	e51b0020 	ldr	r0, [fp, #-32]
1000f200:	e3a01002 	mov	r1, #2
1000f204:	e12fff33 	blx	r3
    }

    return result;
1000f208:	e51b300c 	ldr	r3, [fp, #-12]
}
1000f20c:	e1a00003 	mov	r0, r3
1000f210:	e24bd004 	sub	sp, fp, #4
1000f214:	e8bd8800 	pop	{fp, pc}

1000f218 <rt_data_queue_pop>:

rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
                           const void** data_ptr,
                           rt_size_t *size, 
                           rt_int32_t timeout)
{
1000f218:	e92d4800 	push	{fp, lr}
1000f21c:	e28db004 	add	fp, sp, #4
1000f220:	e24dd028 	sub	sp, sp, #40	; 0x28
1000f224:	e50b0020 	str	r0, [fp, #-32]
1000f228:	e50b1024 	str	r1, [fp, #-36]	; 0x24
1000f22c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
1000f230:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    rt_ubase_t  level;
    rt_thread_t thread;
    rt_err_t    result;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
1000f234:	e51b3020 	ldr	r3, [fp, #-32]
1000f238:	e3530000 	cmp	r3, #0
1000f23c:	1a000005 	bne	1000f258 <rt_data_queue_pop+0x40>
1000f240:	e30f06c8 	movw	r0, #63176	; 0xf6c8
1000f244:	e3410001 	movt	r0, #4097	; 0x1001
1000f248:	e30f1750 	movw	r1, #63312	; 0xf750
1000f24c:	e3411001 	movt	r1, #4097	; 0x1001
1000f250:	e3a020a9 	mov	r2, #169	; 0xa9
1000f254:	ebffdcdb 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(data_ptr != RT_NULL);
1000f258:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000f25c:	e3530000 	cmp	r3, #0
1000f260:	1a000005 	bne	1000f27c <rt_data_queue_pop+0x64>
1000f264:	e30f0704 	movw	r0, #63236	; 0xf704
1000f268:	e3410001 	movt	r0, #4097	; 0x1001
1000f26c:	e30f1750 	movw	r1, #63312	; 0xf750
1000f270:	e3411001 	movt	r1, #4097	; 0x1001
1000f274:	e3a020aa 	mov	r2, #170	; 0xaa
1000f278:	ebffdcd2 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(size != RT_NULL);
1000f27c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000f280:	e3530000 	cmp	r3, #0
1000f284:	1a000005 	bne	1000f2a0 <rt_data_queue_pop+0x88>
1000f288:	e30f0718 	movw	r0, #63256	; 0xf718
1000f28c:	e3410001 	movt	r0, #4097	; 0x1001
1000f290:	e30f1750 	movw	r1, #63312	; 0xf750
1000f294:	e3411001 	movt	r1, #4097	; 0x1001
1000f298:	e3a020ab 	mov	r2, #171	; 0xab
1000f29c:	ebffdcc9 	bl	100065c8 <rt_assert_handler>

    result = RT_EOK;
1000f2a0:	e3a03000 	mov	r3, #0
1000f2a4:	e50b300c 	str	r3, [fp, #-12]
    thread = rt_thread_self();
1000f2a8:	ebffe546 	bl	100087c8 <rt_thread_self>
1000f2ac:	e50b0010 	str	r0, [fp, #-16]
    mask   = queue->size - 1;
1000f2b0:	e51b3020 	ldr	r3, [fp, #-32]
1000f2b4:	e1d330b0 	ldrh	r3, [r3]
1000f2b8:	e2433001 	sub	r3, r3, #1
1000f2bc:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

    level = rt_hw_interrupt_disable();
1000f2c0:	ebfff07d 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f2c4:	e1a03000 	mov	r3, r0
1000f2c8:	e50b3008 	str	r3, [fp, #-8]
    while (queue->get_index == queue->put_index)
1000f2cc:	ea000040 	b	1000f3d4 <rt_data_queue_pop+0x1bc>
    {
        /* queue is empty */
        if (timeout == 0)
1000f2d0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1000f2d4:	e3530000 	cmp	r3, #0
1000f2d8:	1a000002 	bne	1000f2e8 <rt_data_queue_pop+0xd0>
        {
            result = -RT_ETIMEOUT;
1000f2dc:	e3e03001 	mvn	r3, #1
1000f2e0:	e50b300c 	str	r3, [fp, #-12]
            goto __exit;
1000f2e4:	ea00008b 	b	1000f518 <rt_data_queue_pop+0x300>
        }

        /* current context checking */
        RT_DEBUG_NOT_IN_INTERRUPT;
1000f2e8:	ebfff073 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f2ec:	e50b0018 	str	r0, [fp, #-24]
1000f2f0:	ebffd5b2 	bl	100049c0 <rt_interrupt_get_nest>
1000f2f4:	e1a03000 	mov	r3, r0
1000f2f8:	e3530000 	cmp	r3, #0
1000f2fc:	0a00000a 	beq	1000f32c <rt_data_queue_pop+0x114>
1000f300:	e30f06dc 	movw	r0, #63196	; 0xf6dc
1000f304:	e3410001 	movt	r0, #4097	; 0x1001
1000f308:	e30f1750 	movw	r1, #63312	; 0xf750
1000f30c:	e3411001 	movt	r1, #4097	; 0x1001
1000f310:	ebffdbef 	bl	100062d4 <rt_kprintf>
1000f314:	e30f0700 	movw	r0, #63232	; 0xf700
1000f318:	e3410001 	movt	r0, #4097	; 0x1001
1000f31c:	e30f1750 	movw	r1, #63312	; 0xf750
1000f320:	e3411001 	movt	r1, #4097	; 0x1001
1000f324:	e3a020bc 	mov	r2, #188	; 0xbc
1000f328:	ebffdca6 	bl	100065c8 <rt_assert_handler>
1000f32c:	e51b0018 	ldr	r0, [fp, #-24]
1000f330:	ebfff065 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* reset thread error number */
        thread->error = RT_EOK;
1000f334:	e51b3010 	ldr	r3, [fp, #-16]
1000f338:	e3a02000 	mov	r2, #0
1000f33c:	e583202c 	str	r2, [r3, #44]	; 0x2c
        
        /* suspend thread on the pop list */
        rt_thread_suspend(thread);
1000f340:	e51b0010 	ldr	r0, [fp, #-16]
1000f344:	ebffe681 	bl	10008d50 <rt_thread_suspend>
        rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
1000f348:	e51b3020 	ldr	r3, [fp, #-32]
1000f34c:	e2832018 	add	r2, r3, #24
1000f350:	e51b3010 	ldr	r3, [fp, #-16]
1000f354:	e2833010 	add	r3, r3, #16
1000f358:	e1a00002 	mov	r0, r2
1000f35c:	e1a01003 	mov	r1, r3
1000f360:	ebfffea0 	bl	1000ede8 <rt_list_insert_before>
        /* start timer */
        if (timeout > 0)
1000f364:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
1000f368:	e3530000 	cmp	r3, #0
1000f36c:	da00000a 	ble	1000f39c <rt_data_queue_pop+0x184>
        {
            /* reset the timeout of thread timer and start it */
            rt_timer_control(&(thread->thread_timer),
1000f370:	e51b3010 	ldr	r3, [fp, #-16]
1000f374:	e2832048 	add	r2, r3, #72	; 0x48
1000f378:	e24b302c 	sub	r3, fp, #44	; 0x2c
1000f37c:	e1a00002 	mov	r0, r2
1000f380:	e3a01000 	mov	r1, #0
1000f384:	e1a02003 	mov	r2, r3
1000f388:	ebffe91f 	bl	1000980c <rt_timer_control>
                             RT_TIMER_CTRL_SET_TIME,
                             &timeout);
            rt_timer_start(&(thread->thread_timer));
1000f38c:	e51b3010 	ldr	r3, [fp, #-16]
1000f390:	e2833048 	add	r3, r3, #72	; 0x48
1000f394:	e1a00003 	mov	r0, r3
1000f398:	ebffe825 	bl	10009434 <rt_timer_start>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
1000f39c:	e51b3008 	ldr	r3, [fp, #-8]
1000f3a0:	e1a00003 	mov	r0, r3
1000f3a4:	ebfff048 	bl	1000b4cc <rt_hw_interrupt_enable>

        /* do schedule */
        rt_schedule();
1000f3a8:	ebffe317 	bl	1000800c <rt_schedule>

        /* thread is waked up */
        result = thread->error;
1000f3ac:	e51b3010 	ldr	r3, [fp, #-16]
1000f3b0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1000f3b4:	e50b300c 	str	r3, [fp, #-12]
        level  = rt_hw_interrupt_disable();
1000f3b8:	ebfff03f 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f3bc:	e1a03000 	mov	r3, r0
1000f3c0:	e50b3008 	str	r3, [fp, #-8]
        if (result != RT_EOK)
1000f3c4:	e51b300c 	ldr	r3, [fp, #-12]
1000f3c8:	e3530000 	cmp	r3, #0
1000f3cc:	0a000000 	beq	1000f3d4 <rt_data_queue_pop+0x1bc>
            goto __exit;
1000f3d0:	ea000050 	b	1000f518 <rt_data_queue_pop+0x300>
    result = RT_EOK;
    thread = rt_thread_self();
    mask   = queue->size - 1;

    level = rt_hw_interrupt_disable();
    while (queue->get_index == queue->put_index)
1000f3d4:	e51b3020 	ldr	r3, [fp, #-32]
1000f3d8:	e1d320b8 	ldrh	r2, [r3, #8]
1000f3dc:	e51b3020 	ldr	r3, [fp, #-32]
1000f3e0:	e1d330ba 	ldrh	r3, [r3, #10]
1000f3e4:	e1520003 	cmp	r2, r3
1000f3e8:	0affffb8 	beq	1000f2d0 <rt_data_queue_pop+0xb8>
        level  = rt_hw_interrupt_disable();
        if (result != RT_EOK)
            goto __exit;
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
1000f3ec:	e51b3020 	ldr	r3, [fp, #-32]
1000f3f0:	e593200c 	ldr	r2, [r3, #12]
1000f3f4:	e51b3020 	ldr	r3, [fp, #-32]
1000f3f8:	e1d310b8 	ldrh	r1, [r3, #8]
1000f3fc:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
1000f400:	e0033001 	and	r3, r3, r1
1000f404:	e6ff3073 	uxth	r3, r3
1000f408:	e1a03183 	lsl	r3, r3, #3
1000f40c:	e0823003 	add	r3, r2, r3
1000f410:	e5932000 	ldr	r2, [r3]
1000f414:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1000f418:	e5832000 	str	r2, [r3]
    *size     = queue->queue[queue->get_index & mask].data_size;
1000f41c:	e51b3020 	ldr	r3, [fp, #-32]
1000f420:	e593200c 	ldr	r2, [r3, #12]
1000f424:	e51b3020 	ldr	r3, [fp, #-32]
1000f428:	e1d310b8 	ldrh	r1, [r3, #8]
1000f42c:	e15b31b2 	ldrh	r3, [fp, #-18]	; 0xffffffee
1000f430:	e0033001 	and	r3, r3, r1
1000f434:	e6ff3073 	uxth	r3, r3
1000f438:	e1a03183 	lsl	r3, r3, #3
1000f43c:	e0823003 	add	r3, r2, r3
1000f440:	e5932004 	ldr	r2, [r3, #4]
1000f444:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1000f448:	e5832000 	str	r2, [r3]

    queue->get_index += 1;
1000f44c:	e51b3020 	ldr	r3, [fp, #-32]
1000f450:	e1d330b8 	ldrh	r3, [r3, #8]
1000f454:	e2833001 	add	r3, r3, #1
1000f458:	e6ff2073 	uxth	r2, r3
1000f45c:	e51b3020 	ldr	r3, [fp, #-32]
1000f460:	e1c320b8 	strh	r2, [r3, #8]

    if ((queue->waiting_lwm == RT_TRUE) && 
1000f464:	e51b3020 	ldr	r3, [fp, #-32]
1000f468:	e5933004 	ldr	r3, [r3, #4]
1000f46c:	e3530001 	cmp	r3, #1
1000f470:	1a000028 	bne	1000f518 <rt_data_queue_pop+0x300>
        (queue->put_index - queue->get_index) <= queue->lwm)
1000f474:	e51b3020 	ldr	r3, [fp, #-32]
1000f478:	e1d330ba 	ldrh	r3, [r3, #10]
1000f47c:	e1a02003 	mov	r2, r3
1000f480:	e51b3020 	ldr	r3, [fp, #-32]
1000f484:	e1d330b8 	ldrh	r3, [r3, #8]
1000f488:	e0633002 	rsb	r3, r3, r2
1000f48c:	e51b2020 	ldr	r2, [fp, #-32]
1000f490:	e1d220b2 	ldrh	r2, [r2, #2]
    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
    *size     = queue->queue[queue->get_index & mask].data_size;

    queue->get_index += 1;

    if ((queue->waiting_lwm == RT_TRUE) && 
1000f494:	e1530002 	cmp	r3, r2
1000f498:	ca00001e 	bgt	1000f518 <rt_data_queue_pop+0x300>
        (queue->put_index - queue->get_index) <= queue->lwm)
    {
        queue->waiting_lwm = RT_FALSE;
1000f49c:	e51b3020 	ldr	r3, [fp, #-32]
1000f4a0:	e3a02000 	mov	r2, #0
1000f4a4:	e5832004 	str	r2, [r3, #4]

        /*
         * there is at least one thread in suspended list
         * and less than low water mark
         */
        if (!rt_list_isempty(&(queue->suspended_push_list)))
1000f4a8:	e51b3020 	ldr	r3, [fp, #-32]
1000f4ac:	e2833010 	add	r3, r3, #16
1000f4b0:	e1a00003 	mov	r0, r3
1000f4b4:	ebfffe61 	bl	1000ee40 <rt_list_isempty>
1000f4b8:	e1a03000 	mov	r3, r0
1000f4bc:	e3530000 	cmp	r3, #0
1000f4c0:	1a000009 	bne	1000f4ec <rt_data_queue_pop+0x2d4>
        {
            /* get thread entry */
            thread = rt_list_entry(queue->suspended_push_list.next,
1000f4c4:	e51b3020 	ldr	r3, [fp, #-32]
1000f4c8:	e5933010 	ldr	r3, [r3, #16]
1000f4cc:	e2433010 	sub	r3, r3, #16
1000f4d0:	e50b3010 	str	r3, [fp, #-16]
                                   struct rt_thread,
                                   tlist);

            /* resume it */
            rt_thread_resume(thread);
1000f4d4:	e51b0010 	ldr	r0, [fp, #-16]
1000f4d8:	ebffe640 	bl	10008de0 <rt_thread_resume>
            rt_hw_interrupt_enable(level);
1000f4dc:	e51b3008 	ldr	r3, [fp, #-8]
1000f4e0:	e1a00003 	mov	r0, r3
1000f4e4:	ebffeff8 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* perform a schedule */
            rt_schedule();
1000f4e8:	ebffe2c7 	bl	1000800c <rt_schedule>
        }

        if (queue->evt_notify != RT_NULL)
1000f4ec:	e51b3020 	ldr	r3, [fp, #-32]
1000f4f0:	e5933020 	ldr	r3, [r3, #32]
1000f4f4:	e3530000 	cmp	r3, #0
1000f4f8:	0a000004 	beq	1000f510 <rt_data_queue_pop+0x2f8>
            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
1000f4fc:	e51b3020 	ldr	r3, [fp, #-32]
1000f500:	e5933020 	ldr	r3, [r3, #32]
1000f504:	e51b0020 	ldr	r0, [fp, #-32]
1000f508:	e3a01003 	mov	r1, #3
1000f50c:	e12fff33 	blx	r3

        return result;
1000f510:	e51b300c 	ldr	r3, [fp, #-12]
1000f514:	ea00000f 	b	1000f558 <rt_data_queue_pop+0x340>
    }

__exit:
    rt_hw_interrupt_enable(level);
1000f518:	e51b3008 	ldr	r3, [fp, #-8]
1000f51c:	e1a00003 	mov	r0, r3
1000f520:	ebffefe9 	bl	1000b4cc <rt_hw_interrupt_enable>
    if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
1000f524:	e51b300c 	ldr	r3, [fp, #-12]
1000f528:	e3530000 	cmp	r3, #0
1000f52c:	1a000008 	bne	1000f554 <rt_data_queue_pop+0x33c>
1000f530:	e51b3020 	ldr	r3, [fp, #-32]
1000f534:	e5933020 	ldr	r3, [r3, #32]
1000f538:	e3530000 	cmp	r3, #0
1000f53c:	0a000004 	beq	1000f554 <rt_data_queue_pop+0x33c>
    {
        queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
1000f540:	e51b3020 	ldr	r3, [fp, #-32]
1000f544:	e5933020 	ldr	r3, [r3, #32]
1000f548:	e51b0020 	ldr	r0, [fp, #-32]
1000f54c:	e3a01001 	mov	r1, #1
1000f550:	e12fff33 	blx	r3
    }

    return result;
1000f554:	e51b300c 	ldr	r3, [fp, #-12]
}
1000f558:	e1a00003 	mov	r0, r3
1000f55c:	e24bd004 	sub	sp, fp, #4
1000f560:	e8bd8800 	pop	{fp, pc}

1000f564 <rt_data_queue_peak>:
RTM_EXPORT(rt_data_queue_pop);

rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
                            const void** data_ptr,
                            rt_size_t *size)
{
1000f564:	e92d4800 	push	{fp, lr}
1000f568:	e28db004 	add	fp, sp, #4
1000f56c:	e24dd018 	sub	sp, sp, #24
1000f570:	e50b0010 	str	r0, [fp, #-16]
1000f574:	e50b1014 	str	r1, [fp, #-20]
1000f578:	e50b2018 	str	r2, [fp, #-24]
    rt_ubase_t  level;
    rt_uint16_t mask;

    RT_ASSERT(queue != RT_NULL);
1000f57c:	e51b3010 	ldr	r3, [fp, #-16]
1000f580:	e3530000 	cmp	r3, #0
1000f584:	1a000005 	bne	1000f5a0 <rt_data_queue_peak+0x3c>
1000f588:	e30f06c8 	movw	r0, #63176	; 0xf6c8
1000f58c:	e3410001 	movt	r0, #4097	; 0x1001
1000f590:	e30f1764 	movw	r1, #63332	; 0xf764
1000f594:	e3411001 	movt	r1, #4097	; 0x1001
1000f598:	e3a02e11 	mov	r2, #272	; 0x110
1000f59c:	ebffdc09 	bl	100065c8 <rt_assert_handler>

    mask = queue->size - 1;
1000f5a0:	e51b3010 	ldr	r3, [fp, #-16]
1000f5a4:	e1d330b0 	ldrh	r3, [r3]
1000f5a8:	e2433001 	sub	r3, r3, #1
1000f5ac:	e14b30b6 	strh	r3, [fp, #-6]

    level = rt_hw_interrupt_disable();
1000f5b0:	ebffefc1 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f5b4:	e1a03000 	mov	r3, r0
1000f5b8:	e50b300c 	str	r3, [fp, #-12]

    if (queue->get_index == queue->put_index) 
1000f5bc:	e51b3010 	ldr	r3, [fp, #-16]
1000f5c0:	e1d320b8 	ldrh	r2, [r3, #8]
1000f5c4:	e51b3010 	ldr	r3, [fp, #-16]
1000f5c8:	e1d330ba 	ldrh	r3, [r3, #10]
1000f5cc:	e1520003 	cmp	r2, r3
1000f5d0:	1a000004 	bne	1000f5e8 <rt_data_queue_peak+0x84>
    {
        rt_hw_interrupt_enable(level);
1000f5d4:	e51b300c 	ldr	r3, [fp, #-12]
1000f5d8:	e1a00003 	mov	r0, r3
1000f5dc:	ebffefba 	bl	1000b4cc <rt_hw_interrupt_enable>
        
        return -RT_EEMPTY;
1000f5e0:	e3e03003 	mvn	r3, #3
1000f5e4:	ea00001b 	b	1000f658 <rt_data_queue_peak+0xf4>
    }

    *data_ptr = queue->queue[queue->get_index & mask].data_ptr;
1000f5e8:	e51b3010 	ldr	r3, [fp, #-16]
1000f5ec:	e593200c 	ldr	r2, [r3, #12]
1000f5f0:	e51b3010 	ldr	r3, [fp, #-16]
1000f5f4:	e1d310b8 	ldrh	r1, [r3, #8]
1000f5f8:	e15b30b6 	ldrh	r3, [fp, #-6]
1000f5fc:	e0033001 	and	r3, r3, r1
1000f600:	e6ff3073 	uxth	r3, r3
1000f604:	e1a03183 	lsl	r3, r3, #3
1000f608:	e0823003 	add	r3, r2, r3
1000f60c:	e5932000 	ldr	r2, [r3]
1000f610:	e51b3014 	ldr	r3, [fp, #-20]
1000f614:	e5832000 	str	r2, [r3]
    *size     = queue->queue[queue->get_index & mask].data_size;
1000f618:	e51b3010 	ldr	r3, [fp, #-16]
1000f61c:	e593200c 	ldr	r2, [r3, #12]
1000f620:	e51b3010 	ldr	r3, [fp, #-16]
1000f624:	e1d310b8 	ldrh	r1, [r3, #8]
1000f628:	e15b30b6 	ldrh	r3, [fp, #-6]
1000f62c:	e0033001 	and	r3, r3, r1
1000f630:	e6ff3073 	uxth	r3, r3
1000f634:	e1a03183 	lsl	r3, r3, #3
1000f638:	e0823003 	add	r3, r2, r3
1000f63c:	e5932004 	ldr	r2, [r3, #4]
1000f640:	e51b3018 	ldr	r3, [fp, #-24]
1000f644:	e5832000 	str	r2, [r3]

    rt_hw_interrupt_enable(level);
1000f648:	e51b300c 	ldr	r3, [fp, #-12]
1000f64c:	e1a00003 	mov	r0, r3
1000f650:	ebffef9d 	bl	1000b4cc <rt_hw_interrupt_enable>

    return RT_EOK;
1000f654:	e3a03000 	mov	r3, #0
}
1000f658:	e1a00003 	mov	r0, r3
1000f65c:	e24bd004 	sub	sp, fp, #4
1000f660:	e8bd8800 	pop	{fp, pc}

1000f664 <rt_data_queue_reset>:
RTM_EXPORT(rt_data_queue_peak);

void rt_data_queue_reset(struct rt_data_queue *queue)
{
1000f664:	e92d4810 	push	{r4, fp, lr}
1000f668:	e28db008 	add	fp, sp, #8
1000f66c:	e24dd014 	sub	sp, sp, #20
1000f670:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    register rt_ubase_t temp;

    rt_enter_critical();
1000f674:	ebffe30b 	bl	100082a8 <rt_enter_critical>
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
1000f678:	ea00000e 	b	1000f6b8 <rt_data_queue_reset+0x54>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
1000f67c:	ebffef8e 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f680:	e1a03000 	mov	r3, r0
1000f684:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_pop_list.next,
1000f688:	e51b3018 	ldr	r3, [fp, #-24]
1000f68c:	e5933018 	ldr	r3, [r3, #24]
1000f690:	e2433010 	sub	r3, r3, #16
1000f694:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
1000f698:	e51b3010 	ldr	r3, [fp, #-16]
1000f69c:	e3e02000 	mvn	r2, #0
1000f6a0:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
1000f6a4:	e51b0010 	ldr	r0, [fp, #-16]
1000f6a8:	ebffe5cc 	bl	10008de0 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1000f6ac:	e1a03004 	mov	r3, r4
1000f6b0:	e1a00003 	mov	r0, r3
1000f6b4:	ebffef84 	bl	1000b4cc <rt_hw_interrupt_enable>

    rt_enter_critical();
    /* wakeup all suspend threads */

    /* resume on pop list */
    while (!rt_list_isempty(&(queue->suspended_pop_list)))
1000f6b8:	e51b3018 	ldr	r3, [fp, #-24]
1000f6bc:	e2833018 	add	r3, r3, #24
1000f6c0:	e1a00003 	mov	r0, r3
1000f6c4:	ebfffddd 	bl	1000ee40 <rt_list_isempty>
1000f6c8:	e1a03000 	mov	r3, r0
1000f6cc:	e3530000 	cmp	r3, #0
1000f6d0:	0affffe9 	beq	1000f67c <rt_data_queue_reset+0x18>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
1000f6d4:	ea00000e 	b	1000f714 <rt_data_queue_reset+0xb0>
    {
        /* disable interrupt */
        temp = rt_hw_interrupt_disable();
1000f6d8:	ebffef77 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f6dc:	e1a03000 	mov	r3, r0
1000f6e0:	e1a04003 	mov	r4, r3

        /* get next suspend thread */
        thread = rt_list_entry(queue->suspended_push_list.next,
1000f6e4:	e51b3018 	ldr	r3, [fp, #-24]
1000f6e8:	e5933010 	ldr	r3, [r3, #16]
1000f6ec:	e2433010 	sub	r3, r3, #16
1000f6f0:	e50b3010 	str	r3, [fp, #-16]
                               struct rt_thread,
                               tlist);
        /* set error code to RT_ERROR */
        thread->error = -RT_ERROR;
1000f6f4:	e51b3010 	ldr	r3, [fp, #-16]
1000f6f8:	e3e02000 	mvn	r2, #0
1000f6fc:	e583202c 	str	r2, [r3, #44]	; 0x2c
        /*
         * resume thread
         * In rt_thread_resume function, it will remove current thread from
         * suspend list
         */
        rt_thread_resume(thread);
1000f700:	e51b0010 	ldr	r0, [fp, #-16]
1000f704:	ebffe5b5 	bl	10008de0 <rt_thread_resume>

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
1000f708:	e1a03004 	mov	r3, r4
1000f70c:	e1a00003 	mov	r0, r3
1000f710:	ebffef6d 	bl	1000b4cc <rt_hw_interrupt_enable>
        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }

    /* resume on push list */
    while (!rt_list_isempty(&(queue->suspended_push_list)))
1000f714:	e51b3018 	ldr	r3, [fp, #-24]
1000f718:	e2833010 	add	r3, r3, #16
1000f71c:	e1a00003 	mov	r0, r3
1000f720:	ebfffdc6 	bl	1000ee40 <rt_list_isempty>
1000f724:	e1a03000 	mov	r3, r0
1000f728:	e3530000 	cmp	r3, #0
1000f72c:	0affffe9 	beq	1000f6d8 <rt_data_queue_reset+0x74>
        rt_thread_resume(thread);

        /* enable interrupt */
        rt_hw_interrupt_enable(temp);
    }
    rt_exit_critical();
1000f730:	ebffe2ee 	bl	100082f0 <rt_exit_critical>

    rt_schedule();
1000f734:	ebffe234 	bl	1000800c <rt_schedule>
}
1000f738:	e24bd008 	sub	sp, fp, #8
1000f73c:	e8bd8810 	pop	{r4, fp, pc}

1000f740 <_serial_poll_rx>:

/*
 * Serial poll routines 
 */
rt_inline int _serial_poll_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
1000f740:	e92d4800 	push	{fp, lr}
1000f744:	e28db004 	add	fp, sp, #4
1000f748:	e24dd018 	sub	sp, sp, #24
1000f74c:	e50b0010 	str	r0, [fp, #-16]
1000f750:	e50b1014 	str	r1, [fp, #-20]
1000f754:	e50b2018 	str	r2, [fp, #-24]
    int ch;
    int size;
    
    RT_ASSERT(serial != RT_NULL);
1000f758:	e51b3010 	ldr	r3, [fp, #-16]
1000f75c:	e3530000 	cmp	r3, #0
1000f760:	1a000005 	bne	1000f77c <_serial_poll_rx+0x3c>
1000f764:	e30f0778 	movw	r0, #63352	; 0xf778
1000f768:	e3410001 	movt	r0, #4097	; 0x1001
1000f76c:	e30f18c4 	movw	r1, #63684	; 0xf8c4
1000f770:	e3411001 	movt	r1, #4097	; 0x1001
1000f774:	e3a0202e 	mov	r2, #46	; 0x2e
1000f778:	ebffdb92 	bl	100065c8 <rt_assert_handler>
    size = length;
1000f77c:	e51b3018 	ldr	r3, [fp, #-24]
1000f780:	e50b3008 	str	r3, [fp, #-8]

    while (length)
1000f784:	ea000013 	b	1000f7d8 <_serial_poll_rx+0x98>
    {
        ch = serial->ops->getc(serial);
1000f788:	e51b3010 	ldr	r3, [fp, #-16]
1000f78c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000f790:	e593300c 	ldr	r3, [r3, #12]
1000f794:	e51b0010 	ldr	r0, [fp, #-16]
1000f798:	e12fff33 	blx	r3
1000f79c:	e50b000c 	str	r0, [fp, #-12]
        *data = ch; 
1000f7a0:	e51b300c 	ldr	r3, [fp, #-12]
1000f7a4:	e6ef2073 	uxtb	r2, r3
1000f7a8:	e51b3014 	ldr	r3, [fp, #-20]
1000f7ac:	e5c32000 	strb	r2, [r3]
        data ++; length --;
1000f7b0:	e51b3014 	ldr	r3, [fp, #-20]
1000f7b4:	e2833001 	add	r3, r3, #1
1000f7b8:	e50b3014 	str	r3, [fp, #-20]
1000f7bc:	e51b3018 	ldr	r3, [fp, #-24]
1000f7c0:	e2433001 	sub	r3, r3, #1
1000f7c4:	e50b3018 	str	r3, [fp, #-24]

        if (ch == '\n') break;
1000f7c8:	e51b300c 	ldr	r3, [fp, #-12]
1000f7cc:	e353000a 	cmp	r3, #10
1000f7d0:	1a000000 	bne	1000f7d8 <_serial_poll_rx+0x98>
1000f7d4:	ea000002 	b	1000f7e4 <_serial_poll_rx+0xa4>
    int size;
    
    RT_ASSERT(serial != RT_NULL);
    size = length;

    while (length)
1000f7d8:	e51b3018 	ldr	r3, [fp, #-24]
1000f7dc:	e3530000 	cmp	r3, #0
1000f7e0:	1affffe8 	bne	1000f788 <_serial_poll_rx+0x48>
        data ++; length --;

        if (ch == '\n') break;
    }

    return size - length;
1000f7e4:	e51b2008 	ldr	r2, [fp, #-8]
1000f7e8:	e51b3018 	ldr	r3, [fp, #-24]
1000f7ec:	e0633002 	rsb	r3, r3, r2
}
1000f7f0:	e1a00003 	mov	r0, r3
1000f7f4:	e24bd004 	sub	sp, fp, #4
1000f7f8:	e8bd8800 	pop	{fp, pc}

1000f7fc <_serial_poll_tx>:

rt_inline int _serial_poll_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
1000f7fc:	e92d4800 	push	{fp, lr}
1000f800:	e28db004 	add	fp, sp, #4
1000f804:	e24dd018 	sub	sp, sp, #24
1000f808:	e50b0010 	str	r0, [fp, #-16]
1000f80c:	e50b1014 	str	r1, [fp, #-20]
1000f810:	e50b2018 	str	r2, [fp, #-24]
    int size;
    RT_ASSERT(serial != RT_NULL);
1000f814:	e51b3010 	ldr	r3, [fp, #-16]
1000f818:	e3530000 	cmp	r3, #0
1000f81c:	1a000005 	bne	1000f838 <_serial_poll_tx+0x3c>
1000f820:	e30f0778 	movw	r0, #63352	; 0xf778
1000f824:	e3410001 	movt	r0, #4097	; 0x1001
1000f828:	e30f18f4 	movw	r1, #63732	; 0xf8f4
1000f82c:	e3411001 	movt	r1, #4097	; 0x1001
1000f830:	e3a02040 	mov	r2, #64	; 0x40
1000f834:	ebffdb63 	bl	100065c8 <rt_assert_handler>

    size = length;
1000f838:	e51b3018 	ldr	r3, [fp, #-24]
1000f83c:	e50b3008 	str	r3, [fp, #-8]
    while (length)
1000f840:	ea00001c 	b	1000f8b8 <_serial_poll_tx+0xbc>
    {
        /*
         * to be polite with serial console add a line feed
         * to the carriage return character
         */
        if (*data == '\n' && (serial->parent.open_flag & RT_DEVICE_FLAG_STREAM))
1000f844:	e51b3014 	ldr	r3, [fp, #-20]
1000f848:	e5d33000 	ldrb	r3, [r3]
1000f84c:	e353000a 	cmp	r3, #10
1000f850:	1a00000a 	bne	1000f880 <_serial_poll_tx+0x84>
1000f854:	e51b3010 	ldr	r3, [fp, #-16]
1000f858:	e1d331b4 	ldrh	r3, [r3, #20]
1000f85c:	e2033040 	and	r3, r3, #64	; 0x40
1000f860:	e3530000 	cmp	r3, #0
1000f864:	0a000005 	beq	1000f880 <_serial_poll_tx+0x84>
        {
            serial->ops->putc(serial, '\r');
1000f868:	e51b3010 	ldr	r3, [fp, #-16]
1000f86c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000f870:	e5933008 	ldr	r3, [r3, #8]
1000f874:	e51b0010 	ldr	r0, [fp, #-16]
1000f878:	e3a0100d 	mov	r1, #13
1000f87c:	e12fff33 	blx	r3
        }
    
        serial->ops->putc(serial, *data);
1000f880:	e51b3010 	ldr	r3, [fp, #-16]
1000f884:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000f888:	e5933008 	ldr	r3, [r3, #8]
1000f88c:	e51b2014 	ldr	r2, [fp, #-20]
1000f890:	e5d22000 	ldrb	r2, [r2]
1000f894:	e51b0010 	ldr	r0, [fp, #-16]
1000f898:	e1a01002 	mov	r1, r2
1000f89c:	e12fff33 	blx	r3
    
        ++ data;
1000f8a0:	e51b3014 	ldr	r3, [fp, #-20]
1000f8a4:	e2833001 	add	r3, r3, #1
1000f8a8:	e50b3014 	str	r3, [fp, #-20]
        -- length;
1000f8ac:	e51b3018 	ldr	r3, [fp, #-24]
1000f8b0:	e2433001 	sub	r3, r3, #1
1000f8b4:	e50b3018 	str	r3, [fp, #-24]
{
    int size;
    RT_ASSERT(serial != RT_NULL);

    size = length;
    while (length)
1000f8b8:	e51b3018 	ldr	r3, [fp, #-24]
1000f8bc:	e3530000 	cmp	r3, #0
1000f8c0:	1affffdf 	bne	1000f844 <_serial_poll_tx+0x48>
    
        ++ data;
        -- length;
    }

    return size - length;
1000f8c4:	e51b2008 	ldr	r2, [fp, #-8]
1000f8c8:	e51b3018 	ldr	r3, [fp, #-24]
1000f8cc:	e0633002 	rsb	r3, r3, r2
}
1000f8d0:	e1a00003 	mov	r0, r3
1000f8d4:	e24bd004 	sub	sp, fp, #4
1000f8d8:	e8bd8800 	pop	{fp, pc}

1000f8dc <_serial_int_rx>:

/*
 * Serial interrupt routines
 */
rt_inline int _serial_int_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
1000f8dc:	e92d4800 	push	{fp, lr}
1000f8e0:	e28db004 	add	fp, sp, #4
1000f8e4:	e24dd020 	sub	sp, sp, #32
1000f8e8:	e50b0018 	str	r0, [fp, #-24]
1000f8ec:	e50b101c 	str	r1, [fp, #-28]
1000f8f0:	e50b2020 	str	r2, [fp, #-32]
    int size;
    struct rt_serial_rx_fifo* rx_fifo;

    RT_ASSERT(serial != RT_NULL);
1000f8f4:	e51b3018 	ldr	r3, [fp, #-24]
1000f8f8:	e3530000 	cmp	r3, #0
1000f8fc:	1a000005 	bne	1000f918 <_serial_int_rx+0x3c>
1000f900:	e30f0778 	movw	r0, #63352	; 0xf778
1000f904:	e3410001 	movt	r0, #4097	; 0x1001
1000f908:	e30f18a4 	movw	r1, #63652	; 0xf8a4
1000f90c:	e3411001 	movt	r1, #4097	; 0x1001
1000f910:	e3a0205f 	mov	r2, #95	; 0x5f
1000f914:	ebffdb2b 	bl	100065c8 <rt_assert_handler>
    size = length; 
1000f918:	e51b3020 	ldr	r3, [fp, #-32]
1000f91c:	e50b3008 	str	r3, [fp, #-8]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
1000f920:	e51b3018 	ldr	r3, [fp, #-24]
1000f924:	e5933048 	ldr	r3, [r3, #72]	; 0x48
1000f928:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(rx_fifo != RT_NULL);
1000f92c:	e51b300c 	ldr	r3, [fp, #-12]
1000f930:	e3530000 	cmp	r3, #0
1000f934:	1a000005 	bne	1000f950 <_serial_int_rx+0x74>
1000f938:	e30f078c 	movw	r0, #63372	; 0xf78c
1000f93c:	e3410001 	movt	r0, #4097	; 0x1001
1000f940:	e30f18a4 	movw	r1, #63652	; 0xf8a4
1000f944:	e3411001 	movt	r1, #4097	; 0x1001
1000f948:	e3a02063 	mov	r2, #99	; 0x63
1000f94c:	ebffdb1d 	bl	100065c8 <rt_assert_handler>

    /* read from software FIFO */
    while (length)
1000f950:	ea00002f 	b	1000fa14 <_serial_int_rx+0x138>
    {
        int ch;
        rt_base_t level;

        /* disable interrupt */
        level = rt_hw_interrupt_disable();
1000f954:	ebffeed8 	bl	1000b4bc <rt_hw_interrupt_disable>
1000f958:	e50b0010 	str	r0, [fp, #-16]
        if (rx_fifo->get_index != rx_fifo->put_index)
1000f95c:	e51b300c 	ldr	r3, [fp, #-12]
1000f960:	e1d320b6 	ldrh	r2, [r3, #6]
1000f964:	e51b300c 	ldr	r3, [fp, #-12]
1000f968:	e1d330b4 	ldrh	r3, [r3, #4]
1000f96c:	e1520003 	cmp	r2, r3
1000f970:	0a000018 	beq	1000f9d8 <_serial_int_rx+0xfc>
        {
            ch = rx_fifo->buffer[rx_fifo->get_index];
1000f974:	e51b300c 	ldr	r3, [fp, #-12]
1000f978:	e5933000 	ldr	r3, [r3]
1000f97c:	e51b200c 	ldr	r2, [fp, #-12]
1000f980:	e1d220b6 	ldrh	r2, [r2, #6]
1000f984:	e0833002 	add	r3, r3, r2
1000f988:	e5d33000 	ldrb	r3, [r3]
1000f98c:	e50b3014 	str	r3, [fp, #-20]
            rx_fifo->get_index += 1;
1000f990:	e51b300c 	ldr	r3, [fp, #-12]
1000f994:	e1d330b6 	ldrh	r3, [r3, #6]
1000f998:	e2833001 	add	r3, r3, #1
1000f99c:	e6ff2073 	uxth	r2, r3
1000f9a0:	e51b300c 	ldr	r3, [fp, #-12]
1000f9a4:	e1c320b6 	strh	r2, [r3, #6]
            if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
1000f9a8:	e51b300c 	ldr	r3, [fp, #-12]
1000f9ac:	e1d320b6 	ldrh	r2, [r3, #6]
1000f9b0:	e51b3018 	ldr	r3, [fp, #-24]
1000f9b4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
1000f9b8:	e7ef3553 	ubfx	r3, r3, #10, #16
1000f9bc:	e6ff3073 	uxth	r3, r3
1000f9c0:	e1520003 	cmp	r2, r3
1000f9c4:	3a000006 	bcc	1000f9e4 <_serial_int_rx+0x108>
1000f9c8:	e51b300c 	ldr	r3, [fp, #-12]
1000f9cc:	e3a02000 	mov	r2, #0
1000f9d0:	e1c320b6 	strh	r2, [r3, #6]
1000f9d4:	ea000002 	b	1000f9e4 <_serial_int_rx+0x108>
        }
        else
        {
            /* no data, enable interrupt and break out */
            rt_hw_interrupt_enable(level);
1000f9d8:	e51b0010 	ldr	r0, [fp, #-16]
1000f9dc:	ebffeeba 	bl	1000b4cc <rt_hw_interrupt_enable>
            break;
1000f9e0:	ea00000e 	b	1000fa20 <_serial_int_rx+0x144>
        }

        /* enable interrupt */
        rt_hw_interrupt_enable(level);
1000f9e4:	e51b0010 	ldr	r0, [fp, #-16]
1000f9e8:	ebffeeb7 	bl	1000b4cc <rt_hw_interrupt_enable>

        *data = ch & 0xff;
1000f9ec:	e51b3014 	ldr	r3, [fp, #-20]
1000f9f0:	e6ef2073 	uxtb	r2, r3
1000f9f4:	e51b301c 	ldr	r3, [fp, #-28]
1000f9f8:	e5c32000 	strb	r2, [r3]
        data ++; length --;
1000f9fc:	e51b301c 	ldr	r3, [fp, #-28]
1000fa00:	e2833001 	add	r3, r3, #1
1000fa04:	e50b301c 	str	r3, [fp, #-28]
1000fa08:	e51b3020 	ldr	r3, [fp, #-32]
1000fa0c:	e2433001 	sub	r3, r3, #1
1000fa10:	e50b3020 	str	r3, [fp, #-32]
    
    rx_fifo = (struct rt_serial_rx_fifo*) serial->serial_rx;
    RT_ASSERT(rx_fifo != RT_NULL);

    /* read from software FIFO */
    while (length)
1000fa14:	e51b3020 	ldr	r3, [fp, #-32]
1000fa18:	e3530000 	cmp	r3, #0
1000fa1c:	1affffcc 	bne	1000f954 <_serial_int_rx+0x78>

        *data = ch & 0xff;
        data ++; length --;
    }

    return size - length;
1000fa20:	e51b2008 	ldr	r2, [fp, #-8]
1000fa24:	e51b3020 	ldr	r3, [fp, #-32]
1000fa28:	e0633002 	rsb	r3, r3, r2
}
1000fa2c:	e1a00003 	mov	r0, r3
1000fa30:	e24bd004 	sub	sp, fp, #4
1000fa34:	e8bd8800 	pop	{fp, pc}

1000fa38 <_serial_int_tx>:

rt_inline int _serial_int_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
1000fa38:	e92d4800 	push	{fp, lr}
1000fa3c:	e28db004 	add	fp, sp, #4
1000fa40:	e24dd018 	sub	sp, sp, #24
1000fa44:	e50b0010 	str	r0, [fp, #-16]
1000fa48:	e50b1014 	str	r1, [fp, #-20]
1000fa4c:	e50b2018 	str	r2, [fp, #-24]
    int size;
    struct rt_serial_tx_fifo *tx;
    
    RT_ASSERT(serial != RT_NULL);
1000fa50:	e51b3010 	ldr	r3, [fp, #-16]
1000fa54:	e3530000 	cmp	r3, #0
1000fa58:	1a000005 	bne	1000fa74 <_serial_int_tx+0x3c>
1000fa5c:	e30f0778 	movw	r0, #63352	; 0xf778
1000fa60:	e3410001 	movt	r0, #4097	; 0x1001
1000fa64:	e30f18e4 	movw	r1, #63716	; 0xf8e4
1000fa68:	e3411001 	movt	r1, #4097	; 0x1001
1000fa6c:	e3a02089 	mov	r2, #137	; 0x89
1000fa70:	ebffdad4 	bl	100065c8 <rt_assert_handler>

    size = length;
1000fa74:	e51b3018 	ldr	r3, [fp, #-24]
1000fa78:	e50b3008 	str	r3, [fp, #-8]
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
1000fa7c:	e51b3010 	ldr	r3, [fp, #-16]
1000fa80:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
1000fa84:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(tx != RT_NULL);
1000fa88:	e51b300c 	ldr	r3, [fp, #-12]
1000fa8c:	e3530000 	cmp	r3, #0
1000fa90:	1a000005 	bne	1000faac <_serial_int_tx+0x74>
1000fa94:	e30f07a0 	movw	r0, #63392	; 0xf7a0
1000fa98:	e3410001 	movt	r0, #4097	; 0x1001
1000fa9c:	e30f18e4 	movw	r1, #63716	; 0xf8e4
1000faa0:	e3411001 	movt	r1, #4097	; 0x1001
1000faa4:	e3a0208d 	mov	r2, #141	; 0x8d
1000faa8:	ebffdac6 	bl	100065c8 <rt_assert_handler>

    while (length)
1000faac:	ea000015 	b	1000fb08 <_serial_int_tx+0xd0>
    {
        if (serial->ops->putc(serial, *(char*)data) == -1)
1000fab0:	e51b3010 	ldr	r3, [fp, #-16]
1000fab4:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000fab8:	e5933008 	ldr	r3, [r3, #8]
1000fabc:	e51b2014 	ldr	r2, [fp, #-20]
1000fac0:	e5d22000 	ldrb	r2, [r2]
1000fac4:	e51b0010 	ldr	r0, [fp, #-16]
1000fac8:	e1a01002 	mov	r1, r2
1000facc:	e12fff33 	blx	r3
1000fad0:	e1a03000 	mov	r3, r0
1000fad4:	e3730001 	cmn	r3, #1
1000fad8:	1a000004 	bne	1000faf0 <_serial_int_tx+0xb8>
        {
            rt_completion_wait(&(tx->completion), RT_WAITING_FOREVER);
1000fadc:	e51b300c 	ldr	r3, [fp, #-12]
1000fae0:	e1a00003 	mov	r0, r3
1000fae4:	e3e01000 	mvn	r1, #0
1000fae8:	ebfffc1b 	bl	1000eb5c <rt_completion_wait>
            continue;
1000faec:	ea000005 	b	1000fb08 <_serial_int_tx+0xd0>
        }

        data ++; length --;
1000faf0:	e51b3014 	ldr	r3, [fp, #-20]
1000faf4:	e2833001 	add	r3, r3, #1
1000faf8:	e50b3014 	str	r3, [fp, #-20]
1000fafc:	e51b3018 	ldr	r3, [fp, #-24]
1000fb00:	e2433001 	sub	r3, r3, #1
1000fb04:	e50b3018 	str	r3, [fp, #-24]

    size = length;
    tx = (struct rt_serial_tx_fifo*) serial->serial_tx;
    RT_ASSERT(tx != RT_NULL);

    while (length)
1000fb08:	e51b3018 	ldr	r3, [fp, #-24]
1000fb0c:	e3530000 	cmp	r3, #0
1000fb10:	1affffe6 	bne	1000fab0 <_serial_int_tx+0x78>
        }

        data ++; length --;
    }

    return size - length;
1000fb14:	e51b2008 	ldr	r2, [fp, #-8]
1000fb18:	e51b3018 	ldr	r3, [fp, #-24]
1000fb1c:	e0633002 	rsb	r3, r3, r2
}
1000fb20:	e1a00003 	mov	r0, r3
1000fb24:	e24bd004 	sub	sp, fp, #4
1000fb28:	e8bd8800 	pop	{fp, pc}

1000fb2c <_serial_dma_rx>:

/*
 * Serial DMA routines
 */
rt_inline int _serial_dma_rx(struct rt_serial_device *serial, rt_uint8_t *data, int length)
{
1000fb2c:	e92d4800 	push	{fp, lr}
1000fb30:	e28db004 	add	fp, sp, #4
1000fb34:	e24dd020 	sub	sp, sp, #32
1000fb38:	e50b0018 	str	r0, [fp, #-24]
1000fb3c:	e50b101c 	str	r1, [fp, #-28]
1000fb40:	e50b2020 	str	r2, [fp, #-32]
    rt_base_t level;
    int result = RT_EOK;
1000fb44:	e3a03000 	mov	r3, #0
1000fb48:	e50b3008 	str	r3, [fp, #-8]
    struct rt_serial_rx_dma *rx_dma;

    RT_ASSERT((serial != RT_NULL) && (data != RT_NULL));
1000fb4c:	e51b3018 	ldr	r3, [fp, #-24]
1000fb50:	e3530000 	cmp	r3, #0
1000fb54:	0a000002 	beq	1000fb64 <_serial_dma_rx+0x38>
1000fb58:	e51b301c 	ldr	r3, [fp, #-28]
1000fb5c:	e3530000 	cmp	r3, #0
1000fb60:	1a000005 	bne	1000fb7c <_serial_dma_rx+0x50>
1000fb64:	e30f07b0 	movw	r0, #63408	; 0xf7b0
1000fb68:	e3410001 	movt	r0, #4097	; 0x1001
1000fb6c:	e30f18b4 	movw	r1, #63668	; 0xf8b4
1000fb70:	e3411001 	movt	r1, #4097	; 0x1001
1000fb74:	e3a020a6 	mov	r2, #166	; 0xa6
1000fb78:	ebffda92 	bl	100065c8 <rt_assert_handler>
    rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
1000fb7c:	e51b3018 	ldr	r3, [fp, #-24]
1000fb80:	e5933048 	ldr	r3, [r3, #72]	; 0x48
1000fb84:	e50b300c 	str	r3, [fp, #-12]
    RT_ASSERT(rx_dma != RT_NULL);
1000fb88:	e51b300c 	ldr	r3, [fp, #-12]
1000fb8c:	e3530000 	cmp	r3, #0
1000fb90:	1a000005 	bne	1000fbac <_serial_dma_rx+0x80>
1000fb94:	e30f07dc 	movw	r0, #63452	; 0xf7dc
1000fb98:	e3410001 	movt	r0, #4097	; 0x1001
1000fb9c:	e30f18b4 	movw	r1, #63668	; 0xf8b4
1000fba0:	e3411001 	movt	r1, #4097	; 0x1001
1000fba4:	e3a020a8 	mov	r2, #168	; 0xa8
1000fba8:	ebffda86 	bl	100065c8 <rt_assert_handler>
    level = rt_hw_interrupt_disable();
1000fbac:	ebffee42 	bl	1000b4bc <rt_hw_interrupt_disable>
1000fbb0:	e50b0010 	str	r0, [fp, #-16]
    //if (rx_dma->activated != RT_TRUE)
    //{
        //rx_dma->activated = RT_TRUE;
        serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_RX);
1000fbb4:	e51b3018 	ldr	r3, [fp, #-24]
1000fbb8:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000fbbc:	e593c010 	ldr	ip, [r3, #16]
1000fbc0:	e51b3020 	ldr	r3, [fp, #-32]
1000fbc4:	e51b0018 	ldr	r0, [fp, #-24]
1000fbc8:	e51b101c 	ldr	r1, [fp, #-28]
1000fbcc:	e1a02003 	mov	r2, r3
1000fbd0:	e3a03001 	mov	r3, #1
1000fbd4:	e12fff3c 	blx	ip
    //}
    //else result = -RT_EBUSY;
    rt_hw_interrupt_enable(level);
1000fbd8:	e51b0010 	ldr	r0, [fp, #-16]
1000fbdc:	ebffee3a 	bl	1000b4cc <rt_hw_interrupt_enable>

    if (result == RT_EOK) return length;
1000fbe0:	e51b3008 	ldr	r3, [fp, #-8]
1000fbe4:	e3530000 	cmp	r3, #0
1000fbe8:	1a000001 	bne	1000fbf4 <_serial_dma_rx+0xc8>
1000fbec:	e51b3020 	ldr	r3, [fp, #-32]
1000fbf0:	ea000002 	b	1000fc00 <_serial_dma_rx+0xd4>

    rt_set_errno(result);
1000fbf4:	e51b0008 	ldr	r0, [fp, #-8]
1000fbf8:	ebffd393 	bl	10004a4c <rt_set_errno>
    return 0;
1000fbfc:	e3a03000 	mov	r3, #0
}
1000fc00:	e1a00003 	mov	r0, r3
1000fc04:	e24bd004 	sub	sp, fp, #4
1000fc08:	e8bd8800 	pop	{fp, pc}

1000fc0c <_serial_dma_tx>:

rt_inline int _serial_dma_tx(struct rt_serial_device *serial, const rt_uint8_t *data, int length)
{
1000fc0c:	e92d4800 	push	{fp, lr}
1000fc10:	e28db004 	add	fp, sp, #4
1000fc14:	e24dd020 	sub	sp, sp, #32
1000fc18:	e50b0018 	str	r0, [fp, #-24]
1000fc1c:	e50b101c 	str	r1, [fp, #-28]
1000fc20:	e50b2020 	str	r2, [fp, #-32]
    rt_base_t level;
    rt_err_t result;
    struct rt_serial_tx_dma *tx_dma;

    tx_dma = (struct rt_serial_tx_dma*)(serial->serial_tx);
1000fc24:	e51b3018 	ldr	r3, [fp, #-24]
1000fc28:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
1000fc2c:	e50b3008 	str	r3, [fp, #-8]
    
    result = rt_data_queue_push(&(tx_dma->data_queue), data, length, RT_WAITING_FOREVER); 
1000fc30:	e51b3008 	ldr	r3, [fp, #-8]
1000fc34:	e2832004 	add	r2, r3, #4
1000fc38:	e51b3020 	ldr	r3, [fp, #-32]
1000fc3c:	e1a00002 	mov	r0, r2
1000fc40:	e51b101c 	ldr	r1, [fp, #-28]
1000fc44:	e1a02003 	mov	r2, r3
1000fc48:	e3e03000 	mvn	r3, #0
1000fc4c:	ebfffcc5 	bl	1000ef68 <rt_data_queue_push>
1000fc50:	e50b000c 	str	r0, [fp, #-12]
    if (result == RT_EOK)
1000fc54:	e51b300c 	ldr	r3, [fp, #-12]
1000fc58:	e3530000 	cmp	r3, #0
1000fc5c:	1a000018 	bne	1000fcc4 <_serial_dma_tx+0xb8>
    {
        level = rt_hw_interrupt_disable();
1000fc60:	ebffee15 	bl	1000b4bc <rt_hw_interrupt_disable>
1000fc64:	e50b0010 	str	r0, [fp, #-16]
        if (tx_dma->activated != RT_TRUE)
1000fc68:	e51b3008 	ldr	r3, [fp, #-8]
1000fc6c:	e5933000 	ldr	r3, [r3]
1000fc70:	e3530001 	cmp	r3, #1
1000fc74:	0a00000e 	beq	1000fcb4 <_serial_dma_tx+0xa8>
        {
            tx_dma->activated = RT_TRUE;
1000fc78:	e51b3008 	ldr	r3, [fp, #-8]
1000fc7c:	e3a02001 	mov	r2, #1
1000fc80:	e5832000 	str	r2, [r3]
            rt_hw_interrupt_enable(level);
1000fc84:	e51b0010 	ldr	r0, [fp, #-16]
1000fc88:	ebffee0f 	bl	1000b4cc <rt_hw_interrupt_enable>

            /* make a DMA transfer */
            serial->ops->dma_transmit(serial, data, length, RT_SERIAL_DMA_TX);
1000fc8c:	e51b3018 	ldr	r3, [fp, #-24]
1000fc90:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000fc94:	e593c010 	ldr	ip, [r3, #16]
1000fc98:	e51b3020 	ldr	r3, [fp, #-32]
1000fc9c:	e51b0018 	ldr	r0, [fp, #-24]
1000fca0:	e51b101c 	ldr	r1, [fp, #-28]
1000fca4:	e1a02003 	mov	r2, r3
1000fca8:	e3a03002 	mov	r3, #2
1000fcac:	e12fff3c 	blx	ip
1000fcb0:	ea000001 	b	1000fcbc <_serial_dma_tx+0xb0>
        }
        else
        {
            rt_hw_interrupt_enable(level);
1000fcb4:	e51b0010 	ldr	r0, [fp, #-16]
1000fcb8:	ebffee03 	bl	1000b4cc <rt_hw_interrupt_enable>
        }

        return length;
1000fcbc:	e51b3020 	ldr	r3, [fp, #-32]
1000fcc0:	ea000002 	b	1000fcd0 <_serial_dma_tx+0xc4>
    }
    else
    {
        rt_set_errno(result);
1000fcc4:	e51b000c 	ldr	r0, [fp, #-12]
1000fcc8:	ebffd35f 	bl	10004a4c <rt_set_errno>
        return 0;
1000fccc:	e3a03000 	mov	r3, #0
    }
}
1000fcd0:	e1a00003 	mov	r0, r3
1000fcd4:	e24bd004 	sub	sp, fp, #4
1000fcd8:	e8bd8800 	pop	{fp, pc}

1000fcdc <rt_serial_init>:
/* RT-Thread Device Interface */
/*
 * This function initializes serial device.
 */
static rt_err_t rt_serial_init(struct rt_device *dev)
{
1000fcdc:	e92d4800 	push	{fp, lr}
1000fce0:	e28db004 	add	fp, sp, #4
1000fce4:	e24dd010 	sub	sp, sp, #16
1000fce8:	e50b0010 	str	r0, [fp, #-16]
    rt_err_t result = RT_EOK;
1000fcec:	e3a03000 	mov	r3, #0
1000fcf0:	e50b3008 	str	r3, [fp, #-8]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
1000fcf4:	e51b3010 	ldr	r3, [fp, #-16]
1000fcf8:	e3530000 	cmp	r3, #0
1000fcfc:	1a000005 	bne	1000fd18 <rt_serial_init+0x3c>
1000fd00:	e30f07f0 	movw	r0, #63472	; 0xf7f0
1000fd04:	e3410001 	movt	r0, #4097	; 0x1001
1000fd08:	e30f1864 	movw	r1, #63588	; 0xf864
1000fd0c:	e3411001 	movt	r1, #4097	; 0x1001
1000fd10:	e3a020e3 	mov	r2, #227	; 0xe3
1000fd14:	ebffda2b 	bl	100065c8 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
1000fd18:	e51b3010 	ldr	r3, [fp, #-16]
1000fd1c:	e50b300c 	str	r3, [fp, #-12]

    /* initialize rx/tx */
    serial->serial_rx = RT_NULL;
1000fd20:	e51b300c 	ldr	r3, [fp, #-12]
1000fd24:	e3a02000 	mov	r2, #0
1000fd28:	e5832048 	str	r2, [r3, #72]	; 0x48
    serial->serial_tx = RT_NULL;
1000fd2c:	e51b300c 	ldr	r3, [fp, #-12]
1000fd30:	e3a02000 	mov	r2, #0
1000fd34:	e583204c 	str	r2, [r3, #76]	; 0x4c

    /* apply configuration */
    if (serial->ops->configure)
1000fd38:	e51b300c 	ldr	r3, [fp, #-12]
1000fd3c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000fd40:	e5933000 	ldr	r3, [r3]
1000fd44:	e3530000 	cmp	r3, #0
1000fd48:	0a000008 	beq	1000fd70 <rt_serial_init+0x94>
        result = serial->ops->configure(serial, &serial->config);
1000fd4c:	e51b300c 	ldr	r3, [fp, #-12]
1000fd50:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000fd54:	e5933000 	ldr	r3, [r3]
1000fd58:	e51b200c 	ldr	r2, [fp, #-12]
1000fd5c:	e2822040 	add	r2, r2, #64	; 0x40
1000fd60:	e51b000c 	ldr	r0, [fp, #-12]
1000fd64:	e1a01002 	mov	r1, r2
1000fd68:	e12fff33 	blx	r3
1000fd6c:	e50b0008 	str	r0, [fp, #-8]
	rt_kprintf("%x\r\n", result);
1000fd70:	e30f0800 	movw	r0, #63488	; 0xf800
1000fd74:	e3410001 	movt	r0, #4097	; 0x1001
1000fd78:	e51b1008 	ldr	r1, [fp, #-8]
1000fd7c:	ebffd954 	bl	100062d4 <rt_kprintf>
    return result;
1000fd80:	e51b3008 	ldr	r3, [fp, #-8]
}
1000fd84:	e1a00003 	mov	r0, r3
1000fd88:	e24bd004 	sub	sp, fp, #4
1000fd8c:	e8bd8800 	pop	{fp, pc}

1000fd90 <rt_serial_open>:

static rt_err_t rt_serial_open(struct rt_device *dev, rt_uint16_t oflag)
{
1000fd90:	e92d4800 	push	{fp, lr}
1000fd94:	e28db004 	add	fp, sp, #4
1000fd98:	e24dd020 	sub	sp, sp, #32
1000fd9c:	e50b0020 	str	r0, [fp, #-32]
1000fda0:	e1a03001 	mov	r3, r1
1000fda4:	e14b32b2 	strh	r3, [fp, #-34]	; 0xffffffde
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
1000fda8:	e51b3020 	ldr	r3, [fp, #-32]
1000fdac:	e3530000 	cmp	r3, #0
1000fdb0:	1a000005 	bne	1000fdcc <rt_serial_open+0x3c>
1000fdb4:	e30f07f0 	movw	r0, #63472	; 0xf7f0
1000fdb8:	e3410001 	movt	r0, #4097	; 0x1001
1000fdbc:	e30f1874 	movw	r1, #63604	; 0xf874
1000fdc0:	e3411001 	movt	r1, #4097	; 0x1001
1000fdc4:	e3a020f5 	mov	r2, #245	; 0xf5
1000fdc8:	ebffd9fe 	bl	100065c8 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
1000fdcc:	e51b3020 	ldr	r3, [fp, #-32]
1000fdd0:	e50b3008 	str	r3, [fp, #-8]

    /* check device flag with the open flag */
    if ((oflag & RT_DEVICE_FLAG_DMA_RX) && !(dev->flag & RT_DEVICE_FLAG_DMA_RX)) 
1000fdd4:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000fdd8:	e2033c02 	and	r3, r3, #512	; 0x200
1000fddc:	e3530000 	cmp	r3, #0
1000fde0:	0a000006 	beq	1000fe00 <rt_serial_open+0x70>
1000fde4:	e51b3020 	ldr	r3, [fp, #-32]
1000fde8:	e1d331b2 	ldrh	r3, [r3, #18]
1000fdec:	e2033c02 	and	r3, r3, #512	; 0x200
1000fdf0:	e3530000 	cmp	r3, #0
1000fdf4:	1a000001 	bne	1000fe00 <rt_serial_open+0x70>
        return -RT_EIO;
1000fdf8:	e3e03007 	mvn	r3, #7
1000fdfc:	ea0000da 	b	1001016c <rt_serial_open+0x3dc>
    if ((oflag & RT_DEVICE_FLAG_DMA_TX) && !(dev->flag & RT_DEVICE_FLAG_DMA_TX))
1000fe00:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000fe04:	e2033b02 	and	r3, r3, #2048	; 0x800
1000fe08:	e3530000 	cmp	r3, #0
1000fe0c:	0a000006 	beq	1000fe2c <rt_serial_open+0x9c>
1000fe10:	e51b3020 	ldr	r3, [fp, #-32]
1000fe14:	e1d331b2 	ldrh	r3, [r3, #18]
1000fe18:	e2033b02 	and	r3, r3, #2048	; 0x800
1000fe1c:	e3530000 	cmp	r3, #0
1000fe20:	1a000001 	bne	1000fe2c <rt_serial_open+0x9c>
        return -RT_EIO;
1000fe24:	e3e03007 	mvn	r3, #7
1000fe28:	ea0000cf 	b	1001016c <rt_serial_open+0x3dc>
    if ((oflag & RT_DEVICE_FLAG_INT_RX) && !(dev->flag & RT_DEVICE_FLAG_INT_RX))
1000fe2c:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000fe30:	e2033c01 	and	r3, r3, #256	; 0x100
1000fe34:	e3530000 	cmp	r3, #0
1000fe38:	0a000006 	beq	1000fe58 <rt_serial_open+0xc8>
1000fe3c:	e51b3020 	ldr	r3, [fp, #-32]
1000fe40:	e1d331b2 	ldrh	r3, [r3, #18]
1000fe44:	e2033c01 	and	r3, r3, #256	; 0x100
1000fe48:	e3530000 	cmp	r3, #0
1000fe4c:	1a000001 	bne	1000fe58 <rt_serial_open+0xc8>
        return -RT_EIO;
1000fe50:	e3e03007 	mvn	r3, #7
1000fe54:	ea0000c4 	b	1001016c <rt_serial_open+0x3dc>
    if ((oflag & RT_DEVICE_FLAG_INT_TX) && !(dev->flag & RT_DEVICE_FLAG_INT_TX))
1000fe58:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000fe5c:	e2033b01 	and	r3, r3, #1024	; 0x400
1000fe60:	e3530000 	cmp	r3, #0
1000fe64:	0a000006 	beq	1000fe84 <rt_serial_open+0xf4>
1000fe68:	e51b3020 	ldr	r3, [fp, #-32]
1000fe6c:	e1d331b2 	ldrh	r3, [r3, #18]
1000fe70:	e2033b01 	and	r3, r3, #1024	; 0x400
1000fe74:	e3530000 	cmp	r3, #0
1000fe78:	1a000001 	bne	1000fe84 <rt_serial_open+0xf4>
        return -RT_EIO;
1000fe7c:	e3e03007 	mvn	r3, #7
1000fe80:	ea0000b9 	b	1001016c <rt_serial_open+0x3dc>

    /* get open flags */
    dev->open_flag = oflag & 0xff;
1000fe84:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000fe88:	e6ef3073 	uxtb	r3, r3
1000fe8c:	e6ff2073 	uxth	r2, r3
1000fe90:	e51b3020 	ldr	r3, [fp, #-32]
1000fe94:	e1c321b4 	strh	r2, [r3, #20]
    
    /* initialize the Rx/Tx structure according to open flag */
    if (serial->serial_rx == RT_NULL)
1000fe98:	e51b3008 	ldr	r3, [fp, #-8]
1000fe9c:	e5933048 	ldr	r3, [r3, #72]	; 0x48
1000fea0:	e3530000 	cmp	r3, #0
1000fea4:	1a000060 	bne	1001002c <rt_serial_open+0x29c>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_RX)
1000fea8:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000feac:	e2033c02 	and	r3, r3, #512	; 0x200
1000feb0:	e3530000 	cmp	r3, #0
1000feb4:	0a00001f 	beq	1000ff38 <rt_serial_open+0x1a8>
        {
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*) rt_malloc (sizeof(struct rt_serial_rx_dma));
1000feb8:	e3a00004 	mov	r0, #4
1000febc:	ebffdaf9 	bl	10006aa8 <rt_malloc>
1000fec0:	e50b000c 	str	r0, [fp, #-12]
            RT_ASSERT(rx_dma != RT_NULL);
1000fec4:	e51b300c 	ldr	r3, [fp, #-12]
1000fec8:	e3530000 	cmp	r3, #0
1000fecc:	1a000005 	bne	1000fee8 <rt_serial_open+0x158>
1000fed0:	e30f07dc 	movw	r0, #63452	; 0xf7dc
1000fed4:	e3410001 	movt	r0, #4097	; 0x1001
1000fed8:	e30f1874 	movw	r1, #63604	; 0xf874
1000fedc:	e3411001 	movt	r1, #4097	; 0x1001
1000fee0:	e300210d 	movw	r2, #269	; 0x10d
1000fee4:	ebffd9b7 	bl	100065c8 <rt_assert_handler>
            rx_dma->activated = RT_FALSE;
1000fee8:	e51b300c 	ldr	r3, [fp, #-12]
1000feec:	e3a02000 	mov	r2, #0
1000fef0:	e5832000 	str	r2, [r3]

            serial->serial_rx = rx_dma;
1000fef4:	e51b3008 	ldr	r3, [fp, #-8]
1000fef8:	e51b200c 	ldr	r2, [fp, #-12]
1000fefc:	e5832048 	str	r2, [r3, #72]	; 0x48
            dev->open_flag |= RT_DEVICE_FLAG_DMA_RX;
1000ff00:	e51b3020 	ldr	r3, [fp, #-32]
1000ff04:	e1d331b4 	ldrh	r3, [r3, #20]
1000ff08:	e3833c02 	orr	r3, r3, #512	; 0x200
1000ff0c:	e6ff2073 	uxth	r2, r3
1000ff10:	e51b3020 	ldr	r3, [fp, #-32]
1000ff14:	e1c321b4 	strh	r2, [r3, #20]
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_DMARX, (void *)RT_DEVICE_FLAG_DMA_RX);
1000ff18:	e51b3008 	ldr	r3, [fp, #-8]
1000ff1c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
1000ff20:	e5933004 	ldr	r3, [r3, #4]
1000ff24:	e51b0008 	ldr	r0, [fp, #-8]
1000ff28:	e3a01014 	mov	r1, #20
1000ff2c:	e3a02c02 	mov	r2, #512	; 0x200
1000ff30:	e12fff33 	blx	r3
1000ff34:	ea00003c 	b	1001002c <rt_serial_open+0x29c>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
1000ff38:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
1000ff3c:	e2033c01 	and	r3, r3, #256	; 0x100
1000ff40:	e3530000 	cmp	r3, #0
1000ff44:	0a000035 	beq	10010020 <rt_serial_open+0x290>
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
                serial->config.bufsz);
1000ff48:	e51b3008 	ldr	r3, [fp, #-8]
1000ff4c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
1000ff50:	e7ef3553 	ubfx	r3, r3, #10, #16
1000ff54:	e6ff3073 	uxth	r3, r3
        }
        else if (oflag & RT_DEVICE_FLAG_INT_RX)
        {
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*) rt_malloc (sizeof(struct rt_serial_rx_fifo) + 
1000ff58:	e2833008 	add	r3, r3, #8
1000ff5c:	e1a00003 	mov	r0, r3
1000ff60:	ebffdad0 	bl	10006aa8 <rt_malloc>
1000ff64:	e50b0010 	str	r0, [fp, #-16]
                serial->config.bufsz);
            RT_ASSERT(rx_fifo != RT_NULL);
1000ff68:	e51b3010 	ldr	r3, [fp, #-16]
1000ff6c:	e3530000 	cmp	r3, #0
1000ff70:	1a000005 	bne	1000ff8c <rt_serial_open+0x1fc>
1000ff74:	e30f078c 	movw	r0, #63372	; 0xf78c
1000ff78:	e3410001 	movt	r0, #4097	; 0x1001
1000ff7c:	e30f1874 	movw	r1, #63604	; 0xf874
1000ff80:	e3411001 	movt	r1, #4097	; 0x1001
1000ff84:	e300211a 	movw	r2, #282	; 0x11a
1000ff88:	ebffd98e 	bl	100065c8 <rt_assert_handler>
            rx_fifo->buffer = (rt_uint8_t*) (rx_fifo + 1);
1000ff8c:	e51b3010 	ldr	r3, [fp, #-16]
1000ff90:	e2832008 	add	r2, r3, #8
1000ff94:	e51b3010 	ldr	r3, [fp, #-16]
1000ff98:	e5832000 	str	r2, [r3]
            rt_memset(rx_fifo->buffer, 0, serial->config.bufsz);
1000ff9c:	e51b3010 	ldr	r3, [fp, #-16]
1000ffa0:	e5932000 	ldr	r2, [r3]
1000ffa4:	e51b3008 	ldr	r3, [fp, #-8]
1000ffa8:	e5933044 	ldr	r3, [r3, #68]	; 0x44
1000ffac:	e7ef3553 	ubfx	r3, r3, #10, #16
1000ffb0:	e6ff3073 	uxth	r3, r3
1000ffb4:	e1a00002 	mov	r0, r2
1000ffb8:	e3a01000 	mov	r1, #0
1000ffbc:	e1a02003 	mov	r2, r3
1000ffc0:	ebffd2d4 	bl	10004b18 <rt_memset>
            rx_fifo->put_index = 0;
1000ffc4:	e51b3010 	ldr	r3, [fp, #-16]
1000ffc8:	e3a02000 	mov	r2, #0
1000ffcc:	e1c320b4 	strh	r2, [r3, #4]
            rx_fifo->get_index = 0;
1000ffd0:	e51b3010 	ldr	r3, [fp, #-16]
1000ffd4:	e3a02000 	mov	r2, #0
1000ffd8:	e1c320b6 	strh	r2, [r3, #6]

            serial->serial_rx = rx_fifo;
1000ffdc:	e51b3008 	ldr	r3, [fp, #-8]
1000ffe0:	e51b2010 	ldr	r2, [fp, #-16]
1000ffe4:	e5832048 	str	r2, [r3, #72]	; 0x48
            dev->open_flag |= RT_DEVICE_FLAG_INT_RX;
1000ffe8:	e51b3020 	ldr	r3, [fp, #-32]
1000ffec:	e1d331b4 	ldrh	r3, [r3, #20]
1000fff0:	e3833c01 	orr	r3, r3, #256	; 0x100
1000fff4:	e6ff2073 	uxth	r2, r3
1000fff8:	e51b3020 	ldr	r3, [fp, #-32]
1000fffc:	e1c321b4 	strh	r2, [r3, #20]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_RX);
10010000:	e51b3008 	ldr	r3, [fp, #-8]
10010004:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010008:	e5933004 	ldr	r3, [r3, #4]
1001000c:	e51b0008 	ldr	r0, [fp, #-8]
10010010:	e3a01010 	mov	r1, #16
10010014:	e3a02c01 	mov	r2, #256	; 0x100
10010018:	e12fff33 	blx	r3
1001001c:	ea000002 	b	1001002c <rt_serial_open+0x29c>
        }
        else
        {
            serial->serial_rx = RT_NULL;
10010020:	e51b3008 	ldr	r3, [fp, #-8]
10010024:	e3a02000 	mov	r2, #0
10010028:	e5832048 	str	r2, [r3, #72]	; 0x48
        }
    }

    if (serial->serial_tx == RT_NULL)
1001002c:	e51b3008 	ldr	r3, [fp, #-8]
10010030:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10010034:	e3530000 	cmp	r3, #0
10010038:	1a00004a 	bne	10010168 <rt_serial_open+0x3d8>
    {
        if (oflag & RT_DEVICE_FLAG_DMA_TX)
1001003c:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
10010040:	e2033b02 	and	r3, r3, #2048	; 0x800
10010044:	e3530000 	cmp	r3, #0
10010048:	0a00001f 	beq	100100cc <rt_serial_open+0x33c>
        {
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) rt_malloc (sizeof(struct rt_serial_tx_dma));
1001004c:	e3a00028 	mov	r0, #40	; 0x28
10010050:	ebffda94 	bl	10006aa8 <rt_malloc>
10010054:	e50b0014 	str	r0, [fp, #-20]
            RT_ASSERT(tx_dma != RT_NULL);
10010058:	e51b3014 	ldr	r3, [fp, #-20]
1001005c:	e3530000 	cmp	r3, #0
10010060:	1a000005 	bne	1001007c <rt_serial_open+0x2ec>
10010064:	e30f0808 	movw	r0, #63496	; 0xf808
10010068:	e3410001 	movt	r0, #4097	; 0x1001
1001006c:	e30f1874 	movw	r1, #63604	; 0xf874
10010070:	e3411001 	movt	r1, #4097	; 0x1001
10010074:	e3002132 	movw	r2, #306	; 0x132
10010078:	ebffd952 	bl	100065c8 <rt_assert_handler>
            tx_dma->activated = RT_FALSE;
1001007c:	e51b3014 	ldr	r3, [fp, #-20]
10010080:	e3a02000 	mov	r2, #0
10010084:	e5832000 	str	r2, [r3]
            
            rt_data_queue_init(&(tx_dma->data_queue), 8, 4, RT_NULL);
10010088:	e51b3014 	ldr	r3, [fp, #-20]
1001008c:	e2833004 	add	r3, r3, #4
10010090:	e1a00003 	mov	r0, r3
10010094:	e3a01008 	mov	r1, #8
10010098:	e3a02004 	mov	r2, #4
1001009c:	e3a03000 	mov	r3, #0
100100a0:	ebfffb75 	bl	1000ee7c <rt_data_queue_init>
            serial->serial_tx = tx_dma;
100100a4:	e51b3008 	ldr	r3, [fp, #-8]
100100a8:	e51b2014 	ldr	r2, [fp, #-20]
100100ac:	e583204c 	str	r2, [r3, #76]	; 0x4c

            dev->open_flag |= RT_DEVICE_FLAG_DMA_TX;
100100b0:	e51b3020 	ldr	r3, [fp, #-32]
100100b4:	e1d331b4 	ldrh	r3, [r3, #20]
100100b8:	e3833b02 	orr	r3, r3, #2048	; 0x800
100100bc:	e6ff2073 	uxth	r2, r3
100100c0:	e51b3020 	ldr	r3, [fp, #-32]
100100c4:	e1c321b4 	strh	r2, [r3, #20]
100100c8:	ea000026 	b	10010168 <rt_serial_open+0x3d8>
        }
        else if (oflag & RT_DEVICE_FLAG_INT_TX)
100100cc:	e15b32b2 	ldrh	r3, [fp, #-34]	; 0xffffffde
100100d0:	e2033b01 	and	r3, r3, #1024	; 0x400
100100d4:	e3530000 	cmp	r3, #0
100100d8:	0a00001f 	beq	1001015c <rt_serial_open+0x3cc>
        {
            struct rt_serial_tx_fifo *tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*) rt_malloc(sizeof(struct rt_serial_tx_fifo));
100100dc:	e3a0000c 	mov	r0, #12
100100e0:	ebffda70 	bl	10006aa8 <rt_malloc>
100100e4:	e50b0018 	str	r0, [fp, #-24]
            RT_ASSERT(tx_fifo != RT_NULL);
100100e8:	e51b3018 	ldr	r3, [fp, #-24]
100100ec:	e3530000 	cmp	r3, #0
100100f0:	1a000005 	bne	1001010c <rt_serial_open+0x37c>
100100f4:	e30f081c 	movw	r0, #63516	; 0xf81c
100100f8:	e3410001 	movt	r0, #4097	; 0x1001
100100fc:	e30f1874 	movw	r1, #63604	; 0xf874
10010100:	e3411001 	movt	r1, #4097	; 0x1001
10010104:	e300213f 	movw	r2, #319	; 0x13f
10010108:	ebffd92e 	bl	100065c8 <rt_assert_handler>

            rt_completion_init(&(tx_fifo->completion));
1001010c:	e51b3018 	ldr	r3, [fp, #-24]
10010110:	e1a00003 	mov	r0, r3
10010114:	ebfffa76 	bl	1000eaf4 <rt_completion_init>
            serial->serial_tx = tx_fifo;
10010118:	e51b3008 	ldr	r3, [fp, #-8]
1001011c:	e51b2018 	ldr	r2, [fp, #-24]
10010120:	e583204c 	str	r2, [r3, #76]	; 0x4c

            dev->open_flag |= RT_DEVICE_FLAG_INT_TX;
10010124:	e51b3020 	ldr	r3, [fp, #-32]
10010128:	e1d331b4 	ldrh	r3, [r3, #20]
1001012c:	e3833b01 	orr	r3, r3, #1024	; 0x400
10010130:	e6ff2073 	uxth	r2, r3
10010134:	e51b3020 	ldr	r3, [fp, #-32]
10010138:	e1c321b4 	strh	r2, [r3, #20]
            /* configure low level device */
            serial->ops->control(serial, RT_DEVICE_CTRL_SET_INT, (void *)RT_DEVICE_FLAG_INT_TX);
1001013c:	e51b3008 	ldr	r3, [fp, #-8]
10010140:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010144:	e5933004 	ldr	r3, [r3, #4]
10010148:	e51b0008 	ldr	r0, [fp, #-8]
1001014c:	e3a01010 	mov	r1, #16
10010150:	e3a02b01 	mov	r2, #1024	; 0x400
10010154:	e12fff33 	blx	r3
10010158:	ea000002 	b	10010168 <rt_serial_open+0x3d8>
        }
        else
        {
            serial->serial_tx = RT_NULL;
1001015c:	e51b3008 	ldr	r3, [fp, #-8]
10010160:	e3a02000 	mov	r2, #0
10010164:	e583204c 	str	r2, [r3, #76]	; 0x4c
        }
    }

    return RT_EOK;
10010168:	e3a03000 	mov	r3, #0
}
1001016c:	e1a00003 	mov	r0, r3
10010170:	e24bd004 	sub	sp, fp, #4
10010174:	e8bd8800 	pop	{fp, pc}

10010178 <rt_serial_close>:

static rt_err_t rt_serial_close(struct rt_device *dev)
{
10010178:	e92d4800 	push	{fp, lr}
1001017c:	e28db004 	add	fp, sp, #4
10010180:	e24dd020 	sub	sp, sp, #32
10010184:	e50b0020 	str	r0, [fp, #-32]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
10010188:	e51b3020 	ldr	r3, [fp, #-32]
1001018c:	e3530000 	cmp	r3, #0
10010190:	1a000005 	bne	100101ac <rt_serial_close+0x34>
10010194:	e30f07f0 	movw	r0, #63472	; 0xf7f0
10010198:	e3410001 	movt	r0, #4097	; 0x1001
1001019c:	e30f1884 	movw	r1, #63620	; 0xf884
100101a0:	e3411001 	movt	r1, #4097	; 0x1001
100101a4:	e3002155 	movw	r2, #341	; 0x155
100101a8:	ebffd906 	bl	100065c8 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
100101ac:	e51b3020 	ldr	r3, [fp, #-32]
100101b0:	e50b3008 	str	r3, [fp, #-8]

    /* this device has more reference count */
    if (dev->ref_count > 1) return RT_EOK;
100101b4:	e51b3020 	ldr	r3, [fp, #-32]
100101b8:	e5d33016 	ldrb	r3, [r3, #22]
100101bc:	e3530001 	cmp	r3, #1
100101c0:	9a000001 	bls	100101cc <rt_serial_close+0x54>
100101c4:	e3a03000 	mov	r3, #0
100101c8:	ea000080 	b	100103d0 <rt_serial_close+0x258>
    
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
100101cc:	e51b3020 	ldr	r3, [fp, #-32]
100101d0:	e1d331b4 	ldrh	r3, [r3, #20]
100101d4:	e2033c01 	and	r3, r3, #256	; 0x100
100101d8:	e3530000 	cmp	r3, #0
100101dc:	0a00001e 	beq	1001025c <rt_serial_close+0xe4>
    {
        struct rt_serial_rx_fifo* rx_fifo;

        rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
100101e0:	e51b3008 	ldr	r3, [fp, #-8]
100101e4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
100101e8:	e50b300c 	str	r3, [fp, #-12]
        RT_ASSERT(rx_fifo != RT_NULL);
100101ec:	e51b300c 	ldr	r3, [fp, #-12]
100101f0:	e3530000 	cmp	r3, #0
100101f4:	1a000005 	bne	10010210 <rt_serial_close+0x98>
100101f8:	e30f078c 	movw	r0, #63372	; 0xf78c
100101fc:	e3410001 	movt	r0, #4097	; 0x1001
10010200:	e30f1884 	movw	r1, #63620	; 0xf884
10010204:	e3411001 	movt	r1, #4097	; 0x1001
10010208:	e3a02e16 	mov	r2, #352	; 0x160
1001020c:	ebffd8ed 	bl	100065c8 <rt_assert_handler>

        rt_free(rx_fifo);
10010210:	e51b000c 	ldr	r0, [fp, #-12]
10010214:	ebffdc3e 	bl	10007314 <rt_free>
        serial->serial_rx = RT_NULL;
10010218:	e51b3008 	ldr	r3, [fp, #-8]
1001021c:	e3a02000 	mov	r2, #0
10010220:	e5832048 	str	r2, [r3, #72]	; 0x48
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_RX;
10010224:	e51b3020 	ldr	r3, [fp, #-32]
10010228:	e1d331b4 	ldrh	r3, [r3, #20]
1001022c:	e3c33c01 	bic	r3, r3, #256	; 0x100
10010230:	e6ff2073 	uxth	r2, r3
10010234:	e51b3020 	ldr	r3, [fp, #-32]
10010238:	e1c321b4 	strh	r2, [r3, #20]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
1001023c:	e51b3008 	ldr	r3, [fp, #-8]
10010240:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010244:	e5933004 	ldr	r3, [r3, #4]
10010248:	e51b0008 	ldr	r0, [fp, #-8]
1001024c:	e3a01011 	mov	r1, #17
10010250:	e3a02b01 	mov	r2, #1024	; 0x400
10010254:	e12fff33 	blx	r3
10010258:	ea00001b 	b	100102cc <rt_serial_close+0x154>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
1001025c:	e51b3020 	ldr	r3, [fp, #-32]
10010260:	e1d331b4 	ldrh	r3, [r3, #20]
10010264:	e2033c02 	and	r3, r3, #512	; 0x200
10010268:	e3530000 	cmp	r3, #0
1001026c:	0a000016 	beq	100102cc <rt_serial_close+0x154>
    {
        struct rt_serial_rx_dma* rx_dma;

        rx_dma = (struct rt_serial_rx_dma*)serial->serial_tx;
10010270:	e51b3008 	ldr	r3, [fp, #-8]
10010274:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10010278:	e50b3010 	str	r3, [fp, #-16]
        RT_ASSERT(rx_dma != RT_NULL);
1001027c:	e51b3010 	ldr	r3, [fp, #-16]
10010280:	e3530000 	cmp	r3, #0
10010284:	1a000005 	bne	100102a0 <rt_serial_close+0x128>
10010288:	e30f07dc 	movw	r0, #63452	; 0xf7dc
1001028c:	e3410001 	movt	r0, #4097	; 0x1001
10010290:	e30f1884 	movw	r1, #63620	; 0xf884
10010294:	e3411001 	movt	r1, #4097	; 0x1001
10010298:	e300216d 	movw	r2, #365	; 0x16d
1001029c:	ebffd8c9 	bl	100065c8 <rt_assert_handler>

        rt_free(rx_dma);
100102a0:	e51b0010 	ldr	r0, [fp, #-16]
100102a4:	ebffdc1a 	bl	10007314 <rt_free>
        serial->serial_rx = RT_NULL;
100102a8:	e51b3008 	ldr	r3, [fp, #-8]
100102ac:	e3a02000 	mov	r2, #0
100102b0:	e5832048 	str	r2, [r3, #72]	; 0x48
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_RX;
100102b4:	e51b3020 	ldr	r3, [fp, #-32]
100102b8:	e1d331b4 	ldrh	r3, [r3, #20]
100102bc:	e3c33c02 	bic	r3, r3, #512	; 0x200
100102c0:	e6ff2073 	uxth	r2, r3
100102c4:	e51b3020 	ldr	r3, [fp, #-32]
100102c8:	e1c321b4 	strh	r2, [r3, #20]
    }

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
100102cc:	e51b3020 	ldr	r3, [fp, #-32]
100102d0:	e1d331b4 	ldrh	r3, [r3, #20]
100102d4:	e2033b01 	and	r3, r3, #1024	; 0x400
100102d8:	e3530000 	cmp	r3, #0
100102dc:	0a00001e 	beq	1001035c <rt_serial_close+0x1e4>
    {
        struct rt_serial_tx_fifo* tx_fifo;

        tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_rx;
100102e0:	e51b3008 	ldr	r3, [fp, #-8]
100102e4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
100102e8:	e50b3014 	str	r3, [fp, #-20]
        RT_ASSERT(tx_fifo != RT_NULL);
100102ec:	e51b3014 	ldr	r3, [fp, #-20]
100102f0:	e3530000 	cmp	r3, #0
100102f4:	1a000005 	bne	10010310 <rt_serial_close+0x198>
100102f8:	e30f081c 	movw	r0, #63516	; 0xf81c
100102fc:	e3410001 	movt	r0, #4097	; 0x1001
10010300:	e30f1884 	movw	r1, #63620	; 0xf884
10010304:	e3411001 	movt	r1, #4097	; 0x1001
10010308:	e3002179 	movw	r2, #377	; 0x179
1001030c:	ebffd8ad 	bl	100065c8 <rt_assert_handler>

        rt_free(tx_fifo);
10010310:	e51b0014 	ldr	r0, [fp, #-20]
10010314:	ebffdbfe 	bl	10007314 <rt_free>
        serial->serial_tx = RT_NULL;
10010318:	e51b3008 	ldr	r3, [fp, #-8]
1001031c:	e3a02000 	mov	r2, #0
10010320:	e583204c 	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_INT_TX;
10010324:	e51b3020 	ldr	r3, [fp, #-32]
10010328:	e1d331b4 	ldrh	r3, [r3, #20]
1001032c:	e3c33b01 	bic	r3, r3, #1024	; 0x400
10010330:	e6ff2073 	uxth	r2, r3
10010334:	e51b3020 	ldr	r3, [fp, #-32]
10010338:	e1c321b4 	strh	r2, [r3, #20]
        /* configure low level device */
        serial->ops->control(serial, RT_DEVICE_CTRL_CLR_INT, (void*)RT_DEVICE_FLAG_INT_TX);
1001033c:	e51b3008 	ldr	r3, [fp, #-8]
10010340:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010344:	e5933004 	ldr	r3, [r3, #4]
10010348:	e51b0008 	ldr	r0, [fp, #-8]
1001034c:	e3a01011 	mov	r1, #17
10010350:	e3a02b01 	mov	r2, #1024	; 0x400
10010354:	e12fff33 	blx	r3
10010358:	ea00001b 	b	100103cc <rt_serial_close+0x254>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
1001035c:	e51b3020 	ldr	r3, [fp, #-32]
10010360:	e1d331b4 	ldrh	r3, [r3, #20]
10010364:	e2033b02 	and	r3, r3, #2048	; 0x800
10010368:	e3530000 	cmp	r3, #0
1001036c:	0a000016 	beq	100103cc <rt_serial_close+0x254>
    {
        struct rt_serial_tx_dma* tx_dma;

        tx_dma = (struct rt_serial_tx_dma*)serial->serial_tx;
10010370:	e51b3008 	ldr	r3, [fp, #-8]
10010374:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
10010378:	e50b3018 	str	r3, [fp, #-24]
        RT_ASSERT(tx_dma != RT_NULL);
1001037c:	e51b3018 	ldr	r3, [fp, #-24]
10010380:	e3530000 	cmp	r3, #0
10010384:	1a000005 	bne	100103a0 <rt_serial_close+0x228>
10010388:	e30f0808 	movw	r0, #63496	; 0xf808
1001038c:	e3410001 	movt	r0, #4097	; 0x1001
10010390:	e30f1884 	movw	r1, #63620	; 0xf884
10010394:	e3411001 	movt	r1, #4097	; 0x1001
10010398:	e3002186 	movw	r2, #390	; 0x186
1001039c:	ebffd889 	bl	100065c8 <rt_assert_handler>

        rt_free(tx_dma);
100103a0:	e51b0018 	ldr	r0, [fp, #-24]
100103a4:	ebffdbda 	bl	10007314 <rt_free>
        serial->serial_tx = RT_NULL;
100103a8:	e51b3008 	ldr	r3, [fp, #-8]
100103ac:	e3a02000 	mov	r2, #0
100103b0:	e583204c 	str	r2, [r3, #76]	; 0x4c
        dev->open_flag &= ~RT_DEVICE_FLAG_DMA_TX;
100103b4:	e51b3020 	ldr	r3, [fp, #-32]
100103b8:	e1d331b4 	ldrh	r3, [r3, #20]
100103bc:	e3c33b02 	bic	r3, r3, #2048	; 0x800
100103c0:	e6ff2073 	uxth	r2, r3
100103c4:	e51b3020 	ldr	r3, [fp, #-32]
100103c8:	e1c321b4 	strh	r2, [r3, #20]
    }

    return RT_EOK;
100103cc:	e3a03000 	mov	r3, #0
}
100103d0:	e1a00003 	mov	r0, r3
100103d4:	e24bd004 	sub	sp, fp, #4
100103d8:	e8bd8800 	pop	{fp, pc}

100103dc <rt_serial_read>:

static rt_size_t rt_serial_read(struct rt_device *dev,
                                rt_off_t          pos,
                                void             *buffer,
                                rt_size_t         size)
{
100103dc:	e92d4800 	push	{fp, lr}
100103e0:	e28db004 	add	fp, sp, #4
100103e4:	e24dd018 	sub	sp, sp, #24
100103e8:	e50b0010 	str	r0, [fp, #-16]
100103ec:	e50b1014 	str	r1, [fp, #-20]
100103f0:	e50b2018 	str	r2, [fp, #-24]
100103f4:	e50b301c 	str	r3, [fp, #-28]
    struct rt_serial_device *serial;
	//rt_kprintf("&x\r\n",dev->open_flag);

    RT_ASSERT(dev != RT_NULL);
100103f8:	e51b3010 	ldr	r3, [fp, #-16]
100103fc:	e3530000 	cmp	r3, #0
10010400:	1a000005 	bne	1001041c <rt_serial_read+0x40>
10010404:	e30f07f0 	movw	r0, #63472	; 0xf7f0
10010408:	e3410001 	movt	r0, #4097	; 0x1001
1001040c:	e30f1894 	movw	r1, #63636	; 0xf894
10010410:	e3411001 	movt	r1, #4097	; 0x1001
10010414:	e3a02f66 	mov	r2, #408	; 0x198
10010418:	ebffd86a 	bl	100065c8 <rt_assert_handler>
    if (size == 0) return 0;
1001041c:	e51b301c 	ldr	r3, [fp, #-28]
10010420:	e3530000 	cmp	r3, #0
10010424:	1a000001 	bne	10010430 <rt_serial_read+0x54>
10010428:	e3a03000 	mov	r3, #0
1001042c:	ea00001f 	b	100104b0 <rt_serial_read+0xd4>

    serial = (struct rt_serial_device *)dev;
10010430:	e51b3010 	ldr	r3, [fp, #-16]
10010434:	e50b3008 	str	r3, [fp, #-8]
    if (dev->open_flag & RT_DEVICE_FLAG_INT_RX)
10010438:	e51b3010 	ldr	r3, [fp, #-16]
1001043c:	e1d331b4 	ldrh	r3, [r3, #20]
10010440:	e2033c01 	and	r3, r3, #256	; 0x100
10010444:	e3530000 	cmp	r3, #0
10010448:	0a000006 	beq	10010468 <rt_serial_read+0x8c>
    {
        return _serial_int_rx(serial, buffer, size);
1001044c:	e51b301c 	ldr	r3, [fp, #-28]
10010450:	e51b0008 	ldr	r0, [fp, #-8]
10010454:	e51b1018 	ldr	r1, [fp, #-24]
10010458:	e1a02003 	mov	r2, r3
1001045c:	ebfffd1e 	bl	1000f8dc <_serial_int_rx>
10010460:	e1a03000 	mov	r3, r0
10010464:	ea000011 	b	100104b0 <rt_serial_read+0xd4>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_RX)
10010468:	e51b3010 	ldr	r3, [fp, #-16]
1001046c:	e1d331b4 	ldrh	r3, [r3, #20]
10010470:	e2033c02 	and	r3, r3, #512	; 0x200
10010474:	e3530000 	cmp	r3, #0
10010478:	0a000006 	beq	10010498 <rt_serial_read+0xbc>
    {
        return _serial_dma_rx(serial, buffer, size);
1001047c:	e51b301c 	ldr	r3, [fp, #-28]
10010480:	e51b0008 	ldr	r0, [fp, #-8]
10010484:	e51b1018 	ldr	r1, [fp, #-24]
10010488:	e1a02003 	mov	r2, r3
1001048c:	ebfffda6 	bl	1000fb2c <_serial_dma_rx>
10010490:	e1a03000 	mov	r3, r0
10010494:	ea000005 	b	100104b0 <rt_serial_read+0xd4>
    }

    return _serial_poll_rx(serial, buffer, size);
10010498:	e51b301c 	ldr	r3, [fp, #-28]
1001049c:	e51b0008 	ldr	r0, [fp, #-8]
100104a0:	e51b1018 	ldr	r1, [fp, #-24]
100104a4:	e1a02003 	mov	r2, r3
100104a8:	ebfffca4 	bl	1000f740 <_serial_poll_rx>
100104ac:	e1a03000 	mov	r3, r0
}
100104b0:	e1a00003 	mov	r0, r3
100104b4:	e24bd004 	sub	sp, fp, #4
100104b8:	e8bd8800 	pop	{fp, pc}

100104bc <rt_serial_write>:

static rt_size_t rt_serial_write(struct rt_device *dev,
                                 rt_off_t          pos,
                                 const void       *buffer,
                                 rt_size_t         size)
{
100104bc:	e92d4800 	push	{fp, lr}
100104c0:	e28db004 	add	fp, sp, #4
100104c4:	e24dd018 	sub	sp, sp, #24
100104c8:	e50b0010 	str	r0, [fp, #-16]
100104cc:	e50b1014 	str	r1, [fp, #-20]
100104d0:	e50b2018 	str	r2, [fp, #-24]
100104d4:	e50b301c 	str	r3, [fp, #-28]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
100104d8:	e51b3010 	ldr	r3, [fp, #-16]
100104dc:	e3530000 	cmp	r3, #0
100104e0:	1a000005 	bne	100104fc <rt_serial_write+0x40>
100104e4:	e30f07f0 	movw	r0, #63472	; 0xf7f0
100104e8:	e3410001 	movt	r0, #4097	; 0x1001
100104ec:	e30f18d4 	movw	r1, #63700	; 0xf8d4
100104f0:	e3411001 	movt	r1, #4097	; 0x1001
100104f4:	e30021af 	movw	r2, #431	; 0x1af
100104f8:	ebffd832 	bl	100065c8 <rt_assert_handler>
    if (size == 0) return 0;
100104fc:	e51b301c 	ldr	r3, [fp, #-28]
10010500:	e3530000 	cmp	r3, #0
10010504:	1a000001 	bne	10010510 <rt_serial_write+0x54>
10010508:	e3a03000 	mov	r3, #0
1001050c:	ea00001f 	b	10010590 <rt_serial_write+0xd4>

    serial = (struct rt_serial_device *)dev;
10010510:	e51b3010 	ldr	r3, [fp, #-16]
10010514:	e50b3008 	str	r3, [fp, #-8]

    if (dev->open_flag & RT_DEVICE_FLAG_INT_TX)
10010518:	e51b3010 	ldr	r3, [fp, #-16]
1001051c:	e1d331b4 	ldrh	r3, [r3, #20]
10010520:	e2033b01 	and	r3, r3, #1024	; 0x400
10010524:	e3530000 	cmp	r3, #0
10010528:	0a000006 	beq	10010548 <rt_serial_write+0x8c>
    {
        return _serial_int_tx(serial, buffer, size);
1001052c:	e51b301c 	ldr	r3, [fp, #-28]
10010530:	e51b0008 	ldr	r0, [fp, #-8]
10010534:	e51b1018 	ldr	r1, [fp, #-24]
10010538:	e1a02003 	mov	r2, r3
1001053c:	ebfffd3d 	bl	1000fa38 <_serial_int_tx>
10010540:	e1a03000 	mov	r3, r0
10010544:	ea000011 	b	10010590 <rt_serial_write+0xd4>
    }
    else if (dev->open_flag & RT_DEVICE_FLAG_DMA_TX)
10010548:	e51b3010 	ldr	r3, [fp, #-16]
1001054c:	e1d331b4 	ldrh	r3, [r3, #20]
10010550:	e2033b02 	and	r3, r3, #2048	; 0x800
10010554:	e3530000 	cmp	r3, #0
10010558:	0a000006 	beq	10010578 <rt_serial_write+0xbc>
    {
        return _serial_dma_tx(serial, buffer, size);
1001055c:	e51b301c 	ldr	r3, [fp, #-28]
10010560:	e51b0008 	ldr	r0, [fp, #-8]
10010564:	e51b1018 	ldr	r1, [fp, #-24]
10010568:	e1a02003 	mov	r2, r3
1001056c:	ebfffda6 	bl	1000fc0c <_serial_dma_tx>
10010570:	e1a03000 	mov	r3, r0
10010574:	ea000005 	b	10010590 <rt_serial_write+0xd4>
    }
    else
    {
        return _serial_poll_tx(serial, buffer, size);
10010578:	e51b301c 	ldr	r3, [fp, #-28]
1001057c:	e51b0008 	ldr	r0, [fp, #-8]
10010580:	e51b1018 	ldr	r1, [fp, #-24]
10010584:	e1a02003 	mov	r2, r3
10010588:	ebfffc9b 	bl	1000f7fc <_serial_poll_tx>
1001058c:	e1a03000 	mov	r3, r0
    }
}
10010590:	e1a00003 	mov	r0, r3
10010594:	e24bd004 	sub	sp, fp, #4
10010598:	e8bd8800 	pop	{fp, pc}

1001059c <rt_serial_control>:

static rt_err_t rt_serial_control(struct rt_device *dev,
                                  rt_uint8_t        cmd,
                                  void             *args)
{
1001059c:	e92d4800 	push	{fp, lr}
100105a0:	e28db004 	add	fp, sp, #4
100105a4:	e24dd018 	sub	sp, sp, #24
100105a8:	e50b0010 	str	r0, [fp, #-16]
100105ac:	e1a03001 	mov	r3, r1
100105b0:	e50b2018 	str	r2, [fp, #-24]
100105b4:	e54b3011 	strb	r3, [fp, #-17]
    struct rt_serial_device *serial;

    RT_ASSERT(dev != RT_NULL);
100105b8:	e51b3010 	ldr	r3, [fp, #-16]
100105bc:	e3530000 	cmp	r3, #0
100105c0:	1a000005 	bne	100105dc <rt_serial_control+0x40>
100105c4:	e30f07f0 	movw	r0, #63472	; 0xf7f0
100105c8:	e3410001 	movt	r0, #4097	; 0x1001
100105cc:	e30f1904 	movw	r1, #63748	; 0xf904
100105d0:	e3411001 	movt	r1, #4097	; 0x1001
100105d4:	e3a02f72 	mov	r2, #456	; 0x1c8
100105d8:	ebffd7fa 	bl	100065c8 <rt_assert_handler>
    serial = (struct rt_serial_device *)dev;
100105dc:	e51b3010 	ldr	r3, [fp, #-16]
100105e0:	e50b3008 	str	r3, [fp, #-8]

    switch (cmd)
100105e4:	e55b3011 	ldrb	r3, [fp, #-17]
100105e8:	e3530002 	cmp	r3, #2
100105ec:	0a000004 	beq	10010604 <rt_serial_control+0x68>
100105f0:	e3530003 	cmp	r3, #3
100105f4:	0a000010 	beq	1001063c <rt_serial_control+0xa0>
100105f8:	e3530001 	cmp	r3, #1
100105fc:	0a000007 	beq	10010620 <rt_serial_control+0x84>
10010600:	ea000014 	b	10010658 <rt_serial_control+0xbc>
    {
        case RT_DEVICE_CTRL_SUSPEND:
            /* suspend device */
            dev->flag |= RT_DEVICE_FLAG_SUSPENDED;
10010604:	e51b3010 	ldr	r3, [fp, #-16]
10010608:	e1d331b2 	ldrh	r3, [r3, #18]
1001060c:	e3833020 	orr	r3, r3, #32
10010610:	e6ff2073 	uxth	r2, r3
10010614:	e51b3010 	ldr	r3, [fp, #-16]
10010618:	e1c321b2 	strh	r2, [r3, #18]
            break;
1001061c:	ea000016 	b	1001067c <rt_serial_control+0xe0>

        case RT_DEVICE_CTRL_RESUME:
            /* resume device */
            dev->flag &= ~RT_DEVICE_FLAG_SUSPENDED;
10010620:	e51b3010 	ldr	r3, [fp, #-16]
10010624:	e1d331b2 	ldrh	r3, [r3, #18]
10010628:	e3c33020 	bic	r3, r3, #32
1001062c:	e6ff2073 	uxth	r2, r3
10010630:	e51b3010 	ldr	r3, [fp, #-16]
10010634:	e1c321b2 	strh	r2, [r3, #18]
            break;
10010638:	ea00000f 	b	1001067c <rt_serial_control+0xe0>

        case RT_DEVICE_CTRL_CONFIG:
            /* configure device */
            serial->ops->configure(serial, (struct serial_configure *)args);
1001063c:	e51b3008 	ldr	r3, [fp, #-8]
10010640:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010644:	e5933000 	ldr	r3, [r3]
10010648:	e51b0008 	ldr	r0, [fp, #-8]
1001064c:	e51b1018 	ldr	r1, [fp, #-24]
10010650:	e12fff33 	blx	r3
            break;
10010654:	ea000008 	b	1001067c <rt_serial_control+0xe0>

        default :
            /* control device */
            serial->ops->control(serial, cmd, args);
10010658:	e51b3008 	ldr	r3, [fp, #-8]
1001065c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010660:	e5933004 	ldr	r3, [r3, #4]
10010664:	e55b2011 	ldrb	r2, [fp, #-17]
10010668:	e51b0008 	ldr	r0, [fp, #-8]
1001066c:	e1a01002 	mov	r1, r2
10010670:	e51b2018 	ldr	r2, [fp, #-24]
10010674:	e12fff33 	blx	r3
            break;
10010678:	e1a00000 	nop			; (mov r0, r0)
    }

    return RT_EOK;
1001067c:	e3a03000 	mov	r3, #0
}
10010680:	e1a00003 	mov	r0, r3
10010684:	e24bd004 	sub	sp, fp, #4
10010688:	e8bd8800 	pop	{fp, pc}

1001068c <rt_hw_serial_register>:
 */
rt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
                               const char              *name,
                               rt_uint32_t              flag,
                               void                    *data)
{
1001068c:	e92d4800 	push	{fp, lr}
10010690:	e28db004 	add	fp, sp, #4
10010694:	e24dd018 	sub	sp, sp, #24
10010698:	e50b0010 	str	r0, [fp, #-16]
1001069c:	e50b1014 	str	r1, [fp, #-20]
100106a0:	e50b2018 	str	r2, [fp, #-24]
100106a4:	e50b301c 	str	r3, [fp, #-28]
    struct rt_device *device;
    RT_ASSERT(serial != RT_NULL);
100106a8:	e51b3010 	ldr	r3, [fp, #-16]
100106ac:	e3530000 	cmp	r3, #0
100106b0:	1a000005 	bne	100106cc <rt_hw_serial_register+0x40>
100106b4:	e30f0778 	movw	r0, #63352	; 0xf778
100106b8:	e3410001 	movt	r0, #4097	; 0x1001
100106bc:	e30f1918 	movw	r1, #63768	; 0xf918
100106c0:	e3411001 	movt	r1, #4097	; 0x1001
100106c4:	e30021ee 	movw	r2, #494	; 0x1ee
100106c8:	ebffd7be 	bl	100065c8 <rt_assert_handler>

    device = &(serial->parent);
100106cc:	e51b3010 	ldr	r3, [fp, #-16]
100106d0:	e50b3008 	str	r3, [fp, #-8]

    device->type        = RT_Device_Class_Char;
100106d4:	e51b3008 	ldr	r3, [fp, #-8]
100106d8:	e3a02000 	mov	r2, #0
100106dc:	e5c32010 	strb	r2, [r3, #16]
    device->rx_indicate = RT_NULL;
100106e0:	e51b3008 	ldr	r3, [fp, #-8]
100106e4:	e3a02000 	mov	r2, #0
100106e8:	e5832018 	str	r2, [r3, #24]
    device->tx_complete = RT_NULL;
100106ec:	e51b3008 	ldr	r3, [fp, #-8]
100106f0:	e3a02000 	mov	r2, #0
100106f4:	e583201c 	str	r2, [r3, #28]

    device->init        = rt_serial_init;
100106f8:	e51b2008 	ldr	r2, [fp, #-8]
100106fc:	e30f3cdc 	movw	r3, #64732	; 0xfcdc
10010700:	e3413000 	movt	r3, #4096	; 0x1000
10010704:	e5823020 	str	r3, [r2, #32]
    device->open        = rt_serial_open;
10010708:	e51b2008 	ldr	r2, [fp, #-8]
1001070c:	e30f3d90 	movw	r3, #64912	; 0xfd90
10010710:	e3413000 	movt	r3, #4096	; 0x1000
10010714:	e5823024 	str	r3, [r2, #36]	; 0x24
    device->close       = rt_serial_close;
10010718:	e51b2008 	ldr	r2, [fp, #-8]
1001071c:	e3003178 	movw	r3, #376	; 0x178
10010720:	e3413001 	movt	r3, #4097	; 0x1001
10010724:	e5823028 	str	r3, [r2, #40]	; 0x28
    device->read        = rt_serial_read;
10010728:	e51b2008 	ldr	r2, [fp, #-8]
1001072c:	e30033dc 	movw	r3, #988	; 0x3dc
10010730:	e3413001 	movt	r3, #4097	; 0x1001
10010734:	e582302c 	str	r3, [r2, #44]	; 0x2c
    device->write       = rt_serial_write;
10010738:	e51b2008 	ldr	r2, [fp, #-8]
1001073c:	e30034bc 	movw	r3, #1212	; 0x4bc
10010740:	e3413001 	movt	r3, #4097	; 0x1001
10010744:	e5823030 	str	r3, [r2, #48]	; 0x30
    device->control     = rt_serial_control;
10010748:	e51b2008 	ldr	r2, [fp, #-8]
1001074c:	e300359c 	movw	r3, #1436	; 0x59c
10010750:	e3413001 	movt	r3, #4097	; 0x1001
10010754:	e5823034 	str	r3, [r2, #52]	; 0x34
    device->user_data   = data;
10010758:	e51b3008 	ldr	r3, [fp, #-8]
1001075c:	e51b201c 	ldr	r2, [fp, #-28]
10010760:	e5832038 	str	r2, [r3, #56]	; 0x38

    /* register a character device */
    return rt_device_register(device, name, flag);
10010764:	e51b3018 	ldr	r3, [fp, #-24]
10010768:	e6ff3073 	uxth	r3, r3
1001076c:	e51b0008 	ldr	r0, [fp, #-8]
10010770:	e51b1014 	ldr	r1, [fp, #-20]
10010774:	e1a02003 	mov	r2, r3
10010778:	ebffc1a8 	bl	10000e20 <rt_device_register>
1001077c:	e1a03000 	mov	r3, r0
}
10010780:	e1a00003 	mov	r0, r3
10010784:	e24bd004 	sub	sp, fp, #4
10010788:	e8bd8800 	pop	{fp, pc}

1001078c <rt_hw_serial_isr>:

/* ISR for serial interrupt */
void rt_hw_serial_isr(struct rt_serial_device *serial, int event)
{
1001078c:	e92d4800 	push	{fp, lr}
10010790:	e28db004 	add	fp, sp, #4
10010794:	e24dd038 	sub	sp, sp, #56	; 0x38
10010798:	e50b0038 	str	r0, [fp, #-56]	; 0x38
1001079c:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
    switch (event & 0xff)
100107a0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
100107a4:	e6ef3073 	uxtb	r3, r3
100107a8:	e2433001 	sub	r3, r3, #1
100107ac:	e3530003 	cmp	r3, #3
100107b0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
100107b4:	ea0000d3 	b	10010b08 <rt_hw_serial_isr+0x37c>
100107b8:	100107c8 	.word	0x100107c8
100107bc:	100109d4 	.word	0x100109d4
100107c0:	10010ac4 	.word	0x10010ac4
100107c4:	100109f0 	.word	0x100109f0
    {
        case RT_SERIAL_EVENT_RX_IND:
        {
            int ch = -1;
100107c8:	e3e03000 	mvn	r3, #0
100107cc:	e50b3008 	str	r3, [fp, #-8]
            rt_base_t level;
            struct rt_serial_rx_fifo* rx_fifo;

            rx_fifo = (struct rt_serial_rx_fifo*)serial->serial_rx;
100107d0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100107d4:	e5933048 	ldr	r3, [r3, #72]	; 0x48
100107d8:	e50b300c 	str	r3, [fp, #-12]
            RT_ASSERT(rx_fifo != RT_NULL);
100107dc:	e51b300c 	ldr	r3, [fp, #-12]
100107e0:	e3530000 	cmp	r3, #0
100107e4:	1a000005 	bne	10010800 <rt_hw_serial_isr+0x74>
100107e8:	e30f078c 	movw	r0, #63372	; 0xf78c
100107ec:	e3410001 	movt	r0, #4097	; 0x1001
100107f0:	e30f1930 	movw	r1, #63792	; 0xf930
100107f4:	e3411001 	movt	r1, #4097	; 0x1001
100107f8:	e300220e 	movw	r2, #526	; 0x20e
100107fc:	ebffd771 	bl	100065c8 <rt_assert_handler>
            
            /* interrupt mode receive */
            RT_ASSERT(serial->parent.open_flag & RT_DEVICE_FLAG_INT_RX);
10010800:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010804:	e1d331b4 	ldrh	r3, [r3, #20]
10010808:	e2033c01 	and	r3, r3, #256	; 0x100
1001080c:	e3530000 	cmp	r3, #0
10010810:	1a000005 	bne	1001082c <rt_hw_serial_isr+0xa0>
10010814:	e30f0830 	movw	r0, #63536	; 0xf830
10010818:	e3410001 	movt	r0, #4097	; 0x1001
1001081c:	e30f1930 	movw	r1, #63792	; 0xf930
10010820:	e3411001 	movt	r1, #4097	; 0x1001
10010824:	e3002211 	movw	r2, #529	; 0x211
10010828:	ebffd766 	bl	100065c8 <rt_assert_handler>
            
            while (1)
            {
                ch = serial->ops->getc(serial);
1001082c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010830:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010834:	e593300c 	ldr	r3, [r3, #12]
10010838:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
1001083c:	e12fff33 	blx	r3
10010840:	e50b0008 	str	r0, [fp, #-8]
                if (ch == -1) break;
10010844:	e51b3008 	ldr	r3, [fp, #-8]
10010848:	e3730001 	cmn	r3, #1
1001084c:	1a000005 	bne	10010868 <rt_hw_serial_isr+0xdc>
10010850:	e1a00000 	nop			; (mov r0, r0)
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
            }
            
            /* invoke callback */
            if (serial->parent.rx_indicate != RT_NULL)
10010854:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010858:	e5933018 	ldr	r3, [r3, #24]
1001085c:	e3530000 	cmp	r3, #0
10010860:	0a00005a 	beq	100109d0 <rt_hw_serial_isr+0x244>
10010864:	ea000034 	b	1001093c <rt_hw_serial_isr+0x1b0>
            {
                ch = serial->ops->getc(serial);
                if (ch == -1) break;
                
                /* disable interrupt */
                level = rt_hw_interrupt_disable();
10010868:	ebffeb13 	bl	1000b4bc <rt_hw_interrupt_disable>
1001086c:	e50b0010 	str	r0, [fp, #-16]
                
                rx_fifo->buffer[rx_fifo->put_index] = ch;
10010870:	e51b300c 	ldr	r3, [fp, #-12]
10010874:	e5933000 	ldr	r3, [r3]
10010878:	e51b200c 	ldr	r2, [fp, #-12]
1001087c:	e1d220b4 	ldrh	r2, [r2, #4]
10010880:	e0833002 	add	r3, r3, r2
10010884:	e51b2008 	ldr	r2, [fp, #-8]
10010888:	e6ef2072 	uxtb	r2, r2
1001088c:	e5c32000 	strb	r2, [r3]
                rx_fifo->put_index += 1;
10010890:	e51b300c 	ldr	r3, [fp, #-12]
10010894:	e1d330b4 	ldrh	r3, [r3, #4]
10010898:	e2833001 	add	r3, r3, #1
1001089c:	e6ff2073 	uxth	r2, r3
100108a0:	e51b300c 	ldr	r3, [fp, #-12]
100108a4:	e1c320b4 	strh	r2, [r3, #4]
                if (rx_fifo->put_index >= serial->config.bufsz) rx_fifo->put_index = 0;
100108a8:	e51b300c 	ldr	r3, [fp, #-12]
100108ac:	e1d320b4 	ldrh	r2, [r3, #4]
100108b0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100108b4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
100108b8:	e7ef3553 	ubfx	r3, r3, #10, #16
100108bc:	e6ff3073 	uxth	r3, r3
100108c0:	e1520003 	cmp	r2, r3
100108c4:	3a000002 	bcc	100108d4 <rt_hw_serial_isr+0x148>
100108c8:	e51b300c 	ldr	r3, [fp, #-12]
100108cc:	e3a02000 	mov	r2, #0
100108d0:	e1c320b4 	strh	r2, [r3, #4]
                
                /* if the next position is read index, discard this 'read char' */
                if (rx_fifo->put_index == rx_fifo->get_index)
100108d4:	e51b300c 	ldr	r3, [fp, #-12]
100108d8:	e1d320b4 	ldrh	r2, [r3, #4]
100108dc:	e51b300c 	ldr	r3, [fp, #-12]
100108e0:	e1d330b6 	ldrh	r3, [r3, #6]
100108e4:	e1520003 	cmp	r2, r3
100108e8:	1a000010 	bne	10010930 <rt_hw_serial_isr+0x1a4>
                {
                    rx_fifo->get_index += 1;
100108ec:	e51b300c 	ldr	r3, [fp, #-12]
100108f0:	e1d330b6 	ldrh	r3, [r3, #6]
100108f4:	e2833001 	add	r3, r3, #1
100108f8:	e6ff2073 	uxth	r2, r3
100108fc:	e51b300c 	ldr	r3, [fp, #-12]
10010900:	e1c320b6 	strh	r2, [r3, #6]
                    if (rx_fifo->get_index >= serial->config.bufsz) rx_fifo->get_index = 0;
10010904:	e51b300c 	ldr	r3, [fp, #-12]
10010908:	e1d320b6 	ldrh	r2, [r3, #6]
1001090c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010910:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10010914:	e7ef3553 	ubfx	r3, r3, #10, #16
10010918:	e6ff3073 	uxth	r3, r3
1001091c:	e1520003 	cmp	r2, r3
10010920:	3a000002 	bcc	10010930 <rt_hw_serial_isr+0x1a4>
10010924:	e51b300c 	ldr	r3, [fp, #-12]
10010928:	e3a02000 	mov	r2, #0
1001092c:	e1c320b6 	strh	r2, [r3, #6]
                }
                
                /* enable interrupt */
                rt_hw_interrupt_enable(level);
10010930:	e51b0010 	ldr	r0, [fp, #-16]
10010934:	ebffeae4 	bl	1000b4cc <rt_hw_interrupt_enable>
            }
10010938:	eaffffbb 	b	1001082c <rt_hw_serial_isr+0xa0>
            if (serial->parent.rx_indicate != RT_NULL)
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
1001093c:	ebffeade 	bl	1000b4bc <rt_hw_interrupt_disable>
10010940:	e50b0010 	str	r0, [fp, #-16]
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
10010944:	e51b300c 	ldr	r3, [fp, #-12]
10010948:	e1d320b4 	ldrh	r2, [r3, #4]
1001094c:	e51b300c 	ldr	r3, [fp, #-12]
10010950:	e1d330b6 	ldrh	r3, [r3, #6]
10010954:	e1520003 	cmp	r2, r3
10010958:	3a000006 	bcc	10010978 <rt_hw_serial_isr+0x1ec>
1001095c:	e51b300c 	ldr	r3, [fp, #-12]
10010960:	e1d330b4 	ldrh	r3, [r3, #4]
10010964:	e1a02003 	mov	r2, r3
10010968:	e51b300c 	ldr	r3, [fp, #-12]
1001096c:	e1d330b6 	ldrh	r3, [r3, #6]
10010970:	e0633002 	rsb	r3, r3, r2
10010974:	ea00000b 	b	100109a8 <rt_hw_serial_isr+0x21c>
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
10010978:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1001097c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
10010980:	e7ef3553 	ubfx	r3, r3, #10, #16
10010984:	e6ff3073 	uxth	r3, r3
10010988:	e1a02003 	mov	r2, r3
1001098c:	e51b300c 	ldr	r3, [fp, #-12]
10010990:	e1d330b4 	ldrh	r3, [r3, #4]
10010994:	e1a01003 	mov	r1, r3
10010998:	e51b300c 	ldr	r3, [fp, #-12]
1001099c:	e1d330b6 	ldrh	r3, [r3, #6]
100109a0:	e0633001 	rsb	r3, r3, r1
100109a4:	e0823003 	add	r3, r2, r3
            {
                rt_size_t rx_length;
            
                /* get rx length */
                level = rt_hw_interrupt_disable();
                rx_length = (rx_fifo->put_index >= rx_fifo->get_index)? (rx_fifo->put_index - rx_fifo->get_index):
100109a8:	e50b3014 	str	r3, [fp, #-20]
                    (serial->config.bufsz - (rx_fifo->get_index - rx_fifo->put_index));
                rt_hw_interrupt_enable(level);
100109ac:	e51b0010 	ldr	r0, [fp, #-16]
100109b0:	ebffeac5 	bl	1000b4cc <rt_hw_interrupt_enable>

                serial->parent.rx_indicate(&serial->parent, rx_length);
100109b4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100109b8:	e5933018 	ldr	r3, [r3, #24]
100109bc:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
100109c0:	e1a00002 	mov	r0, r2
100109c4:	e51b1014 	ldr	r1, [fp, #-20]
100109c8:	e12fff33 	blx	r3
            }
            break;
100109cc:	ea00004d 	b	10010b08 <rt_hw_serial_isr+0x37c>
100109d0:	ea00004c 	b	10010b08 <rt_hw_serial_isr+0x37c>
        }
        case RT_SERIAL_EVENT_TX_DONE:
        {
            struct rt_serial_tx_fifo* tx_fifo;

            tx_fifo = (struct rt_serial_tx_fifo*)serial->serial_tx;
100109d4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100109d8:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
100109dc:	e50b3018 	str	r3, [fp, #-24]
            rt_completion_done(&(tx_fifo->completion));
100109e0:	e51b3018 	ldr	r3, [fp, #-24]
100109e4:	e1a00003 	mov	r0, r3
100109e8:	ebfff8c4 	bl	1000ed00 <rt_completion_done>
            break;
100109ec:	ea000045 	b	10010b08 <rt_hw_serial_isr+0x37c>
            const void *data_ptr;
            rt_size_t data_size;
            const void *last_data_ptr;
            struct rt_serial_tx_dma* tx_dma;

            tx_dma = (struct rt_serial_tx_dma*) serial->serial_tx;
100109f0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
100109f4:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
100109f8:	e50b301c 	str	r3, [fp, #-28]
            
            rt_data_queue_pop(&(tx_dma->data_queue), &last_data_ptr, &data_size, 0);
100109fc:	e51b301c 	ldr	r3, [fp, #-28]
10010a00:	e2831004 	add	r1, r3, #4
10010a04:	e24b2030 	sub	r2, fp, #48	; 0x30
10010a08:	e24b302c 	sub	r3, fp, #44	; 0x2c
10010a0c:	e1a00001 	mov	r0, r1
10010a10:	e1a01002 	mov	r1, r2
10010a14:	e1a02003 	mov	r2, r3
10010a18:	e3a03000 	mov	r3, #0
10010a1c:	ebfff9fd 	bl	1000f218 <rt_data_queue_pop>
            if (rt_data_queue_peak(&(tx_dma->data_queue), &data_ptr, &data_size) == RT_EOK)
10010a20:	e51b301c 	ldr	r3, [fp, #-28]
10010a24:	e2831004 	add	r1, r3, #4
10010a28:	e24b2028 	sub	r2, fp, #40	; 0x28
10010a2c:	e24b302c 	sub	r3, fp, #44	; 0x2c
10010a30:	e1a00001 	mov	r0, r1
10010a34:	e1a01002 	mov	r1, r2
10010a38:	e1a02003 	mov	r2, r3
10010a3c:	ebfffac8 	bl	1000f564 <rt_data_queue_peak>
10010a40:	e1a03000 	mov	r3, r0
10010a44:	e3530000 	cmp	r3, #0
10010a48:	1a00000d 	bne	10010a84 <rt_hw_serial_isr+0x2f8>
            {
                /* transmit next data node */
                tx_dma->activated = RT_TRUE;
10010a4c:	e51b301c 	ldr	r3, [fp, #-28]
10010a50:	e3a02001 	mov	r2, #1
10010a54:	e5832000 	str	r2, [r3]
                serial->ops->dma_transmit(serial, data_ptr, data_size, RT_SERIAL_DMA_TX);
10010a58:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010a5c:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
10010a60:	e593c010 	ldr	ip, [r3, #16]
10010a64:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10010a68:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
10010a6c:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
10010a70:	e1a01002 	mov	r1, r2
10010a74:	e1a02003 	mov	r2, r3
10010a78:	e3a03002 	mov	r3, #2
10010a7c:	e12fff3c 	blx	ip
10010a80:	ea000002 	b	10010a90 <rt_hw_serial_isr+0x304>
            }
            else
            {
                tx_dma->activated = RT_FALSE;
10010a84:	e51b301c 	ldr	r3, [fp, #-28]
10010a88:	e3a02000 	mov	r2, #0
10010a8c:	e5832000 	str	r2, [r3]
            }
            
            /* invoke callback */
            if (serial->parent.tx_complete != RT_NULL)
10010a90:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010a94:	e593301c 	ldr	r3, [r3, #28]
10010a98:	e3530000 	cmp	r3, #0
10010a9c:	0a000006 	beq	10010abc <rt_hw_serial_isr+0x330>
            {
                serial->parent.tx_complete(&serial->parent, (void*)last_data_ptr);
10010aa0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010aa4:	e593301c 	ldr	r3, [r3, #28]
10010aa8:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
10010aac:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
10010ab0:	e1a00001 	mov	r0, r1
10010ab4:	e1a01002 	mov	r1, r2
10010ab8:	e12fff33 	blx	r3
            }
            break;
10010abc:	e1a00000 	nop			; (mov r0, r0)
10010ac0:	ea000010 	b	10010b08 <rt_hw_serial_isr+0x37c>
        case RT_SERIAL_EVENT_RX_DMADONE:
        {
            int length;
            struct rt_serial_rx_dma* rx_dma;

            rx_dma = (struct rt_serial_rx_dma*)serial->serial_rx;
10010ac4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010ac8:	e5933048 	ldr	r3, [r3, #72]	; 0x48
10010acc:	e50b3020 	str	r3, [fp, #-32]
            /* get DMA rx length */
            length = (event & (~0xff)) >> 8;
10010ad0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
10010ad4:	e1a03443 	asr	r3, r3, #8
10010ad8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
            serial->parent.rx_indicate(&(serial->parent), length);
10010adc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
10010ae0:	e5933018 	ldr	r3, [r3, #24]
10010ae4:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
10010ae8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10010aec:	e1a00001 	mov	r0, r1
10010af0:	e1a01002 	mov	r1, r2
10010af4:	e12fff33 	blx	r3
            rx_dma->activated = RT_FALSE;
10010af8:	e51b3020 	ldr	r3, [fp, #-32]
10010afc:	e3a02000 	mov	r2, #0
10010b00:	e5832000 	str	r2, [r3]
            break;
10010b04:	e1a00000 	nop			; (mov r0, r0)
        }
    }
}
10010b08:	e24bd004 	sub	sp, fp, #4
10010b0c:	e8bd8800 	pop	{fp, pc}

10010b10 <finsh_get_prompt>:
#if defined(FINSH_USING_MSH) || (defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR))
#if defined(RT_USING_DFS)
#include <dfs_posix.h>
#endif
const char *finsh_get_prompt()
{
10010b10:	e92d4800 	push	{fp, lr}
10010b14:	e28db004 	add	fp, sp, #4
#define _MSH_PROMPT "msh "
#define _PROMPT     "finsh "
    static char finsh_prompt[RT_CONSOLEBUF_SIZE + 1] = {0};

#ifdef FINSH_USING_MSH
    if (msh_is_used()) strcpy(finsh_prompt, _MSH_PROMPT);
10010b18:	eb000a4e 	bl	10013458 <msh_is_used>
10010b1c:	e1a03000 	mov	r3, r0
10010b20:	e3530000 	cmp	r3, #0
10010b24:	0a000008 	beq	10010b4c <finsh_get_prompt+0x3c>
10010b28:	e3093cd4 	movw	r3, #40148	; 0x9cd4
10010b2c:	e3413002 	movt	r3, #4098	; 0x1002
10010b30:	e30f2944 	movw	r2, #63812	; 0xf944
10010b34:	e3412001 	movt	r2, #4097	; 0x1001
10010b38:	e8920003 	ldm	r2, {r0, r1}
10010b3c:	e5830000 	str	r0, [r3]
10010b40:	e2833004 	add	r3, r3, #4
10010b44:	e5c31000 	strb	r1, [r3]
10010b48:	ea00000a 	b	10010b78 <finsh_get_prompt+0x68>
    else
#endif
        strcpy(finsh_prompt, _PROMPT);
10010b4c:	e3093cd4 	movw	r3, #40148	; 0x9cd4
10010b50:	e3413002 	movt	r3, #4098	; 0x1002
10010b54:	e30f294c 	movw	r2, #63820	; 0xf94c
10010b58:	e3412001 	movt	r2, #4097	; 0x1001
10010b5c:	e8920003 	ldm	r2, {r0, r1}
10010b60:	e5830000 	str	r0, [r3]
10010b64:	e2833004 	add	r3, r3, #4
10010b68:	e1c310b0 	strh	r1, [r3]
10010b6c:	e2833002 	add	r3, r3, #2
10010b70:	e1a02821 	lsr	r2, r1, #16
10010b74:	e5c32000 	strb	r2, [r3]
#if defined(RT_USING_DFS) && defined(DFS_USING_WORKDIR)
    /* get current working directory */
    getcwd(&finsh_prompt[rt_strlen(finsh_prompt)], RT_CONSOLEBUF_SIZE - rt_strlen(finsh_prompt));
#endif

    strcat(finsh_prompt, ">");
10010b78:	e3090cd4 	movw	r0, #40148	; 0x9cd4
10010b7c:	e3410002 	movt	r0, #4098	; 0x1002
10010b80:	fa00343a 	blx	1001dc70 <strlen>
10010b84:	e1a03000 	mov	r3, r0
10010b88:	e1a02003 	mov	r2, r3
10010b8c:	e3093cd4 	movw	r3, #40148	; 0x9cd4
10010b90:	e3413002 	movt	r3, #4098	; 0x1002
10010b94:	e0822003 	add	r2, r2, r3
10010b98:	e30f3954 	movw	r3, #63828	; 0xf954
10010b9c:	e3413001 	movt	r3, #4097	; 0x1001
10010ba0:	e1d330b0 	ldrh	r3, [r3]
10010ba4:	e1c230b0 	strh	r3, [r2]

    return finsh_prompt;
10010ba8:	e3093cd4 	movw	r3, #40148	; 0x9cd4
10010bac:	e3413002 	movt	r3, #4098	; 0x1002
}
10010bb0:	e1a00003 	mov	r0, r3
10010bb4:	e8bd8800 	pop	{fp, pc}

10010bb8 <finsh_rx_ind>:
#endif

static rt_err_t finsh_rx_ind(rt_device_t dev, rt_size_t size)
{
10010bb8:	e92d4800 	push	{fp, lr}
10010bbc:	e28db004 	add	fp, sp, #4
10010bc0:	e24dd008 	sub	sp, sp, #8
10010bc4:	e50b0008 	str	r0, [fp, #-8]
10010bc8:	e50b100c 	str	r1, [fp, #-12]
    RT_ASSERT(shell != RT_NULL);
10010bcc:	e30a3654 	movw	r3, #42580	; 0xa654
10010bd0:	e3413002 	movt	r3, #4098	; 0x1002
10010bd4:	e5933000 	ldr	r3, [r3]
10010bd8:	e3530000 	cmp	r3, #0
10010bdc:	1a000005 	bne	10010bf8 <finsh_rx_ind+0x40>
10010be0:	e30f0958 	movw	r0, #63832	; 0xf958
10010be4:	e3410001 	movt	r0, #4097	; 0x1001
10010be8:	e30f1a18 	movw	r1, #64024	; 0xfa18
10010bec:	e3411001 	movt	r1, #4097	; 0x1001
10010bf0:	e3a02056 	mov	r2, #86	; 0x56
10010bf4:	ebffd673 	bl	100065c8 <rt_assert_handler>

    /* release semaphore to let finsh thread rx data */
    rt_sem_release(&shell->rx_sem);
10010bf8:	e30a3654 	movw	r3, #42580	; 0xa654
10010bfc:	e3413002 	movt	r3, #4098	; 0x1002
10010c00:	e5933000 	ldr	r3, [r3]
10010c04:	e1a00003 	mov	r0, r3
10010c08:	ebffc4db 	bl	10001f7c <rt_sem_release>

    return RT_EOK;
10010c0c:	e3a03000 	mov	r3, #0
}
10010c10:	e1a00003 	mov	r0, r3
10010c14:	e24bd004 	sub	sp, fp, #4
10010c18:	e8bd8800 	pop	{fp, pc}

10010c1c <finsh_set_device>:
 * This function sets the input device of finsh shell.
 *
 * @param device_name the name of new input device.
 */
void finsh_set_device(const char *device_name)
{
10010c1c:	e92d4800 	push	{fp, lr}
10010c20:	e28db004 	add	fp, sp, #4
10010c24:	e24dd010 	sub	sp, sp, #16
10010c28:	e50b0010 	str	r0, [fp, #-16]
    rt_device_t dev = RT_NULL;
10010c2c:	e3a03000 	mov	r3, #0
10010c30:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(shell != RT_NULL);
10010c34:	e30a3654 	movw	r3, #42580	; 0xa654
10010c38:	e3413002 	movt	r3, #4098	; 0x1002
10010c3c:	e5933000 	ldr	r3, [r3]
10010c40:	e3530000 	cmp	r3, #0
10010c44:	1a000005 	bne	10010c60 <finsh_set_device+0x44>
10010c48:	e30f0958 	movw	r0, #63832	; 0xf958
10010c4c:	e3410001 	movt	r0, #4097	; 0x1001
10010c50:	e30f1a28 	movw	r1, #64040	; 0xfa28
10010c54:	e3411001 	movt	r1, #4097	; 0x1001
10010c58:	e3a02069 	mov	r2, #105	; 0x69
10010c5c:	ebffd659 	bl	100065c8 <rt_assert_handler>
    dev = rt_device_find(device_name);
10010c60:	e51b0010 	ldr	r0, [fp, #-16]
10010c64:	ebffc0aa 	bl	10000f14 <rt_device_find>
10010c68:	e50b0008 	str	r0, [fp, #-8]
    if (dev == RT_NULL)
10010c6c:	e51b3008 	ldr	r3, [fp, #-8]
10010c70:	e3530000 	cmp	r3, #0
10010c74:	1a000004 	bne	10010c8c <finsh_set_device+0x70>
    {
        rt_kprintf("finsh: can not find device: %s\n", device_name);
10010c78:	e30f096c 	movw	r0, #63852	; 0xf96c
10010c7c:	e3410001 	movt	r0, #4097	; 0x1001
10010c80:	e51b1010 	ldr	r1, [fp, #-16]
10010c84:	ebffd592 	bl	100062d4 <rt_kprintf>
        return;
10010c88:	ea00003b 	b	10010d7c <finsh_set_device+0x160>
    }

    /* check whether it's a same device */
    if (dev == shell->device) return;
10010c8c:	e30a3654 	movw	r3, #42580	; 0xa654
10010c90:	e3413002 	movt	r3, #4098	; 0x1002
10010c94:	e5933000 	ldr	r3, [r3]
10010c98:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
10010c9c:	e51b3008 	ldr	r3, [fp, #-8]
10010ca0:	e1520003 	cmp	r2, r3
10010ca4:	1a000000 	bne	10010cac <finsh_set_device+0x90>
10010ca8:	ea000033 	b	10010d7c <finsh_set_device+0x160>
    /* open this device and set the new device in finsh shell */
    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_INT_RX | \
10010cac:	e51b0008 	ldr	r0, [fp, #-8]
10010cb0:	e3001143 	movw	r1, #323	; 0x143
10010cb4:	ebffc0fa 	bl	100010a4 <rt_device_open>
10010cb8:	e1a03000 	mov	r3, r0
10010cbc:	e3530000 	cmp	r3, #0
10010cc0:	1a00002d 	bne	10010d7c <finsh_set_device+0x160>
                       RT_DEVICE_FLAG_STREAM) == RT_EOK)
    {
        if (shell->device != RT_NULL)
10010cc4:	e30a3654 	movw	r3, #42580	; 0xa654
10010cc8:	e3413002 	movt	r3, #4098	; 0x1002
10010ccc:	e5933000 	ldr	r3, [r3]
10010cd0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10010cd4:	e3530000 	cmp	r3, #0
10010cd8:	0a00000c 	beq	10010d10 <finsh_set_device+0xf4>
        {
            /* close old finsh device */
            rt_device_close(shell->device);
10010cdc:	e30a3654 	movw	r3, #42580	; 0xa654
10010ce0:	e3413002 	movt	r3, #4098	; 0x1002
10010ce4:	e5933000 	ldr	r3, [r3]
10010ce8:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10010cec:	e1a00003 	mov	r0, r3
10010cf0:	ebffc151 	bl	1000123c <rt_device_close>
            rt_device_set_rx_indicate(shell->device, RT_NULL);
10010cf4:	e30a3654 	movw	r3, #42580	; 0xa654
10010cf8:	e3413002 	movt	r3, #4098	; 0x1002
10010cfc:	e5933000 	ldr	r3, [r3]
10010d00:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10010d04:	e1a00003 	mov	r0, r3
10010d08:	e3a01000 	mov	r1, #0
10010d0c:	ebffc1f8 	bl	100014f4 <rt_device_set_rx_indicate>
        }

        /* clear line buffer before switch to new device */
        memset(shell->line, 0, sizeof(shell->line));
10010d10:	e30a3654 	movw	r3, #42580	; 0xa654
10010d14:	e3413002 	movt	r3, #4098	; 0x1002
10010d18:	e5933000 	ldr	r3, [r3]
10010d1c:	e2833e25 	add	r3, r3, #592	; 0x250
10010d20:	e1a00003 	mov	r0, r3
10010d24:	e3a01000 	mov	r1, #0
10010d28:	e3a02050 	mov	r2, #80	; 0x50
10010d2c:	fa0032ea 	blx	1001d8dc <memset>
        shell->line_curpos = shell->line_position = 0;
10010d30:	e30a3654 	movw	r3, #42580	; 0xa654
10010d34:	e3413002 	movt	r3, #4098	; 0x1002
10010d38:	e5932000 	ldr	r2, [r3]
10010d3c:	e30a3654 	movw	r3, #42580	; 0xa654
10010d40:	e3413002 	movt	r3, #4098	; 0x1002
10010d44:	e5933000 	ldr	r3, [r3]
10010d48:	e3a01000 	mov	r1, #0
10010d4c:	e5c312a0 	strb	r1, [r3, #672]	; 0x2a0
10010d50:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10010d54:	e5c232a1 	strb	r3, [r2, #673]	; 0x2a1

        shell->device = dev;
10010d58:	e30a3654 	movw	r3, #42580	; 0xa654
10010d5c:	e3413002 	movt	r3, #4098	; 0x1002
10010d60:	e5933000 	ldr	r3, [r3]
10010d64:	e51b2008 	ldr	r2, [fp, #-8]
10010d68:	e58322a4 	str	r2, [r3, #676]	; 0x2a4
        rt_device_set_rx_indicate(dev, finsh_rx_ind);
10010d6c:	e51b0008 	ldr	r0, [fp, #-8]
10010d70:	e3001bb8 	movw	r1, #3000	; 0xbb8
10010d74:	e3411001 	movt	r1, #4097	; 0x1001
10010d78:	ebffc1dd 	bl	100014f4 <rt_device_set_rx_indicate>
    }
}
10010d7c:	e24bd004 	sub	sp, fp, #4
10010d80:	e8bd8800 	pop	{fp, pc}

10010d84 <finsh_get_device>:
 * This function returns current finsh shell input device.
 *
 * @return the finsh shell input device name is returned.
 */
const char *finsh_get_device()
{
10010d84:	e92d4800 	push	{fp, lr}
10010d88:	e28db004 	add	fp, sp, #4
    RT_ASSERT(shell != RT_NULL);
10010d8c:	e30a3654 	movw	r3, #42580	; 0xa654
10010d90:	e3413002 	movt	r3, #4098	; 0x1002
10010d94:	e5933000 	ldr	r3, [r3]
10010d98:	e3530000 	cmp	r3, #0
10010d9c:	1a000005 	bne	10010db8 <finsh_get_device+0x34>
10010da0:	e30f0958 	movw	r0, #63832	; 0xf958
10010da4:	e3410001 	movt	r0, #4097	; 0x1001
10010da8:	e30f1a3c 	movw	r1, #64060	; 0xfa3c
10010dac:	e3411001 	movt	r1, #4097	; 0x1001
10010db0:	e3a02090 	mov	r2, #144	; 0x90
10010db4:	ebffd603 	bl	100065c8 <rt_assert_handler>
    return shell->device->parent.name;
10010db8:	e30a3654 	movw	r3, #42580	; 0xa654
10010dbc:	e3413002 	movt	r3, #4098	; 0x1002
10010dc0:	e5933000 	ldr	r3, [r3]
10010dc4:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
}
10010dc8:	e1a00003 	mov	r0, r3
10010dcc:	e8bd8800 	pop	{fp, pc}

10010dd0 <finsh_set_echo>:
 * FINSH_OPTION_ECHO=0x01 is echo mode, other values are none-echo mode.
 *
 * @param echo the echo mode
 */
void finsh_set_echo(rt_uint32_t echo)
{
10010dd0:	e92d4800 	push	{fp, lr}
10010dd4:	e28db004 	add	fp, sp, #4
10010dd8:	e24dd008 	sub	sp, sp, #8
10010ddc:	e50b0008 	str	r0, [fp, #-8]
    RT_ASSERT(shell != RT_NULL);
10010de0:	e30a3654 	movw	r3, #42580	; 0xa654
10010de4:	e3413002 	movt	r3, #4098	; 0x1002
10010de8:	e5933000 	ldr	r3, [r3]
10010dec:	e3530000 	cmp	r3, #0
10010df0:	1a000005 	bne	10010e0c <finsh_set_echo+0x3c>
10010df4:	e30f0958 	movw	r0, #63832	; 0xf958
10010df8:	e3410001 	movt	r0, #4097	; 0x1001
10010dfc:	e30f1a50 	movw	r1, #64080	; 0xfa50
10010e00:	e3411001 	movt	r1, #4097	; 0x1001
10010e04:	e3a0209f 	mov	r2, #159	; 0x9f
10010e08:	ebffd5ee 	bl	100065c8 <rt_assert_handler>
    shell->echo_mode = (rt_uint8_t)echo;
10010e0c:	e30a3654 	movw	r3, #42580	; 0xa654
10010e10:	e3413002 	movt	r3, #4098	; 0x1002
10010e14:	e5932000 	ldr	r2, [r3]
10010e18:	e51b3008 	ldr	r3, [fp, #-8]
10010e1c:	e6ef3073 	uxtb	r3, r3
10010e20:	e2033001 	and	r3, r3, #1
10010e24:	e6ef1073 	uxtb	r1, r3
10010e28:	e5d2301d 	ldrb	r3, [r2, #29]
10010e2c:	e7c03011 	bfi	r3, r1, #0, #1
10010e30:	e5c2301d 	strb	r3, [r2, #29]
}
10010e34:	e24bd004 	sub	sp, fp, #4
10010e38:	e8bd8800 	pop	{fp, pc}

10010e3c <finsh_get_echo>:
 * This function gets the echo mode of finsh shell.
 *
 * @return the echo mode
 */
rt_uint32_t finsh_get_echo()
{
10010e3c:	e92d4800 	push	{fp, lr}
10010e40:	e28db004 	add	fp, sp, #4
    RT_ASSERT(shell != RT_NULL);
10010e44:	e30a3654 	movw	r3, #42580	; 0xa654
10010e48:	e3413002 	movt	r3, #4098	; 0x1002
10010e4c:	e5933000 	ldr	r3, [r3]
10010e50:	e3530000 	cmp	r3, #0
10010e54:	1a000005 	bne	10010e70 <finsh_get_echo+0x34>
10010e58:	e30f0958 	movw	r0, #63832	; 0xf958
10010e5c:	e3410001 	movt	r0, #4097	; 0x1001
10010e60:	e30f1a60 	movw	r1, #64096	; 0xfa60
10010e64:	e3411001 	movt	r1, #4097	; 0x1001
10010e68:	e3a020ac 	mov	r2, #172	; 0xac
10010e6c:	ebffd5d5 	bl	100065c8 <rt_assert_handler>

    return shell->echo_mode;
10010e70:	e30a3654 	movw	r3, #42580	; 0xa654
10010e74:	e3413002 	movt	r3, #4098	; 0x1002
10010e78:	e5933000 	ldr	r3, [r3]
10010e7c:	e5d3301d 	ldrb	r3, [r3, #29]
10010e80:	e7e03053 	ubfx	r3, r3, #0, #1
10010e84:	e6ef3073 	uxtb	r3, r3
}
10010e88:	e1a00003 	mov	r0, r3
10010e8c:	e8bd8800 	pop	{fp, pc}

10010e90 <shell_auto_complete>:

static void shell_auto_complete(char *prefix)
{
10010e90:	e92d4800 	push	{fp, lr}
10010e94:	e28db004 	add	fp, sp, #4
10010e98:	e24dd008 	sub	sp, sp, #8
10010e9c:	e50b0008 	str	r0, [fp, #-8]

    rt_kprintf("\n");
10010ea0:	e30f098c 	movw	r0, #63884	; 0xf98c
10010ea4:	e3410001 	movt	r0, #4097	; 0x1001
10010ea8:	ebffd509 	bl	100062d4 <rt_kprintf>
#ifdef FINSH_USING_MSH
    if (msh_is_used() == RT_TRUE)
10010eac:	eb000969 	bl	10013458 <msh_is_used>
10010eb0:	e1a03000 	mov	r3, r0
10010eb4:	e3530001 	cmp	r3, #1
10010eb8:	1a000002 	bne	10010ec8 <shell_auto_complete+0x38>
    {
        msh_auto_complete(prefix);
10010ebc:	e51b0008 	ldr	r0, [fp, #-8]
10010ec0:	eb000b3c 	bl	10013bb8 <msh_auto_complete>
10010ec4:	ea000001 	b	10010ed0 <shell_auto_complete+0x40>
    else
#endif
    {
#ifndef FINSH_USING_MSH_ONLY
        extern void list_prefix(char * prefix);
        list_prefix(prefix);
10010ec8:	e51b0008 	ldr	r0, [fp, #-8]
10010ecc:	eb00081a 	bl	10012f3c <list_prefix>
#endif
    }

    rt_kprintf("%s%s", FINSH_PROMPT, prefix);
10010ed0:	ebffff0e 	bl	10010b10 <finsh_get_prompt>
10010ed4:	e1a03000 	mov	r3, r0
10010ed8:	e30f0990 	movw	r0, #63888	; 0xf990
10010edc:	e3410001 	movt	r0, #4097	; 0x1001
10010ee0:	e1a01003 	mov	r1, r3
10010ee4:	e51b2008 	ldr	r2, [fp, #-8]
10010ee8:	ebffd4f9 	bl	100062d4 <rt_kprintf>
}
10010eec:	e24bd004 	sub	sp, fp, #4
10010ef0:	e8bd8800 	pop	{fp, pc}

10010ef4 <finsh_run_line>:

#ifndef FINSH_USING_MSH_ONLY
void finsh_run_line(struct finsh_parser *parser, const char *line)
{
10010ef4:	e92d4830 	push	{r4, r5, fp, lr}
10010ef8:	e28db00c 	add	fp, sp, #12
10010efc:	e24dd010 	sub	sp, sp, #16
10010f00:	e50b0018 	str	r0, [fp, #-24]
10010f04:	e50b101c 	str	r1, [fp, #-28]
    const char *err_str;

    rt_kprintf("\n");
10010f08:	e30f098c 	movw	r0, #63884	; 0xf98c
10010f0c:	e3410001 	movt	r0, #4097	; 0x1001
10010f10:	ebffd4ef 	bl	100062d4 <rt_kprintf>
    finsh_parser_run(parser, (unsigned char *)line);
10010f14:	e51b0018 	ldr	r0, [fp, #-24]
10010f18:	e51b101c 	ldr	r1, [fp, #-28]
10010f1c:	eb0029c2 	bl	1001b62c <finsh_parser_run>

    /* compile node root */
    if (finsh_errno() == 0)
10010f20:	eb001a71 	bl	100178ec <finsh_errno>
10010f24:	e1a03000 	mov	r3, r0
10010f28:	e3530000 	cmp	r3, #0
10010f2c:	1a000004 	bne	10010f44 <finsh_run_line+0x50>
    {
        finsh_compiler_run(parser->root);
10010f30:	e51b3018 	ldr	r3, [fp, #-24]
10010f34:	e5933098 	ldr	r3, [r3, #152]	; 0x98
10010f38:	e1a00003 	mov	r0, r3
10010f3c:	eb001a13 	bl	10017790 <finsh_compiler_run>
10010f40:	ea000008 	b	10010f68 <finsh_run_line+0x74>
    }
    else
    {
        err_str = finsh_error_string(finsh_errno());
10010f44:	eb001a68 	bl	100178ec <finsh_errno>
10010f48:	e1a03000 	mov	r3, r0
10010f4c:	e1a00003 	mov	r0, r3
10010f50:	eb001a6e 	bl	10017910 <finsh_error_string>
10010f54:	e50b0010 	str	r0, [fp, #-16]
        rt_kprintf("%s\n", err_str);
10010f58:	e30f0998 	movw	r0, #63896	; 0xf998
10010f5c:	e3410001 	movt	r0, #4097	; 0x1001
10010f60:	e51b1010 	ldr	r1, [fp, #-16]
10010f64:	ebffd4da 	bl	100062d4 <rt_kprintf>
    }

    /* run virtual machine */
    if (finsh_errno() == 0)
10010f68:	eb001a5f 	bl	100178ec <finsh_errno>
10010f6c:	e1a03000 	mov	r3, r0
10010f70:	e3530000 	cmp	r3, #0
10010f74:	1a000022 	bne	10011004 <finsh_run_line+0x110>
    {
        char ch;
        finsh_vm_run();
10010f78:	eb002b81 	bl	1001bd84 <finsh_vm_run>

        ch = (unsigned char)finsh_stack_bottom();
10010f7c:	eb001c31 	bl	10018048 <finsh_stack_bottom>
10010f80:	e1a03000 	mov	r3, r0
10010f84:	e54b3011 	strb	r3, [fp, #-17]
        if (ch > 0x20 && ch < 0x7e)
10010f88:	e55b3011 	ldrb	r3, [fp, #-17]
10010f8c:	e3530020 	cmp	r3, #32
10010f90:	9a000011 	bls	10010fdc <finsh_run_line+0xe8>
10010f94:	e55b3011 	ldrb	r3, [fp, #-17]
10010f98:	e353007d 	cmp	r3, #125	; 0x7d
10010f9c:	8a00000e 	bhi	10010fdc <finsh_run_line+0xe8>
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
                       (unsigned char)finsh_stack_bottom(),
10010fa0:	eb001c28 	bl	10018048 <finsh_stack_bottom>
10010fa4:	e1a03000 	mov	r3, r0
10010fa8:	e6ef3073 	uxtb	r3, r3
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
10010fac:	e1a05003 	mov	r5, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
10010fb0:	eb001c24 	bl	10018048 <finsh_stack_bottom>
10010fb4:	e1a03000 	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
10010fb8:	e1a04003 	mov	r4, r3
                       (unsigned char)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
10010fbc:	eb001c21 	bl	10018048 <finsh_stack_bottom>
10010fc0:	e1a03000 	mov	r3, r0
        finsh_vm_run();

        ch = (unsigned char)finsh_stack_bottom();
        if (ch > 0x20 && ch < 0x7e)
        {
            rt_kprintf("\t'%c', %d, 0x%08x\n",
10010fc4:	e30f099c 	movw	r0, #63900	; 0xf99c
10010fc8:	e3410001 	movt	r0, #4097	; 0x1001
10010fcc:	e1a01005 	mov	r1, r5
10010fd0:	e1a02004 	mov	r2, r4
10010fd4:	ebffd4be 	bl	100062d4 <rt_kprintf>
10010fd8:	ea000009 	b	10011004 <finsh_run_line+0x110>
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
                       (unsigned int)finsh_stack_bottom(),
10010fdc:	eb001c19 	bl	10018048 <finsh_stack_bottom>
10010fe0:	e1a03000 	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
10010fe4:	e1a04003 	mov	r4, r3
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
10010fe8:	eb001c16 	bl	10018048 <finsh_stack_bottom>
10010fec:	e1a03000 	mov	r3, r0
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
        else
        {
            rt_kprintf("\t%d, 0x%08x\n",
10010ff0:	e30f09b0 	movw	r0, #63920	; 0xf9b0
10010ff4:	e3410001 	movt	r0, #4097	; 0x1001
10010ff8:	e1a01004 	mov	r1, r4
10010ffc:	e1a02003 	mov	r2, r3
10011000:	ebffd4b3 	bl	100062d4 <rt_kprintf>
                       (unsigned int)finsh_stack_bottom(),
                       (unsigned int)finsh_stack_bottom());
        }
    }

    finsh_flush(parser);
10011004:	e51b0018 	ldr	r0, [fp, #-24]
10011008:	eb001c17 	bl	1001806c <finsh_flush>
}
1001100c:	e24bd00c 	sub	sp, fp, #12
10011010:	e8bd8830 	pop	{r4, r5, fp, pc}

10011014 <shell_handle_history>:
#endif

#ifdef FINSH_USING_HISTORY
static rt_bool_t shell_handle_history(struct finsh_shell *shell)
{
10011014:	e92d4800 	push	{fp, lr}
10011018:	e28db004 	add	fp, sp, #4
1001101c:	e24dd008 	sub	sp, sp, #8
10011020:	e50b0008 	str	r0, [fp, #-8]
    for (i = 0; i <= 60; i++)
        putchar(' ');
    rt_kprintf("\r");

#else
    rt_kprintf("\033[2K\r");
10011024:	e30f09c0 	movw	r0, #63936	; 0xf9c0
10011028:	e3410001 	movt	r0, #4097	; 0x1001
1001102c:	ebffd4a8 	bl	100062d4 <rt_kprintf>
#endif
    rt_kprintf("%s%s", FINSH_PROMPT, shell->line);
10011030:	ebfffeb6 	bl	10010b10 <finsh_get_prompt>
10011034:	e1a02000 	mov	r2, r0
10011038:	e51b3008 	ldr	r3, [fp, #-8]
1001103c:	e2833e25 	add	r3, r3, #592	; 0x250
10011040:	e30f0990 	movw	r0, #63888	; 0xf990
10011044:	e3410001 	movt	r0, #4097	; 0x1001
10011048:	e1a01002 	mov	r1, r2
1001104c:	e1a02003 	mov	r2, r3
10011050:	ebffd49f 	bl	100062d4 <rt_kprintf>
    return RT_FALSE;
10011054:	e3a03000 	mov	r3, #0
}
10011058:	e1a00003 	mov	r0, r3
1001105c:	e24bd004 	sub	sp, fp, #4
10011060:	e8bd8800 	pop	{fp, pc}

10011064 <shell_push_history>:

static void shell_push_history(struct finsh_shell *shell)
{
10011064:	e92d4800 	push	{fp, lr}
10011068:	e28db004 	add	fp, sp, #4
1001106c:	e24dd010 	sub	sp, sp, #16
10011070:	e50b0010 	str	r0, [fp, #-16]
    if (shell->line_position != 0)
10011074:	e51b3010 	ldr	r3, [fp, #-16]
10011078:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
1001107c:	e3530000 	cmp	r3, #0
10011080:	0a000065 	beq	1001121c <shell_push_history+0x1b8>
    {
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
10011084:	e51b3010 	ldr	r3, [fp, #-16]
10011088:	e1d332b0 	ldrh	r3, [r3, #32]
1001108c:	e3530004 	cmp	r3, #4
10011090:	9a00003d 	bls	1001118c <shell_push_history+0x128>
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
10011094:	e3a03000 	mov	r3, #0
10011098:	e50b3008 	str	r3, [fp, #-8]
1001109c:	ea000017 	b	10011100 <shell_push_history+0x9c>
            {
                memcpy(&shell->cmd_history[index][0],
100110a0:	e51b3008 	ldr	r3, [fp, #-8]
100110a4:	e1a03203 	lsl	r3, r3, #4
100110a8:	e1a02103 	lsl	r2, r3, #2
100110ac:	e0833002 	add	r3, r3, r2
100110b0:	e2833020 	add	r3, r3, #32
100110b4:	e51b2010 	ldr	r2, [fp, #-16]
100110b8:	e0823003 	add	r3, r2, r3
100110bc:	e2831002 	add	r1, r3, #2
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
100110c0:	e51b3008 	ldr	r3, [fp, #-8]
100110c4:	e2833001 	add	r3, r3, #1
100110c8:	e1a03203 	lsl	r3, r3, #4
100110cc:	e1a02103 	lsl	r2, r3, #2
100110d0:	e0833002 	add	r3, r3, r2
100110d4:	e2833020 	add	r3, r3, #32
100110d8:	e51b2010 	ldr	r2, [fp, #-16]
100110dc:	e0823003 	add	r3, r2, r3
100110e0:	e2833002 	add	r3, r3, #2
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
            {
                memcpy(&shell->cmd_history[index][0],
100110e4:	e1a00001 	mov	r0, r1
100110e8:	e1a01003 	mov	r1, r3
100110ec:	e3a02050 	mov	r2, #80	; 0x50
100110f0:	fa0031cf 	blx	1001d834 <memcpy>
        /* push history */
        if (shell->history_count >= FINSH_HISTORY_LINES)
        {
            /* move history */
            int index;
            for (index = 0; index < FINSH_HISTORY_LINES - 1; index ++)
100110f4:	e51b3008 	ldr	r3, [fp, #-8]
100110f8:	e2833001 	add	r3, r3, #1
100110fc:	e50b3008 	str	r3, [fp, #-8]
10011100:	e51b3008 	ldr	r3, [fp, #-8]
10011104:	e3530003 	cmp	r3, #3
10011108:	daffffe4 	ble	100110a0 <shell_push_history+0x3c>
            {
                memcpy(&shell->cmd_history[index][0],
                       &shell->cmd_history[index + 1][0], FINSH_CMD_SIZE);
            }
            memset(&shell->cmd_history[index][0], 0, FINSH_CMD_SIZE);
1001110c:	e51b3008 	ldr	r3, [fp, #-8]
10011110:	e1a03203 	lsl	r3, r3, #4
10011114:	e1a02103 	lsl	r2, r3, #2
10011118:	e0833002 	add	r3, r3, r2
1001111c:	e2833020 	add	r3, r3, #32
10011120:	e51b2010 	ldr	r2, [fp, #-16]
10011124:	e0823003 	add	r3, r2, r3
10011128:	e2833002 	add	r3, r3, #2
1001112c:	e1a00003 	mov	r0, r3
10011130:	e3a01000 	mov	r1, #0
10011134:	e3a02050 	mov	r2, #80	; 0x50
10011138:	fa0031e7 	blx	1001d8dc <memset>
            memcpy(&shell->cmd_history[index][0], shell->line, shell->line_position);
1001113c:	e51b3008 	ldr	r3, [fp, #-8]
10011140:	e1a03203 	lsl	r3, r3, #4
10011144:	e1a02103 	lsl	r2, r3, #2
10011148:	e0833002 	add	r3, r3, r2
1001114c:	e2833020 	add	r3, r3, #32
10011150:	e51b2010 	ldr	r2, [fp, #-16]
10011154:	e0823003 	add	r3, r2, r3
10011158:	e2831002 	add	r1, r3, #2
1001115c:	e51b3010 	ldr	r3, [fp, #-16]
10011160:	e2832e25 	add	r2, r3, #592	; 0x250
10011164:	e51b3010 	ldr	r3, [fp, #-16]
10011168:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
1001116c:	e1a00001 	mov	r0, r1
10011170:	e1a01002 	mov	r1, r2
10011174:	e1a02003 	mov	r2, r3
10011178:	fa0031ad 	blx	1001d834 <memcpy>

            /* it's the maximum history */
            shell->history_count = FINSH_HISTORY_LINES;
1001117c:	e51b3010 	ldr	r3, [fp, #-16]
10011180:	e3a02005 	mov	r2, #5
10011184:	e1c322b0 	strh	r2, [r3, #32]
10011188:	ea000023 	b	1001121c <shell_push_history+0x1b8>
        }
        else
        {
            memset(&shell->cmd_history[shell->history_count][0], 0, FINSH_CMD_SIZE);
1001118c:	e51b3010 	ldr	r3, [fp, #-16]
10011190:	e1d332b0 	ldrh	r3, [r3, #32]
10011194:	e1a03203 	lsl	r3, r3, #4
10011198:	e1a02103 	lsl	r2, r3, #2
1001119c:	e0833002 	add	r3, r3, r2
100111a0:	e2833020 	add	r3, r3, #32
100111a4:	e51b2010 	ldr	r2, [fp, #-16]
100111a8:	e0823003 	add	r3, r2, r3
100111ac:	e2833002 	add	r3, r3, #2
100111b0:	e1a00003 	mov	r0, r3
100111b4:	e3a01000 	mov	r1, #0
100111b8:	e3a02050 	mov	r2, #80	; 0x50
100111bc:	fa0031c6 	blx	1001d8dc <memset>
            memcpy(&shell->cmd_history[shell->history_count][0], shell->line, shell->line_position);
100111c0:	e51b3010 	ldr	r3, [fp, #-16]
100111c4:	e1d332b0 	ldrh	r3, [r3, #32]
100111c8:	e1a03203 	lsl	r3, r3, #4
100111cc:	e1a02103 	lsl	r2, r3, #2
100111d0:	e0833002 	add	r3, r3, r2
100111d4:	e2833020 	add	r3, r3, #32
100111d8:	e51b2010 	ldr	r2, [fp, #-16]
100111dc:	e0823003 	add	r3, r2, r3
100111e0:	e2831002 	add	r1, r3, #2
100111e4:	e51b3010 	ldr	r3, [fp, #-16]
100111e8:	e2832e25 	add	r2, r3, #592	; 0x250
100111ec:	e51b3010 	ldr	r3, [fp, #-16]
100111f0:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100111f4:	e1a00001 	mov	r0, r1
100111f8:	e1a01002 	mov	r1, r2
100111fc:	e1a02003 	mov	r2, r3
10011200:	fa00318b 	blx	1001d834 <memcpy>

            /* increase count and set current history position */
            shell->history_count ++;
10011204:	e51b3010 	ldr	r3, [fp, #-16]
10011208:	e1d332b0 	ldrh	r3, [r3, #32]
1001120c:	e2833001 	add	r3, r3, #1
10011210:	e6ff2073 	uxth	r2, r3
10011214:	e51b3010 	ldr	r3, [fp, #-16]
10011218:	e1c322b0 	strh	r2, [r3, #32]
        }
    }
    shell->current_history = shell->history_count;
1001121c:	e51b3010 	ldr	r3, [fp, #-16]
10011220:	e1d322b0 	ldrh	r2, [r3, #32]
10011224:	e51b3010 	ldr	r3, [fp, #-16]
10011228:	e1c321be 	strh	r2, [r3, #30]
}
1001122c:	e24bd004 	sub	sp, fp, #4
10011230:	e8bd8800 	pop	{fp, pc}

10011234 <finsh_thread_entry>:

#ifndef RT_USING_HEAP
struct finsh_shell _shell;
#endif
void finsh_thread_entry(void *parameter)
{
10011234:	e92d4830 	push	{r4, r5, fp, lr}
10011238:	e28db00c 	add	fp, sp, #12
1001123c:	e24dd018 	sub	sp, sp, #24
10011240:	e50b0020 	str	r0, [fp, #-32]
    char ch;

    /* normal is echo mode */
    shell->echo_mode = 1;
10011244:	e30a3654 	movw	r3, #42580	; 0xa654
10011248:	e3413002 	movt	r3, #4098	; 0x1002
1001124c:	e5932000 	ldr	r2, [r3]
10011250:	e5d2301d 	ldrb	r3, [r2, #29]
10011254:	e3833001 	orr	r3, r3, #1
10011258:	e5c2301d 	strb	r3, [r2, #29]

#ifndef FINSH_USING_MSH_ONLY
    finsh_init(&shell->parser);
1001125c:	e30a3654 	movw	r3, #42580	; 0xa654
10011260:	e3413002 	movt	r3, #4098	; 0x1002
10011264:	e5933000 	ldr	r3, [r3]
10011268:	e2833f6d 	add	r3, r3, #436	; 0x1b4
1001126c:	e1a00003 	mov	r0, r3
10011270:	eb001b66 	bl	10018010 <finsh_init>
#endif
    rt_kprintf(FINSH_PROMPT);
10011274:	ebfffe25 	bl	10010b10 <finsh_get_prompt>
10011278:	e1a03000 	mov	r3, r0
1001127c:	e1a00003 	mov	r0, r3
10011280:	ebffd413 	bl	100062d4 <rt_kprintf>

    /* set console device as shell device */
    if (shell->device == RT_NULL)
10011284:	e30a3654 	movw	r3, #42580	; 0xa654
10011288:	e3413002 	movt	r3, #4098	; 0x1002
1001128c:	e5933000 	ldr	r3, [r3]
10011290:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10011294:	e3530000 	cmp	r3, #0
10011298:	1a000020 	bne	10011320 <finsh_thread_entry+0xec>
    {
#ifdef RT_USING_CONSOLE
        shell->device = rt_console_get_device();
1001129c:	e30a3654 	movw	r3, #42580	; 0xa654
100112a0:	e3413002 	movt	r3, #4098	; 0x1002
100112a4:	e5934000 	ldr	r4, [r3]
100112a8:	ebffd3d6 	bl	10006208 <rt_console_get_device>
100112ac:	e1a03000 	mov	r3, r0
100112b0:	e58432a4 	str	r3, [r4, #676]	; 0x2a4
        RT_ASSERT(shell->device);
100112b4:	e30a3654 	movw	r3, #42580	; 0xa654
100112b8:	e3413002 	movt	r3, #4098	; 0x1002
100112bc:	e5933000 	ldr	r3, [r3]
100112c0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
100112c4:	e3530000 	cmp	r3, #0
100112c8:	1a000005 	bne	100112e4 <finsh_thread_entry+0xb0>
100112cc:	e30f09c8 	movw	r0, #63944	; 0xf9c8
100112d0:	e3410001 	movt	r0, #4097	; 0x1001
100112d4:	e30f1a70 	movw	r1, #64112	; 0xfa70
100112d8:	e3411001 	movt	r1, #4097	; 0x1001
100112dc:	e300213a 	movw	r2, #314	; 0x13a
100112e0:	ebffd4b8 	bl	100065c8 <rt_assert_handler>
        rt_device_set_rx_indicate(shell->device, finsh_rx_ind);
100112e4:	e30a3654 	movw	r3, #42580	; 0xa654
100112e8:	e3413002 	movt	r3, #4098	; 0x1002
100112ec:	e5933000 	ldr	r3, [r3]
100112f0:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
100112f4:	e1a00003 	mov	r0, r3
100112f8:	e3001bb8 	movw	r1, #3000	; 0xbb8
100112fc:	e3411001 	movt	r1, #4097	; 0x1001
10011300:	ebffc07b 	bl	100014f4 <rt_device_set_rx_indicate>
        rt_device_open(shell->device, (RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_INT_RX));
10011304:	e30a3654 	movw	r3, #42580	; 0xa654
10011308:	e3413002 	movt	r3, #4098	; 0x1002
1001130c:	e5933000 	ldr	r3, [r3]
10011310:	e59332a4 	ldr	r3, [r3, #676]	; 0x2a4
10011314:	e1a00003 	mov	r0, r3
10011318:	e3001143 	movw	r1, #323	; 0x143
1001131c:	ebffbf60 	bl	100010a4 <rt_device_open>
    }

    while (1)
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;
10011320:	e30a3654 	movw	r3, #42580	; 0xa654
10011324:	e3413002 	movt	r3, #4098	; 0x1002
10011328:	e5933000 	ldr	r3, [r3]
1001132c:	e1a00003 	mov	r0, r3
10011330:	e3e01000 	mvn	r1, #0
10011334:	ebffc27c 	bl	10001d2c <rt_sem_take>
10011338:	e1a03000 	mov	r3, r0
1001133c:	e3530000 	cmp	r3, #0
10011340:	0a000000 	beq	10011348 <finsh_thread_entry+0x114>
10011344:	ea0002c0 	b	10011e4c <finsh_thread_entry+0xc18>

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
10011348:	ea0002b2 	b	10011e18 <finsh_thread_entry+0xbe4>
             * up key  : 0x1b 0x5b 0x41
             * down key: 0x1b 0x5b 0x42
             * right key:0x1b 0x5b 0x43
             * left key: 0x1b 0x5b 0x44
             */
            if (ch == 0x1b)
1001134c:	e55b3019 	ldrb	r3, [fp, #-25]
10011350:	e353001b 	cmp	r3, #27
10011354:	1a000005 	bne	10011370 <finsh_thread_entry+0x13c>
            {
                shell->stat = WAIT_SPEC_KEY;
10011358:	e30a3654 	movw	r3, #42580	; 0xa654
1001135c:	e3413002 	movt	r3, #4098	; 0x1002
10011360:	e5933000 	ldr	r3, [r3]
10011364:	e3a02001 	mov	r2, #1
10011368:	e5c3201c 	strb	r2, [r3, #28]
                continue;
1001136c:	ea0002a9 	b	10011e18 <finsh_thread_entry+0xbe4>
            }
            else if (shell->stat == WAIT_SPEC_KEY)
10011370:	e30a3654 	movw	r3, #42580	; 0xa654
10011374:	e3413002 	movt	r3, #4098	; 0x1002
10011378:	e5933000 	ldr	r3, [r3]
1001137c:	e5d3301c 	ldrb	r3, [r3, #28]
10011380:	e3530001 	cmp	r3, #1
10011384:	1a00000e 	bne	100113c4 <finsh_thread_entry+0x190>
            {
                if (ch == 0x5b)
10011388:	e55b3019 	ldrb	r3, [fp, #-25]
1001138c:	e353005b 	cmp	r3, #91	; 0x5b
10011390:	1a000005 	bne	100113ac <finsh_thread_entry+0x178>
                {
                    shell->stat = WAIT_FUNC_KEY;
10011394:	e30a3654 	movw	r3, #42580	; 0xa654
10011398:	e3413002 	movt	r3, #4098	; 0x1002
1001139c:	e5933000 	ldr	r3, [r3]
100113a0:	e3a02002 	mov	r2, #2
100113a4:	e5c3201c 	strb	r2, [r3, #28]
                    continue;
100113a8:	ea00029a 	b	10011e18 <finsh_thread_entry+0xbe4>
                }

                shell->stat = WAIT_NORMAL;
100113ac:	e30a3654 	movw	r3, #42580	; 0xa654
100113b0:	e3413002 	movt	r3, #4098	; 0x1002
100113b4:	e5933000 	ldr	r3, [r3]
100113b8:	e3a02000 	mov	r2, #0
100113bc:	e5c3201c 	strb	r2, [r3, #28]
100113c0:	ea0000d5 	b	1001171c <finsh_thread_entry+0x4e8>
            }
            else if (shell->stat == WAIT_FUNC_KEY)
100113c4:	e30a3654 	movw	r3, #42580	; 0xa654
100113c8:	e3413002 	movt	r3, #4098	; 0x1002
100113cc:	e5933000 	ldr	r3, [r3]
100113d0:	e5d3301c 	ldrb	r3, [r3, #28]
100113d4:	e3530002 	cmp	r3, #2
100113d8:	1a0000cf 	bne	1001171c <finsh_thread_entry+0x4e8>
            {
                shell->stat = WAIT_NORMAL;
100113dc:	e30a3654 	movw	r3, #42580	; 0xa654
100113e0:	e3413002 	movt	r3, #4098	; 0x1002
100113e4:	e5933000 	ldr	r3, [r3]
100113e8:	e3a02000 	mov	r2, #0
100113ec:	e5c3201c 	strb	r2, [r3, #28]

                if (ch == 0x41) /* up key */
100113f0:	e55b3019 	ldrb	r3, [fp, #-25]
100113f4:	e3530041 	cmp	r3, #65	; 0x41
100113f8:	1a00003d 	bne	100114f4 <finsh_thread_entry+0x2c0>
                {
#ifdef FINSH_USING_HISTORY
                    /* prev history */
                    if (shell->current_history > 0)
100113fc:	e30a3654 	movw	r3, #42580	; 0xa654
10011400:	e3413002 	movt	r3, #4098	; 0x1002
10011404:	e5933000 	ldr	r3, [r3]
10011408:	e1d331be 	ldrh	r3, [r3, #30]
1001140c:	e3530000 	cmp	r3, #0
10011410:	0a000031 	beq	100114dc <finsh_thread_entry+0x2a8>
                        shell->current_history --;
10011414:	e30a3654 	movw	r3, #42580	; 0xa654
10011418:	e3413002 	movt	r3, #4098	; 0x1002
1001141c:	e5933000 	ldr	r3, [r3]
10011420:	e1d321be 	ldrh	r2, [r3, #30]
10011424:	e2422001 	sub	r2, r2, #1
10011428:	e6ff2072 	uxth	r2, r2
1001142c:	e1c321be 	strh	r2, [r3, #30]
                        shell->current_history = 0;
                        continue;
                    }

                    /* copy the history command */
                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
10011430:	e30a3654 	movw	r3, #42580	; 0xa654
10011434:	e3413002 	movt	r3, #4098	; 0x1002
10011438:	e5933000 	ldr	r3, [r3]
1001143c:	e2830e25 	add	r0, r3, #592	; 0x250
10011440:	e30a3654 	movw	r3, #42580	; 0xa654
10011444:	e3413002 	movt	r3, #4098	; 0x1002
10011448:	e5932000 	ldr	r2, [r3]
1001144c:	e30a3654 	movw	r3, #42580	; 0xa654
10011450:	e3413002 	movt	r3, #4098	; 0x1002
10011454:	e5933000 	ldr	r3, [r3]
10011458:	e1d331be 	ldrh	r3, [r3, #30]
1001145c:	e1a03203 	lsl	r3, r3, #4
10011460:	e1a01103 	lsl	r1, r3, #2
10011464:	e0833001 	add	r3, r3, r1
10011468:	e2833020 	add	r3, r3, #32
1001146c:	e0823003 	add	r3, r2, r3
10011470:	e2833002 	add	r3, r3, #2
10011474:	e1a01003 	mov	r1, r3
10011478:	e3a02050 	mov	r2, #80	; 0x50
1001147c:	fa0030ec 	blx	1001d834 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
10011480:	e30a3654 	movw	r3, #42580	; 0xa654
10011484:	e3413002 	movt	r3, #4098	; 0x1002
10011488:	e5935000 	ldr	r5, [r3]
1001148c:	e30a3654 	movw	r3, #42580	; 0xa654
10011490:	e3413002 	movt	r3, #4098	; 0x1002
10011494:	e5934000 	ldr	r4, [r3]
10011498:	e30a3654 	movw	r3, #42580	; 0xa654
1001149c:	e3413002 	movt	r3, #4098	; 0x1002
100114a0:	e5933000 	ldr	r3, [r3]
100114a4:	e2833e25 	add	r3, r3, #592	; 0x250
100114a8:	e1a00003 	mov	r0, r3
100114ac:	fa0031ef 	blx	1001dc70 <strlen>
100114b0:	e1a03000 	mov	r3, r0
100114b4:	e6ef3073 	uxtb	r3, r3
100114b8:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
100114bc:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
100114c0:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1
                    shell_handle_history(shell);
100114c4:	e30a3654 	movw	r3, #42580	; 0xa654
100114c8:	e3413002 	movt	r3, #4098	; 0x1002
100114cc:	e5933000 	ldr	r3, [r3]
100114d0:	e1a00003 	mov	r0, r3
100114d4:	ebfffece 	bl	10011014 <shell_handle_history>
#endif
                    continue;
100114d8:	ea00024e 	b	10011e18 <finsh_thread_entry+0xbe4>
                    /* prev history */
                    if (shell->current_history > 0)
                        shell->current_history --;
                    else
                    {
                        shell->current_history = 0;
100114dc:	e30a3654 	movw	r3, #42580	; 0xa654
100114e0:	e3413002 	movt	r3, #4098	; 0x1002
100114e4:	e5933000 	ldr	r3, [r3]
100114e8:	e3a02000 	mov	r2, #0
100114ec:	e1c321be 	strh	r2, [r3, #30]
                        continue;
100114f0:	ea000248 	b	10011e18 <finsh_thread_entry+0xbe4>
                    shell->line_curpos = shell->line_position = strlen(shell->line);
                    shell_handle_history(shell);
#endif
                    continue;
                }
                else if (ch == 0x42) /* down key */
100114f4:	e55b3019 	ldrb	r3, [fp, #-25]
100114f8:	e3530042 	cmp	r3, #66	; 0x42
100114fc:	1a000050 	bne	10011644 <finsh_thread_entry+0x410>
                {
#ifdef FINSH_USING_HISTORY
                    /* next history */
                    if (shell->current_history < shell->history_count - 1)
10011500:	e30a3654 	movw	r3, #42580	; 0xa654
10011504:	e3413002 	movt	r3, #4098	; 0x1002
10011508:	e5933000 	ldr	r3, [r3]
1001150c:	e1d331be 	ldrh	r3, [r3, #30]
10011510:	e1a02003 	mov	r2, r3
10011514:	e30a3654 	movw	r3, #42580	; 0xa654
10011518:	e3413002 	movt	r3, #4098	; 0x1002
1001151c:	e5933000 	ldr	r3, [r3]
10011520:	e1d332b0 	ldrh	r3, [r3, #32]
10011524:	e2433001 	sub	r3, r3, #1
10011528:	e1520003 	cmp	r2, r3
1001152c:	aa000007 	bge	10011550 <finsh_thread_entry+0x31c>
                        shell->current_history ++;
10011530:	e30a3654 	movw	r3, #42580	; 0xa654
10011534:	e3413002 	movt	r3, #4098	; 0x1002
10011538:	e5933000 	ldr	r3, [r3]
1001153c:	e1d321be 	ldrh	r2, [r3, #30]
10011540:	e2822001 	add	r2, r2, #1
10011544:	e6ff2072 	uxth	r2, r2
10011548:	e1c321be 	strh	r2, [r3, #30]
1001154c:	ea000011 	b	10011598 <finsh_thread_entry+0x364>
                    else
                    {
                        /* set to the end of history */
                        if (shell->history_count != 0)
10011550:	e30a3654 	movw	r3, #42580	; 0xa654
10011554:	e3413002 	movt	r3, #4098	; 0x1002
10011558:	e5933000 	ldr	r3, [r3]
1001155c:	e1d332b0 	ldrh	r3, [r3, #32]
10011560:	e3530000 	cmp	r3, #0
10011564:	0a00000a 	beq	10011594 <finsh_thread_entry+0x360>
                            shell->current_history = shell->history_count - 1;
10011568:	e30a3654 	movw	r3, #42580	; 0xa654
1001156c:	e3413002 	movt	r3, #4098	; 0x1002
10011570:	e5932000 	ldr	r2, [r3]
10011574:	e30a3654 	movw	r3, #42580	; 0xa654
10011578:	e3413002 	movt	r3, #4098	; 0x1002
1001157c:	e5933000 	ldr	r3, [r3]
10011580:	e1d332b0 	ldrh	r3, [r3, #32]
10011584:	e2433001 	sub	r3, r3, #1
10011588:	e6ff3073 	uxth	r3, r3
1001158c:	e1c231be 	strh	r3, [r2, #30]
10011590:	ea000000 	b	10011598 <finsh_thread_entry+0x364>
                        else
                            continue;
10011594:	ea00021f 	b	10011e18 <finsh_thread_entry+0xbe4>
                    }

                    memcpy(shell->line, &shell->cmd_history[shell->current_history][0],
10011598:	e30a3654 	movw	r3, #42580	; 0xa654
1001159c:	e3413002 	movt	r3, #4098	; 0x1002
100115a0:	e5933000 	ldr	r3, [r3]
100115a4:	e2830e25 	add	r0, r3, #592	; 0x250
100115a8:	e30a3654 	movw	r3, #42580	; 0xa654
100115ac:	e3413002 	movt	r3, #4098	; 0x1002
100115b0:	e5932000 	ldr	r2, [r3]
100115b4:	e30a3654 	movw	r3, #42580	; 0xa654
100115b8:	e3413002 	movt	r3, #4098	; 0x1002
100115bc:	e5933000 	ldr	r3, [r3]
100115c0:	e1d331be 	ldrh	r3, [r3, #30]
100115c4:	e1a03203 	lsl	r3, r3, #4
100115c8:	e1a01103 	lsl	r1, r3, #2
100115cc:	e0833001 	add	r3, r3, r1
100115d0:	e2833020 	add	r3, r3, #32
100115d4:	e0823003 	add	r3, r2, r3
100115d8:	e2833002 	add	r3, r3, #2
100115dc:	e1a01003 	mov	r1, r3
100115e0:	e3a02050 	mov	r2, #80	; 0x50
100115e4:	fa003092 	blx	1001d834 <memcpy>
                           FINSH_CMD_SIZE);
                    shell->line_curpos = shell->line_position = strlen(shell->line);
100115e8:	e30a3654 	movw	r3, #42580	; 0xa654
100115ec:	e3413002 	movt	r3, #4098	; 0x1002
100115f0:	e5935000 	ldr	r5, [r3]
100115f4:	e30a3654 	movw	r3, #42580	; 0xa654
100115f8:	e3413002 	movt	r3, #4098	; 0x1002
100115fc:	e5934000 	ldr	r4, [r3]
10011600:	e30a3654 	movw	r3, #42580	; 0xa654
10011604:	e3413002 	movt	r3, #4098	; 0x1002
10011608:	e5933000 	ldr	r3, [r3]
1001160c:	e2833e25 	add	r3, r3, #592	; 0x250
10011610:	e1a00003 	mov	r0, r3
10011614:	fa003195 	blx	1001dc70 <strlen>
10011618:	e1a03000 	mov	r3, r0
1001161c:	e6ef3073 	uxtb	r3, r3
10011620:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
10011624:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
10011628:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1
                    shell_handle_history(shell);
1001162c:	e30a3654 	movw	r3, #42580	; 0xa654
10011630:	e3413002 	movt	r3, #4098	; 0x1002
10011634:	e5933000 	ldr	r3, [r3]
10011638:	e1a00003 	mov	r0, r3
1001163c:	ebfffe74 	bl	10011014 <shell_handle_history>
#endif
                    continue;
10011640:	ea0001f4 	b	10011e18 <finsh_thread_entry+0xbe4>
                }
                else if (ch == 0x44) /* left key */
10011644:	e55b3019 	ldrb	r3, [fp, #-25]
10011648:	e3530044 	cmp	r3, #68	; 0x44
1001164c:	1a000010 	bne	10011694 <finsh_thread_entry+0x460>
                {
                    if (shell->line_curpos)
10011650:	e30a3654 	movw	r3, #42580	; 0xa654
10011654:	e3413002 	movt	r3, #4098	; 0x1002
10011658:	e5933000 	ldr	r3, [r3]
1001165c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011660:	e3530000 	cmp	r3, #0
10011664:	0a000009 	beq	10011690 <finsh_thread_entry+0x45c>
                    {
                        rt_kprintf("\b");
10011668:	e30f09d8 	movw	r0, #63960	; 0xf9d8
1001166c:	e3410001 	movt	r0, #4097	; 0x1001
10011670:	ebffd317 	bl	100062d4 <rt_kprintf>
                        shell->line_curpos --;
10011674:	e30a3654 	movw	r3, #42580	; 0xa654
10011678:	e3413002 	movt	r3, #4098	; 0x1002
1001167c:	e5933000 	ldr	r3, [r3]
10011680:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
10011684:	e2422001 	sub	r2, r2, #1
10011688:	e6ef2072 	uxtb	r2, r2
1001168c:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
                    }

                    continue;
10011690:	ea0001e0 	b	10011e18 <finsh_thread_entry+0xbe4>
                }
                else if (ch == 0x43) /* right key */
10011694:	e55b3019 	ldrb	r3, [fp, #-25]
10011698:	e3530043 	cmp	r3, #67	; 0x43
1001169c:	1a00001e 	bne	1001171c <finsh_thread_entry+0x4e8>
                {
                    if (shell->line_curpos < shell->line_position)
100116a0:	e30a3654 	movw	r3, #42580	; 0xa654
100116a4:	e3413002 	movt	r3, #4098	; 0x1002
100116a8:	e5933000 	ldr	r3, [r3]
100116ac:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
100116b0:	e30a3654 	movw	r3, #42580	; 0xa654
100116b4:	e3413002 	movt	r3, #4098	; 0x1002
100116b8:	e5933000 	ldr	r3, [r3]
100116bc:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100116c0:	e1520003 	cmp	r2, r3
100116c4:	2a000013 	bcs	10011718 <finsh_thread_entry+0x4e4>
                    {
                        rt_kprintf("%c", shell->line[shell->line_curpos]);
100116c8:	e30a3654 	movw	r3, #42580	; 0xa654
100116cc:	e3413002 	movt	r3, #4098	; 0x1002
100116d0:	e5932000 	ldr	r2, [r3]
100116d4:	e30a3654 	movw	r3, #42580	; 0xa654
100116d8:	e3413002 	movt	r3, #4098	; 0x1002
100116dc:	e5933000 	ldr	r3, [r3]
100116e0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100116e4:	e0823003 	add	r3, r2, r3
100116e8:	e5d33250 	ldrb	r3, [r3, #592]	; 0x250
100116ec:	e30f09dc 	movw	r0, #63964	; 0xf9dc
100116f0:	e3410001 	movt	r0, #4097	; 0x1001
100116f4:	e1a01003 	mov	r1, r3
100116f8:	ebffd2f5 	bl	100062d4 <rt_kprintf>
                        shell->line_curpos ++;
100116fc:	e30a3654 	movw	r3, #42580	; 0xa654
10011700:	e3413002 	movt	r3, #4098	; 0x1002
10011704:	e5933000 	ldr	r3, [r3]
10011708:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
1001170c:	e2822001 	add	r2, r2, #1
10011710:	e6ef2072 	uxtb	r2, r2
10011714:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
                    }

                    continue;
10011718:	ea0001be 	b	10011e18 <finsh_thread_entry+0xbe4>
                }

            }

            /* handle CR key */
            if (ch == '\r')
1001171c:	e55b3019 	ldrb	r3, [fp, #-25]
10011720:	e353000d 	cmp	r3, #13
10011724:	1a000018 	bne	1001178c <finsh_thread_entry+0x558>
            {
                char next;

                if (rt_device_read(shell->device, 0, &next, 1) == 1)
10011728:	e30a3654 	movw	r3, #42580	; 0xa654
1001172c:	e3413002 	movt	r3, #4098	; 0x1002
10011730:	e5933000 	ldr	r3, [r3]
10011734:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
10011738:	e24b301a 	sub	r3, fp, #26
1001173c:	e1a00002 	mov	r0, r2
10011740:	e3a01000 	mov	r1, #0
10011744:	e1a02003 	mov	r2, r3
10011748:	e3a03001 	mov	r3, #1
1001174c:	ebffbef1 	bl	10001318 <rt_device_read>
10011750:	e1a03000 	mov	r3, r0
10011754:	e3530001 	cmp	r3, #1
10011758:	1a000008 	bne	10011780 <finsh_thread_entry+0x54c>
                {
                    if (next == '\0') ch = 'r'; /* linux telnet will issue '\0' */
1001175c:	e55b301a 	ldrb	r3, [fp, #-26]
10011760:	e3530000 	cmp	r3, #0
10011764:	1a000002 	bne	10011774 <finsh_thread_entry+0x540>
10011768:	e3a03072 	mov	r3, #114	; 0x72
1001176c:	e54b3019 	strb	r3, [fp, #-25]
10011770:	ea0000b1 	b	10011a3c <finsh_thread_entry+0x808>
                    else ch = next;
10011774:	e55b301a 	ldrb	r3, [fp, #-26]
10011778:	e54b3019 	strb	r3, [fp, #-25]
1001177c:	ea0000ae 	b	10011a3c <finsh_thread_entry+0x808>
                }
                else ch = '\r';
10011780:	e3a0300d 	mov	r3, #13
10011784:	e54b3019 	strb	r3, [fp, #-25]
10011788:	ea0000ab 	b	10011a3c <finsh_thread_entry+0x808>
            }
            /* handle tab key */
            else if (ch == '\t')
1001178c:	e55b3019 	ldrb	r3, [fp, #-25]
10011790:	e3530009 	cmp	r3, #9
10011794:	1a000028 	bne	1001183c <finsh_thread_entry+0x608>
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
10011798:	e3a03000 	mov	r3, #0
1001179c:	e50b3010 	str	r3, [fp, #-16]
100117a0:	ea000005 	b	100117bc <finsh_thread_entry+0x588>
                    rt_kprintf("\b");
100117a4:	e30f09d8 	movw	r0, #63960	; 0xf9d8
100117a8:	e3410001 	movt	r0, #4097	; 0x1001
100117ac:	ebffd2c8 	bl	100062d4 <rt_kprintf>
            /* handle tab key */
            else if (ch == '\t')
            {
                int i;
                /* move the cursor to the beginning of line */
                for (i = 0; i < shell->line_curpos; i++)
100117b0:	e51b3010 	ldr	r3, [fp, #-16]
100117b4:	e2833001 	add	r3, r3, #1
100117b8:	e50b3010 	str	r3, [fp, #-16]
100117bc:	e30a3654 	movw	r3, #42580	; 0xa654
100117c0:	e3413002 	movt	r3, #4098	; 0x1002
100117c4:	e5933000 	ldr	r3, [r3]
100117c8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100117cc:	e1a02003 	mov	r2, r3
100117d0:	e51b3010 	ldr	r3, [fp, #-16]
100117d4:	e1520003 	cmp	r2, r3
100117d8:	cafffff1 	bgt	100117a4 <finsh_thread_entry+0x570>
                    rt_kprintf("\b");

                /* auto complete */
                shell_auto_complete(&shell->line[0]);
100117dc:	e30a3654 	movw	r3, #42580	; 0xa654
100117e0:	e3413002 	movt	r3, #4098	; 0x1002
100117e4:	e5933000 	ldr	r3, [r3]
100117e8:	e2833e25 	add	r3, r3, #592	; 0x250
100117ec:	e1a00003 	mov	r0, r3
100117f0:	ebfffda6 	bl	10010e90 <shell_auto_complete>
                /* re-calculate position */
                shell->line_curpos = shell->line_position = strlen(shell->line);
100117f4:	e30a3654 	movw	r3, #42580	; 0xa654
100117f8:	e3413002 	movt	r3, #4098	; 0x1002
100117fc:	e5935000 	ldr	r5, [r3]
10011800:	e30a3654 	movw	r3, #42580	; 0xa654
10011804:	e3413002 	movt	r3, #4098	; 0x1002
10011808:	e5934000 	ldr	r4, [r3]
1001180c:	e30a3654 	movw	r3, #42580	; 0xa654
10011810:	e3413002 	movt	r3, #4098	; 0x1002
10011814:	e5933000 	ldr	r3, [r3]
10011818:	e2833e25 	add	r3, r3, #592	; 0x250
1001181c:	e1a00003 	mov	r0, r3
10011820:	fa003112 	blx	1001dc70 <strlen>
10011824:	e1a03000 	mov	r3, r0
10011828:	e6ef3073 	uxtb	r3, r3
1001182c:	e5c432a0 	strb	r3, [r4, #672]	; 0x2a0
10011830:	e5d432a0 	ldrb	r3, [r4, #672]	; 0x2a0
10011834:	e5c532a1 	strb	r3, [r5, #673]	; 0x2a1

                continue;
10011838:	ea000176 	b	10011e18 <finsh_thread_entry+0xbe4>
            }
            /* handle backspace key */
            else if (ch == 0x7f || ch == 0x08)
1001183c:	e55b3019 	ldrb	r3, [fp, #-25]
10011840:	e353007f 	cmp	r3, #127	; 0x7f
10011844:	0a000002 	beq	10011854 <finsh_thread_entry+0x620>
10011848:	e55b3019 	ldrb	r3, [fp, #-25]
1001184c:	e3530008 	cmp	r3, #8
10011850:	1a000079 	bne	10011a3c <finsh_thread_entry+0x808>
            {
                /* note that shell->line_curpos >= 0 */
                if (shell->line_curpos == 0)
10011854:	e30a3654 	movw	r3, #42580	; 0xa654
10011858:	e3413002 	movt	r3, #4098	; 0x1002
1001185c:	e5933000 	ldr	r3, [r3]
10011860:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011864:	e3530000 	cmp	r3, #0
10011868:	1a000000 	bne	10011870 <finsh_thread_entry+0x63c>
                    continue;
1001186c:	ea000169 	b	10011e18 <finsh_thread_entry+0xbe4>

                shell->line_position--;
10011870:	e30a3654 	movw	r3, #42580	; 0xa654
10011874:	e3413002 	movt	r3, #4098	; 0x1002
10011878:	e5933000 	ldr	r3, [r3]
1001187c:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
10011880:	e2422001 	sub	r2, r2, #1
10011884:	e6ef2072 	uxtb	r2, r2
10011888:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
                shell->line_curpos--;
1001188c:	e30a3654 	movw	r3, #42580	; 0xa654
10011890:	e3413002 	movt	r3, #4098	; 0x1002
10011894:	e5933000 	ldr	r3, [r3]
10011898:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
1001189c:	e2422001 	sub	r2, r2, #1
100118a0:	e6ef2072 	uxtb	r2, r2
100118a4:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1

                if (shell->line_position > shell->line_curpos)
100118a8:	e30a3654 	movw	r3, #42580	; 0xa654
100118ac:	e3413002 	movt	r3, #4098	; 0x1002
100118b0:	e5933000 	ldr	r3, [r3]
100118b4:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
100118b8:	e30a3654 	movw	r3, #42580	; 0xa654
100118bc:	e3413002 	movt	r3, #4098	; 0x1002
100118c0:	e5933000 	ldr	r3, [r3]
100118c4:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100118c8:	e1520003 	cmp	r2, r3
100118cc:	9a00004c 	bls	10011a04 <finsh_thread_entry+0x7d0>
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
100118d0:	e30a3654 	movw	r3, #42580	; 0xa654
100118d4:	e3413002 	movt	r3, #4098	; 0x1002
100118d8:	e5932000 	ldr	r2, [r3]
100118dc:	e30a3654 	movw	r3, #42580	; 0xa654
100118e0:	e3413002 	movt	r3, #4098	; 0x1002
100118e4:	e5933000 	ldr	r3, [r3]
100118e8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100118ec:	e2833e25 	add	r3, r3, #592	; 0x250
100118f0:	e0821003 	add	r1, r2, r3
                               &shell->line[shell->line_curpos + 1],
100118f4:	e30a3654 	movw	r3, #42580	; 0xa654
100118f8:	e3413002 	movt	r3, #4098	; 0x1002
100118fc:	e5932000 	ldr	r2, [r3]
10011900:	e30a3654 	movw	r3, #42580	; 0xa654
10011904:	e3413002 	movt	r3, #4098	; 0x1002
10011908:	e5933000 	ldr	r3, [r3]
1001190c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011910:	e2833001 	add	r3, r3, #1
10011914:	e2833e25 	add	r3, r3, #592	; 0x250
10011918:	e0822003 	add	r2, r2, r3
                               shell->line_position - shell->line_curpos);
1001191c:	e30a3654 	movw	r3, #42580	; 0xa654
10011920:	e3413002 	movt	r3, #4098	; 0x1002
10011924:	e5933000 	ldr	r3, [r3]
10011928:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
1001192c:	e1a00003 	mov	r0, r3
10011930:	e30a3654 	movw	r3, #42580	; 0xa654
10011934:	e3413002 	movt	r3, #4098	; 0x1002
10011938:	e5933000 	ldr	r3, [r3]
1001193c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011940:	e0633000 	rsb	r3, r3, r0

                if (shell->line_position > shell->line_curpos)
                {
                    int i;

                    rt_memmove(&shell->line[shell->line_curpos],
10011944:	e1a00001 	mov	r0, r1
10011948:	e1a01002 	mov	r1, r2
1001194c:	e1a02003 	mov	r2, r3
10011950:	ebffcd2e 	bl	10004e10 <rt_memmove>
                               &shell->line[shell->line_curpos + 1],
                               shell->line_position - shell->line_curpos);
                    shell->line[shell->line_position] = 0;
10011954:	e30a3654 	movw	r3, #42580	; 0xa654
10011958:	e3413002 	movt	r3, #4098	; 0x1002
1001195c:	e5932000 	ldr	r2, [r3]
10011960:	e30a3654 	movw	r3, #42580	; 0xa654
10011964:	e3413002 	movt	r3, #4098	; 0x1002
10011968:	e5933000 	ldr	r3, [r3]
1001196c:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011970:	e0823003 	add	r3, r2, r3
10011974:	e3a02000 	mov	r2, #0
10011978:	e5c32250 	strb	r2, [r3, #592]	; 0x250

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);
1001197c:	e30a3654 	movw	r3, #42580	; 0xa654
10011980:	e3413002 	movt	r3, #4098	; 0x1002
10011984:	e5932000 	ldr	r2, [r3]
10011988:	e30a3654 	movw	r3, #42580	; 0xa654
1001198c:	e3413002 	movt	r3, #4098	; 0x1002
10011990:	e5933000 	ldr	r3, [r3]
10011994:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011998:	e2833e25 	add	r3, r3, #592	; 0x250
1001199c:	e0823003 	add	r3, r2, r3
100119a0:	e30f09e0 	movw	r0, #63968	; 0xf9e0
100119a4:	e3410001 	movt	r0, #4097	; 0x1001
100119a8:	e1a01003 	mov	r1, r3
100119ac:	ebffd248 	bl	100062d4 <rt_kprintf>

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
100119b0:	e30a3654 	movw	r3, #42580	; 0xa654
100119b4:	e3413002 	movt	r3, #4098	; 0x1002
100119b8:	e5933000 	ldr	r3, [r3]
100119bc:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
100119c0:	e50b3014 	str	r3, [fp, #-20]
100119c4:	ea000005 	b	100119e0 <finsh_thread_entry+0x7ac>
                        rt_kprintf("\b");
100119c8:	e30f09d8 	movw	r0, #63960	; 0xf9d8
100119cc:	e3410001 	movt	r0, #4097	; 0x1001
100119d0:	ebffd23f 	bl	100062d4 <rt_kprintf>
                    shell->line[shell->line_position] = 0;

                    rt_kprintf("\b%s  \b", &shell->line[shell->line_curpos]);

                    /* move the cursor to the origin position */
                    for (i = shell->line_curpos; i <= shell->line_position; i++)
100119d4:	e51b3014 	ldr	r3, [fp, #-20]
100119d8:	e2833001 	add	r3, r3, #1
100119dc:	e50b3014 	str	r3, [fp, #-20]
100119e0:	e30a3654 	movw	r3, #42580	; 0xa654
100119e4:	e3413002 	movt	r3, #4098	; 0x1002
100119e8:	e5933000 	ldr	r3, [r3]
100119ec:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
100119f0:	e1a02003 	mov	r2, r3
100119f4:	e51b3014 	ldr	r3, [fp, #-20]
100119f8:	e1520003 	cmp	r2, r3
100119fc:	aafffff1 	bge	100119c8 <finsh_thread_entry+0x794>
10011a00:	ea00000c 	b	10011a38 <finsh_thread_entry+0x804>
                        rt_kprintf("\b");
                }
                else
                {
                    rt_kprintf("\b \b");
10011a04:	e30f09e8 	movw	r0, #63976	; 0xf9e8
10011a08:	e3410001 	movt	r0, #4097	; 0x1001
10011a0c:	ebffd230 	bl	100062d4 <rt_kprintf>
                    shell->line[shell->line_position] = 0;
10011a10:	e30a3654 	movw	r3, #42580	; 0xa654
10011a14:	e3413002 	movt	r3, #4098	; 0x1002
10011a18:	e5932000 	ldr	r2, [r3]
10011a1c:	e30a3654 	movw	r3, #42580	; 0xa654
10011a20:	e3413002 	movt	r3, #4098	; 0x1002
10011a24:	e5933000 	ldr	r3, [r3]
10011a28:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011a2c:	e0823003 	add	r3, r2, r3
10011a30:	e3a02000 	mov	r2, #0
10011a34:	e5c32250 	strb	r2, [r3, #592]	; 0x250
                }

                continue;
10011a38:	ea0000f6 	b	10011e18 <finsh_thread_entry+0xbe4>
            }

            /* handle end of line, break */
            if (ch == '\r' || ch == '\n')
10011a3c:	e55b3019 	ldrb	r3, [fp, #-25]
10011a40:	e353000d 	cmp	r3, #13
10011a44:	0a000002 	beq	10011a54 <finsh_thread_entry+0x820>
10011a48:	e55b3019 	ldrb	r3, [fp, #-25]
10011a4c:	e353000a 	cmp	r3, #10
10011a50:	1a00004d 	bne	10011b8c <finsh_thread_entry+0x958>
            {
#ifdef FINSH_USING_HISTORY
                shell_push_history(shell);
10011a54:	e30a3654 	movw	r3, #42580	; 0xa654
10011a58:	e3413002 	movt	r3, #4098	; 0x1002
10011a5c:	e5933000 	ldr	r3, [r3]
10011a60:	e1a00003 	mov	r0, r3
10011a64:	ebfffd7e 	bl	10011064 <shell_push_history>
#endif

#ifdef FINSH_USING_MSH
                if (msh_is_used() == RT_TRUE)
10011a68:	eb00067a 	bl	10013458 <msh_is_used>
10011a6c:	e1a03000 	mov	r3, r0
10011a70:	e3530001 	cmp	r3, #1
10011a74:	1a00000e 	bne	10011ab4 <finsh_thread_entry+0x880>
                {
                    rt_kprintf("\n");
10011a78:	e30f098c 	movw	r0, #63884	; 0xf98c
10011a7c:	e3410001 	movt	r0, #4097	; 0x1001
10011a80:	ebffd213 	bl	100062d4 <rt_kprintf>
                    msh_exec(shell->line, shell->line_position);
10011a84:	e30a3654 	movw	r3, #42580	; 0xa654
10011a88:	e3413002 	movt	r3, #4098	; 0x1002
10011a8c:	e5933000 	ldr	r3, [r3]
10011a90:	e2832e25 	add	r2, r3, #592	; 0x250
10011a94:	e30a3654 	movw	r3, #42580	; 0xa654
10011a98:	e3413002 	movt	r3, #4098	; 0x1002
10011a9c:	e5933000 	ldr	r3, [r3]
10011aa0:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011aa4:	e1a00002 	mov	r0, r2
10011aa8:	e1a01003 	mov	r1, r3
10011aac:	eb0007e2 	bl	10013a3c <msh_exec>
10011ab0:	ea00001e 	b	10011b30 <finsh_thread_entry+0x8fc>
                else
#endif
                {
#ifndef FINSH_USING_MSH_ONLY
                    /* add ';' and run the command line */
                    shell->line[shell->line_position] = ';';
10011ab4:	e30a3654 	movw	r3, #42580	; 0xa654
10011ab8:	e3413002 	movt	r3, #4098	; 0x1002
10011abc:	e5932000 	ldr	r2, [r3]
10011ac0:	e30a3654 	movw	r3, #42580	; 0xa654
10011ac4:	e3413002 	movt	r3, #4098	; 0x1002
10011ac8:	e5933000 	ldr	r3, [r3]
10011acc:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011ad0:	e0823003 	add	r3, r2, r3
10011ad4:	e3a0203b 	mov	r2, #59	; 0x3b
10011ad8:	e5c32250 	strb	r2, [r3, #592]	; 0x250

                    if (shell->line_position != 0) finsh_run_line(&shell->parser, shell->line);
10011adc:	e30a3654 	movw	r3, #42580	; 0xa654
10011ae0:	e3413002 	movt	r3, #4098	; 0x1002
10011ae4:	e5933000 	ldr	r3, [r3]
10011ae8:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011aec:	e3530000 	cmp	r3, #0
10011af0:	0a00000b 	beq	10011b24 <finsh_thread_entry+0x8f0>
10011af4:	e30a3654 	movw	r3, #42580	; 0xa654
10011af8:	e3413002 	movt	r3, #4098	; 0x1002
10011afc:	e5933000 	ldr	r3, [r3]
10011b00:	e2832f6d 	add	r2, r3, #436	; 0x1b4
10011b04:	e30a3654 	movw	r3, #42580	; 0xa654
10011b08:	e3413002 	movt	r3, #4098	; 0x1002
10011b0c:	e5933000 	ldr	r3, [r3]
10011b10:	e2833e25 	add	r3, r3, #592	; 0x250
10011b14:	e1a00002 	mov	r0, r2
10011b18:	e1a01003 	mov	r1, r3
10011b1c:	ebfffcf4 	bl	10010ef4 <finsh_run_line>
10011b20:	ea000002 	b	10011b30 <finsh_thread_entry+0x8fc>
                    else rt_kprintf("\n");
10011b24:	e30f098c 	movw	r0, #63884	; 0xf98c
10011b28:	e3410001 	movt	r0, #4097	; 0x1001
10011b2c:	ebffd1e8 	bl	100062d4 <rt_kprintf>
#endif
                }

                rt_kprintf(FINSH_PROMPT);
10011b30:	ebfffbf6 	bl	10010b10 <finsh_get_prompt>
10011b34:	e1a03000 	mov	r3, r0
10011b38:	e1a00003 	mov	r0, r3
10011b3c:	ebffd1e4 	bl	100062d4 <rt_kprintf>
                memset(shell->line, 0, sizeof(shell->line));
10011b40:	e30a3654 	movw	r3, #42580	; 0xa654
10011b44:	e3413002 	movt	r3, #4098	; 0x1002
10011b48:	e5933000 	ldr	r3, [r3]
10011b4c:	e2833e25 	add	r3, r3, #592	; 0x250
10011b50:	e1a00003 	mov	r0, r3
10011b54:	e3a01000 	mov	r1, #0
10011b58:	e3a02050 	mov	r2, #80	; 0x50
10011b5c:	fa002f5e 	blx	1001d8dc <memset>
                shell->line_curpos = shell->line_position = 0;
10011b60:	e30a3654 	movw	r3, #42580	; 0xa654
10011b64:	e3413002 	movt	r3, #4098	; 0x1002
10011b68:	e5932000 	ldr	r2, [r3]
10011b6c:	e30a3654 	movw	r3, #42580	; 0xa654
10011b70:	e3413002 	movt	r3, #4098	; 0x1002
10011b74:	e5933000 	ldr	r3, [r3]
10011b78:	e3a01000 	mov	r1, #0
10011b7c:	e5c312a0 	strb	r1, [r3, #672]	; 0x2a0
10011b80:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011b84:	e5c232a1 	strb	r3, [r2, #673]	; 0x2a1
                break;
10011b88:	ea0000af 	b	10011e4c <finsh_thread_entry+0xc18>
            }

            /* it's a large line, discard it */
            if (shell->line_position >= FINSH_CMD_SIZE)
10011b8c:	e30a3654 	movw	r3, #42580	; 0xa654
10011b90:	e3413002 	movt	r3, #4098	; 0x1002
10011b94:	e5933000 	ldr	r3, [r3]
10011b98:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011b9c:	e353004f 	cmp	r3, #79	; 0x4f
10011ba0:	9a000004 	bls	10011bb8 <finsh_thread_entry+0x984>
                shell->line_position = 0;
10011ba4:	e30a3654 	movw	r3, #42580	; 0xa654
10011ba8:	e3413002 	movt	r3, #4098	; 0x1002
10011bac:	e5933000 	ldr	r3, [r3]
10011bb0:	e3a02000 	mov	r2, #0
10011bb4:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0

            /* normal character */
            if (shell->line_curpos < shell->line_position)
10011bb8:	e30a3654 	movw	r3, #42580	; 0xa654
10011bbc:	e3413002 	movt	r3, #4098	; 0x1002
10011bc0:	e5933000 	ldr	r3, [r3]
10011bc4:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
10011bc8:	e30a3654 	movw	r3, #42580	; 0xa654
10011bcc:	e3413002 	movt	r3, #4098	; 0x1002
10011bd0:	e5933000 	ldr	r3, [r3]
10011bd4:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011bd8:	e1520003 	cmp	r2, r3
10011bdc:	2a000055 	bcs	10011d38 <finsh_thread_entry+0xb04>
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
10011be0:	e30a3654 	movw	r3, #42580	; 0xa654
10011be4:	e3413002 	movt	r3, #4098	; 0x1002
10011be8:	e5932000 	ldr	r2, [r3]
10011bec:	e30a3654 	movw	r3, #42580	; 0xa654
10011bf0:	e3413002 	movt	r3, #4098	; 0x1002
10011bf4:	e5933000 	ldr	r3, [r3]
10011bf8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011bfc:	e2833001 	add	r3, r3, #1
10011c00:	e2833e25 	add	r3, r3, #592	; 0x250
10011c04:	e0821003 	add	r1, r2, r3
                           &shell->line[shell->line_curpos],
10011c08:	e30a3654 	movw	r3, #42580	; 0xa654
10011c0c:	e3413002 	movt	r3, #4098	; 0x1002
10011c10:	e5932000 	ldr	r2, [r3]
10011c14:	e30a3654 	movw	r3, #42580	; 0xa654
10011c18:	e3413002 	movt	r3, #4098	; 0x1002
10011c1c:	e5933000 	ldr	r3, [r3]
10011c20:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011c24:	e2833e25 	add	r3, r3, #592	; 0x250
10011c28:	e0822003 	add	r2, r2, r3
                           shell->line_position - shell->line_curpos);
10011c2c:	e30a3654 	movw	r3, #42580	; 0xa654
10011c30:	e3413002 	movt	r3, #4098	; 0x1002
10011c34:	e5933000 	ldr	r3, [r3]
10011c38:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011c3c:	e1a00003 	mov	r0, r3
10011c40:	e30a3654 	movw	r3, #42580	; 0xa654
10011c44:	e3413002 	movt	r3, #4098	; 0x1002
10011c48:	e5933000 	ldr	r3, [r3]
10011c4c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011c50:	e0633000 	rsb	r3, r3, r0
            /* normal character */
            if (shell->line_curpos < shell->line_position)
            {
                int i;

                rt_memmove(&shell->line[shell->line_curpos + 1],
10011c54:	e1a00001 	mov	r0, r1
10011c58:	e1a01002 	mov	r1, r2
10011c5c:	e1a02003 	mov	r2, r3
10011c60:	ebffcc6a 	bl	10004e10 <rt_memmove>
                           &shell->line[shell->line_curpos],
                           shell->line_position - shell->line_curpos);
                shell->line[shell->line_curpos] = ch;
10011c64:	e30a3654 	movw	r3, #42580	; 0xa654
10011c68:	e3413002 	movt	r3, #4098	; 0x1002
10011c6c:	e5932000 	ldr	r2, [r3]
10011c70:	e30a3654 	movw	r3, #42580	; 0xa654
10011c74:	e3413002 	movt	r3, #4098	; 0x1002
10011c78:	e5933000 	ldr	r3, [r3]
10011c7c:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011c80:	e55b1019 	ldrb	r1, [fp, #-25]
10011c84:	e0823003 	add	r3, r2, r3
10011c88:	e1a02001 	mov	r2, r1
10011c8c:	e5c32250 	strb	r2, [r3, #592]	; 0x250
                if (shell->echo_mode)
10011c90:	e30a3654 	movw	r3, #42580	; 0xa654
10011c94:	e3413002 	movt	r3, #4098	; 0x1002
10011c98:	e5933000 	ldr	r3, [r3]
10011c9c:	e5d3301d 	ldrb	r3, [r3, #29]
10011ca0:	e2033001 	and	r3, r3, #1
10011ca4:	e6ef3073 	uxtb	r3, r3
10011ca8:	e3530000 	cmp	r3, #0
10011cac:	0a00000c 	beq	10011ce4 <finsh_thread_entry+0xab0>
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);
10011cb0:	e30a3654 	movw	r3, #42580	; 0xa654
10011cb4:	e3413002 	movt	r3, #4098	; 0x1002
10011cb8:	e5932000 	ldr	r2, [r3]
10011cbc:	e30a3654 	movw	r3, #42580	; 0xa654
10011cc0:	e3413002 	movt	r3, #4098	; 0x1002
10011cc4:	e5933000 	ldr	r3, [r3]
10011cc8:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011ccc:	e2833e25 	add	r3, r3, #592	; 0x250
10011cd0:	e0823003 	add	r3, r2, r3
10011cd4:	e30f09ec 	movw	r0, #63980	; 0xf9ec
10011cd8:	e3410001 	movt	r0, #4097	; 0x1001
10011cdc:	e1a01003 	mov	r1, r3
10011ce0:	ebffd17b 	bl	100062d4 <rt_kprintf>

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
10011ce4:	e30a3654 	movw	r3, #42580	; 0xa654
10011ce8:	e3413002 	movt	r3, #4098	; 0x1002
10011cec:	e5933000 	ldr	r3, [r3]
10011cf0:	e5d332a1 	ldrb	r3, [r3, #673]	; 0x2a1
10011cf4:	e50b3018 	str	r3, [fp, #-24]
10011cf8:	ea000005 	b	10011d14 <finsh_thread_entry+0xae0>
                    rt_kprintf("\b");
10011cfc:	e30f09d8 	movw	r0, #63960	; 0xf9d8
10011d00:	e3410001 	movt	r0, #4097	; 0x1001
10011d04:	ebffd172 	bl	100062d4 <rt_kprintf>
                shell->line[shell->line_curpos] = ch;
                if (shell->echo_mode)
                    rt_kprintf("%s", &shell->line[shell->line_curpos]);

                /* move the cursor to new position */
                for (i = shell->line_curpos; i < shell->line_position; i++)
10011d08:	e51b3018 	ldr	r3, [fp, #-24]
10011d0c:	e2833001 	add	r3, r3, #1
10011d10:	e50b3018 	str	r3, [fp, #-24]
10011d14:	e30a3654 	movw	r3, #42580	; 0xa654
10011d18:	e3413002 	movt	r3, #4098	; 0x1002
10011d1c:	e5933000 	ldr	r3, [r3]
10011d20:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011d24:	e1a02003 	mov	r2, r3
10011d28:	e51b3018 	ldr	r3, [fp, #-24]
10011d2c:	e1520003 	cmp	r2, r3
10011d30:	cafffff1 	bgt	10011cfc <finsh_thread_entry+0xac8>
10011d34:	ea000017 	b	10011d98 <finsh_thread_entry+0xb64>
                    rt_kprintf("\b");
            }
            else
            {
                shell->line[shell->line_position] = ch;
10011d38:	e30a3654 	movw	r3, #42580	; 0xa654
10011d3c:	e3413002 	movt	r3, #4098	; 0x1002
10011d40:	e5932000 	ldr	r2, [r3]
10011d44:	e30a3654 	movw	r3, #42580	; 0xa654
10011d48:	e3413002 	movt	r3, #4098	; 0x1002
10011d4c:	e5933000 	ldr	r3, [r3]
10011d50:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011d54:	e55b1019 	ldrb	r1, [fp, #-25]
10011d58:	e0823003 	add	r3, r2, r3
10011d5c:	e1a02001 	mov	r2, r1
10011d60:	e5c32250 	strb	r2, [r3, #592]	; 0x250
                if (shell->echo_mode)
10011d64:	e30a3654 	movw	r3, #42580	; 0xa654
10011d68:	e3413002 	movt	r3, #4098	; 0x1002
10011d6c:	e5933000 	ldr	r3, [r3]
10011d70:	e5d3301d 	ldrb	r3, [r3, #29]
10011d74:	e2033001 	and	r3, r3, #1
10011d78:	e6ef3073 	uxtb	r3, r3
10011d7c:	e3530000 	cmp	r3, #0
10011d80:	0a000004 	beq	10011d98 <finsh_thread_entry+0xb64>
                    rt_kprintf("%c", ch);
10011d84:	e55b3019 	ldrb	r3, [fp, #-25]
10011d88:	e30f09dc 	movw	r0, #63964	; 0xf9dc
10011d8c:	e3410001 	movt	r0, #4097	; 0x1001
10011d90:	e1a01003 	mov	r1, r3
10011d94:	ebffd14e 	bl	100062d4 <rt_kprintf>
            }

            ch = 0;
10011d98:	e3a03000 	mov	r3, #0
10011d9c:	e54b3019 	strb	r3, [fp, #-25]
            shell->line_position ++;
10011da0:	e30a3654 	movw	r3, #42580	; 0xa654
10011da4:	e3413002 	movt	r3, #4098	; 0x1002
10011da8:	e5933000 	ldr	r3, [r3]
10011dac:	e5d322a0 	ldrb	r2, [r3, #672]	; 0x2a0
10011db0:	e2822001 	add	r2, r2, #1
10011db4:	e6ef2072 	uxtb	r2, r2
10011db8:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
            shell->line_curpos++;
10011dbc:	e30a3654 	movw	r3, #42580	; 0xa654
10011dc0:	e3413002 	movt	r3, #4098	; 0x1002
10011dc4:	e5933000 	ldr	r3, [r3]
10011dc8:	e5d322a1 	ldrb	r2, [r3, #673]	; 0x2a1
10011dcc:	e2822001 	add	r2, r2, #1
10011dd0:	e6ef2072 	uxtb	r2, r2
10011dd4:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
            if (shell->line_position >= 80)
10011dd8:	e30a3654 	movw	r3, #42580	; 0xa654
10011ddc:	e3413002 	movt	r3, #4098	; 0x1002
10011de0:	e5933000 	ldr	r3, [r3]
10011de4:	e5d332a0 	ldrb	r3, [r3, #672]	; 0x2a0
10011de8:	e353004f 	cmp	r3, #79	; 0x4f
10011dec:	9a000009 	bls	10011e18 <finsh_thread_entry+0xbe4>
            {
                /* clear command line */
                shell->line_position = 0;
10011df0:	e30a3654 	movw	r3, #42580	; 0xa654
10011df4:	e3413002 	movt	r3, #4098	; 0x1002
10011df8:	e5933000 	ldr	r3, [r3]
10011dfc:	e3a02000 	mov	r2, #0
10011e00:	e5c322a0 	strb	r2, [r3, #672]	; 0x2a0
                shell->line_curpos = 0;
10011e04:	e30a3654 	movw	r3, #42580	; 0xa654
10011e08:	e3413002 	movt	r3, #4098	; 0x1002
10011e0c:	e5933000 	ldr	r3, [r3]
10011e10:	e3a02000 	mov	r2, #0
10011e14:	e5c322a1 	strb	r2, [r3, #673]	; 0x2a1
    {
        /* wait receive */
        if (rt_sem_take(&shell->rx_sem, RT_WAITING_FOREVER) != RT_EOK) continue;

        /* read one character from device */
        while (rt_device_read(shell->device, 0, &ch, 1) == 1)
10011e18:	e30a3654 	movw	r3, #42580	; 0xa654
10011e1c:	e3413002 	movt	r3, #4098	; 0x1002
10011e20:	e5933000 	ldr	r3, [r3]
10011e24:	e59322a4 	ldr	r2, [r3, #676]	; 0x2a4
10011e28:	e24b3019 	sub	r3, fp, #25
10011e2c:	e1a00002 	mov	r0, r2
10011e30:	e3a01000 	mov	r1, #0
10011e34:	e1a02003 	mov	r2, r3
10011e38:	e3a03001 	mov	r3, #1
10011e3c:	ebffbd35 	bl	10001318 <rt_device_read>
10011e40:	e1a03000 	mov	r3, r0
10011e44:	e3530001 	cmp	r3, #1
10011e48:	0afffd3f 	beq	1001134c <finsh_thread_entry+0x118>
                /* clear command line */
                shell->line_position = 0;
                shell->line_curpos = 0;
            }
        } /* end of device read */
    }
10011e4c:	eafffd33 	b	10011320 <finsh_thread_entry+0xec>

10011e50 <finsh_system_function_init>:
}

void finsh_system_function_init(const void *begin, const void *end)
{
10011e50:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10011e54:	e28db000 	add	fp, sp, #0
10011e58:	e24dd00c 	sub	sp, sp, #12
10011e5c:	e50b0008 	str	r0, [fp, #-8]
10011e60:	e50b100c 	str	r1, [fp, #-12]
    _syscall_table_begin = (struct finsh_syscall *) begin;
10011e64:	e3093d58 	movw	r3, #40280	; 0x9d58
10011e68:	e3413002 	movt	r3, #4098	; 0x1002
10011e6c:	e51b2008 	ldr	r2, [fp, #-8]
10011e70:	e5832000 	str	r2, [r3]
    _syscall_table_end = (struct finsh_syscall *) end;
10011e74:	e3093d5c 	movw	r3, #40284	; 0x9d5c
10011e78:	e3413002 	movt	r3, #4098	; 0x1002
10011e7c:	e51b200c 	ldr	r2, [fp, #-12]
10011e80:	e5832000 	str	r2, [r3]
}
10011e84:	e24bd000 	sub	sp, fp, #0
10011e88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10011e8c:	e12fff1e 	bx	lr

10011e90 <finsh_system_var_init>:

void finsh_system_var_init(const void *begin, const void *end)
{
10011e90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10011e94:	e28db000 	add	fp, sp, #0
10011e98:	e24dd00c 	sub	sp, sp, #12
10011e9c:	e50b0008 	str	r0, [fp, #-8]
10011ea0:	e50b100c 	str	r1, [fp, #-12]
    _sysvar_table_begin = (struct finsh_sysvar *) begin;
10011ea4:	e3093d60 	movw	r3, #40288	; 0x9d60
10011ea8:	e3413002 	movt	r3, #4098	; 0x1002
10011eac:	e51b2008 	ldr	r2, [fp, #-8]
10011eb0:	e5832000 	str	r2, [r3]
    _sysvar_table_end = (struct finsh_sysvar *) end;
10011eb4:	e3093d64 	movw	r3, #40292	; 0x9d64
10011eb8:	e3413002 	movt	r3, #4098	; 0x1002
10011ebc:	e51b200c 	ldr	r2, [fp, #-12]
10011ec0:	e5832000 	str	r2, [r3]
}
10011ec4:	e24bd000 	sub	sp, fp, #0
10011ec8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10011ecc:	e12fff1e 	bx	lr

10011ed0 <finsh_system_init>:
 * @ingroup finsh
 *
 * This function will initialize finsh shell
 */
int finsh_system_init(void)
{
10011ed0:	e92d4800 	push	{fp, lr}
10011ed4:	e28db004 	add	fp, sp, #4
10011ed8:	e24dd018 	sub	sp, sp, #24
    /* GNU GCC Compiler and TI CCS */
    extern const int __fsymtab_start;
    extern const int __fsymtab_end;
    extern const int __vsymtab_start;
    extern const int __vsymtab_end;
    finsh_system_function_init(&__fsymtab_start, &__fsymtab_end);
10011edc:	e30d0fc0 	movw	r0, #57280	; 0xdfc0
10011ee0:	e3410001 	movt	r0, #4097	; 0x1001
10011ee4:	e30e111c 	movw	r1, #57628	; 0xe11c
10011ee8:	e3411001 	movt	r1, #4097	; 0x1001
10011eec:	ebffffd7 	bl	10011e50 <finsh_system_function_init>
    finsh_system_var_init(&__vsymtab_start, &__vsymtab_end);
10011ef0:	e30e011c 	movw	r0, #57628	; 0xe11c
10011ef4:	e3410001 	movt	r0, #4097	; 0x1001
10011ef8:	e30e112c 	movw	r1, #57644	; 0xe12c
10011efc:	e3411001 	movt	r1, #4097	; 0x1001
10011f00:	ebffffe2 	bl	10011e90 <finsh_system_var_init>
#endif
#endif

    /* create or set shell structure */
#ifdef RT_USING_HEAP
    shell = (struct finsh_shell *)rt_malloc(sizeof(struct finsh_shell));
10011f04:	e3a00faa 	mov	r0, #680	; 0x2a8
10011f08:	ebffd2e6 	bl	10006aa8 <rt_malloc>
10011f0c:	e1a02000 	mov	r2, r0
10011f10:	e30a3654 	movw	r3, #42580	; 0xa654
10011f14:	e3413002 	movt	r3, #4098	; 0x1002
10011f18:	e5832000 	str	r2, [r3]
    if (shell == RT_NULL)
10011f1c:	e30a3654 	movw	r3, #42580	; 0xa654
10011f20:	e3413002 	movt	r3, #4098	; 0x1002
10011f24:	e5933000 	ldr	r3, [r3]
10011f28:	e3530000 	cmp	r3, #0
10011f2c:	1a000004 	bne	10011f44 <finsh_system_init+0x74>
    {
        rt_kprintf("no memory for shell\n");
10011f30:	e30f09f0 	movw	r0, #63984	; 0xf9f0
10011f34:	e3410001 	movt	r0, #4097	; 0x1001
10011f38:	ebffd0e5 	bl	100062d4 <rt_kprintf>
        return -1;
10011f3c:	e3e03000 	mvn	r3, #0
10011f40:	ea000028 	b	10011fe8 <finsh_system_init+0x118>
    }
#else
    shell = &_shell;
#endif

    memset(shell, 0, sizeof(struct finsh_shell));
10011f44:	e30a3654 	movw	r3, #42580	; 0xa654
10011f48:	e3413002 	movt	r3, #4098	; 0x1002
10011f4c:	e5933000 	ldr	r3, [r3]
10011f50:	e1a00003 	mov	r0, r3
10011f54:	e3a01000 	mov	r1, #0
10011f58:	e3a02faa 	mov	r2, #680	; 0x2a8
10011f5c:	fa002e5e 	blx	1001d8dc <memset>

    rt_sem_init(&(shell->rx_sem), "shrx", 0, 0);
10011f60:	e30a3654 	movw	r3, #42580	; 0xa654
10011f64:	e3413002 	movt	r3, #4098	; 0x1002
10011f68:	e5933000 	ldr	r3, [r3]
10011f6c:	e1a00003 	mov	r0, r3
10011f70:	e30f1a08 	movw	r1, #64008	; 0xfa08
10011f74:	e3411001 	movt	r1, #4097	; 0x1001
10011f78:	e3a02000 	mov	r2, #0
10011f7c:	e3a03000 	mov	r3, #0
10011f80:	ebffbed2 	bl	10001ad0 <rt_sem_init>
    result = rt_thread_init(&finsh_thread,
10011f84:	e3083cd4 	movw	r3, #36052	; 0x8cd4
10011f88:	e3413002 	movt	r3, #4098	; 0x1002
10011f8c:	e58d3000 	str	r3, [sp]
10011f90:	e3a03a01 	mov	r3, #4096	; 0x1000
10011f94:	e58d3004 	str	r3, [sp, #4]
10011f98:	e3a03014 	mov	r3, #20
10011f9c:	e58d3008 	str	r3, [sp, #8]
10011fa0:	e3a0300a 	mov	r3, #10
10011fa4:	e58d300c 	str	r3, [sp, #12]
10011fa8:	e3080c5c 	movw	r0, #35932	; 0x8c5c
10011fac:	e3410002 	movt	r0, #4098	; 0x1002
10011fb0:	e30f1a10 	movw	r1, #64016	; 0xfa10
10011fb4:	e3411001 	movt	r1, #4097	; 0x1001
10011fb8:	e3012234 	movw	r2, #4660	; 0x1234
10011fbc:	e3412001 	movt	r2, #4097	; 0x1001
10011fc0:	e3a03000 	mov	r3, #0
10011fc4:	ebffd9d1 	bl	10008710 <rt_thread_init>
10011fc8:	e50b0008 	str	r0, [fp, #-8]
                            "tshell",
                            finsh_thread_entry, RT_NULL,
                            &finsh_thread_stack[0], sizeof(finsh_thread_stack),
                            FINSH_THREAD_PRIORITY, 10);

    if (result == RT_EOK)
10011fcc:	e51b3008 	ldr	r3, [fp, #-8]
10011fd0:	e3530000 	cmp	r3, #0
10011fd4:	1a000002 	bne	10011fe4 <finsh_system_init+0x114>
        rt_thread_startup(&finsh_thread);
10011fd8:	e3080c5c 	movw	r0, #35932	; 0x8c5c
10011fdc:	e3410002 	movt	r0, #4098	; 0x1002
10011fe0:	ebffda01 	bl	100087ec <rt_thread_startup>
    return 0;
10011fe4:	e3a03000 	mov	r3, #0
}
10011fe8:	e1a00003 	mov	r0, r3
10011fec:	e24bd004 	sub	sp, fp, #4
10011ff0:	e8bd8800 	pop	{fp, pc}

10011ff4 <rt_list_isempty>:
/**
 * @brief tests whether a list is empty
 * @param l the list to test.
 */
rt_inline int rt_list_isempty(const rt_list_t *l)
{
10011ff4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10011ff8:	e28db000 	add	fp, sp, #0
10011ffc:	e24dd00c 	sub	sp, sp, #12
10012000:	e50b0008 	str	r0, [fp, #-8]
    return l->next == l;
10012004:	e51b3008 	ldr	r3, [fp, #-8]
10012008:	e5932000 	ldr	r2, [r3]
1001200c:	e51b3008 	ldr	r3, [fp, #-8]
10012010:	e1520003 	cmp	r2, r3
10012014:	03a03001 	moveq	r3, #1
10012018:	13a03000 	movne	r3, #0
1001201c:	e6ef3073 	uxtb	r3, r3
}
10012020:	e1a00003 	mov	r0, r3
10012024:	e24bd000 	sub	sp, fp, #0
10012028:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001202c:	e12fff1e 	bx	lr

10012030 <rt_list_len>:

#include <rtthread.h>
#include "finsh.h"

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
10012030:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012034:	e28db000 	add	fp, sp, #0
10012038:	e24dd014 	sub	sp, sp, #20
1001203c:	e50b0010 	str	r0, [fp, #-16]
    unsigned int len = 0;
10012040:	e3a03000 	mov	r3, #0
10012044:	e50b3008 	str	r3, [fp, #-8]
    const rt_list_t *p = l;
10012048:	e51b3010 	ldr	r3, [fp, #-16]
1001204c:	e50b300c 	str	r3, [fp, #-12]
    while (p->next != l)
10012050:	ea000005 	b	1001206c <rt_list_len+0x3c>
    {
        p = p->next;
10012054:	e51b300c 	ldr	r3, [fp, #-12]
10012058:	e5933000 	ldr	r3, [r3]
1001205c:	e50b300c 	str	r3, [fp, #-12]
        len ++;
10012060:	e51b3008 	ldr	r3, [fp, #-8]
10012064:	e2833001 	add	r3, r3, #1
10012068:	e50b3008 	str	r3, [fp, #-8]

rt_inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
1001206c:	e51b300c 	ldr	r3, [fp, #-12]
10012070:	e5932000 	ldr	r2, [r3]
10012074:	e51b3010 	ldr	r3, [fp, #-16]
10012078:	e1520003 	cmp	r2, r3
1001207c:	1afffff4 	bne	10012054 <rt_list_len+0x24>
    {
        p = p->next;
        len ++;
    }

    return len;
10012080:	e51b3008 	ldr	r3, [fp, #-8]
}
10012084:	e1a00003 	mov	r0, r3
10012088:	e24bd000 	sub	sp, fp, #0
1001208c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012090:	e12fff1e 	bx	lr

10012094 <hello>:

long hello(void)
{
10012094:	e92d4800 	push	{fp, lr}
10012098:	e28db004 	add	fp, sp, #4
    rt_kprintf("Hello RT-Thread!\n");
1001209c:	e30f0a84 	movw	r0, #64132	; 0xfa84
100120a0:	e3410001 	movt	r0, #4097	; 0x1001
100120a4:	ebffd08a 	bl	100062d4 <rt_kprintf>

    return 0;
100120a8:	e3a03000 	mov	r3, #0
}
100120ac:	e1a00003 	mov	r0, r3
100120b0:	e8bd8800 	pop	{fp, pc}

100120b4 <version>:
FINSH_FUNCTION_EXPORT(hello, say hello world);

extern void rt_show_version(void);
long version(void)
{
100120b4:	e92d4800 	push	{fp, lr}
100120b8:	e28db004 	add	fp, sp, #4
    rt_show_version();
100120bc:	ebffccb8 	bl	100053a4 <rt_show_version>

    return 0;
100120c0:	e3a03000 	mov	r3, #0
}
100120c4:	e1a00003 	mov	r0, r3
100120c8:	e8bd8800 	pop	{fp, pc}

100120cc <_list_thread>:
MSH_CMD_EXPORT(version, show RT-Thread version information);

extern struct rt_object_information rt_object_container[];

static long _list_thread(struct rt_list_node *list)
{
100120cc:	e92d4800 	push	{fp, lr}
100120d0:	e28db004 	add	fp, sp, #4
100120d4:	e24dd020 	sub	sp, sp, #32
100120d8:	e50b0018 	str	r0, [fp, #-24]
    struct rt_thread *thread;
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
100120dc:	e30f0a98 	movw	r0, #64152	; 0xfa98
100120e0:	e3410001 	movt	r0, #4097	; 0x1001
100120e4:	ebffd07a 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
100120e8:	e30f0ae4 	movw	r0, #64228	; 0xfae4
100120ec:	e3410001 	movt	r0, #4097	; 0x1001
100120f0:	ebffd077 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
100120f4:	e51b3018 	ldr	r3, [fp, #-24]
100120f8:	e5933000 	ldr	r3, [r3]
100120fc:	e50b3008 	str	r3, [fp, #-8]
10012100:	ea000057 	b	10012264 <_list_thread+0x198>
    {
        thread = rt_list_entry(node, struct rt_thread, list);
10012104:	e51b3008 	ldr	r3, [fp, #-8]
10012108:	e2433008 	sub	r3, r3, #8
1001210c:	e50b3010 	str	r3, [fp, #-16]
        rt_kprintf("%-8.*s 0x%02x", RT_NAME_MAX, thread->name, thread->current_priority);
10012110:	e51b2010 	ldr	r2, [fp, #-16]
10012114:	e51b3010 	ldr	r3, [fp, #-16]
10012118:	e5d33031 	ldrb	r3, [r3, #49]	; 0x31
1001211c:	e30f0b2c 	movw	r0, #64300	; 0xfb2c
10012120:	e3410001 	movt	r0, #4097	; 0x1001
10012124:	e3a01006 	mov	r1, #6
10012128:	ebffd069 	bl	100062d4 <rt_kprintf>

        if (thread->stat == RT_THREAD_READY)        rt_kprintf(" ready  ");
1001212c:	e51b3010 	ldr	r3, [fp, #-16]
10012130:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10012134:	e3530001 	cmp	r3, #1
10012138:	1a000003 	bne	1001214c <_list_thread+0x80>
1001213c:	e30f0b3c 	movw	r0, #64316	; 0xfb3c
10012140:	e3410001 	movt	r0, #4097	; 0x1001
10012144:	ebffd062 	bl	100062d4 <rt_kprintf>
10012148:	ea000016 	b	100121a8 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_SUSPEND) rt_kprintf(" suspend");
1001214c:	e51b3010 	ldr	r3, [fp, #-16]
10012150:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10012154:	e3530002 	cmp	r3, #2
10012158:	1a000003 	bne	1001216c <_list_thread+0xa0>
1001215c:	e30f0b48 	movw	r0, #64328	; 0xfb48
10012160:	e3410001 	movt	r0, #4097	; 0x1001
10012164:	ebffd05a 	bl	100062d4 <rt_kprintf>
10012168:	ea00000e 	b	100121a8 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_INIT)    rt_kprintf(" init   ");
1001216c:	e51b3010 	ldr	r3, [fp, #-16]
10012170:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10012174:	e3530000 	cmp	r3, #0
10012178:	1a000003 	bne	1001218c <_list_thread+0xc0>
1001217c:	e30f0b54 	movw	r0, #64340	; 0xfb54
10012180:	e3410001 	movt	r0, #4097	; 0x1001
10012184:	ebffd052 	bl	100062d4 <rt_kprintf>
10012188:	ea000006 	b	100121a8 <_list_thread+0xdc>
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");
1001218c:	e51b3010 	ldr	r3, [fp, #-16]
10012190:	e5d33030 	ldrb	r3, [r3, #48]	; 0x30
10012194:	e3530004 	cmp	r3, #4
10012198:	1a000002 	bne	100121a8 <_list_thread+0xdc>
1001219c:	e30f0b60 	movw	r0, #64352	; 0xfb60
100121a0:	e3410001 	movt	r0, #4097	; 0x1001
100121a4:	ebffd04a 	bl	100062d4 <rt_kprintf>

        ptr = (rt_uint8_t*)thread->stack_addr;
100121a8:	e51b3010 	ldr	r3, [fp, #-16]
100121ac:	e5933024 	ldr	r3, [r3, #36]	; 0x24
100121b0:	e50b300c 	str	r3, [fp, #-12]
        while (*ptr == '#')ptr ++;
100121b4:	ea000002 	b	100121c4 <_list_thread+0xf8>
100121b8:	e51b300c 	ldr	r3, [fp, #-12]
100121bc:	e2833001 	add	r3, r3, #1
100121c0:	e50b300c 	str	r3, [fp, #-12]
100121c4:	e51b300c 	ldr	r3, [fp, #-12]
100121c8:	e5d33000 	ldrb	r3, [r3]
100121cc:	e3530023 	cmp	r3, #35	; 0x23
100121d0:	0afffff8 	beq	100121b8 <_list_thread+0xec>

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
100121d4:	e51b3010 	ldr	r3, [fp, #-16]
100121d8:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
100121dc:	e1a02003 	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
100121e0:	e51b3010 	ldr	r3, [fp, #-16]
100121e4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
100121e8:	e1a01003 	mov	r1, r3
100121ec:	e51b3010 	ldr	r3, [fp, #-16]
100121f0:	e5933018 	ldr	r3, [r3, #24]
100121f4:	e0633001 	rsb	r3, r3, r1
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
100121f8:	e0821003 	add	r1, r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
100121fc:	e51b3010 	ldr	r3, [fp, #-16]
10012200:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10012204:	e1a0e003 	mov	lr, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
10012208:	e51b3010 	ldr	r3, [fp, #-16]
1001220c:	e1d332b8 	ldrh	r3, [r3, #40]	; 0x28
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10012210:	e1a02003 	mov	r2, r3
            thread->stack_size + ((rt_uint32_t)thread->stack_addr - (rt_uint32_t)thread->sp),
            thread->stack_size,
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
10012214:	e51b3010 	ldr	r3, [fp, #-16]
10012218:	e5933024 	ldr	r3, [r3, #36]	; 0x24
1001221c:	e1a00003 	mov	r0, r3
10012220:	e51b300c 	ldr	r3, [fp, #-12]
10012224:	e0633000 	rsb	r3, r3, r0
        else if (thread->stat == RT_THREAD_CLOSE)   rt_kprintf(" close  ");

        ptr = (rt_uint8_t*)thread->stack_addr;
        while (*ptr == '#')ptr ++;

        rt_kprintf(" 0x%08x 0x%08x 0x%08x 0x%08x %03d\n",
10012228:	e082c003 	add	ip, r2, r3
1001222c:	e51b3010 	ldr	r3, [fp, #-16]
10012230:	e5932044 	ldr	r2, [r3, #68]	; 0x44
10012234:	e51b3010 	ldr	r3, [fp, #-16]
10012238:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
1001223c:	e58d2000 	str	r2, [sp]
10012240:	e58d3004 	str	r3, [sp, #4]
10012244:	e30f0b6c 	movw	r0, #64364	; 0xfb6c
10012248:	e3410001 	movt	r0, #4097	; 0x1001
1001224c:	e1a0200e 	mov	r2, lr
10012250:	e1a0300c 	mov	r3, ip
10012254:	ebffd01e 	bl	100062d4 <rt_kprintf>
    struct rt_list_node *node;
    rt_uint8_t *ptr;

    rt_kprintf(" thread  pri  status      sp     stack size max used   left tick  error\n");
    rt_kprintf("-------- ---- ------- ---------- ---------- ---------- ---------- ---\n");
    for (node = list->next; node != list; node = node->next)
10012258:	e51b3008 	ldr	r3, [fp, #-8]
1001225c:	e5933000 	ldr	r3, [r3]
10012260:	e50b3008 	str	r3, [fp, #-8]
10012264:	e51b2008 	ldr	r2, [fp, #-8]
10012268:	e51b3018 	ldr	r3, [fp, #-24]
1001226c:	e1520003 	cmp	r2, r3
10012270:	1affffa3 	bne	10012104 <_list_thread+0x38>
            thread->stack_size - ((rt_uint32_t) ptr - (rt_uint32_t)thread->stack_addr),
            thread->remaining_tick,
            thread->error);
    }
	
    return 0;
10012274:	e3a03000 	mov	r3, #0
}
10012278:	e1a00003 	mov	r0, r3
1001227c:	e24bd004 	sub	sp, fp, #4
10012280:	e8bd8800 	pop	{fp, pc}

10012284 <list_thread>:

long list_thread(void)
{
10012284:	e92d4800 	push	{fp, lr}
10012288:	e28db004 	add	fp, sp, #4
    return _list_thread(&rt_object_container[RT_Object_Class_Thread].object_list);
1001228c:	e59f000c 	ldr	r0, [pc, #12]	; 100122a0 <list_thread+0x1c>
10012290:	ebffff8d 	bl	100120cc <_list_thread>
10012294:	e1a03000 	mov	r3, r0
}
10012298:	e1a00003 	mov	r0, r3
1001229c:	e8bd8800 	pop	{fp, pc}
100122a0:	100209bc 	.word	0x100209bc

100122a4 <show_wait_queue>:
FINSH_FUNCTION_EXPORT(list_thread, list thread);
MSH_CMD_EXPORT(list_thread, list thread);

static void show_wait_queue(struct rt_list_node *list)
{
100122a4:	e92d4800 	push	{fp, lr}
100122a8:	e28db004 	add	fp, sp, #4
100122ac:	e24dd010 	sub	sp, sp, #16
100122b0:	e50b0010 	str	r0, [fp, #-16]
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
100122b4:	e51b3010 	ldr	r3, [fp, #-16]
100122b8:	e5933000 	ldr	r3, [r3]
100122bc:	e50b3008 	str	r3, [fp, #-8]
100122c0:	ea000012 	b	10012310 <show_wait_queue+0x6c>
    {
        thread = rt_list_entry(node, struct rt_thread, tlist);
100122c4:	e51b3008 	ldr	r3, [fp, #-8]
100122c8:	e2433010 	sub	r3, r3, #16
100122cc:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%s", thread->name);
100122d0:	e51b300c 	ldr	r3, [fp, #-12]
100122d4:	e30f0b90 	movw	r0, #64400	; 0xfb90
100122d8:	e3410001 	movt	r0, #4097	; 0x1001
100122dc:	e1a01003 	mov	r1, r3
100122e0:	ebffcffb 	bl	100062d4 <rt_kprintf>

        if (node->next != list)
100122e4:	e51b3008 	ldr	r3, [fp, #-8]
100122e8:	e5932000 	ldr	r2, [r3]
100122ec:	e51b3010 	ldr	r3, [fp, #-16]
100122f0:	e1520003 	cmp	r2, r3
100122f4:	0a000002 	beq	10012304 <show_wait_queue+0x60>
            rt_kprintf("/");
100122f8:	e30f0b94 	movw	r0, #64404	; 0xfb94
100122fc:	e3410001 	movt	r0, #4097	; 0x1001
10012300:	ebffcff3 	bl	100062d4 <rt_kprintf>
static void show_wait_queue(struct rt_list_node *list)
{
    struct rt_thread *thread;
    struct rt_list_node *node;

    for (node = list->next; node != list; node = node->next)
10012304:	e51b3008 	ldr	r3, [fp, #-8]
10012308:	e5933000 	ldr	r3, [r3]
1001230c:	e50b3008 	str	r3, [fp, #-8]
10012310:	e51b2008 	ldr	r2, [fp, #-8]
10012314:	e51b3010 	ldr	r3, [fp, #-16]
10012318:	e1520003 	cmp	r2, r3
1001231c:	1affffe8 	bne	100122c4 <show_wait_queue+0x20>
        rt_kprintf("%s", thread->name);

        if (node->next != list)
            rt_kprintf("/");
    }
}
10012320:	e24bd004 	sub	sp, fp, #4
10012324:	e8bd8800 	pop	{fp, pc}

10012328 <_list_sem>:

#ifdef RT_USING_SEMAPHORE
static long _list_sem(struct rt_list_node *list)
{
10012328:	e92d4830 	push	{r4, r5, fp, lr}
1001232c:	e28db00c 	add	fp, sp, #12
10012330:	e24dd018 	sub	sp, sp, #24
10012334:	e50b0018 	str	r0, [fp, #-24]
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
10012338:	e30f0b98 	movw	r0, #64408	; 0xfb98
1001233c:	e3410001 	movt	r0, #4097	; 0x1001
10012340:	ebffcfe3 	bl	100062d4 <rt_kprintf>
    rt_kprintf("--------  --- --------------\n");
10012344:	e30f0bb8 	movw	r0, #64440	; 0xfbb8
10012348:	e3410001 	movt	r0, #4097	; 0x1001
1001234c:	ebffcfe0 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10012350:	e51b3018 	ldr	r3, [fp, #-24]
10012354:	e5933000 	ldr	r3, [r3]
10012358:	e50b3010 	str	r3, [fp, #-16]
1001235c:	ea000034 	b	10012434 <_list_sem+0x10c>
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
10012360:	e51b3010 	ldr	r3, [fp, #-16]
10012364:	e2433008 	sub	r3, r3, #8
10012368:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&sem->parent.suspend_thread))
1001236c:	e51b3014 	ldr	r3, [fp, #-20]
10012370:	e2833010 	add	r3, r3, #16
10012374:	e1a00003 	mov	r0, r3
10012378:	ebffff1d 	bl	10011ff4 <rt_list_isempty>
1001237c:	e1a03000 	mov	r3, r0
10012380:	e3530000 	cmp	r3, #0
10012384:	1a000017 	bne	100123e8 <_list_sem+0xc0>
        {
            rt_kprintf("%-8.*s  %03d %d:", 
                       RT_NAME_MAX,
                       sem->parent.parent.name,
10012388:	e51b4014 	ldr	r4, [fp, #-20]
                       sem->value,
1001238c:	e51b3014 	ldr	r3, [fp, #-20]
10012390:	e1d331b8 	ldrh	r3, [r3, #24]
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
10012394:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
10012398:	e51b3014 	ldr	r3, [fp, #-20]
1001239c:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        sem = (struct rt_semaphore *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&sem->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  %03d %d:", 
100123a0:	e1a00003 	mov	r0, r3
100123a4:	ebffff21 	bl	10012030 <rt_list_len>
100123a8:	e1a03000 	mov	r3, r0
100123ac:	e58d3000 	str	r3, [sp]
100123b0:	e30f0bd8 	movw	r0, #64472	; 0xfbd8
100123b4:	e3410001 	movt	r0, #4097	; 0x1001
100123b8:	e3a01006 	mov	r1, #6
100123bc:	e1a02004 	mov	r2, r4
100123c0:	e1a03005 	mov	r3, r5
100123c4:	ebffcfc2 	bl	100062d4 <rt_kprintf>
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
            show_wait_queue(&(sem->parent.suspend_thread));
100123c8:	e51b3014 	ldr	r3, [fp, #-20]
100123cc:	e2833010 	add	r3, r3, #16
100123d0:	e1a00003 	mov	r0, r3
100123d4:	ebffffb2 	bl	100122a4 <show_wait_queue>
            rt_kprintf("\n");
100123d8:	e30f0bec 	movw	r0, #64492	; 0xfbec
100123dc:	e3410001 	movt	r0, #4097	; 0x1001
100123e0:	ebffcfbb 	bl	100062d4 <rt_kprintf>
100123e4:	ea00000f 	b	10012428 <_list_sem+0x100>
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
                       RT_NAME_MAX,
                       sem->parent.parent.name,
100123e8:	e51b4014 	ldr	r4, [fp, #-20]
                       sem->value,
100123ec:	e51b3014 	ldr	r3, [fp, #-20]
100123f0:	e1d331b8 	ldrh	r3, [r3, #24]
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
100123f4:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       sem->parent.parent.name,
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
100123f8:	e51b3014 	ldr	r3, [fp, #-20]
100123fc:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(sem->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  %03d %d\n",
10012400:	e1a00003 	mov	r0, r3
10012404:	ebffff09 	bl	10012030 <rt_list_len>
10012408:	e1a03000 	mov	r3, r0
1001240c:	e58d3000 	str	r3, [sp]
10012410:	e30f0bf0 	movw	r0, #64496	; 0xfbf0
10012414:	e3410001 	movt	r0, #4097	; 0x1001
10012418:	e3a01006 	mov	r1, #6
1001241c:	e1a02004 	mov	r2, r4
10012420:	e1a03005 	mov	r3, r5
10012424:	ebffcfaa 	bl	100062d4 <rt_kprintf>
    struct rt_semaphore *sem;
    struct rt_list_node *node;

    rt_kprintf("semaphore v   suspend thread\n");
    rt_kprintf("--------  --- --------------\n");
    for (node = list->next; node != list; node = node->next)
10012428:	e51b3010 	ldr	r3, [fp, #-16]
1001242c:	e5933000 	ldr	r3, [r3]
10012430:	e50b3010 	str	r3, [fp, #-16]
10012434:	e51b2010 	ldr	r2, [fp, #-16]
10012438:	e51b3018 	ldr	r3, [fp, #-24]
1001243c:	e1520003 	cmp	r2, r3
10012440:	1affffc6 	bne	10012360 <_list_sem+0x38>
                       sem->value,
                       rt_list_len(&sem->parent.suspend_thread));
        }
    }

    return 0;
10012444:	e3a03000 	mov	r3, #0
}
10012448:	e1a00003 	mov	r0, r3
1001244c:	e24bd00c 	sub	sp, fp, #12
10012450:	e8bd8830 	pop	{r4, r5, fp, pc}

10012454 <list_sem>:

long list_sem(void)
{
10012454:	e92d4800 	push	{fp, lr}
10012458:	e28db004 	add	fp, sp, #4
    return _list_sem(&rt_object_container[RT_Object_Class_Semaphore].object_list);
1001245c:	e59f000c 	ldr	r0, [pc, #12]	; 10012470 <list_sem+0x1c>
10012460:	ebffffb0 	bl	10012328 <_list_sem>
10012464:	e1a03000 	mov	r3, r0
}
10012468:	e1a00003 	mov	r0, r3
1001246c:	e8bd8800 	pop	{fp, pc}
10012470:	100209cc 	.word	0x100209cc

10012474 <_list_event>:
MSH_CMD_EXPORT(list_sem, list semaphore in system);
#endif

#ifdef RT_USING_EVENT
static long _list_event(struct rt_list_node *list)
{
10012474:	e92d4830 	push	{r4, r5, fp, lr}
10012478:	e28db00c 	add	fp, sp, #12
1001247c:	e24dd018 	sub	sp, sp, #24
10012480:	e50b0018 	str	r0, [fp, #-24]
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
10012484:	e30f0c04 	movw	r0, #64516	; 0xfc04
10012488:	e3410001 	movt	r0, #4097	; 0x1001
1001248c:	ebffcf90 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- ---------- --------------\n");
10012490:	e30f0c28 	movw	r0, #64552	; 0xfc28
10012494:	e3410001 	movt	r0, #4097	; 0x1001
10012498:	ebffcf8d 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
1001249c:	e51b3018 	ldr	r3, [fp, #-24]
100124a0:	e5933000 	ldr	r3, [r3]
100124a4:	e50b3010 	str	r3, [fp, #-16]
100124a8:	ea00002a 	b	10012558 <_list_event+0xe4>
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
100124ac:	e51b3010 	ldr	r3, [fp, #-16]
100124b0:	e2433008 	sub	r3, r3, #8
100124b4:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&e->parent.suspend_thread))
100124b8:	e51b3014 	ldr	r3, [fp, #-20]
100124bc:	e2833010 	add	r3, r3, #16
100124c0:	e1a00003 	mov	r0, r3
100124c4:	ebfffeca 	bl	10011ff4 <rt_list_isempty>
100124c8:	e1a03000 	mov	r3, r0
100124cc:	e3530000 	cmp	r3, #0
100124d0:	1a000016 	bne	10012530 <_list_event+0xbc>
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
                       RT_NAME_MAX,
                       e->parent.parent.name,
100124d4:	e51b5014 	ldr	r5, [fp, #-20]
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
100124d8:	e51b3014 	ldr	r3, [fp, #-20]
100124dc:	e5934018 	ldr	r4, [r3, #24]
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
100124e0:	e51b3014 	ldr	r3, [fp, #-20]
100124e4:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        e = (struct rt_event *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&e->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s  0x%08x %03d:",
100124e8:	e1a00003 	mov	r0, r3
100124ec:	ebfffecf 	bl	10012030 <rt_list_len>
100124f0:	e1a03000 	mov	r3, r0
100124f4:	e58d3000 	str	r3, [sp]
100124f8:	e30f0c4c 	movw	r0, #64588	; 0xfc4c
100124fc:	e3410001 	movt	r0, #4097	; 0x1001
10012500:	e3a01006 	mov	r1, #6
10012504:	e1a02005 	mov	r2, r5
10012508:	e1a03004 	mov	r3, r4
1001250c:	ebffcf70 	bl	100062d4 <rt_kprintf>
                       RT_NAME_MAX,
                       e->parent.parent.name,
                       e->set,
                       rt_list_len(&e->parent.suspend_thread));
            show_wait_queue(&(e->parent.suspend_thread));
10012510:	e51b3014 	ldr	r3, [fp, #-20]
10012514:	e2833010 	add	r3, r3, #16
10012518:	e1a00003 	mov	r0, r3
1001251c:	ebffff60 	bl	100122a4 <show_wait_queue>
            rt_kprintf("\n");
10012520:	e30f0bec 	movw	r0, #64492	; 0xfbec
10012524:	e3410001 	movt	r0, #4097	; 0x1001
10012528:	ebffcf69 	bl	100062d4 <rt_kprintf>
1001252c:	ea000006 	b	1001254c <_list_event+0xd8>
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
10012530:	e51b2014 	ldr	r2, [fp, #-20]
            show_wait_queue(&(e->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s  0x%08x 0\n",
10012534:	e51b3014 	ldr	r3, [fp, #-20]
10012538:	e5933018 	ldr	r3, [r3, #24]
1001253c:	e30f0c64 	movw	r0, #64612	; 0xfc64
10012540:	e3410001 	movt	r0, #4097	; 0x1001
10012544:	e3a01006 	mov	r1, #6
10012548:	ebffcf61 	bl	100062d4 <rt_kprintf>
    struct rt_event *e;
    struct rt_list_node *node;

    rt_kprintf("event    set        suspend thread\n");
    rt_kprintf("-------- ---------- --------------\n");
    for (node = list->next; node != list; node = node->next)
1001254c:	e51b3010 	ldr	r3, [fp, #-16]
10012550:	e5933000 	ldr	r3, [r3]
10012554:	e50b3010 	str	r3, [fp, #-16]
10012558:	e51b2010 	ldr	r2, [fp, #-16]
1001255c:	e51b3018 	ldr	r3, [fp, #-24]
10012560:	e1520003 	cmp	r2, r3
10012564:	1affffd0 	bne	100124ac <_list_event+0x38>
            rt_kprintf("%-8.*s  0x%08x 0\n",
                       RT_NAME_MAX, e->parent.parent.name, e->set);
        }
    }

    return 0;
10012568:	e3a03000 	mov	r3, #0
}
1001256c:	e1a00003 	mov	r0, r3
10012570:	e24bd00c 	sub	sp, fp, #12
10012574:	e8bd8830 	pop	{r4, r5, fp, pc}

10012578 <list_event>:

long list_event(void)
{
10012578:	e92d4800 	push	{fp, lr}
1001257c:	e28db004 	add	fp, sp, #4
    return _list_event(&rt_object_container[RT_Object_Class_Event].object_list);
10012580:	e59f000c 	ldr	r0, [pc, #12]	; 10012594 <list_event+0x1c>
10012584:	ebffffba 	bl	10012474 <_list_event>
10012588:	e1a03000 	mov	r3, r0
}
1001258c:	e1a00003 	mov	r0, r3
10012590:	e8bd8800 	pop	{fp, pc}
10012594:	100209ec 	.word	0x100209ec

10012598 <_list_mutex>:
MSH_CMD_EXPORT(list_event, list event in system);
#endif

#ifdef RT_USING_MUTEX
static long _list_mutex(struct rt_list_node *list)
{
10012598:	e92d4870 	push	{r4, r5, r6, fp, lr}
1001259c:	e28db010 	add	fp, sp, #16
100125a0:	e24dd024 	sub	sp, sp, #36	; 0x24
100125a4:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
100125a8:	e30f0c78 	movw	r0, #64632	; 0xfc78
100125ac:	e3410001 	movt	r0, #4097	; 0x1001
100125b0:	ebffcf47 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- -------- ---- --------------\n");
100125b4:	e30f0ca0 	movw	r0, #64672	; 0xfca0
100125b8:	e3410001 	movt	r0, #4097	; 0x1001
100125bc:	ebffcf44 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
100125c0:	e51b3020 	ldr	r3, [fp, #-32]
100125c4:	e5933000 	ldr	r3, [r3]
100125c8:	e50b3018 	str	r3, [fp, #-24]
100125cc:	ea00001a 	b	1001263c <_list_mutex+0xa4>
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
100125d0:	e51b3018 	ldr	r3, [fp, #-24]
100125d4:	e2433008 	sub	r3, r3, #8
100125d8:	e50b301c 	str	r3, [fp, #-28]
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
                   RT_NAME_MAX,
                   m->parent.parent.name,
100125dc:	e51b401c 	ldr	r4, [fp, #-28]
                   RT_NAME_MAX,
                   m->owner->name,
100125e0:	e51b301c 	ldr	r3, [fp, #-28]
100125e4:	e593301c 	ldr	r3, [r3, #28]
100125e8:	e1a06003 	mov	r6, r3
                   m->hold,
100125ec:	e51b301c 	ldr	r3, [fp, #-28]
100125f0:	e5d3301b 	ldrb	r3, [r3, #27]
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
100125f4:	e1a05003 	mov	r5, r3
                   RT_NAME_MAX,
                   m->parent.parent.name,
                   RT_NAME_MAX,
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
100125f8:	e51b301c 	ldr	r3, [fp, #-28]
100125fc:	e2833010 	add	r3, r3, #16
    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mutex *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-8.*s %04d %d\n",
10012600:	e1a00003 	mov	r0, r3
10012604:	ebfffe89 	bl	10012030 <rt_list_len>
10012608:	e1a03000 	mov	r3, r0
1001260c:	e58d6000 	str	r6, [sp]
10012610:	e58d5004 	str	r5, [sp, #4]
10012614:	e58d3008 	str	r3, [sp, #8]
10012618:	e30f0cc8 	movw	r0, #64712	; 0xfcc8
1001261c:	e3410001 	movt	r0, #4097	; 0x1001
10012620:	e3a01006 	mov	r1, #6
10012624:	e1a02004 	mov	r2, r4
10012628:	e3a03006 	mov	r3, #6
1001262c:	ebffcf28 	bl	100062d4 <rt_kprintf>
    struct rt_mutex *m;
    struct rt_list_node *node;

    rt_kprintf("mutex    owner    hold suspend thread\n");
    rt_kprintf("-------- -------- ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
10012630:	e51b3018 	ldr	r3, [fp, #-24]
10012634:	e5933000 	ldr	r3, [r3]
10012638:	e50b3018 	str	r3, [fp, #-24]
1001263c:	e51b2018 	ldr	r2, [fp, #-24]
10012640:	e51b3020 	ldr	r3, [fp, #-32]
10012644:	e1520003 	cmp	r2, r3
10012648:	1affffe0 	bne	100125d0 <_list_mutex+0x38>
                   m->owner->name,
                   m->hold,
                   rt_list_len(&m->parent.suspend_thread));
    }

    return 0;
1001264c:	e3a03000 	mov	r3, #0
}
10012650:	e1a00003 	mov	r0, r3
10012654:	e24bd010 	sub	sp, fp, #16
10012658:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

1001265c <list_mutex>:

long list_mutex(void)
{
1001265c:	e92d4800 	push	{fp, lr}
10012660:	e28db004 	add	fp, sp, #4
    return _list_mutex(&rt_object_container[RT_Object_Class_Mutex].object_list);
10012664:	e59f000c 	ldr	r0, [pc, #12]	; 10012678 <list_mutex+0x1c>
10012668:	ebffffca 	bl	10012598 <_list_mutex>
1001266c:	e1a03000 	mov	r3, r0
}
10012670:	e1a00003 	mov	r0, r3
10012674:	e8bd8800 	pop	{fp, pc}
10012678:	100209dc 	.word	0x100209dc

1001267c <_list_mailbox>:
MSH_CMD_EXPORT(list_mutex, list mutex in system);
#endif

#ifdef RT_USING_MAILBOX
static long _list_mailbox(struct rt_list_node *list)
{
1001267c:	e92d4870 	push	{r4, r5, r6, fp, lr}
10012680:	e28db010 	add	fp, sp, #16
10012684:	e24dd01c 	sub	sp, sp, #28
10012688:	e50b0020 	str	r0, [fp, #-32]
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
1001268c:	e30f0ce0 	movw	r0, #64736	; 0xfce0
10012690:	e3410001 	movt	r0, #4097	; 0x1001
10012694:	ebffcf0e 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- ----  ---- --------------\n");
10012698:	e30f0d04 	movw	r0, #64772	; 0xfd04
1001269c:	e3410001 	movt	r0, #4097	; 0x1001
100126a0:	ebffcf0b 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
100126a4:	e51b3020 	ldr	r3, [fp, #-32]
100126a8:	e5933000 	ldr	r3, [r3]
100126ac:	e50b3018 	str	r3, [fp, #-24]
100126b0:	ea00003c 	b	100127a8 <_list_mailbox+0x12c>
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
100126b4:	e51b3018 	ldr	r3, [fp, #-24]
100126b8:	e2433008 	sub	r3, r3, #8
100126bc:	e50b301c 	str	r3, [fp, #-28]
        if (!rt_list_isempty(&m->parent.suspend_thread))
100126c0:	e51b301c 	ldr	r3, [fp, #-28]
100126c4:	e2833010 	add	r3, r3, #16
100126c8:	e1a00003 	mov	r0, r3
100126cc:	ebfffe48 	bl	10011ff4 <rt_list_isempty>
100126d0:	e1a03000 	mov	r3, r0
100126d4:	e3530000 	cmp	r3, #0
100126d8:	1a00001b 	bne	1001274c <_list_mailbox+0xd0>
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
100126dc:	e51b401c 	ldr	r4, [fp, #-28]
                       m->entry,
100126e0:	e51b301c 	ldr	r3, [fp, #-28]
100126e4:	e1d331be 	ldrh	r3, [r3, #30]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
100126e8:	e1a06003 	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
100126ec:	e51b301c 	ldr	r3, [fp, #-28]
100126f0:	e1d331bc 	ldrh	r3, [r3, #28]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
100126f4:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
100126f8:	e51b301c 	ldr	r3, [fp, #-28]
100126fc:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_mailbox *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %04d %d:",
10012700:	e1a00003 	mov	r0, r3
10012704:	ebfffe49 	bl	10012030 <rt_list_len>
10012708:	e1a03000 	mov	r3, r0
1001270c:	e58d5000 	str	r5, [sp]
10012710:	e58d3004 	str	r3, [sp, #4]
10012714:	e30f0d28 	movw	r0, #64808	; 0xfd28
10012718:	e3410001 	movt	r0, #4097	; 0x1001
1001271c:	e3a01006 	mov	r1, #6
10012720:	e1a02004 	mov	r2, r4
10012724:	e1a03006 	mov	r3, r6
10012728:	ebffcee9 	bl	100062d4 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
1001272c:	e51b301c 	ldr	r3, [fp, #-28]
10012730:	e2833010 	add	r3, r3, #16
10012734:	e1a00003 	mov	r0, r3
10012738:	ebfffed9 	bl	100122a4 <show_wait_queue>
            rt_kprintf("\n");
1001273c:	e30f0bec 	movw	r0, #64492	; 0xfbec
10012740:	e3410001 	movt	r0, #4097	; 0x1001
10012744:	ebffcee2 	bl	100062d4 <rt_kprintf>
10012748:	ea000013 	b	1001279c <_list_mailbox+0x120>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
1001274c:	e51b401c 	ldr	r4, [fp, #-28]
                       m->entry,
10012750:	e51b301c 	ldr	r3, [fp, #-28]
10012754:	e1d331be 	ldrh	r3, [r3, #30]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
10012758:	e1a06003 	mov	r6, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
1001275c:	e51b301c 	ldr	r3, [fp, #-28]
10012760:	e1d331bc 	ldrh	r3, [r3, #28]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
10012764:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
10012768:	e51b301c 	ldr	r3, [fp, #-28]
1001276c:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d %d\n",
10012770:	e1a00003 	mov	r0, r3
10012774:	ebfffe2d 	bl	10012030 <rt_list_len>
10012778:	e1a03000 	mov	r3, r0
1001277c:	e58d5000 	str	r5, [sp]
10012780:	e58d3004 	str	r3, [sp, #4]
10012784:	e30f0d40 	movw	r0, #64832	; 0xfd40
10012788:	e3410001 	movt	r0, #4097	; 0x1001
1001278c:	e3a01006 	mov	r1, #6
10012790:	e1a02004 	mov	r2, r4
10012794:	e1a03006 	mov	r3, r6
10012798:	ebffcecd 	bl	100062d4 <rt_kprintf>
    struct rt_mailbox *m;
    struct rt_list_node *node;

    rt_kprintf("mailbox  entry size suspend thread\n");
    rt_kprintf("-------- ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
1001279c:	e51b3018 	ldr	r3, [fp, #-24]
100127a0:	e5933000 	ldr	r3, [r3]
100127a4:	e50b3018 	str	r3, [fp, #-24]
100127a8:	e51b2018 	ldr	r2, [fp, #-24]
100127ac:	e51b3020 	ldr	r3, [fp, #-32]
100127b0:	e1520003 	cmp	r2, r3
100127b4:	1affffbe 	bne	100126b4 <_list_mailbox+0x38>
                       m->size,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
100127b8:	e3a03000 	mov	r3, #0
}
100127bc:	e1a00003 	mov	r0, r3
100127c0:	e24bd010 	sub	sp, fp, #16
100127c4:	e8bd8870 	pop	{r4, r5, r6, fp, pc}

100127c8 <list_mailbox>:

long list_mailbox(void)
{
100127c8:	e92d4800 	push	{fp, lr}
100127cc:	e28db004 	add	fp, sp, #4
    return _list_mailbox(&rt_object_container[RT_Object_Class_MailBox].object_list);
100127d0:	e59f000c 	ldr	r0, [pc, #12]	; 100127e4 <list_mailbox+0x1c>
100127d4:	ebffffa8 	bl	1001267c <_list_mailbox>
100127d8:	e1a03000 	mov	r3, r0
}
100127dc:	e1a00003 	mov	r0, r3
100127e0:	e8bd8800 	pop	{fp, pc}
100127e4:	100209fc 	.word	0x100209fc

100127e8 <_list_msgqueue>:
MSH_CMD_EXPORT(list_mailbox, list mail box in system);
#endif

#ifdef RT_USING_MESSAGEQUEUE
static long _list_msgqueue(struct rt_list_node *list)
{
100127e8:	e92d4830 	push	{r4, r5, fp, lr}
100127ec:	e28db00c 	add	fp, sp, #12
100127f0:	e24dd018 	sub	sp, sp, #24
100127f4:	e50b0018 	str	r0, [fp, #-24]
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
100127f8:	e30f0d58 	movw	r0, #64856	; 0xfd58
100127fc:	e3410001 	movt	r0, #4097	; 0x1001
10012800:	ebffceb3 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- ----  --------------\n");
10012804:	e30f0d78 	movw	r0, #64888	; 0xfd78
10012808:	e3410001 	movt	r0, #4097	; 0x1001
1001280c:	ebffceb0 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10012810:	e51b3018 	ldr	r3, [fp, #-24]
10012814:	e5933000 	ldr	r3, [r3]
10012818:	e50b3010 	str	r3, [fp, #-16]
1001281c:	ea000034 	b	100128f4 <_list_msgqueue+0x10c>
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
10012820:	e51b3010 	ldr	r3, [fp, #-16]
10012824:	e2433008 	sub	r3, r3, #8
10012828:	e50b3014 	str	r3, [fp, #-20]
        if (!rt_list_isempty(&m->parent.suspend_thread))
1001282c:	e51b3014 	ldr	r3, [fp, #-20]
10012830:	e2833010 	add	r3, r3, #16
10012834:	e1a00003 	mov	r0, r3
10012838:	ebfffded 	bl	10011ff4 <rt_list_isempty>
1001283c:	e1a03000 	mov	r3, r0
10012840:	e3530000 	cmp	r3, #0
10012844:	1a000017 	bne	100128a8 <_list_msgqueue+0xc0>
        {
            rt_kprintf("%-8.*s %04d  %d:",
                       RT_NAME_MAX,
                       m->parent.parent.name,
10012848:	e51b4014 	ldr	r4, [fp, #-20]
                       m->entry,
1001284c:	e51b3014 	ldr	r3, [fp, #-20]
10012850:	e1d332b0 	ldrh	r3, [r3, #32]
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
10012854:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
10012858:	e51b3014 	ldr	r3, [fp, #-20]
1001285c:	e2833010 	add	r3, r3, #16
    for (node = list->next; node != list; node = node->next)
    {
        m = (struct rt_messagequeue *)(rt_list_entry(node, struct rt_object, list));
        if (!rt_list_isempty(&m->parent.suspend_thread))
        {
            rt_kprintf("%-8.*s %04d  %d:",
10012860:	e1a00003 	mov	r0, r3
10012864:	ebfffdf1 	bl	10012030 <rt_list_len>
10012868:	e1a03000 	mov	r3, r0
1001286c:	e58d3000 	str	r3, [sp]
10012870:	e30f0d98 	movw	r0, #64920	; 0xfd98
10012874:	e3410001 	movt	r0, #4097	; 0x1001
10012878:	e3a01006 	mov	r1, #6
1001287c:	e1a02004 	mov	r2, r4
10012880:	e1a03005 	mov	r3, r5
10012884:	ebffce92 	bl	100062d4 <rt_kprintf>
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
            show_wait_queue(&(m->parent.suspend_thread));
10012888:	e51b3014 	ldr	r3, [fp, #-20]
1001288c:	e2833010 	add	r3, r3, #16
10012890:	e1a00003 	mov	r0, r3
10012894:	ebfffe82 	bl	100122a4 <show_wait_queue>
            rt_kprintf("\n");
10012898:	e30f0bec 	movw	r0, #64492	; 0xfbec
1001289c:	e3410001 	movt	r0, #4097	; 0x1001
100128a0:	ebffce8b 	bl	100062d4 <rt_kprintf>
100128a4:	ea00000f 	b	100128e8 <_list_msgqueue+0x100>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
                       RT_NAME_MAX,
                       m->parent.parent.name,
100128a8:	e51b4014 	ldr	r4, [fp, #-20]
                       m->entry,
100128ac:	e51b3014 	ldr	r3, [fp, #-20]
100128b0:	e1d332b0 	ldrh	r3, [r3, #32]
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
100128b4:	e1a05003 	mov	r5, r3
                       RT_NAME_MAX,
                       m->parent.parent.name,
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
100128b8:	e51b3014 	ldr	r3, [fp, #-20]
100128bc:	e2833010 	add	r3, r3, #16
            show_wait_queue(&(m->parent.suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %d\n",
100128c0:	e1a00003 	mov	r0, r3
100128c4:	ebfffdd9 	bl	10012030 <rt_list_len>
100128c8:	e1a03000 	mov	r3, r0
100128cc:	e58d3000 	str	r3, [sp]
100128d0:	e30f0dac 	movw	r0, #64940	; 0xfdac
100128d4:	e3410001 	movt	r0, #4097	; 0x1001
100128d8:	e3a01006 	mov	r1, #6
100128dc:	e1a02004 	mov	r2, r4
100128e0:	e1a03005 	mov	r3, r5
100128e4:	ebffce7a 	bl	100062d4 <rt_kprintf>
    struct rt_messagequeue *m;
    struct rt_list_node *node;

    rt_kprintf("msgqueue entry suspend thread\n");
    rt_kprintf("-------- ----  --------------\n");
    for (node = list->next; node != list; node = node->next)
100128e8:	e51b3010 	ldr	r3, [fp, #-16]
100128ec:	e5933000 	ldr	r3, [r3]
100128f0:	e50b3010 	str	r3, [fp, #-16]
100128f4:	e51b2010 	ldr	r2, [fp, #-16]
100128f8:	e51b3018 	ldr	r3, [fp, #-24]
100128fc:	e1520003 	cmp	r2, r3
10012900:	1affffc6 	bne	10012820 <_list_msgqueue+0x38>
                       m->entry,
                       rt_list_len(&m->parent.suspend_thread));
        }
    }

    return 0;
10012904:	e3a03000 	mov	r3, #0
}
10012908:	e1a00003 	mov	r0, r3
1001290c:	e24bd00c 	sub	sp, fp, #12
10012910:	e8bd8830 	pop	{r4, r5, fp, pc}

10012914 <list_msgqueue>:

long list_msgqueue(void)
{
10012914:	e92d4800 	push	{fp, lr}
10012918:	e28db004 	add	fp, sp, #4
    return _list_msgqueue(&rt_object_container[RT_Object_Class_MessageQueue].object_list);
1001291c:	e59f000c 	ldr	r0, [pc, #12]	; 10012930 <list_msgqueue+0x1c>
10012920:	ebffffb0 	bl	100127e8 <_list_msgqueue>
10012924:	e1a03000 	mov	r3, r0
}
10012928:	e1a00003 	mov	r0, r3
1001292c:	e8bd8800 	pop	{fp, pc}
10012930:	10020a0c 	.word	0x10020a0c

10012934 <_list_mempool>:
MSH_CMD_EXPORT(list_memheap, list memory heap in system);
#endif

#ifdef RT_USING_MEMPOOL
static long _list_mempool(struct rt_list_node *list)
{
10012934:	e92d4800 	push	{fp, lr}
10012938:	e28db004 	add	fp, sp, #4
1001293c:	e24dd020 	sub	sp, sp, #32
10012940:	e50b0010 	str	r0, [fp, #-16]
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
10012944:	e30f0dc0 	movw	r0, #64960	; 0xfdc0
10012948:	e3410001 	movt	r0, #4097	; 0x1001
1001294c:	ebffce60 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- ----  ----  ---- --------------\n");
10012950:	e30f0dec 	movw	r0, #65004	; 0xfdec
10012954:	e3410001 	movt	r0, #4097	; 0x1001
10012958:	ebffce5d 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
1001295c:	e51b3010 	ldr	r3, [fp, #-16]
10012960:	e5933000 	ldr	r3, [r3]
10012964:	e50b3008 	str	r3, [fp, #-8]
10012968:	ea000035 	b	10012a44 <_list_mempool+0x110>
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
1001296c:	e51b3008 	ldr	r3, [fp, #-8]
10012970:	e2433008 	sub	r3, r3, #8
10012974:	e50b300c 	str	r3, [fp, #-12]
        if (mp->suspend_thread_count > 0)
10012978:	e51b300c 	ldr	r3, [fp, #-12]
1001297c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10012980:	e3530000 	cmp	r3, #0
10012984:	0a000019 	beq	100129f0 <_list_mempool+0xbc>
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
                       RT_NAME_MAX,
                       mp->parent.name,
10012988:	e51be00c 	ldr	lr, [fp, #-12]
    for (node = list->next; node != list; node = node->next)
    {
        mp = (struct rt_mempool *)rt_list_entry(node, struct rt_object, list);
        if (mp->suspend_thread_count > 0)
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d:",
1001298c:	e51b300c 	ldr	r3, [fp, #-12]
10012990:	e593c018 	ldr	ip, [r3, #24]
10012994:	e51b300c 	ldr	r3, [fp, #-12]
10012998:	e5931020 	ldr	r1, [r3, #32]
1001299c:	e51b300c 	ldr	r3, [fp, #-12]
100129a0:	e5932024 	ldr	r2, [r3, #36]	; 0x24
100129a4:	e51b300c 	ldr	r3, [fp, #-12]
100129a8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
100129ac:	e58d1000 	str	r1, [sp]
100129b0:	e58d2004 	str	r2, [sp, #4]
100129b4:	e58d3008 	str	r3, [sp, #8]
100129b8:	e30f0e18 	movw	r0, #65048	; 0xfe18
100129bc:	e3410001 	movt	r0, #4097	; 0x1001
100129c0:	e3a01006 	mov	r1, #6
100129c4:	e1a0200e 	mov	r2, lr
100129c8:	e1a0300c 	mov	r3, ip
100129cc:	ebffce40 	bl	100062d4 <rt_kprintf>
                       mp->parent.name,
                       mp->block_size,
                       mp->block_total_count,
                       mp->block_free_count,
                       mp->suspend_thread_count);
            show_wait_queue(&(mp->suspend_thread));
100129d0:	e51b300c 	ldr	r3, [fp, #-12]
100129d4:	e2833028 	add	r3, r3, #40	; 0x28
100129d8:	e1a00003 	mov	r0, r3
100129dc:	ebfffe30 	bl	100122a4 <show_wait_queue>
            rt_kprintf("\n");
100129e0:	e30f0bec 	movw	r0, #64492	; 0xfbec
100129e4:	e3410001 	movt	r0, #4097	; 0x1001
100129e8:	ebffce39 	bl	100062d4 <rt_kprintf>
100129ec:	ea000011 	b	10012a38 <_list_mempool+0x104>
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
                       RT_NAME_MAX,
                       mp->parent.name,
100129f0:	e51be00c 	ldr	lr, [fp, #-12]
            show_wait_queue(&(mp->suspend_thread));
            rt_kprintf("\n");
        }
        else
        {
            rt_kprintf("%-8.*s %04d  %04d  %04d %d\n",
100129f4:	e51b300c 	ldr	r3, [fp, #-12]
100129f8:	e593c018 	ldr	ip, [r3, #24]
100129fc:	e51b300c 	ldr	r3, [fp, #-12]
10012a00:	e5931020 	ldr	r1, [r3, #32]
10012a04:	e51b300c 	ldr	r3, [fp, #-12]
10012a08:	e5932024 	ldr	r2, [r3, #36]	; 0x24
10012a0c:	e51b300c 	ldr	r3, [fp, #-12]
10012a10:	e5933030 	ldr	r3, [r3, #48]	; 0x30
10012a14:	e58d1000 	str	r1, [sp]
10012a18:	e58d2004 	str	r2, [sp, #4]
10012a1c:	e58d3008 	str	r3, [sp, #8]
10012a20:	e30f0e34 	movw	r0, #65076	; 0xfe34
10012a24:	e3410001 	movt	r0, #4097	; 0x1001
10012a28:	e3a01006 	mov	r1, #6
10012a2c:	e1a0200e 	mov	r2, lr
10012a30:	e1a0300c 	mov	r3, ip
10012a34:	ebffce26 	bl	100062d4 <rt_kprintf>
    struct rt_mempool *mp;
    struct rt_list_node *node;

    rt_kprintf("mempool  block total free suspend thread\n");
    rt_kprintf("-------- ----  ----  ---- --------------\n");
    for (node = list->next; node != list; node = node->next)
10012a38:	e51b3008 	ldr	r3, [fp, #-8]
10012a3c:	e5933000 	ldr	r3, [r3]
10012a40:	e50b3008 	str	r3, [fp, #-8]
10012a44:	e51b2008 	ldr	r2, [fp, #-8]
10012a48:	e51b3010 	ldr	r3, [fp, #-16]
10012a4c:	e1520003 	cmp	r2, r3
10012a50:	1affffc5 	bne	1001296c <_list_mempool+0x38>
                       mp->block_free_count,
                       mp->suspend_thread_count);
        }
    }

    return 0;
10012a54:	e3a03000 	mov	r3, #0
}
10012a58:	e1a00003 	mov	r0, r3
10012a5c:	e24bd004 	sub	sp, fp, #4
10012a60:	e8bd8800 	pop	{fp, pc}

10012a64 <list_mempool>:

long list_mempool(void)
{
10012a64:	e92d4800 	push	{fp, lr}
10012a68:	e28db004 	add	fp, sp, #4
    return _list_mempool(&rt_object_container[RT_Object_Class_MemPool].object_list);
10012a6c:	e59f000c 	ldr	r0, [pc, #12]	; 10012a80 <list_mempool+0x1c>
10012a70:	ebffffaf 	bl	10012934 <_list_mempool>
10012a74:	e1a03000 	mov	r3, r0
}
10012a78:	e1a00003 	mov	r0, r3
10012a7c:	e8bd8800 	pop	{fp, pc}
10012a80:	10020a1c 	.word	0x10020a1c

10012a84 <_list_timer>:
FINSH_FUNCTION_EXPORT(list_mempool, list memory pool in system)
MSH_CMD_EXPORT(list_mempool, list memory pool in system);
#endif

static long _list_timer(struct rt_list_node *list)
{
10012a84:	e92d4800 	push	{fp, lr}
10012a88:	e28db004 	add	fp, sp, #4
10012a8c:	e24dd018 	sub	sp, sp, #24
10012a90:	e50b0010 	str	r0, [fp, #-16]
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
10012a94:	e30f0e50 	movw	r0, #65104	; 0xfe50
10012a98:	e3410001 	movt	r0, #4097	; 0x1001
10012a9c:	ebffce0c 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- ---------- ---------- -----------\n");
10012aa0:	e30f0e78 	movw	r0, #65144	; 0xfe78
10012aa4:	e3410001 	movt	r0, #4097	; 0x1001
10012aa8:	ebffce09 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10012aac:	e51b3010 	ldr	r3, [fp, #-16]
10012ab0:	e5933000 	ldr	r3, [r3]
10012ab4:	e50b3008 	str	r3, [fp, #-8]
10012ab8:	ea00001c 	b	10012b30 <_list_timer+0xac>
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
10012abc:	e51b3008 	ldr	r3, [fp, #-8]
10012ac0:	e2433008 	sub	r3, r3, #8
10012ac4:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
                   RT_NAME_MAX,
                   timer->parent.name,
10012ac8:	e51b200c 	ldr	r2, [fp, #-12]
    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        timer = (struct rt_timer *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s 0x%08x 0x%08x ",
10012acc:	e51b300c 	ldr	r3, [fp, #-12]
10012ad0:	e593c020 	ldr	ip, [r3, #32]
10012ad4:	e51b300c 	ldr	r3, [fp, #-12]
10012ad8:	e5933024 	ldr	r3, [r3, #36]	; 0x24
10012adc:	e58d3000 	str	r3, [sp]
10012ae0:	e30f0ea4 	movw	r0, #65188	; 0xfea4
10012ae4:	e3410001 	movt	r0, #4097	; 0x1001
10012ae8:	e3a01006 	mov	r1, #6
10012aec:	e1a0300c 	mov	r3, ip
10012af0:	ebffcdf7 	bl	100062d4 <rt_kprintf>
                   RT_NAME_MAX,
                   timer->parent.name,
                   timer->init_tick,
                   timer->timeout_tick);
        if (timer->parent.flag & RT_TIMER_FLAG_ACTIVATED)
10012af4:	e51b300c 	ldr	r3, [fp, #-12]
10012af8:	e5d33007 	ldrb	r3, [r3, #7]
10012afc:	e2033001 	and	r3, r3, #1
10012b00:	e3530000 	cmp	r3, #0
10012b04:	0a000003 	beq	10012b18 <_list_timer+0x94>
            rt_kprintf("activated\n");
10012b08:	e30f0ebc 	movw	r0, #65212	; 0xfebc
10012b0c:	e3410001 	movt	r0, #4097	; 0x1001
10012b10:	ebffcdef 	bl	100062d4 <rt_kprintf>
10012b14:	ea000002 	b	10012b24 <_list_timer+0xa0>
        else
            rt_kprintf("deactivated\n");
10012b18:	e30f0ec8 	movw	r0, #65224	; 0xfec8
10012b1c:	e3410001 	movt	r0, #4097	; 0x1001
10012b20:	ebffcdeb 	bl	100062d4 <rt_kprintf>
    struct rt_timer *timer;
    struct rt_list_node *node;

    rt_kprintf("timer    periodic   timeout    flag\n");
    rt_kprintf("-------- ---------- ---------- -----------\n");
    for (node = list->next; node != list; node = node->next)
10012b24:	e51b3008 	ldr	r3, [fp, #-8]
10012b28:	e5933000 	ldr	r3, [r3]
10012b2c:	e50b3008 	str	r3, [fp, #-8]
10012b30:	e51b2008 	ldr	r2, [fp, #-8]
10012b34:	e51b3010 	ldr	r3, [fp, #-16]
10012b38:	e1520003 	cmp	r2, r3
10012b3c:	1affffde 	bne	10012abc <_list_timer+0x38>
            rt_kprintf("activated\n");
        else
            rt_kprintf("deactivated\n");
    }

    rt_kprintf("current tick:0x%08x\n", rt_tick_get());
10012b40:	ebffb82f 	bl	10000c04 <rt_tick_get>
10012b44:	e1a03000 	mov	r3, r0
10012b48:	e30f0ed8 	movw	r0, #65240	; 0xfed8
10012b4c:	e3410001 	movt	r0, #4097	; 0x1001
10012b50:	e1a01003 	mov	r1, r3
10012b54:	ebffcdde 	bl	100062d4 <rt_kprintf>

    return 0;
10012b58:	e3a03000 	mov	r3, #0
}
10012b5c:	e1a00003 	mov	r0, r3
10012b60:	e24bd004 	sub	sp, fp, #4
10012b64:	e8bd8800 	pop	{fp, pc}

10012b68 <list_timer>:

long list_timer(void)
{
10012b68:	e92d4800 	push	{fp, lr}
10012b6c:	e28db004 	add	fp, sp, #4
    return _list_timer(&rt_object_container[RT_Object_Class_Timer].object_list);
10012b70:	e59f000c 	ldr	r0, [pc, #12]	; 10012b84 <list_timer+0x1c>
10012b74:	ebffffc2 	bl	10012a84 <_list_timer>
10012b78:	e1a03000 	mov	r3, r0
}
10012b7c:	e1a00003 	mov	r0, r3
10012b80:	e8bd8800 	pop	{fp, pc}
10012b84:	10020a3c 	.word	0x10020a3c

10012b88 <_list_device>:
FINSH_FUNCTION_EXPORT(list_timer, list timer in system);
MSH_CMD_EXPORT(list_timer, list timer in system);

#ifdef RT_USING_DEVICE
static long _list_device(struct rt_list_node *list)
{
10012b88:	e92d4800 	push	{fp, lr}
10012b8c:	e28db004 	add	fp, sp, #4
10012b90:	e24dd068 	sub	sp, sp, #104	; 0x68
10012b94:	e50b0060 	str	r0, [fp, #-96]	; 0x60
    struct rt_device *device;
    struct rt_list_node *node;
    char * const device_type_str[] =
10012b98:	e3003078 	movw	r3, #120	; 0x78
10012b9c:	e3413002 	movt	r3, #4098	; 0x1002
10012ba0:	e24b205c 	sub	r2, fp, #92	; 0x5c
10012ba4:	e1a01003 	mov	r1, r3
10012ba8:	e3a03050 	mov	r3, #80	; 0x50
10012bac:	e1a00002 	mov	r0, r2
10012bb0:	e1a02003 	mov	r2, r3
10012bb4:	fa002b1e 	blx	1001d834 <memcpy>
		"Timer Device",
		"Miscellaneous Device",
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
10012bb8:	e30f0ef0 	movw	r0, #65264	; 0xfef0
10012bbc:	e3410001 	movt	r0, #4097	; 0x1001
10012bc0:	ebffcdc3 	bl	100062d4 <rt_kprintf>
    rt_kprintf("-------- -------------------- ----------\n");
10012bc4:	e30f0f1c 	movw	r0, #65308	; 0xff1c
10012bc8:	e3410001 	movt	r0, #4097	; 0x1001
10012bcc:	ebffcdc0 	bl	100062d4 <rt_kprintf>
    for (node = list->next; node != list; node = node->next)
10012bd0:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10012bd4:	e5933000 	ldr	r3, [r3]
10012bd8:	e50b3008 	str	r3, [fp, #-8]
10012bdc:	ea00001a 	b	10012c4c <_list_device+0xc4>
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
10012be0:	e51b3008 	ldr	r3, [fp, #-8]
10012be4:	e2433008 	sub	r3, r3, #8
10012be8:	e50b300c 	str	r3, [fp, #-12]
        rt_kprintf("%-8.*s %-20s %-8d\n",
                   RT_NAME_MAX,
                   device->parent.name,
10012bec:	e51bc00c 	ldr	ip, [fp, #-12]
                   (device->type <= RT_Device_Class_Unknown) ?
10012bf0:	e51b300c 	ldr	r3, [fp, #-12]
10012bf4:	e5d33010 	ldrb	r3, [r3, #16]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
10012bf8:	e3530013 	cmp	r3, #19
10012bfc:	8a000006 	bhi	10012c1c <_list_device+0x94>
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
10012c00:	e51b300c 	ldr	r3, [fp, #-12]
10012c04:	e5d33010 	ldrb	r3, [r3, #16]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
10012c08:	e1a03103 	lsl	r3, r3, #2
10012c0c:	e24b2004 	sub	r2, fp, #4
10012c10:	e0823003 	add	r3, r2, r3
10012c14:	e5133058 	ldr	r3, [r3, #-88]	; 0x58
10012c18:	ea000000 	b	10012c20 <_list_device+0x98>
10012c1c:	e51b3010 	ldr	r3, [fp, #-16]
                   RT_NAME_MAX,
                   device->parent.name,
                   (device->type <= RT_Device_Class_Unknown) ?
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
10012c20:	e51b200c 	ldr	r2, [fp, #-12]
10012c24:	e5d22016 	ldrb	r2, [r2, #22]
    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
    {
        device = (struct rt_device *)(rt_list_entry(node, struct rt_object, list));
        rt_kprintf("%-8.*s %-20s %-8d\n",
10012c28:	e58d2000 	str	r2, [sp]
10012c2c:	e30f0f48 	movw	r0, #65352	; 0xff48
10012c30:	e3410001 	movt	r0, #4097	; 0x1001
10012c34:	e3a01006 	mov	r1, #6
10012c38:	e1a0200c 	mov	r2, ip
10012c3c:	ebffcda4 	bl	100062d4 <rt_kprintf>
        "Unknown"
    };

    rt_kprintf("device   type                 ref count\n");
    rt_kprintf("-------- -------------------- ----------\n");
    for (node = list->next; node != list; node = node->next)
10012c40:	e51b3008 	ldr	r3, [fp, #-8]
10012c44:	e5933000 	ldr	r3, [r3]
10012c48:	e50b3008 	str	r3, [fp, #-8]
10012c4c:	e51b2008 	ldr	r2, [fp, #-8]
10012c50:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10012c54:	e1520003 	cmp	r2, r3
10012c58:	1affffe0 	bne	10012be0 <_list_device+0x58>
                   device_type_str[device->type] :
                   device_type_str[RT_Device_Class_Unknown],
                   device->ref_count);
    }

    return 0;
10012c5c:	e3a03000 	mov	r3, #0
}
10012c60:	e1a00003 	mov	r0, r3
10012c64:	e24bd004 	sub	sp, fp, #4
10012c68:	e8bd8800 	pop	{fp, pc}

10012c6c <list_device>:

long list_device(void)
{
10012c6c:	e92d4800 	push	{fp, lr}
10012c70:	e28db004 	add	fp, sp, #4
    return _list_device(&rt_object_container[RT_Object_Class_Device].object_list);
10012c74:	e59f000c 	ldr	r0, [pc, #12]	; 10012c88 <list_device+0x1c>
10012c78:	ebffffc2 	bl	10012b88 <_list_device>
10012c7c:	e1a03000 	mov	r3, r0
}
10012c80:	e1a00003 	mov	r0, r3
10012c84:	e8bd8800 	pop	{fp, pc}
10012c88:	10020a2c 	.word	0x10020a2c

10012c8c <list>:
}
FINSH_FUNCTION_EXPORT(list_mod_detail, list module objects in system)
#endif

long list(void)
{
10012c8c:	e92d4800 	push	{fp, lr}
10012c90:	e28db004 	add	fp, sp, #4
10012c94:	e24dd010 	sub	sp, sp, #16
#ifndef FINSH_USING_MSH_ONLY
    struct finsh_syscall_item *syscall_item;
    struct finsh_sysvar_item *sysvar_item;
#endif
	
    rt_kprintf("--Function List:\n");
10012c98:	e30000c8 	movw	r0, #200	; 0xc8
10012c9c:	e3410002 	movt	r0, #4098	; 0x1002
10012ca0:	ebffcd8b 	bl	100062d4 <rt_kprintf>
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10012ca4:	e3093d58 	movw	r3, #40280	; 0x9d58
10012ca8:	e3413002 	movt	r3, #4098	; 0x1002
10012cac:	e5933000 	ldr	r3, [r3]
10012cb0:	e50b3010 	str	r3, [fp, #-16]
10012cb4:	ea000016 	b	10012d14 <list+0x88>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip the internal command */
			if (strncmp((char*)index->name, "__", 2) == 0) continue;
10012cb8:	e51b3010 	ldr	r3, [fp, #-16]
10012cbc:	e5933000 	ldr	r3, [r3]
10012cc0:	e1a00003 	mov	r0, r3
10012cc4:	e30010dc 	movw	r1, #220	; 0xdc
10012cc8:	e3411002 	movt	r1, #4098	; 0x1002
10012ccc:	e3a02002 	mov	r2, #2
10012cd0:	fa002bfd 	blx	1001dccc <strncmp>
10012cd4:	e1a03000 	mov	r3, r0
10012cd8:	e3530000 	cmp	r3, #0
10012cdc:	1a000000 	bne	10012ce4 <list+0x58>
10012ce0:	ea000008 	b	10012d08 <list+0x7c>

#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10012ce4:	e51b3010 	ldr	r3, [fp, #-16]
10012ce8:	e5932000 	ldr	r2, [r3]
10012cec:	e51b3010 	ldr	r3, [fp, #-16]
10012cf0:	e5933004 	ldr	r3, [r3, #4]
10012cf4:	e30000e0 	movw	r0, #224	; 0xe0
10012cf8:	e3410002 	movt	r0, #4098	; 0x1002
10012cfc:	e1a01002 	mov	r1, r2
10012d00:	e1a02003 	mov	r2, r3
10012d04:	ebffcd72 	bl	100062d4 <rt_kprintf>
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
10012d08:	e51b3010 	ldr	r3, [fp, #-16]
10012d0c:	e283300c 	add	r3, r3, #12
10012d10:	e50b3010 	str	r3, [fp, #-16]
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
10012d14:	e3093d5c 	movw	r3, #40284	; 0x9d5c
10012d18:	e3413002 	movt	r3, #4098	; 0x1002
10012d1c:	e5933000 	ldr	r3, [r3]
#endif
	
    rt_kprintf("--Function List:\n");
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10012d20:	e51b2010 	ldr	r2, [fp, #-16]
10012d24:	e1520003 	cmp	r2, r3
10012d28:	3affffe2 	bcc	10012cb8 <list+0x2c>
        }
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
10012d2c:	e3093d74 	movw	r3, #40308	; 0x9d74
10012d30:	e3413002 	movt	r3, #4098	; 0x1002
10012d34:	e5933000 	ldr	r3, [r3]
10012d38:	e50b3008 	str	r3, [fp, #-8]
    while (syscall_item != NULL)
10012d3c:	ea000008 	b	10012d64 <list+0xd8>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
10012d40:	e51b3008 	ldr	r3, [fp, #-8]
10012d44:	e5933004 	ldr	r3, [r3, #4]
10012d48:	e30000f0 	movw	r0, #240	; 0xf0
10012d4c:	e3410002 	movt	r0, #4098	; 0x1002
10012d50:	e1a01003 	mov	r1, r3
10012d54:	ebffcd5e 	bl	100062d4 <rt_kprintf>
        syscall_item = syscall_item->next;
10012d58:	e51b3008 	ldr	r3, [fp, #-8]
10012d5c:	e5933000 	ldr	r3, [r3]
10012d60:	e50b3008 	str	r3, [fp, #-8]
    }

#ifndef FINSH_USING_MSH_ONLY
    /* list syscall list */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
10012d64:	e51b3008 	ldr	r3, [fp, #-8]
10012d68:	e3530000 	cmp	r3, #0
10012d6c:	1afffff3 	bne	10012d40 <list+0xb4>
    {
        rt_kprintf("[l] %s\n", syscall_item->syscall.name);
        syscall_item = syscall_item->next;
    }

    rt_kprintf("--Variable List:\n");
10012d70:	e30000f8 	movw	r0, #248	; 0xf8
10012d74:	e3410002 	movt	r0, #4098	; 0x1002
10012d78:	ebffcd55 	bl	100062d4 <rt_kprintf>
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
10012d7c:	e3093d60 	movw	r3, #40288	; 0x9d60
10012d80:	e3413002 	movt	r3, #4098	; 0x1002
10012d84:	e5933000 	ldr	r3, [r3]
10012d88:	e50b3014 	str	r3, [fp, #-20]
10012d8c:	ea00000b 	b	10012dc0 <list+0x134>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
#ifdef FINSH_USING_DESCRIPTION
            rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10012d90:	e51b3014 	ldr	r3, [fp, #-20]
10012d94:	e5932000 	ldr	r2, [r3]
10012d98:	e51b3014 	ldr	r3, [fp, #-20]
10012d9c:	e5933004 	ldr	r3, [r3, #4]
10012da0:	e30000e0 	movw	r0, #224	; 0xe0
10012da4:	e3410002 	movt	r0, #4098	; 0x1002
10012da8:	e1a01002 	mov	r1, r2
10012dac:	e1a02003 	mov	r2, r3
10012db0:	ebffcd47 	bl	100062d4 <rt_kprintf>
    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
10012db4:	e51b3014 	ldr	r3, [fp, #-20]
10012db8:	e2833010 	add	r3, r3, #16
10012dbc:	e50b3014 	str	r3, [fp, #-20]

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
10012dc0:	e3093d64 	movw	r3, #40292	; 0x9d64
10012dc4:	e3413002 	movt	r3, #4098	; 0x1002
10012dc8:	e5933000 	ldr	r3, [r3]
    }

    rt_kprintf("--Variable List:\n");
    {
        struct finsh_sysvar *index;
        for (index = _sysvar_table_begin;
10012dcc:	e51b2014 	ldr	r2, [fp, #-20]
10012dd0:	e1520003 	cmp	r2, r3
10012dd4:	3affffed 	bcc	10012d90 <list+0x104>
            rt_kprintf("%s\n", index->name);
#endif
        }
    }

    sysvar_item = global_sysvar_list;
10012dd8:	e30a3824 	movw	r3, #43044	; 0xa824
10012ddc:	e3413002 	movt	r3, #4098	; 0x1002
10012de0:	e5933000 	ldr	r3, [r3]
10012de4:	e50b300c 	str	r3, [fp, #-12]
    while (sysvar_item != NULL)
10012de8:	ea000008 	b	10012e10 <list+0x184>
    {
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
10012dec:	e51b300c 	ldr	r3, [fp, #-12]
10012df0:	e5933004 	ldr	r3, [r3, #4]
10012df4:	e30000f0 	movw	r0, #240	; 0xf0
10012df8:	e3410002 	movt	r0, #4098	; 0x1002
10012dfc:	e1a01003 	mov	r1, r3
10012e00:	ebffcd33 	bl	100062d4 <rt_kprintf>
        sysvar_item = sysvar_item->next;
10012e04:	e51b300c 	ldr	r3, [fp, #-12]
10012e08:	e5933000 	ldr	r3, [r3]
10012e0c:	e50b300c 	str	r3, [fp, #-12]
#endif
        }
    }

    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
10012e10:	e51b300c 	ldr	r3, [fp, #-12]
10012e14:	e3530000 	cmp	r3, #0
10012e18:	1afffff3 	bne	10012dec <list+0x160>
        rt_kprintf("[l] %s\n", sysvar_item->sysvar.name);
        sysvar_item = sysvar_item->next;
    }
#endif
	
    return 0;
10012e1c:	e3a03000 	mov	r3, #0
}
10012e20:	e1a00003 	mov	r0, r3
10012e24:	e24bd004 	sub	sp, fp, #4
10012e28:	e8bd8800 	pop	{fp, pc}

10012e2c <str_is_prefix>:
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
10012e2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012e30:	e28db000 	add	fp, sp, #0
10012e34:	e24dd00c 	sub	sp, sp, #12
10012e38:	e50b0008 	str	r0, [fp, #-8]
10012e3c:	e50b100c 	str	r1, [fp, #-12]
    while ((*prefix) && (*prefix == *str))
10012e40:	ea000005 	b	10012e5c <str_is_prefix+0x30>
    {
        prefix ++;
10012e44:	e51b3008 	ldr	r3, [fp, #-8]
10012e48:	e2833001 	add	r3, r3, #1
10012e4c:	e50b3008 	str	r3, [fp, #-8]
        str ++;
10012e50:	e51b300c 	ldr	r3, [fp, #-12]
10012e54:	e2833001 	add	r3, r3, #1
10012e58:	e50b300c 	str	r3, [fp, #-12]
FINSH_FUNCTION_EXPORT(list, list all symbol in system)

#ifndef FINSH_USING_MSH_ONLY
static int str_is_prefix(const char *prefix, const char *str)
{
    while ((*prefix) && (*prefix == *str))
10012e5c:	e51b3008 	ldr	r3, [fp, #-8]
10012e60:	e5d33000 	ldrb	r3, [r3]
10012e64:	e3530000 	cmp	r3, #0
10012e68:	0a000005 	beq	10012e84 <str_is_prefix+0x58>
10012e6c:	e51b3008 	ldr	r3, [fp, #-8]
10012e70:	e5d32000 	ldrb	r2, [r3]
10012e74:	e51b300c 	ldr	r3, [fp, #-12]
10012e78:	e5d33000 	ldrb	r3, [r3]
10012e7c:	e1520003 	cmp	r2, r3
10012e80:	0affffef 	beq	10012e44 <str_is_prefix+0x18>
    {
        prefix ++;
        str ++;
    }

    if (*prefix == 0)
10012e84:	e51b3008 	ldr	r3, [fp, #-8]
10012e88:	e5d33000 	ldrb	r3, [r3]
10012e8c:	e3530000 	cmp	r3, #0
10012e90:	1a000001 	bne	10012e9c <str_is_prefix+0x70>
        return 0;
10012e94:	e3a03000 	mov	r3, #0
10012e98:	ea000000 	b	10012ea0 <str_is_prefix+0x74>

    return -1;
10012e9c:	e3e03000 	mvn	r3, #0
}
10012ea0:	e1a00003 	mov	r0, r3
10012ea4:	e24bd000 	sub	sp, fp, #0
10012ea8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012eac:	e12fff1e 	bx	lr

10012eb0 <str_common>:

static int str_common(const char *str1, const char *str2)
{
10012eb0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10012eb4:	e28db000 	add	fp, sp, #0
10012eb8:	e24dd014 	sub	sp, sp, #20
10012ebc:	e50b0010 	str	r0, [fp, #-16]
10012ec0:	e50b1014 	str	r1, [fp, #-20]
    const char *str = str1;
10012ec4:	e51b3010 	ldr	r3, [fp, #-16]
10012ec8:	e50b3008 	str	r3, [fp, #-8]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
10012ecc:	ea000005 	b	10012ee8 <str_common+0x38>
    {
        str ++;
10012ed0:	e51b3008 	ldr	r3, [fp, #-8]
10012ed4:	e2833001 	add	r3, r3, #1
10012ed8:	e50b3008 	str	r3, [fp, #-8]
        str2 ++;
10012edc:	e51b3014 	ldr	r3, [fp, #-20]
10012ee0:	e2833001 	add	r3, r3, #1
10012ee4:	e50b3014 	str	r3, [fp, #-20]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
10012ee8:	e51b3008 	ldr	r3, [fp, #-8]
10012eec:	e5d33000 	ldrb	r3, [r3]
10012ef0:	e3530000 	cmp	r3, #0
10012ef4:	0a000009 	beq	10012f20 <str_common+0x70>
10012ef8:	e51b3014 	ldr	r3, [fp, #-20]
10012efc:	e5d33000 	ldrb	r3, [r3]
10012f00:	e3530000 	cmp	r3, #0
10012f04:	0a000005 	beq	10012f20 <str_common+0x70>
10012f08:	e51b3008 	ldr	r3, [fp, #-8]
10012f0c:	e5d32000 	ldrb	r2, [r3]
10012f10:	e51b3014 	ldr	r3, [fp, #-20]
10012f14:	e5d33000 	ldrb	r3, [r3]
10012f18:	e1520003 	cmp	r2, r3
10012f1c:	0affffeb 	beq	10012ed0 <str_common+0x20>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
10012f20:	e51b2008 	ldr	r2, [fp, #-8]
10012f24:	e51b3010 	ldr	r3, [fp, #-16]
10012f28:	e0633002 	rsb	r3, r3, r2
}
10012f2c:	e1a00003 	mov	r0, r3
10012f30:	e24bd000 	sub	sp, fp, #0
10012f34:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10012f38:	e12fff1e 	bx	lr

10012f3c <list_prefix>:

void list_prefix(char *prefix)
{
10012f3c:	e92d4800 	push	{fp, lr}
10012f40:	e28db004 	add	fp, sp, #4
10012f44:	e24dd028 	sub	sp, sp, #40	; 0x28
10012f48:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    struct finsh_sysvar_item *sysvar_item;
    rt_uint16_t func_cnt, var_cnt;
    int length, min_length;
    const char *name_ptr;

    func_cnt = 0;
10012f4c:	e3a03000 	mov	r3, #0
10012f50:	e14b30be 	strh	r3, [fp, #-14]
    var_cnt  = 0;
10012f54:	e3a03000 	mov	r3, #0
10012f58:	e14b31b0 	strh	r3, [fp, #-16]
    min_length = 0;
10012f5c:	e3a03000 	mov	r3, #0
10012f60:	e50b3014 	str	r3, [fp, #-20]
    name_ptr = RT_NULL;
10012f64:	e3a03000 	mov	r3, #0
10012f68:	e50b3018 	str	r3, [fp, #-24]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10012f6c:	e3093d58 	movw	r3, #40280	; 0x9d58
10012f70:	e3413002 	movt	r3, #4098	; 0x1002
10012f74:	e5933000 	ldr	r3, [r3]
10012f78:	e50b301c 	str	r3, [fp, #-28]
10012f7c:	ea000041 	b	10013088 <list_prefix+0x14c>
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
        {
			/* skip internal command */
			if (str_is_prefix("__", index->name) == 0) continue;
10012f80:	e51b301c 	ldr	r3, [fp, #-28]
10012f84:	e5933000 	ldr	r3, [r3]
10012f88:	e30000dc 	movw	r0, #220	; 0xdc
10012f8c:	e3410002 	movt	r0, #4098	; 0x1002
10012f90:	e1a01003 	mov	r1, r3
10012f94:	ebffffa4 	bl	10012e2c <str_is_prefix>
10012f98:	e1a03000 	mov	r3, r0
10012f9c:	e3530000 	cmp	r3, #0
10012fa0:	1a000000 	bne	10012fa8 <list_prefix+0x6c>
10012fa4:	ea000034 	b	1001307c <list_prefix+0x140>
			
            if (str_is_prefix(prefix, index->name) == 0)
10012fa8:	e51b301c 	ldr	r3, [fp, #-28]
10012fac:	e5933000 	ldr	r3, [r3]
10012fb0:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
10012fb4:	e1a01003 	mov	r1, r3
10012fb8:	ebffff9b 	bl	10012e2c <str_is_prefix>
10012fbc:	e1a03000 	mov	r3, r0
10012fc0:	e3530000 	cmp	r3, #0
10012fc4:	1a00002c 	bne	1001307c <list_prefix+0x140>
            {
                if (func_cnt == 0)
10012fc8:	e15b30be 	ldrh	r3, [fp, #-14]
10012fcc:	e3530000 	cmp	r3, #0
10012fd0:	1a00000d 	bne	1001300c <list_prefix+0xd0>
                {
                    rt_kprintf("--function:\n");
10012fd4:	e300010c 	movw	r0, #268	; 0x10c
10012fd8:	e3410002 	movt	r0, #4098	; 0x1002
10012fdc:	ebffccbc 	bl	100062d4 <rt_kprintf>

                    if (*prefix != 0)
10012fe0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10012fe4:	e5d33000 	ldrb	r3, [r3]
10012fe8:	e3530000 	cmp	r3, #0
10012fec:	0a000006 	beq	1001300c <list_prefix+0xd0>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
10012ff0:	e51b301c 	ldr	r3, [fp, #-28]
10012ff4:	e5933000 	ldr	r3, [r3]
10012ff8:	e50b3018 	str	r3, [fp, #-24]

                        /* set initial length */
                        min_length = strlen(name_ptr);
10012ffc:	e51b0018 	ldr	r0, [fp, #-24]
10013000:	fa002b1a 	blx	1001dc70 <strlen>
10013004:	e1a03000 	mov	r3, r0
10013008:	e50b3014 	str	r3, [fp, #-20]
                    }
                }

                func_cnt ++;
1001300c:	e15b30be 	ldrh	r3, [fp, #-14]
10013010:	e2833001 	add	r3, r3, #1
10013014:	e14b30be 	strh	r3, [fp, #-14]

                if (*prefix != 0)
10013018:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001301c:	e5d33000 	ldrb	r3, [r3]
10013020:	e3530000 	cmp	r3, #0
10013024:	0a00000b 	beq	10013058 <list_prefix+0x11c>
                {
                    length = str_common(name_ptr, index->name);
10013028:	e51b301c 	ldr	r3, [fp, #-28]
1001302c:	e5933000 	ldr	r3, [r3]
10013030:	e51b0018 	ldr	r0, [fp, #-24]
10013034:	e1a01003 	mov	r1, r3
10013038:	ebffff9c 	bl	10012eb0 <str_common>
1001303c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                    if (length < min_length)
10013040:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10013044:	e51b3014 	ldr	r3, [fp, #-20]
10013048:	e1520003 	cmp	r2, r3
1001304c:	aa000001 	bge	10013058 <list_prefix+0x11c>
                        min_length = length;
10013050:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10013054:	e50b3014 	str	r3, [fp, #-20]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10013058:	e51b301c 	ldr	r3, [fp, #-28]
1001305c:	e5932000 	ldr	r2, [r3]
10013060:	e51b301c 	ldr	r3, [fp, #-28]
10013064:	e5933004 	ldr	r3, [r3, #4]
10013068:	e30000e0 	movw	r0, #224	; 0xe0
1001306c:	e3410002 	movt	r0, #4098	; 0x1002
10013070:	e1a01002 	mov	r1, r2
10013074:	e1a02003 	mov	r2, r3
10013078:	ebffcc95 	bl	100062d4 <rt_kprintf>
    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
             FINSH_NEXT_SYSCALL(index))
1001307c:	e51b301c 	ldr	r3, [fp, #-28]
10013080:	e283300c 	add	r3, r3, #12
10013084:	e50b301c 	str	r3, [fp, #-28]

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
             index < _syscall_table_end;
10013088:	e3093d5c 	movw	r3, #40284	; 0x9d5c
1001308c:	e3413002 	movt	r3, #4098	; 0x1002
10013090:	e5933000 	ldr	r3, [r3]
    name_ptr = RT_NULL;

    /* checks in system function call */
    {
        struct finsh_syscall *index;
        for (index = _syscall_table_begin;
10013094:	e51b201c 	ldr	r2, [fp, #-28]
10013098:	e1520003 	cmp	r2, r3
1001309c:	3affffb7 	bcc	10012f80 <list_prefix+0x44>
            }
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
100130a0:	e3093d74 	movw	r3, #40308	; 0x9d74
100130a4:	e3413002 	movt	r3, #4098	; 0x1002
100130a8:	e5933000 	ldr	r3, [r3]
100130ac:	e50b3008 	str	r3, [fp, #-8]
    while (syscall_item != NULL)
100130b0:	ea000037 	b	10013194 <list_prefix+0x258>
    {
        if (str_is_prefix(prefix, syscall_item->syscall.name) == 0)
100130b4:	e51b3008 	ldr	r3, [fp, #-8]
100130b8:	e5933004 	ldr	r3, [r3, #4]
100130bc:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
100130c0:	e1a01003 	mov	r1, r3
100130c4:	ebffff58 	bl	10012e2c <str_is_prefix>
100130c8:	e1a03000 	mov	r3, r0
100130cc:	e3530000 	cmp	r3, #0
100130d0:	1a00002c 	bne	10013188 <list_prefix+0x24c>
        {
            if (func_cnt == 0)
100130d4:	e15b30be 	ldrh	r3, [fp, #-14]
100130d8:	e3530000 	cmp	r3, #0
100130dc:	1a000010 	bne	10013124 <list_prefix+0x1e8>
            {
                rt_kprintf("--function:\n");
100130e0:	e300010c 	movw	r0, #268	; 0x10c
100130e4:	e3410002 	movt	r0, #4098	; 0x1002
100130e8:	ebffcc79 	bl	100062d4 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
100130ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100130f0:	e5d33000 	ldrb	r3, [r3]
100130f4:	e3530000 	cmp	r3, #0
100130f8:	0a000009 	beq	10013124 <list_prefix+0x1e8>
100130fc:	e51b3018 	ldr	r3, [fp, #-24]
10013100:	e3530000 	cmp	r3, #0
10013104:	1a000006 	bne	10013124 <list_prefix+0x1e8>
                {
                    /* set name_ptr */
                    name_ptr = syscall_item->syscall.name;
10013108:	e51b3008 	ldr	r3, [fp, #-8]
1001310c:	e5933004 	ldr	r3, [r3, #4]
10013110:	e50b3018 	str	r3, [fp, #-24]

                    /* set initial length */
                    min_length = strlen(name_ptr);
10013114:	e51b0018 	ldr	r0, [fp, #-24]
10013118:	fa002ad4 	blx	1001dc70 <strlen>
1001311c:	e1a03000 	mov	r3, r0
10013120:	e50b3014 	str	r3, [fp, #-20]
                }
            }

            func_cnt ++;
10013124:	e15b30be 	ldrh	r3, [fp, #-14]
10013128:	e2833001 	add	r3, r3, #1
1001312c:	e14b30be 	strh	r3, [fp, #-14]

            if (*prefix != 0)
10013130:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013134:	e5d33000 	ldrb	r3, [r3]
10013138:	e3530000 	cmp	r3, #0
1001313c:	0a00000b 	beq	10013170 <list_prefix+0x234>
            {
                length = str_common(name_ptr, syscall_item->syscall.name);
10013140:	e51b3008 	ldr	r3, [fp, #-8]
10013144:	e5933004 	ldr	r3, [r3, #4]
10013148:	e51b0018 	ldr	r0, [fp, #-24]
1001314c:	e1a01003 	mov	r1, r3
10013150:	ebffff56 	bl	10012eb0 <str_common>
10013154:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                if (length < min_length)
10013158:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001315c:	e51b3014 	ldr	r3, [fp, #-20]
10013160:	e1520003 	cmp	r2, r3
10013164:	aa000001 	bge	10013170 <list_prefix+0x234>
                    min_length = length;
10013168:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001316c:	e50b3014 	str	r3, [fp, #-20]
            }

            rt_kprintf("[l] %s\n", syscall_item->syscall.name);
10013170:	e51b3008 	ldr	r3, [fp, #-8]
10013174:	e5933004 	ldr	r3, [r3, #4]
10013178:	e30000f0 	movw	r0, #240	; 0xf0
1001317c:	e3410002 	movt	r0, #4098	; 0x1002
10013180:	e1a01003 	mov	r1, r3
10013184:	ebffcc52 	bl	100062d4 <rt_kprintf>
        }
        syscall_item = syscall_item->next;
10013188:	e51b3008 	ldr	r3, [fp, #-8]
1001318c:	e5933000 	ldr	r3, [r3]
10013190:	e50b3008 	str	r3, [fp, #-8]
        }
    }

    /* checks in dynamic system function call */
    syscall_item = global_syscall_list;
    while (syscall_item != NULL)
10013194:	e51b3008 	ldr	r3, [fp, #-8]
10013198:	e3530000 	cmp	r3, #0
1001319c:	1affffc4 	bne	100130b4 <list_prefix+0x178>
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
100131a0:	e3093d60 	movw	r3, #40288	; 0x9d60
100131a4:	e3413002 	movt	r3, #4098	; 0x1002
100131a8:	e5933000 	ldr	r3, [r3]
100131ac:	e50b3020 	str	r3, [fp, #-32]
100131b0:	ea00003a 	b	100132a0 <list_prefix+0x364>
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
        {
            if (str_is_prefix(prefix, index->name) == 0)
100131b4:	e51b3020 	ldr	r3, [fp, #-32]
100131b8:	e5933000 	ldr	r3, [r3]
100131bc:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
100131c0:	e1a01003 	mov	r1, r3
100131c4:	ebffff18 	bl	10012e2c <str_is_prefix>
100131c8:	e1a03000 	mov	r3, r0
100131cc:	e3530000 	cmp	r3, #0
100131d0:	1a00002f 	bne	10013294 <list_prefix+0x358>
            {
                if (var_cnt == 0)
100131d4:	e15b31b0 	ldrh	r3, [fp, #-16]
100131d8:	e3530000 	cmp	r3, #0
100131dc:	1a000010 	bne	10013224 <list_prefix+0x2e8>
                {
                    rt_kprintf("--variable:\n");
100131e0:	e300011c 	movw	r0, #284	; 0x11c
100131e4:	e3410002 	movt	r0, #4098	; 0x1002
100131e8:	ebffcc39 	bl	100062d4 <rt_kprintf>

                    if (*prefix != 0 && name_ptr == NULL)
100131ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100131f0:	e5d33000 	ldrb	r3, [r3]
100131f4:	e3530000 	cmp	r3, #0
100131f8:	0a000009 	beq	10013224 <list_prefix+0x2e8>
100131fc:	e51b3018 	ldr	r3, [fp, #-24]
10013200:	e3530000 	cmp	r3, #0
10013204:	1a000006 	bne	10013224 <list_prefix+0x2e8>
                    {
                        /* set name_ptr */
                        name_ptr = index->name;
10013208:	e51b3020 	ldr	r3, [fp, #-32]
1001320c:	e5933000 	ldr	r3, [r3]
10013210:	e50b3018 	str	r3, [fp, #-24]

                        /* set initial length */
                        min_length = strlen(name_ptr);
10013214:	e51b0018 	ldr	r0, [fp, #-24]
10013218:	fa002a94 	blx	1001dc70 <strlen>
1001321c:	e1a03000 	mov	r3, r0
10013220:	e50b3014 	str	r3, [fp, #-20]

                    }
                }

                var_cnt ++;
10013224:	e15b31b0 	ldrh	r3, [fp, #-16]
10013228:	e2833001 	add	r3, r3, #1
1001322c:	e14b31b0 	strh	r3, [fp, #-16]

                if (*prefix != 0)
10013230:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013234:	e5d33000 	ldrb	r3, [r3]
10013238:	e3530000 	cmp	r3, #0
1001323c:	0a00000b 	beq	10013270 <list_prefix+0x334>
                {
                    length = str_common(name_ptr, index->name);
10013240:	e51b3020 	ldr	r3, [fp, #-32]
10013244:	e5933000 	ldr	r3, [r3]
10013248:	e51b0018 	ldr	r0, [fp, #-24]
1001324c:	e1a01003 	mov	r1, r3
10013250:	ebffff16 	bl	10012eb0 <str_common>
10013254:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                    if (length < min_length)
10013258:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001325c:	e51b3014 	ldr	r3, [fp, #-20]
10013260:	e1520003 	cmp	r2, r3
10013264:	aa000001 	bge	10013270 <list_prefix+0x334>
                        min_length = length;
10013268:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
1001326c:	e50b3014 	str	r3, [fp, #-20]
                }

#ifdef FINSH_USING_DESCRIPTION
                rt_kprintf("%-16s -- %s\n", index->name, index->desc);
10013270:	e51b3020 	ldr	r3, [fp, #-32]
10013274:	e5932000 	ldr	r2, [r3]
10013278:	e51b3020 	ldr	r3, [fp, #-32]
1001327c:	e5933004 	ldr	r3, [r3, #4]
10013280:	e30000e0 	movw	r0, #224	; 0xe0
10013284:	e3410002 	movt	r0, #4098	; 0x1002
10013288:	e1a01002 	mov	r1, r2
1001328c:	e1a02003 	mov	r2, r3
10013290:	ebffcc0f 	bl	100062d4 <rt_kprintf>
    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
             FINSH_NEXT_SYSVAR(index))
10013294:	e51b3020 	ldr	r3, [fp, #-32]
10013298:	e2833010 	add	r3, r3, #16
1001329c:	e50b3020 	str	r3, [fp, #-32]

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
             index < _sysvar_table_end;
100132a0:	e3093d64 	movw	r3, #40292	; 0x9d64
100132a4:	e3413002 	movt	r3, #4098	; 0x1002
100132a8:	e5933000 	ldr	r3, [r3]
    }

    /* checks in system variable */
    {
        struct finsh_sysvar* index;
        for (index = _sysvar_table_begin;
100132ac:	e51b2020 	ldr	r2, [fp, #-32]
100132b0:	e1520003 	cmp	r2, r3
100132b4:	3affffbe 	bcc	100131b4 <list_prefix+0x278>
            }
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
100132b8:	e30a3824 	movw	r3, #43044	; 0xa824
100132bc:	e3413002 	movt	r3, #4098	; 0x1002
100132c0:	e5933000 	ldr	r3, [r3]
100132c4:	e50b300c 	str	r3, [fp, #-12]
    while (sysvar_item != NULL)
100132c8:	ea000037 	b	100133ac <list_prefix+0x470>
    {
        if (str_is_prefix(prefix, sysvar_item->sysvar.name) == 0)
100132cc:	e51b300c 	ldr	r3, [fp, #-12]
100132d0:	e5933004 	ldr	r3, [r3, #4]
100132d4:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
100132d8:	e1a01003 	mov	r1, r3
100132dc:	ebfffed2 	bl	10012e2c <str_is_prefix>
100132e0:	e1a03000 	mov	r3, r0
100132e4:	e3530000 	cmp	r3, #0
100132e8:	1a00002c 	bne	100133a0 <list_prefix+0x464>
        {
            if (var_cnt == 0)
100132ec:	e15b31b0 	ldrh	r3, [fp, #-16]
100132f0:	e3530000 	cmp	r3, #0
100132f4:	1a000010 	bne	1001333c <list_prefix+0x400>
            {
                rt_kprintf("--variable:\n");
100132f8:	e300011c 	movw	r0, #284	; 0x11c
100132fc:	e3410002 	movt	r0, #4098	; 0x1002
10013300:	ebffcbf3 	bl	100062d4 <rt_kprintf>
                if (*prefix != 0 && name_ptr == NULL)
10013304:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013308:	e5d33000 	ldrb	r3, [r3]
1001330c:	e3530000 	cmp	r3, #0
10013310:	0a000009 	beq	1001333c <list_prefix+0x400>
10013314:	e51b3018 	ldr	r3, [fp, #-24]
10013318:	e3530000 	cmp	r3, #0
1001331c:	1a000006 	bne	1001333c <list_prefix+0x400>
                {
                    /* set name_ptr */
                    name_ptr = sysvar_item->sysvar.name;
10013320:	e51b300c 	ldr	r3, [fp, #-12]
10013324:	e5933004 	ldr	r3, [r3, #4]
10013328:	e50b3018 	str	r3, [fp, #-24]

                    /* set initial length */
                    min_length = strlen(name_ptr);
1001332c:	e51b0018 	ldr	r0, [fp, #-24]
10013330:	fa002a4e 	blx	1001dc70 <strlen>
10013334:	e1a03000 	mov	r3, r0
10013338:	e50b3014 	str	r3, [fp, #-20]
                }
            }

            var_cnt ++;
1001333c:	e15b31b0 	ldrh	r3, [fp, #-16]
10013340:	e2833001 	add	r3, r3, #1
10013344:	e14b31b0 	strh	r3, [fp, #-16]

            if (*prefix != 0)
10013348:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001334c:	e5d33000 	ldrb	r3, [r3]
10013350:	e3530000 	cmp	r3, #0
10013354:	0a00000b 	beq	10013388 <list_prefix+0x44c>
            {
                length = str_common(name_ptr, sysvar_item->sysvar.name);
10013358:	e51b300c 	ldr	r3, [fp, #-12]
1001335c:	e5933004 	ldr	r3, [r3, #4]
10013360:	e51b0018 	ldr	r0, [fp, #-24]
10013364:	e1a01003 	mov	r1, r3
10013368:	ebfffed0 	bl	10012eb0 <str_common>
1001336c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
                if (length < min_length)
10013370:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10013374:	e51b3014 	ldr	r3, [fp, #-20]
10013378:	e1520003 	cmp	r2, r3
1001337c:	aa000001 	bge	10013388 <list_prefix+0x44c>
                    min_length = length;
10013380:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
10013384:	e50b3014 	str	r3, [fp, #-20]
            }

            rt_kprintf("[v] %s\n", sysvar_item->sysvar.name);
10013388:	e51b300c 	ldr	r3, [fp, #-12]
1001338c:	e5933004 	ldr	r3, [r3, #4]
10013390:	e300012c 	movw	r0, #300	; 0x12c
10013394:	e3410002 	movt	r0, #4098	; 0x1002
10013398:	e1a01003 	mov	r1, r3
1001339c:	ebffcbcc 	bl	100062d4 <rt_kprintf>
        }
        sysvar_item = sysvar_item->next;
100133a0:	e51b300c 	ldr	r3, [fp, #-12]
100133a4:	e5933000 	ldr	r3, [r3]
100133a8:	e50b300c 	str	r3, [fp, #-12]
        }
    }

    /* checks in dynamic system variable */
    sysvar_item = global_sysvar_list;
    while (sysvar_item != NULL)
100133ac:	e51b300c 	ldr	r3, [fp, #-12]
100133b0:	e3530000 	cmp	r3, #0
100133b4:	1affffc4 	bne	100132cc <list_prefix+0x390>
        }
        sysvar_item = sysvar_item->next;
    }

    /* only one matched */
    if (name_ptr != NULL)
100133b8:	e51b3018 	ldr	r3, [fp, #-24]
100133bc:	e3530000 	cmp	r3, #0
100133c0:	0a000004 	beq	100133d8 <list_prefix+0x49c>
    {
        rt_strncpy(prefix, name_ptr, min_length);
100133c4:	e51b3014 	ldr	r3, [fp, #-20]
100133c8:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
100133cc:	e51b1018 	ldr	r1, [fp, #-24]
100133d0:	e1a02003 	mov	r2, r3
100133d4:	ebffc750 	bl	1000511c <rt_strncpy>
    }
}
100133d8:	e24bd004 	sub	sp, fp, #4
100133dc:	e8bd8800 	pop	{fp, pc}

100133e0 <cmd_ps>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_netstat, __cmd_netstat, list the information of TCP/IP);
#endif
#endif /* RT_USING_LWIP */

int cmd_ps(int argc, char** argv)
{
100133e0:	e92d4800 	push	{fp, lr}
100133e4:	e28db004 	add	fp, sp, #4
100133e8:	e24dd008 	sub	sp, sp, #8
100133ec:	e50b0008 	str	r0, [fp, #-8]
100133f0:	e50b100c 	str	r1, [fp, #-12]
    extern long list_thread(void);

    list_thread();
100133f4:	ebfffba2 	bl	10012284 <list_thread>
    return 0;
100133f8:	e3a03000 	mov	r3, #0
}
100133fc:	e1a00003 	mov	r0, r3
10013400:	e24bd004 	sub	sp, fp, #4
10013404:	e8bd8800 	pop	{fp, pc}

10013408 <cmd_time>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_ps, __cmd_ps, List threads in the system.);

int cmd_time(int argc, char** argv)
{
10013408:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001340c:	e28db000 	add	fp, sp, #0
10013410:	e24dd00c 	sub	sp, sp, #12
10013414:	e50b0008 	str	r0, [fp, #-8]
10013418:	e50b100c 	str	r1, [fp, #-12]
    return 0;
1001341c:	e3a03000 	mov	r3, #0
}
10013420:	e1a00003 	mov	r0, r3
10013424:	e24bd000 	sub	sp, fp, #0
10013428:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001342c:	e12fff1e 	bx	lr

10013430 <cmd_free>:
FINSH_FUNCTION_EXPORT_ALIAS(cmd_time, __cmd_time, Execute command with time.);

#ifdef RT_USING_HEAP
int cmd_free(int argc, char** argv)
{
10013430:	e92d4800 	push	{fp, lr}
10013434:	e28db004 	add	fp, sp, #4
10013438:	e24dd008 	sub	sp, sp, #8
1001343c:	e50b0008 	str	r0, [fp, #-8]
10013440:	e50b100c 	str	r1, [fp, #-12]
    extern void list_memheap(void);

#ifdef RT_USING_MEMHEAP_AS_HEAP
    list_memheap();
#else
    list_mem();
10013444:	ebffd064 	bl	100075dc <list_mem>
#endif
    return 0;
10013448:	e3a03000 	mov	r3, #0
}
1001344c:	e1a00003 	mov	r0, r3
10013450:	e24bd004 	sub	sp, fp, #4
10013454:	e8bd8800 	pop	{fp, pc}

10013458 <msh_is_used>:
static rt_bool_t __msh_state = RT_TRUE;
#else
static rt_bool_t __msh_state = RT_FALSE;
#endif
rt_bool_t msh_is_used(void)
{
10013458:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001345c:	e28db000 	add	fp, sp, #0
    return __msh_state;
10013460:	e3003a48 	movw	r3, #2632	; 0xa48
10013464:	e3413002 	movt	r3, #4098	; 0x1002
10013468:	e5933000 	ldr	r3, [r3]
}
1001346c:	e1a00003 	mov	r0, r3
10013470:	e24bd000 	sub	sp, fp, #0
10013474:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013478:	e12fff1e 	bx	lr

1001347c <msh_exit>:

static int msh_exit(int argc, char** argv)
{
1001347c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013480:	e28db000 	add	fp, sp, #0
10013484:	e24dd00c 	sub	sp, sp, #12
10013488:	e50b0008 	str	r0, [fp, #-8]
1001348c:	e50b100c 	str	r1, [fp, #-12]
    /* return to finsh shell mode */
    __msh_state = RT_FALSE;
10013490:	e3003a48 	movw	r3, #2632	; 0xa48
10013494:	e3413002 	movt	r3, #4098	; 0x1002
10013498:	e3a02000 	mov	r2, #0
1001349c:	e5832000 	str	r2, [r3]

    return 0;
100134a0:	e3a03000 	mov	r3, #0
}
100134a4:	e1a00003 	mov	r0, r3
100134a8:	e24bd000 	sub	sp, fp, #0
100134ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100134b0:	e12fff1e 	bx	lr

100134b4 <msh_enter>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_exit, __cmd_exit, return to RT-Thread shell mode.);

static int msh_enter(void)
{
100134b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100134b8:	e28db000 	add	fp, sp, #0
    /* enter module shell mode */
    __msh_state = RT_TRUE;
100134bc:	e3003a48 	movw	r3, #2632	; 0xa48
100134c0:	e3413002 	movt	r3, #4098	; 0x1002
100134c4:	e3a02001 	mov	r2, #1
100134c8:	e5832000 	str	r2, [r3]
    return 0;
100134cc:	e3a03000 	mov	r3, #0
}
100134d0:	e1a00003 	mov	r0, r3
100134d4:	e24bd000 	sub	sp, fp, #0
100134d8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100134dc:	e12fff1e 	bx	lr

100134e0 <msh_help>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_enter, msh, use module shell);
#endif

int msh_help(int argc, char** argv)
{
100134e0:	e92d4800 	push	{fp, lr}
100134e4:	e28db004 	add	fp, sp, #4
100134e8:	e24dd010 	sub	sp, sp, #16
100134ec:	e50b0010 	str	r0, [fp, #-16]
100134f0:	e50b1014 	str	r1, [fp, #-20]
    rt_kprintf("RT-Thread shell commands:\n");
100134f4:	e3000134 	movw	r0, #308	; 0x134
100134f8:	e3410002 	movt	r0, #4098	; 0x1002
100134fc:	ebffcb74 	bl	100062d4 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
10013500:	e3093d58 	movw	r3, #40280	; 0x9d58
10013504:	e3413002 	movt	r3, #4098	; 0x1002
10013508:	e5933000 	ldr	r3, [r3]
1001350c:	e50b3008 	str	r3, [fp, #-8]
10013510:	ea000017 	b	10013574 <msh_help+0x94>
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
        {
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
10013514:	e51b3008 	ldr	r3, [fp, #-8]
10013518:	e5933000 	ldr	r3, [r3]
1001351c:	e1a00003 	mov	r0, r3
10013520:	e3001150 	movw	r1, #336	; 0x150
10013524:	e3411002 	movt	r1, #4098	; 0x1002
10013528:	e3a02006 	mov	r2, #6
1001352c:	fa0029e6 	blx	1001dccc <strncmp>
10013530:	e1a03000 	mov	r3, r0
10013534:	e3530000 	cmp	r3, #0
10013538:	0a000000 	beq	10013540 <msh_help+0x60>
1001353c:	ea000009 	b	10013568 <msh_help+0x88>
#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
            rt_kprintf("%-16s - %s\n", &index->name[6], index->desc);
10013540:	e51b3008 	ldr	r3, [fp, #-8]
10013544:	e5933000 	ldr	r3, [r3]
10013548:	e2832006 	add	r2, r3, #6
1001354c:	e51b3008 	ldr	r3, [fp, #-8]
10013550:	e5933004 	ldr	r3, [r3, #4]
10013554:	e3000158 	movw	r0, #344	; 0x158
10013558:	e3410002 	movt	r0, #4098	; 0x1002
1001355c:	e1a01002 	mov	r1, r2
10013560:	e1a02003 	mov	r2, r3
10013564:	ebffcb5a 	bl	100062d4 <rt_kprintf>
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
            FINSH_NEXT_SYSCALL(index))
10013568:	e51b3008 	ldr	r3, [fp, #-8]
1001356c:	e283300c 	add	r3, r3, #12
10013570:	e50b3008 	str	r3, [fp, #-8]
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
            index < _syscall_table_end;
10013574:	e3093d5c 	movw	r3, #40284	; 0x9d5c
10013578:	e3413002 	movt	r3, #4098	; 0x1002
1001357c:	e5933000 	ldr	r3, [r3]
{
    rt_kprintf("RT-Thread shell commands:\n");
    {
        struct finsh_syscall *index;

        for (index = _syscall_table_begin;
10013580:	e51b2008 	ldr	r2, [fp, #-8]
10013584:	e1520003 	cmp	r2, r3
10013588:	3affffe1 	bcc	10013514 <msh_help+0x34>
#else
            rt_kprintf("%s ", &index->name[6]);
#endif
        }
    }
    rt_kprintf("\n");
1001358c:	e3000164 	movw	r0, #356	; 0x164
10013590:	e3410002 	movt	r0, #4098	; 0x1002
10013594:	ebffcb4e 	bl	100062d4 <rt_kprintf>

    return 0;
10013598:	e3a03000 	mov	r3, #0
}
1001359c:	e1a00003 	mov	r0, r3
100135a0:	e24bd004 	sub	sp, fp, #4
100135a4:	e8bd8800 	pop	{fp, pc}

100135a8 <msh_split>:
FINSH_FUNCTION_EXPORT_ALIAS(msh_help, __cmd_help, RT-Thread shell help.);

static int msh_split(char* cmd, rt_size_t length, char* argv[RT_FINSH_ARG_MAX])
{
100135a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100135ac:	e28db000 	add	fp, sp, #0
100135b0:	e24dd024 	sub	sp, sp, #36	; 0x24
100135b4:	e50b0018 	str	r0, [fp, #-24]
100135b8:	e50b101c 	str	r1, [fp, #-28]
100135bc:	e50b2020 	str	r2, [fp, #-32]
    char *ptr;
    rt_size_t position;
    rt_size_t argc;

    ptr = cmd;
100135c0:	e51b3018 	ldr	r3, [fp, #-24]
100135c4:	e50b3008 	str	r3, [fp, #-8]
    position = 0; argc = 0;
100135c8:	e3a03000 	mov	r3, #0
100135cc:	e50b300c 	str	r3, [fp, #-12]
100135d0:	e3a03000 	mov	r3, #0
100135d4:	e50b3010 	str	r3, [fp, #-16]

    while (position < length)
100135d8:	ea00007b 	b	100137cc <msh_split+0x224>
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
100135dc:	ea000008 	b	10013604 <msh_split+0x5c>
        {
            *ptr = '\0';
100135e0:	e51b3008 	ldr	r3, [fp, #-8]
100135e4:	e3a02000 	mov	r2, #0
100135e8:	e5c32000 	strb	r2, [r3]
            ptr ++; position ++;
100135ec:	e51b3008 	ldr	r3, [fp, #-8]
100135f0:	e2833001 	add	r3, r3, #1
100135f4:	e50b3008 	str	r3, [fp, #-8]
100135f8:	e51b300c 	ldr	r3, [fp, #-12]
100135fc:	e2833001 	add	r3, r3, #1
10013600:	e50b300c 	str	r3, [fp, #-12]
    position = 0; argc = 0;

    while (position < length)
    {
        /* strip bank and tab */
        while ((*ptr == ' ' || *ptr == '\t') && position < length)
10013604:	e51b3008 	ldr	r3, [fp, #-8]
10013608:	e5d33000 	ldrb	r3, [r3]
1001360c:	e3530020 	cmp	r3, #32
10013610:	0a000003 	beq	10013624 <msh_split+0x7c>
10013614:	e51b3008 	ldr	r3, [fp, #-8]
10013618:	e5d33000 	ldrb	r3, [r3]
1001361c:	e3530009 	cmp	r3, #9
10013620:	1a000003 	bne	10013634 <msh_split+0x8c>
10013624:	e51b200c 	ldr	r2, [fp, #-12]
10013628:	e51b301c 	ldr	r3, [fp, #-28]
1001362c:	e1520003 	cmp	r2, r3
10013630:	3affffea 	bcc	100135e0 <msh_split+0x38>
        {
            *ptr = '\0';
            ptr ++; position ++;
        }
        if (position >= length) break;
10013634:	e51b200c 	ldr	r2, [fp, #-12]
10013638:	e51b301c 	ldr	r3, [fp, #-28]
1001363c:	e1520003 	cmp	r2, r3
10013640:	3a000000 	bcc	10013648 <msh_split+0xa0>
10013644:	ea000064 	b	100137dc <msh_split+0x234>

        /* handle string */
        if (*ptr == '"')
10013648:	e51b3008 	ldr	r3, [fp, #-8]
1001364c:	e5d33000 	ldrb	r3, [r3]
10013650:	e3530022 	cmp	r3, #34	; 0x22
10013654:	1a00003b 	bne	10013748 <msh_split+0x1a0>
        {
            ptr ++; position ++;
10013658:	e51b3008 	ldr	r3, [fp, #-8]
1001365c:	e2833001 	add	r3, r3, #1
10013660:	e50b3008 	str	r3, [fp, #-8]
10013664:	e51b300c 	ldr	r3, [fp, #-12]
10013668:	e2833001 	add	r3, r3, #1
1001366c:	e50b300c 	str	r3, [fp, #-12]
            argv[argc] = ptr; argc ++;
10013670:	e51b3010 	ldr	r3, [fp, #-16]
10013674:	e1a03103 	lsl	r3, r3, #2
10013678:	e51b2020 	ldr	r2, [fp, #-32]
1001367c:	e0823003 	add	r3, r2, r3
10013680:	e51b2008 	ldr	r2, [fp, #-8]
10013684:	e5832000 	str	r2, [r3]
10013688:	e51b3010 	ldr	r3, [fp, #-16]
1001368c:	e2833001 	add	r3, r3, #1
10013690:	e50b3010 	str	r3, [fp, #-16]

            /* skip this string */
            while (*ptr != '"' && position < length)
10013694:	ea000014 	b	100136ec <msh_split+0x144>
            {
                if (*ptr == '\\')
10013698:	e51b3008 	ldr	r3, [fp, #-8]
1001369c:	e5d33000 	ldrb	r3, [r3]
100136a0:	e353005c 	cmp	r3, #92	; 0x5c
100136a4:	1a00000a 	bne	100136d4 <msh_split+0x12c>
                {
                    if (*(ptr + 1) == '"')
100136a8:	e51b3008 	ldr	r3, [fp, #-8]
100136ac:	e2833001 	add	r3, r3, #1
100136b0:	e5d33000 	ldrb	r3, [r3]
100136b4:	e3530022 	cmp	r3, #34	; 0x22
100136b8:	1a000005 	bne	100136d4 <msh_split+0x12c>
                    {
                        ptr ++; position ++;
100136bc:	e51b3008 	ldr	r3, [fp, #-8]
100136c0:	e2833001 	add	r3, r3, #1
100136c4:	e50b3008 	str	r3, [fp, #-8]
100136c8:	e51b300c 	ldr	r3, [fp, #-12]
100136cc:	e2833001 	add	r3, r3, #1
100136d0:	e50b300c 	str	r3, [fp, #-12]
                    }
                }
                ptr ++; position ++;
100136d4:	e51b3008 	ldr	r3, [fp, #-8]
100136d8:	e2833001 	add	r3, r3, #1
100136dc:	e50b3008 	str	r3, [fp, #-8]
100136e0:	e51b300c 	ldr	r3, [fp, #-12]
100136e4:	e2833001 	add	r3, r3, #1
100136e8:	e50b300c 	str	r3, [fp, #-12]
        {
            ptr ++; position ++;
            argv[argc] = ptr; argc ++;

            /* skip this string */
            while (*ptr != '"' && position < length)
100136ec:	e51b3008 	ldr	r3, [fp, #-8]
100136f0:	e5d33000 	ldrb	r3, [r3]
100136f4:	e3530022 	cmp	r3, #34	; 0x22
100136f8:	0a000003 	beq	1001370c <msh_split+0x164>
100136fc:	e51b200c 	ldr	r2, [fp, #-12]
10013700:	e51b301c 	ldr	r3, [fp, #-28]
10013704:	e1520003 	cmp	r2, r3
10013708:	3affffe2 	bcc	10013698 <msh_split+0xf0>
                        ptr ++; position ++;
                    }
                }
                ptr ++; position ++;
            }
            if (position >= length) break;
1001370c:	e51b200c 	ldr	r2, [fp, #-12]
10013710:	e51b301c 	ldr	r3, [fp, #-28]
10013714:	e1520003 	cmp	r2, r3
10013718:	3a000000 	bcc	10013720 <msh_split+0x178>
1001371c:	ea00002e 	b	100137dc <msh_split+0x234>

            /* skip '"' */
            *ptr = '\0'; ptr ++; position ++;
10013720:	e51b3008 	ldr	r3, [fp, #-8]
10013724:	e3a02000 	mov	r2, #0
10013728:	e5c32000 	strb	r2, [r3]
1001372c:	e51b3008 	ldr	r3, [fp, #-8]
10013730:	e2833001 	add	r3, r3, #1
10013734:	e50b3008 	str	r3, [fp, #-8]
10013738:	e51b300c 	ldr	r3, [fp, #-12]
1001373c:	e2833001 	add	r3, r3, #1
10013740:	e50b300c 	str	r3, [fp, #-12]
10013744:	ea000020 	b	100137cc <msh_split+0x224>
        }
        else
        {
            argv[argc] = ptr;
10013748:	e51b3010 	ldr	r3, [fp, #-16]
1001374c:	e1a03103 	lsl	r3, r3, #2
10013750:	e51b2020 	ldr	r2, [fp, #-32]
10013754:	e0823003 	add	r3, r2, r3
10013758:	e51b2008 	ldr	r2, [fp, #-8]
1001375c:	e5832000 	str	r2, [r3]
            argc ++;
10013760:	e51b3010 	ldr	r3, [fp, #-16]
10013764:	e2833001 	add	r3, r3, #1
10013768:	e50b3010 	str	r3, [fp, #-16]
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
1001376c:	ea000005 	b	10013788 <msh_split+0x1e0>
            {
                ptr ++; position ++;
10013770:	e51b3008 	ldr	r3, [fp, #-8]
10013774:	e2833001 	add	r3, r3, #1
10013778:	e50b3008 	str	r3, [fp, #-8]
1001377c:	e51b300c 	ldr	r3, [fp, #-12]
10013780:	e2833001 	add	r3, r3, #1
10013784:	e50b300c 	str	r3, [fp, #-12]
        }
        else
        {
            argv[argc] = ptr;
            argc ++;
            while ((*ptr != ' ' && *ptr != '\t') && position < length)
10013788:	e51b3008 	ldr	r3, [fp, #-8]
1001378c:	e5d33000 	ldrb	r3, [r3]
10013790:	e3530020 	cmp	r3, #32
10013794:	0a000007 	beq	100137b8 <msh_split+0x210>
10013798:	e51b3008 	ldr	r3, [fp, #-8]
1001379c:	e5d33000 	ldrb	r3, [r3]
100137a0:	e3530009 	cmp	r3, #9
100137a4:	0a000003 	beq	100137b8 <msh_split+0x210>
100137a8:	e51b200c 	ldr	r2, [fp, #-12]
100137ac:	e51b301c 	ldr	r3, [fp, #-28]
100137b0:	e1520003 	cmp	r2, r3
100137b4:	3affffed 	bcc	10013770 <msh_split+0x1c8>
            {
                ptr ++; position ++;
            }
            if (position >= length) break;
100137b8:	e51b200c 	ldr	r2, [fp, #-12]
100137bc:	e51b301c 	ldr	r3, [fp, #-28]
100137c0:	e1520003 	cmp	r2, r3
100137c4:	3a000000 	bcc	100137cc <msh_split+0x224>
100137c8:	ea000003 	b	100137dc <msh_split+0x234>
    rt_size_t argc;

    ptr = cmd;
    position = 0; argc = 0;

    while (position < length)
100137cc:	e51b200c 	ldr	r2, [fp, #-12]
100137d0:	e51b301c 	ldr	r3, [fp, #-28]
100137d4:	e1520003 	cmp	r2, r3
100137d8:	3affff7f 	bcc	100135dc <msh_split+0x34>
            }
            if (position >= length) break;
        }
    }

    return argc;
100137dc:	e51b3010 	ldr	r3, [fp, #-16]
}
100137e0:	e1a00003 	mov	r0, r3
100137e4:	e24bd000 	sub	sp, fp, #0
100137e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100137ec:	e12fff1e 	bx	lr

100137f0 <msh_get_cmd>:

static cmd_function_t msh_get_cmd(char *cmd, int size)
{
100137f0:	e92d4800 	push	{fp, lr}
100137f4:	e28db004 	add	fp, sp, #4
100137f8:	e24dd010 	sub	sp, sp, #16
100137fc:	e50b0010 	str	r0, [fp, #-16]
10013800:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;
10013804:	e3a03000 	mov	r3, #0
10013808:	e50b300c 	str	r3, [fp, #-12]

    for (index = _syscall_table_begin;
1001380c:	e3093d58 	movw	r3, #40280	; 0x9d58
10013810:	e3413002 	movt	r3, #4098	; 0x1002
10013814:	e5933000 	ldr	r3, [r3]
10013818:	e50b3008 	str	r3, [fp, #-8]
1001381c:	ea000024 	b	100138b4 <msh_get_cmd+0xc4>
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
10013820:	e51b3008 	ldr	r3, [fp, #-8]
10013824:	e5933000 	ldr	r3, [r3]
10013828:	e1a00003 	mov	r0, r3
1001382c:	e3001150 	movw	r1, #336	; 0x150
10013830:	e3411002 	movt	r1, #4098	; 0x1002
10013834:	e3a02006 	mov	r2, #6
10013838:	fa002923 	blx	1001dccc <strncmp>
1001383c:	e1a03000 	mov	r3, r0
10013840:	e3530000 	cmp	r3, #0
10013844:	0a000000 	beq	1001384c <msh_get_cmd+0x5c>
10013848:	ea000016 	b	100138a8 <msh_get_cmd+0xb8>
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
1001384c:	e51b3008 	ldr	r3, [fp, #-8]
10013850:	e5933000 	ldr	r3, [r3]
10013854:	e2832006 	add	r2, r3, #6
10013858:	e51b3014 	ldr	r3, [fp, #-20]
1001385c:	e1a00002 	mov	r0, r2
10013860:	e51b1010 	ldr	r1, [fp, #-16]
10013864:	e1a02003 	mov	r2, r3
10013868:	fa002917 	blx	1001dccc <strncmp>
1001386c:	e1a03000 	mov	r3, r0
10013870:	e3530000 	cmp	r3, #0
10013874:	1a00000b 	bne	100138a8 <msh_get_cmd+0xb8>
			index->name[6 + size] == '\0')
10013878:	e51b3008 	ldr	r3, [fp, #-8]
1001387c:	e5933000 	ldr	r3, [r3]
10013880:	e51b2014 	ldr	r2, [fp, #-20]
10013884:	e2822006 	add	r2, r2, #6
10013888:	e0833002 	add	r3, r3, r2
1001388c:	e5d33000 	ldrb	r3, [r3]
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
    {
        if (strncmp(index->name, "__cmd_", 6) != 0) continue;
        
        if (strncmp(&index->name[6], cmd, size) == 0 &&
10013890:	e3530000 	cmp	r3, #0
10013894:	1a000003 	bne	100138a8 <msh_get_cmd+0xb8>
			index->name[6 + size] == '\0')
        {
            cmd_func = (cmd_function_t)index->func;
10013898:	e51b3008 	ldr	r3, [fp, #-8]
1001389c:	e5933008 	ldr	r3, [r3, #8]
100138a0:	e50b300c 	str	r3, [fp, #-12]
            break;
100138a4:	ea000008 	b	100138cc <msh_get_cmd+0xdc>
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
        FINSH_NEXT_SYSCALL(index))
100138a8:	e51b3008 	ldr	r3, [fp, #-8]
100138ac:	e283300c 	add	r3, r3, #12
100138b0:	e50b3008 	str	r3, [fp, #-8]
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
        index < _syscall_table_end;
100138b4:	e3093d5c 	movw	r3, #40284	; 0x9d5c
100138b8:	e3413002 	movt	r3, #4098	; 0x1002
100138bc:	e5933000 	ldr	r3, [r3]
static cmd_function_t msh_get_cmd(char *cmd, int size)
{
    struct finsh_syscall *index;
    cmd_function_t cmd_func = RT_NULL;

    for (index = _syscall_table_begin;
100138c0:	e51b2008 	ldr	r2, [fp, #-8]
100138c4:	e1520003 	cmp	r2, r3
100138c8:	3affffd4 	bcc	10013820 <msh_get_cmd+0x30>
            cmd_func = (cmd_function_t)index->func;
            break;
        }
    }

    return cmd_func;
100138cc:	e51b300c 	ldr	r3, [fp, #-12]
}
100138d0:	e1a00003 	mov	r0, r3
100138d4:	e24bd004 	sub	sp, fp, #4
100138d8:	e8bd8800 	pop	{fp, pc}

100138dc <_msh_exec_cmd>:
}
RTM_EXPORT(system);
#endif

static int _msh_exec_cmd(char* cmd, rt_size_t length, int *retp)
{
100138dc:	e92d4800 	push	{fp, lr}
100138e0:	e28db004 	add	fp, sp, #4
100138e4:	e24dd048 	sub	sp, sp, #72	; 0x48
100138e8:	e50b0040 	str	r0, [fp, #-64]	; 0x40
100138ec:	e50b1044 	str	r1, [fp, #-68]	; 0x44
100138f0:	e50b2048 	str	r2, [fp, #-72]	; 0x48
    int argc;
    int cmd0_size = 0;
100138f4:	e3a03000 	mov	r3, #0
100138f8:	e50b3008 	str	r3, [fp, #-8]
    cmd_function_t cmd_func;
    char *argv[RT_FINSH_ARG_MAX];

    RT_ASSERT(cmd);
100138fc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10013900:	e3530000 	cmp	r3, #0
10013904:	1a000005 	bne	10013920 <_msh_exec_cmd+0x44>
10013908:	e3000168 	movw	r0, #360	; 0x168
1001390c:	e3410002 	movt	r0, #4098	; 0x1002
10013910:	e3001190 	movw	r1, #400	; 0x190
10013914:	e3411002 	movt	r1, #4098	; 0x1002
10013918:	e300210a 	movw	r2, #266	; 0x10a
1001391c:	ebffcb29 	bl	100065c8 <rt_assert_handler>
    RT_ASSERT(retp);
10013920:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10013924:	e3530000 	cmp	r3, #0
10013928:	1a000005 	bne	10013944 <_msh_exec_cmd+0x68>
1001392c:	e300016c 	movw	r0, #364	; 0x16c
10013930:	e3410002 	movt	r0, #4098	; 0x1002
10013934:	e3001190 	movw	r1, #400	; 0x190
10013938:	e3411002 	movt	r1, #4098	; 0x1002
1001393c:	e300210b 	movw	r2, #267	; 0x10b
10013940:	ebffcb20 	bl	100065c8 <rt_assert_handler>

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
10013944:	ea000002 	b	10013954 <_msh_exec_cmd+0x78>
        cmd0_size ++;
10013948:	e51b3008 	ldr	r3, [fp, #-8]
1001394c:	e2833001 	add	r3, r3, #1
10013950:	e50b3008 	str	r3, [fp, #-8]

    RT_ASSERT(cmd);
    RT_ASSERT(retp);

    /* find the size of first command */
    while ((cmd[cmd0_size] != ' ' && cmd[cmd0_size] != '\t') && cmd0_size < length)
10013954:	e51b3008 	ldr	r3, [fp, #-8]
10013958:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
1001395c:	e0823003 	add	r3, r2, r3
10013960:	e5d33000 	ldrb	r3, [r3]
10013964:	e3530020 	cmp	r3, #32
10013968:	0a000009 	beq	10013994 <_msh_exec_cmd+0xb8>
1001396c:	e51b3008 	ldr	r3, [fp, #-8]
10013970:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
10013974:	e0823003 	add	r3, r2, r3
10013978:	e5d33000 	ldrb	r3, [r3]
1001397c:	e3530009 	cmp	r3, #9
10013980:	0a000003 	beq	10013994 <_msh_exec_cmd+0xb8>
10013984:	e51b2008 	ldr	r2, [fp, #-8]
10013988:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
1001398c:	e1520003 	cmp	r2, r3
10013990:	3affffec 	bcc	10013948 <_msh_exec_cmd+0x6c>
        cmd0_size ++;
    if (cmd0_size == 0)
10013994:	e51b3008 	ldr	r3, [fp, #-8]
10013998:	e3530000 	cmp	r3, #0
1001399c:	1a000001 	bne	100139a8 <_msh_exec_cmd+0xcc>
        return -RT_ERROR;
100139a0:	e3e03000 	mvn	r3, #0
100139a4:	ea000021 	b	10013a30 <_msh_exec_cmd+0x154>

    cmd_func = msh_get_cmd(cmd, cmd0_size);
100139a8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
100139ac:	e51b1008 	ldr	r1, [fp, #-8]
100139b0:	ebffff8e 	bl	100137f0 <msh_get_cmd>
100139b4:	e50b000c 	str	r0, [fp, #-12]
    if (cmd_func == RT_NULL)
100139b8:	e51b300c 	ldr	r3, [fp, #-12]
100139bc:	e3530000 	cmp	r3, #0
100139c0:	1a000001 	bne	100139cc <_msh_exec_cmd+0xf0>
        return -RT_ERROR;
100139c4:	e3e03000 	mvn	r3, #0
100139c8:	ea000018 	b	10013a30 <_msh_exec_cmd+0x154>

    /* split arguments */
    memset(argv, 0x00, sizeof(argv));
100139cc:	e24b3038 	sub	r3, fp, #56	; 0x38
100139d0:	e1a00003 	mov	r0, r3
100139d4:	e3a01000 	mov	r1, #0
100139d8:	e3a02028 	mov	r2, #40	; 0x28
100139dc:	fa0027be 	blx	1001d8dc <memset>
    argc = msh_split(cmd, length, argv);
100139e0:	e24b3038 	sub	r3, fp, #56	; 0x38
100139e4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
100139e8:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
100139ec:	e1a02003 	mov	r2, r3
100139f0:	ebfffeec 	bl	100135a8 <msh_split>
100139f4:	e50b0010 	str	r0, [fp, #-16]
    if (argc == 0)
100139f8:	e51b3010 	ldr	r3, [fp, #-16]
100139fc:	e3530000 	cmp	r3, #0
10013a00:	1a000001 	bne	10013a0c <_msh_exec_cmd+0x130>
        return -RT_ERROR;
10013a04:	e3e03000 	mvn	r3, #0
10013a08:	ea000008 	b	10013a30 <_msh_exec_cmd+0x154>

    /* exec this command */
    *retp = cmd_func(argc, argv);
10013a0c:	e24b2038 	sub	r2, fp, #56	; 0x38
10013a10:	e51b300c 	ldr	r3, [fp, #-12]
10013a14:	e51b0010 	ldr	r0, [fp, #-16]
10013a18:	e1a01002 	mov	r1, r2
10013a1c:	e12fff33 	blx	r3
10013a20:	e1a02000 	mov	r2, r0
10013a24:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10013a28:	e5832000 	str	r2, [r3]
    return 0;
10013a2c:	e3a03000 	mov	r3, #0
}
10013a30:	e1a00003 	mov	r0, r3
10013a34:	e24bd004 	sub	sp, fp, #4
10013a38:	e8bd8800 	pop	{fp, pc}

10013a3c <msh_exec>:

int msh_exec(char* cmd, rt_size_t length)
{
10013a3c:	e92d4800 	push	{fp, lr}
10013a40:	e28db004 	add	fp, sp, #4
10013a44:	e24dd010 	sub	sp, sp, #16
10013a48:	e50b0010 	str	r0, [fp, #-16]
10013a4c:	e50b1014 	str	r1, [fp, #-20]
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
10013a50:	ea000005 	b	10013a6c <msh_exec+0x30>
    {
        cmd++;
10013a54:	e51b3010 	ldr	r3, [fp, #-16]
10013a58:	e2833001 	add	r3, r3, #1
10013a5c:	e50b3010 	str	r3, [fp, #-16]
        length--;
10013a60:	e51b3014 	ldr	r3, [fp, #-20]
10013a64:	e2433001 	sub	r3, r3, #1
10013a68:	e50b3014 	str	r3, [fp, #-20]
int msh_exec(char* cmd, rt_size_t length)
{
    int cmd_ret;

	/* strim the beginning of command */
    while(*cmd  == ' ' || *cmd == '\t')
10013a6c:	e51b3010 	ldr	r3, [fp, #-16]
10013a70:	e5d33000 	ldrb	r3, [r3]
10013a74:	e3530020 	cmp	r3, #32
10013a78:	0afffff5 	beq	10013a54 <msh_exec+0x18>
10013a7c:	e51b3010 	ldr	r3, [fp, #-16]
10013a80:	e5d33000 	ldrb	r3, [r3]
10013a84:	e3530009 	cmp	r3, #9
10013a88:	0afffff1 	beq	10013a54 <msh_exec+0x18>
    {
        cmd++;
        length--;
    }

    if (length == 0)
10013a8c:	e51b3014 	ldr	r3, [fp, #-20]
10013a90:	e3530000 	cmp	r3, #0
10013a94:	1a000001 	bne	10013aa0 <msh_exec+0x64>
        return 0;
10013a98:	e3a03000 	mov	r3, #0
10013a9c:	ea00001f 	b	10013b20 <msh_exec+0xe4>
    /* Exec sequence:
     * 1. built-in command
     * 2. module(if enabled)
     * 3. chdir to the directry(if possible)
     */
    if (_msh_exec_cmd(cmd, length, &cmd_ret) == 0)
10013aa0:	e24b300c 	sub	r3, fp, #12
10013aa4:	e51b0010 	ldr	r0, [fp, #-16]
10013aa8:	e51b1014 	ldr	r1, [fp, #-20]
10013aac:	e1a02003 	mov	r2, r3
10013ab0:	ebffff89 	bl	100138dc <_msh_exec_cmd>
10013ab4:	e1a03000 	mov	r3, r0
10013ab8:	e3530000 	cmp	r3, #0
10013abc:	1a000001 	bne	10013ac8 <msh_exec+0x8c>
    {
        return cmd_ret;
10013ac0:	e51b300c 	ldr	r3, [fp, #-12]
10013ac4:	ea000015 	b	10013b20 <msh_exec+0xe4>
#endif

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
10013ac8:	e51b3010 	ldr	r3, [fp, #-16]
10013acc:	e50b3008 	str	r3, [fp, #-8]
        while(*tcmd != ' ' && *tcmd != '\0')
10013ad0:	ea000002 	b	10013ae0 <msh_exec+0xa4>
        {
            tcmd++;
10013ad4:	e51b3008 	ldr	r3, [fp, #-8]
10013ad8:	e2833001 	add	r3, r3, #1
10013adc:	e50b3008 	str	r3, [fp, #-8]

    /* truncate the cmd at the first space. */
    {
        char *tcmd;
        tcmd = cmd;
        while(*tcmd != ' ' && *tcmd != '\0')
10013ae0:	e51b3008 	ldr	r3, [fp, #-8]
10013ae4:	e5d33000 	ldrb	r3, [r3]
10013ae8:	e3530020 	cmp	r3, #32
10013aec:	0a000003 	beq	10013b00 <msh_exec+0xc4>
10013af0:	e51b3008 	ldr	r3, [fp, #-8]
10013af4:	e5d33000 	ldrb	r3, [r3]
10013af8:	e3530000 	cmp	r3, #0
10013afc:	1afffff4 	bne	10013ad4 <msh_exec+0x98>
        {
            tcmd++;
        }
        *tcmd = '\0';
10013b00:	e51b3008 	ldr	r3, [fp, #-8]
10013b04:	e3a02000 	mov	r2, #0
10013b08:	e5c32000 	strb	r2, [r3]
    }
    rt_kprintf("%s: command not found.\n", cmd);
10013b0c:	e3000174 	movw	r0, #372	; 0x174
10013b10:	e3410002 	movt	r0, #4098	; 0x1002
10013b14:	e51b1010 	ldr	r1, [fp, #-16]
10013b18:	ebffc9ed 	bl	100062d4 <rt_kprintf>
    return -1;
10013b1c:	e3e03000 	mvn	r3, #0
}
10013b20:	e1a00003 	mov	r0, r3
10013b24:	e24bd004 	sub	sp, fp, #4
10013b28:	e8bd8800 	pop	{fp, pc}

10013b2c <str_common>:

static int str_common(const char *str1, const char *str2)
{
10013b2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10013b30:	e28db000 	add	fp, sp, #0
10013b34:	e24dd014 	sub	sp, sp, #20
10013b38:	e50b0010 	str	r0, [fp, #-16]
10013b3c:	e50b1014 	str	r1, [fp, #-20]
    const char *str = str1;
10013b40:	e51b3010 	ldr	r3, [fp, #-16]
10013b44:	e50b3008 	str	r3, [fp, #-8]

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
10013b48:	ea000005 	b	10013b64 <str_common+0x38>
    {
        str ++;
10013b4c:	e51b3008 	ldr	r3, [fp, #-8]
10013b50:	e2833001 	add	r3, r3, #1
10013b54:	e50b3008 	str	r3, [fp, #-8]
        str2 ++;
10013b58:	e51b3014 	ldr	r3, [fp, #-20]
10013b5c:	e2833001 	add	r3, r3, #1
10013b60:	e50b3014 	str	r3, [fp, #-20]

static int str_common(const char *str1, const char *str2)
{
    const char *str = str1;

    while ((*str != 0) && (*str2 != 0) && (*str == *str2))
10013b64:	e51b3008 	ldr	r3, [fp, #-8]
10013b68:	e5d33000 	ldrb	r3, [r3]
10013b6c:	e3530000 	cmp	r3, #0
10013b70:	0a000009 	beq	10013b9c <str_common+0x70>
10013b74:	e51b3014 	ldr	r3, [fp, #-20]
10013b78:	e5d33000 	ldrb	r3, [r3]
10013b7c:	e3530000 	cmp	r3, #0
10013b80:	0a000005 	beq	10013b9c <str_common+0x70>
10013b84:	e51b3008 	ldr	r3, [fp, #-8]
10013b88:	e5d32000 	ldrb	r2, [r3]
10013b8c:	e51b3014 	ldr	r3, [fp, #-20]
10013b90:	e5d33000 	ldrb	r3, [r3]
10013b94:	e1520003 	cmp	r2, r3
10013b98:	0affffeb 	beq	10013b4c <str_common+0x20>
    {
        str ++;
        str2 ++;
    }

    return (str - str1);
10013b9c:	e51b2008 	ldr	r2, [fp, #-8]
10013ba0:	e51b3010 	ldr	r3, [fp, #-16]
10013ba4:	e0633002 	rsb	r3, r3, r2
}
10013ba8:	e1a00003 	mov	r0, r3
10013bac:	e24bd000 	sub	sp, fp, #0
10013bb0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10013bb4:	e12fff1e 	bx	lr

10013bb8 <msh_auto_complete>:
    rt_free(full_path);
}
#endif

void msh_auto_complete(char *prefix)
{
10013bb8:	e92d4800 	push	{fp, lr}
10013bbc:	e28db004 	add	fp, sp, #4
10013bc0:	e24dd020 	sub	sp, sp, #32
10013bc4:	e50b0020 	str	r0, [fp, #-32]
    int length, min_length;
    const char *name_ptr, *cmd_name;
    struct finsh_syscall *index;

    min_length = 0;
10013bc8:	e3a03000 	mov	r3, #0
10013bcc:	e50b3008 	str	r3, [fp, #-8]
    name_ptr = RT_NULL;
10013bd0:	e3a03000 	mov	r3, #0
10013bd4:	e50b300c 	str	r3, [fp, #-12]

    if (*prefix == '\0') 
10013bd8:	e51b3020 	ldr	r3, [fp, #-32]
10013bdc:	e5d33000 	ldrb	r3, [r3]
10013be0:	e3530000 	cmp	r3, #0
10013be4:	1a000003 	bne	10013bf8 <msh_auto_complete+0x40>
    {
        msh_help(0, RT_NULL);
10013be8:	e3a00000 	mov	r0, #0
10013bec:	e3a01000 	mov	r1, #0
10013bf0:	ebfffe3a 	bl	100134e0 <msh_help>
        return;
10013bf4:	ea000046 	b	10013d14 <msh_auto_complete+0x15c>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
10013bf8:	e3093d58 	movw	r3, #40280	; 0x9d58
10013bfc:	e3413002 	movt	r3, #4098	; 0x1002
10013c00:	e5933000 	ldr	r3, [r3]
10013c04:	e50b3010 	str	r3, [fp, #-16]
10013c08:	ea000032 	b	10013cd8 <msh_auto_complete+0x120>
        {
            /* skip finsh shell function */
            if (strncmp(index->name, "__cmd_", 6) != 0) continue;
10013c0c:	e51b3010 	ldr	r3, [fp, #-16]
10013c10:	e5933000 	ldr	r3, [r3]
10013c14:	e1a00003 	mov	r0, r3
10013c18:	e3001150 	movw	r1, #336	; 0x150
10013c1c:	e3411002 	movt	r1, #4098	; 0x1002
10013c20:	e3a02006 	mov	r2, #6
10013c24:	fa002828 	blx	1001dccc <strncmp>
10013c28:	e1a03000 	mov	r3, r0
10013c2c:	e3530000 	cmp	r3, #0
10013c30:	0a000000 	beq	10013c38 <msh_auto_complete+0x80>
10013c34:	ea000024 	b	10013ccc <msh_auto_complete+0x114>

            cmd_name = (const char*) &index->name[6];
10013c38:	e51b3010 	ldr	r3, [fp, #-16]
10013c3c:	e5933000 	ldr	r3, [r3]
10013c40:	e2833006 	add	r3, r3, #6
10013c44:	e50b3014 	str	r3, [fp, #-20]
            if (strncmp(prefix, cmd_name, strlen(prefix)) == 0)
10013c48:	e51b0020 	ldr	r0, [fp, #-32]
10013c4c:	fa002807 	blx	1001dc70 <strlen>
10013c50:	e1a03000 	mov	r3, r0
10013c54:	e51b0020 	ldr	r0, [fp, #-32]
10013c58:	e51b1014 	ldr	r1, [fp, #-20]
10013c5c:	e1a02003 	mov	r2, r3
10013c60:	fa002819 	blx	1001dccc <strncmp>
10013c64:	e1a03000 	mov	r3, r0
10013c68:	e3530000 	cmp	r3, #0
10013c6c:	1a000016 	bne	10013ccc <msh_auto_complete+0x114>
            {
                if (min_length == 0)
10013c70:	e51b3008 	ldr	r3, [fp, #-8]
10013c74:	e3530000 	cmp	r3, #0
10013c78:	1a000005 	bne	10013c94 <msh_auto_complete+0xdc>
                {
                    /* set name_ptr */
                    name_ptr = cmd_name;
10013c7c:	e51b3014 	ldr	r3, [fp, #-20]
10013c80:	e50b300c 	str	r3, [fp, #-12]
                    /* set initial length */
                    min_length = strlen(name_ptr);
10013c84:	e51b000c 	ldr	r0, [fp, #-12]
10013c88:	fa0027f8 	blx	1001dc70 <strlen>
10013c8c:	e1a03000 	mov	r3, r0
10013c90:	e50b3008 	str	r3, [fp, #-8]
                }

                length = str_common(name_ptr, cmd_name);
10013c94:	e51b000c 	ldr	r0, [fp, #-12]
10013c98:	e51b1014 	ldr	r1, [fp, #-20]
10013c9c:	ebffffa2 	bl	10013b2c <str_common>
10013ca0:	e50b0018 	str	r0, [fp, #-24]
                if (length < min_length)
10013ca4:	e51b2018 	ldr	r2, [fp, #-24]
10013ca8:	e51b3008 	ldr	r3, [fp, #-8]
10013cac:	e1520003 	cmp	r2, r3
10013cb0:	aa000001 	bge	10013cbc <msh_auto_complete+0x104>
                    min_length = length;
10013cb4:	e51b3018 	ldr	r3, [fp, #-24]
10013cb8:	e50b3008 	str	r3, [fp, #-8]

                rt_kprintf("%s\n", cmd_name);
10013cbc:	e300018c 	movw	r0, #396	; 0x18c
10013cc0:	e3410002 	movt	r0, #4098	; 0x1002
10013cc4:	e51b1014 	ldr	r1, [fp, #-20]
10013cc8:	ebffc981 	bl	100062d4 <rt_kprintf>
    }
#endif

    /* checks in internal command */
    {
        for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
10013ccc:	e51b3010 	ldr	r3, [fp, #-16]
10013cd0:	e283300c 	add	r3, r3, #12
10013cd4:	e50b3010 	str	r3, [fp, #-16]
10013cd8:	e3093d5c 	movw	r3, #40284	; 0x9d5c
10013cdc:	e3413002 	movt	r3, #4098	; 0x1002
10013ce0:	e5933000 	ldr	r3, [r3]
10013ce4:	e51b2010 	ldr	r2, [fp, #-16]
10013ce8:	e1520003 	cmp	r2, r3
10013cec:	3affffc6 	bcc	10013c0c <msh_auto_complete+0x54>
            }
        }
    }

    /* auto complete string */
    if (name_ptr != NULL)
10013cf0:	e51b300c 	ldr	r3, [fp, #-12]
10013cf4:	e3530000 	cmp	r3, #0
10013cf8:	0a000004 	beq	10013d10 <msh_auto_complete+0x158>
    {
        rt_strncpy(prefix, name_ptr, min_length);
10013cfc:	e51b3008 	ldr	r3, [fp, #-8]
10013d00:	e51b0020 	ldr	r0, [fp, #-32]
10013d04:	e51b100c 	ldr	r1, [fp, #-12]
10013d08:	e1a02003 	mov	r2, r3
10013d0c:	ebffc502 	bl	1000511c <rt_strncpy>
    }

    return ;
10013d10:	e1a00000 	nop			; (mov r0, r0)
}
10013d14:	e24bd004 	sub	sp, fp, #4
10013d18:	e8bd8800 	pop	{fp, pc}

10013d1c <finsh_compile>:
#define finsh_code_byte(x)  do { *finsh_compile_pc = (x); finsh_compile_pc ++; } while(0)
#define finsh_code_word(x)  do { FINSH_SET16(finsh_compile_pc, x); finsh_compile_pc +=2; } while(0)
#define finsh_code_dword(x) do { FINSH_SET32(finsh_compile_pc, x); finsh_compile_pc +=4; } while(0)

static int finsh_compile(struct finsh_node* node)
{
10013d1c:	e92d4800 	push	{fp, lr}
10013d20:	e28db004 	add	fp, sp, #4
10013d24:	e24dd028 	sub	sp, sp, #40	; 0x28
10013d28:	e50b0028 	str	r0, [fp, #-40]	; 0x28
    if (node != NULL)
10013d2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013d30:	e3530000 	cmp	r3, #0
10013d34:	0a000db3 	beq	10017408 <finsh_compile+0x36ec>
    {
        /* compile child node */
        if (finsh_node_child(node) != NULL)
10013d38:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013d3c:	e5933010 	ldr	r3, [r3, #16]
10013d40:	e3530000 	cmp	r3, #0
10013d44:	0a000003 	beq	10013d58 <finsh_compile+0x3c>
            finsh_compile(finsh_node_child(node));
10013d48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013d4c:	e5933010 	ldr	r3, [r3, #16]
10013d50:	e1a00003 	mov	r0, r3
10013d54:	ebfffff0 	bl	10013d1c <finsh_compile>

        /* compile current node */
        switch (node->node_type)
10013d58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013d5c:	e5d33000 	ldrb	r3, [r3]
10013d60:	e2433001 	sub	r3, r3, #1
10013d64:	e353001a 	cmp	r3, #26
10013d68:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10013d6c:	ea000d97 	b	100173d0 <finsh_compile+0x36b4>
10013d70:	10013ddc 	.word	0x10013ddc
10013d74:	10014674 	.word	0x10014674
10013d78:	100146dc 	.word	0x100146dc
10013d7c:	100146dc 	.word	0x100146dc
10013d80:	100147b4 	.word	0x100147b4
10013d84:	100147b4 	.word	0x100147b4
10013d88:	1001488c 	.word	0x1001488c
10013d8c:	1001495c 	.word	0x1001495c
10013d90:	10014a2c 	.word	0x10014a2c
10013d94:	10014afc 	.word	0x10014afc
10013d98:	10014bcc 	.word	0x10014bcc
10013d9c:	10014c9c 	.word	0x10014c9c
10013da0:	10014d6c 	.word	0x10014d6c
10013da4:	10014e3c 	.word	0x10014e3c
10013da8:	10014f0c 	.word	0x10014f0c
10013dac:	10014fdc 	.word	0x10014fdc
10013db0:	100150ac 	.word	0x100150ac
10013db4:	1001517c 	.word	0x1001517c
10013db8:	10015238 	.word	0x10015238
10013dbc:	100173d0 	.word	0x100173d0
10013dc0:	10015534 	.word	0x10015534
10013dc4:	10015b48 	.word	0x10015b48
10013dc8:	1001615c 	.word	0x1001615c
10013dcc:	100169ec 	.word	0x100169ec
10013dd0:	100172f8 	.word	0x100172f8
10013dd4:	100173dc 	.word	0x100173dc
10013dd8:	1001727c 	.word	0x1001727c
        {
        case FINSH_NODE_ID:
            {
                /* identifier::syscall */
                if (node->idtype & FINSH_IDTYPE_SYSCALL)
10013ddc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013de0:	e5d33002 	ldrb	r3, [r3, #2]
10013de4:	e2033004 	and	r3, r3, #4
10013de8:	e3530000 	cmp	r3, #0
10013dec:	0a000039 	beq	10013ed8 <finsh_compile+0x1bc>
                {
                    /* load address */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10013df0:	e30a3658 	movw	r3, #42584	; 0xa658
10013df4:	e3413002 	movt	r3, #4098	; 0x1002
10013df8:	e5933000 	ldr	r3, [r3]
10013dfc:	e3a02024 	mov	r2, #36	; 0x24
10013e00:	e5c32000 	strb	r2, [r3]
10013e04:	e30a3658 	movw	r3, #42584	; 0xa658
10013e08:	e3413002 	movt	r3, #4098	; 0x1002
10013e0c:	e5933000 	ldr	r3, [r3]
10013e10:	e2832001 	add	r2, r3, #1
10013e14:	e30a3658 	movw	r3, #42584	; 0xa658
10013e18:	e3413002 	movt	r3, #4098	; 0x1002
10013e1c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)node->id.syscall->func);
10013e20:	e30a3658 	movw	r3, #42584	; 0xa658
10013e24:	e3413002 	movt	r3, #4098	; 0x1002
10013e28:	e5933000 	ldr	r3, [r3]
10013e2c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10013e30:	e5922008 	ldr	r2, [r2, #8]
10013e34:	e5922008 	ldr	r2, [r2, #8]
10013e38:	e6ef2072 	uxtb	r2, r2
10013e3c:	e5c32000 	strb	r2, [r3]
10013e40:	e30a3658 	movw	r3, #42584	; 0xa658
10013e44:	e3413002 	movt	r3, #4098	; 0x1002
10013e48:	e5933000 	ldr	r3, [r3]
10013e4c:	e2833001 	add	r3, r3, #1
10013e50:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10013e54:	e5922008 	ldr	r2, [r2, #8]
10013e58:	e5922008 	ldr	r2, [r2, #8]
10013e5c:	e1a02422 	lsr	r2, r2, #8
10013e60:	e6ef2072 	uxtb	r2, r2
10013e64:	e5c32000 	strb	r2, [r3]
10013e68:	e30a3658 	movw	r3, #42584	; 0xa658
10013e6c:	e3413002 	movt	r3, #4098	; 0x1002
10013e70:	e5933000 	ldr	r3, [r3]
10013e74:	e2833002 	add	r3, r3, #2
10013e78:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10013e7c:	e5922008 	ldr	r2, [r2, #8]
10013e80:	e5922008 	ldr	r2, [r2, #8]
10013e84:	e1a02822 	lsr	r2, r2, #16
10013e88:	e6ef2072 	uxtb	r2, r2
10013e8c:	e5c32000 	strb	r2, [r3]
10013e90:	e30a3658 	movw	r3, #42584	; 0xa658
10013e94:	e3413002 	movt	r3, #4098	; 0x1002
10013e98:	e5933000 	ldr	r3, [r3]
10013e9c:	e2833003 	add	r3, r3, #3
10013ea0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10013ea4:	e5922008 	ldr	r2, [r2, #8]
10013ea8:	e5922008 	ldr	r2, [r2, #8]
10013eac:	e1a02c22 	lsr	r2, r2, #24
10013eb0:	e6ef2072 	uxtb	r2, r2
10013eb4:	e5c32000 	strb	r2, [r3]
10013eb8:	e30a3658 	movw	r3, #42584	; 0xa658
10013ebc:	e3413002 	movt	r3, #4098	; 0x1002
10013ec0:	e5933000 	ldr	r3, [r3]
10013ec4:	e2832004 	add	r2, r3, #4
10013ec8:	e30a3658 	movw	r3, #42584	; 0xa658
10013ecc:	e3413002 	movt	r3, #4098	; 0x1002
10013ed0:	e5832000 	str	r2, [r3]
10013ed4:	ea0001e5 	b	10014670 <finsh_compile+0x954>
                }
                /* identifier::sysvar */
                else if (node->idtype & FINSH_IDTYPE_SYSVAR)
10013ed8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013edc:	e5d33002 	ldrb	r3, [r3, #2]
10013ee0:	e2033002 	and	r3, r3, #2
10013ee4:	e3530000 	cmp	r3, #0
10013ee8:	0a0000f0 	beq	100142b0 <finsh_compile+0x594>
                {
                    struct finsh_sysvar* sysvar;

                    sysvar = node->id.sysvar;
10013eec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013ef0:	e5933008 	ldr	r3, [r3, #8]
10013ef4:	e50b3010 	str	r3, [fp, #-16]
                    if (sysvar != NULL)
10013ef8:	e51b3010 	ldr	r3, [fp, #-16]
10013efc:	e3530000 	cmp	r3, #0
10013f00:	0a0000e9 	beq	100142ac <finsh_compile+0x590>
                    {
                        switch (sysvar->type)
10013f04:	e51b3010 	ldr	r3, [fp, #-16]
10013f08:	e5d33008 	ldrb	r3, [r3, #8]
10013f0c:	e2433003 	sub	r3, r3, #3
10013f10:	e353000b 	cmp	r3, #11
10013f14:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10013f18:	ea0001d4 	b	10014670 <finsh_compile+0x954>
10013f1c:	10013f4c 	.word	0x10013f4c
10013f20:	10013f4c 	.word	0x10013f4c
10013f24:	1001418c 	.word	0x1001418c
10013f28:	1001406c 	.word	0x1001406c
10013f2c:	1001406c 	.word	0x1001406c
10013f30:	1001418c 	.word	0x1001418c
10013f34:	1001418c 	.word	0x1001418c
10013f38:	1001418c 	.word	0x1001418c
10013f3c:	1001418c 	.word	0x1001418c
10013f40:	1001418c 	.word	0x1001418c
10013f44:	1001418c 	.word	0x1001418c
10013f48:	1001418c 	.word	0x1001418c
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10013f4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10013f50:	e5d33002 	ldrb	r3, [r3, #2]
10013f54:	e2033008 	and	r3, r3, #8
10013f58:	e3530000 	cmp	r3, #0
10013f5c:	0a00000c 	beq	10013f94 <finsh_compile+0x278>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10013f60:	e30a3658 	movw	r3, #42584	; 0xa658
10013f64:	e3413002 	movt	r3, #4098	; 0x1002
10013f68:	e5933000 	ldr	r3, [r3]
10013f6c:	e3a02024 	mov	r2, #36	; 0x24
10013f70:	e5c32000 	strb	r2, [r3]
10013f74:	e30a3658 	movw	r3, #42584	; 0xa658
10013f78:	e3413002 	movt	r3, #4098	; 0x1002
10013f7c:	e5933000 	ldr	r3, [r3]
10013f80:	e2832001 	add	r2, r3, #1
10013f84:	e30a3658 	movw	r3, #42584	; 0xa658
10013f88:	e3413002 	movt	r3, #4098	; 0x1002
10013f8c:	e5832000 	str	r2, [r3]
10013f90:	ea00000b 	b	10013fc4 <finsh_compile+0x2a8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10013f94:	e30a3658 	movw	r3, #42584	; 0xa658
10013f98:	e3413002 	movt	r3, #4098	; 0x1002
10013f9c:	e5933000 	ldr	r3, [r3]
10013fa0:	e3a02025 	mov	r2, #37	; 0x25
10013fa4:	e5c32000 	strb	r2, [r3]
10013fa8:	e30a3658 	movw	r3, #42584	; 0xa658
10013fac:	e3413002 	movt	r3, #4098	; 0x1002
10013fb0:	e5933000 	ldr	r3, [r3]
10013fb4:	e2832001 	add	r2, r3, #1
10013fb8:	e30a3658 	movw	r3, #42584	; 0xa658
10013fbc:	e3413002 	movt	r3, #4098	; 0x1002
10013fc0:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
10013fc4:	e30a3658 	movw	r3, #42584	; 0xa658
10013fc8:	e3413002 	movt	r3, #4098	; 0x1002
10013fcc:	e5933000 	ldr	r3, [r3]
10013fd0:	e51b2010 	ldr	r2, [fp, #-16]
10013fd4:	e592200c 	ldr	r2, [r2, #12]
10013fd8:	e6ef2072 	uxtb	r2, r2
10013fdc:	e5c32000 	strb	r2, [r3]
10013fe0:	e30a3658 	movw	r3, #42584	; 0xa658
10013fe4:	e3413002 	movt	r3, #4098	; 0x1002
10013fe8:	e5933000 	ldr	r3, [r3]
10013fec:	e2833001 	add	r3, r3, #1
10013ff0:	e51b2010 	ldr	r2, [fp, #-16]
10013ff4:	e592200c 	ldr	r2, [r2, #12]
10013ff8:	e1a02422 	lsr	r2, r2, #8
10013ffc:	e6ef2072 	uxtb	r2, r2
10014000:	e5c32000 	strb	r2, [r3]
10014004:	e30a3658 	movw	r3, #42584	; 0xa658
10014008:	e3413002 	movt	r3, #4098	; 0x1002
1001400c:	e5933000 	ldr	r3, [r3]
10014010:	e2833002 	add	r3, r3, #2
10014014:	e51b2010 	ldr	r2, [fp, #-16]
10014018:	e592200c 	ldr	r2, [r2, #12]
1001401c:	e1a02822 	lsr	r2, r2, #16
10014020:	e6ef2072 	uxtb	r2, r2
10014024:	e5c32000 	strb	r2, [r3]
10014028:	e30a3658 	movw	r3, #42584	; 0xa658
1001402c:	e3413002 	movt	r3, #4098	; 0x1002
10014030:	e5933000 	ldr	r3, [r3]
10014034:	e2833003 	add	r3, r3, #3
10014038:	e51b2010 	ldr	r2, [fp, #-16]
1001403c:	e592200c 	ldr	r2, [r2, #12]
10014040:	e1a02c22 	lsr	r2, r2, #24
10014044:	e6ef2072 	uxtb	r2, r2
10014048:	e5c32000 	strb	r2, [r3]
1001404c:	e30a3658 	movw	r3, #42584	; 0xa658
10014050:	e3413002 	movt	r3, #4098	; 0x1002
10014054:	e5933000 	ldr	r3, [r3]
10014058:	e2832004 	add	r2, r3, #4
1001405c:	e30a3658 	movw	r3, #42584	; 0xa658
10014060:	e3413002 	movt	r3, #4098	; 0x1002
10014064:	e5832000 	str	r2, [r3]
                            break;
10014068:	ea00008f 	b	100142ac <finsh_compile+0x590>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
1001406c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014070:	e5d33002 	ldrb	r3, [r3, #2]
10014074:	e2033008 	and	r3, r3, #8
10014078:	e3530000 	cmp	r3, #0
1001407c:	0a00000c 	beq	100140b4 <finsh_compile+0x398>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10014080:	e30a3658 	movw	r3, #42584	; 0xa658
10014084:	e3413002 	movt	r3, #4098	; 0x1002
10014088:	e5933000 	ldr	r3, [r3]
1001408c:	e3a02024 	mov	r2, #36	; 0x24
10014090:	e5c32000 	strb	r2, [r3]
10014094:	e30a3658 	movw	r3, #42584	; 0xa658
10014098:	e3413002 	movt	r3, #4098	; 0x1002
1001409c:	e5933000 	ldr	r3, [r3]
100140a0:	e2832001 	add	r2, r3, #1
100140a4:	e30a3658 	movw	r3, #42584	; 0xa658
100140a8:	e3413002 	movt	r3, #4098	; 0x1002
100140ac:	e5832000 	str	r2, [r3]
100140b0:	ea00000b 	b	100140e4 <finsh_compile+0x3c8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
100140b4:	e30a3658 	movw	r3, #42584	; 0xa658
100140b8:	e3413002 	movt	r3, #4098	; 0x1002
100140bc:	e5933000 	ldr	r3, [r3]
100140c0:	e3a02026 	mov	r2, #38	; 0x26
100140c4:	e5c32000 	strb	r2, [r3]
100140c8:	e30a3658 	movw	r3, #42584	; 0xa658
100140cc:	e3413002 	movt	r3, #4098	; 0x1002
100140d0:	e5933000 	ldr	r3, [r3]
100140d4:	e2832001 	add	r2, r3, #1
100140d8:	e30a3658 	movw	r3, #42584	; 0xa658
100140dc:	e3413002 	movt	r3, #4098	; 0x1002
100140e0:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
100140e4:	e30a3658 	movw	r3, #42584	; 0xa658
100140e8:	e3413002 	movt	r3, #4098	; 0x1002
100140ec:	e5933000 	ldr	r3, [r3]
100140f0:	e51b2010 	ldr	r2, [fp, #-16]
100140f4:	e592200c 	ldr	r2, [r2, #12]
100140f8:	e6ef2072 	uxtb	r2, r2
100140fc:	e5c32000 	strb	r2, [r3]
10014100:	e30a3658 	movw	r3, #42584	; 0xa658
10014104:	e3413002 	movt	r3, #4098	; 0x1002
10014108:	e5933000 	ldr	r3, [r3]
1001410c:	e2833001 	add	r3, r3, #1
10014110:	e51b2010 	ldr	r2, [fp, #-16]
10014114:	e592200c 	ldr	r2, [r2, #12]
10014118:	e1a02422 	lsr	r2, r2, #8
1001411c:	e6ef2072 	uxtb	r2, r2
10014120:	e5c32000 	strb	r2, [r3]
10014124:	e30a3658 	movw	r3, #42584	; 0xa658
10014128:	e3413002 	movt	r3, #4098	; 0x1002
1001412c:	e5933000 	ldr	r3, [r3]
10014130:	e2833002 	add	r3, r3, #2
10014134:	e51b2010 	ldr	r2, [fp, #-16]
10014138:	e592200c 	ldr	r2, [r2, #12]
1001413c:	e1a02822 	lsr	r2, r2, #16
10014140:	e6ef2072 	uxtb	r2, r2
10014144:	e5c32000 	strb	r2, [r3]
10014148:	e30a3658 	movw	r3, #42584	; 0xa658
1001414c:	e3413002 	movt	r3, #4098	; 0x1002
10014150:	e5933000 	ldr	r3, [r3]
10014154:	e2833003 	add	r3, r3, #3
10014158:	e51b2010 	ldr	r2, [fp, #-16]
1001415c:	e592200c 	ldr	r2, [r2, #12]
10014160:	e1a02c22 	lsr	r2, r2, #24
10014164:	e6ef2072 	uxtb	r2, r2
10014168:	e5c32000 	strb	r2, [r3]
1001416c:	e30a3658 	movw	r3, #42584	; 0xa658
10014170:	e3413002 	movt	r3, #4098	; 0x1002
10014174:	e5933000 	ldr	r3, [r3]
10014178:	e2832004 	add	r2, r3, #4
1001417c:	e30a3658 	movw	r3, #42584	; 0xa658
10014180:	e3413002 	movt	r3, #4098	; 0x1002
10014184:	e5832000 	str	r2, [r3]
                            break;
10014188:	ea000047 	b	100142ac <finsh_compile+0x590>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
1001418c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014190:	e5d33002 	ldrb	r3, [r3, #2]
10014194:	e2033008 	and	r3, r3, #8
10014198:	e3530000 	cmp	r3, #0
1001419c:	0a00000c 	beq	100141d4 <finsh_compile+0x4b8>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
100141a0:	e30a3658 	movw	r3, #42584	; 0xa658
100141a4:	e3413002 	movt	r3, #4098	; 0x1002
100141a8:	e5933000 	ldr	r3, [r3]
100141ac:	e3a02024 	mov	r2, #36	; 0x24
100141b0:	e5c32000 	strb	r2, [r3]
100141b4:	e30a3658 	movw	r3, #42584	; 0xa658
100141b8:	e3413002 	movt	r3, #4098	; 0x1002
100141bc:	e5933000 	ldr	r3, [r3]
100141c0:	e2832001 	add	r2, r3, #1
100141c4:	e30a3658 	movw	r3, #42584	; 0xa658
100141c8:	e3413002 	movt	r3, #4098	; 0x1002
100141cc:	e5832000 	str	r2, [r3]
100141d0:	ea00000b 	b	10014204 <finsh_compile+0x4e8>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
100141d4:	e30a3658 	movw	r3, #42584	; 0xa658
100141d8:	e3413002 	movt	r3, #4098	; 0x1002
100141dc:	e5933000 	ldr	r3, [r3]
100141e0:	e3a02027 	mov	r2, #39	; 0x27
100141e4:	e5c32000 	strb	r2, [r3]
100141e8:	e30a3658 	movw	r3, #42584	; 0xa658
100141ec:	e3413002 	movt	r3, #4098	; 0x1002
100141f0:	e5933000 	ldr	r3, [r3]
100141f4:	e2832001 	add	r2, r3, #1
100141f8:	e30a3658 	movw	r3, #42584	; 0xa658
100141fc:	e3413002 	movt	r3, #4098	; 0x1002
10014200:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)(sysvar->var));
10014204:	e30a3658 	movw	r3, #42584	; 0xa658
10014208:	e3413002 	movt	r3, #4098	; 0x1002
1001420c:	e5933000 	ldr	r3, [r3]
10014210:	e51b2010 	ldr	r2, [fp, #-16]
10014214:	e592200c 	ldr	r2, [r2, #12]
10014218:	e6ef2072 	uxtb	r2, r2
1001421c:	e5c32000 	strb	r2, [r3]
10014220:	e30a3658 	movw	r3, #42584	; 0xa658
10014224:	e3413002 	movt	r3, #4098	; 0x1002
10014228:	e5933000 	ldr	r3, [r3]
1001422c:	e2833001 	add	r3, r3, #1
10014230:	e51b2010 	ldr	r2, [fp, #-16]
10014234:	e592200c 	ldr	r2, [r2, #12]
10014238:	e1a02422 	lsr	r2, r2, #8
1001423c:	e6ef2072 	uxtb	r2, r2
10014240:	e5c32000 	strb	r2, [r3]
10014244:	e30a3658 	movw	r3, #42584	; 0xa658
10014248:	e3413002 	movt	r3, #4098	; 0x1002
1001424c:	e5933000 	ldr	r3, [r3]
10014250:	e2833002 	add	r3, r3, #2
10014254:	e51b2010 	ldr	r2, [fp, #-16]
10014258:	e592200c 	ldr	r2, [r2, #12]
1001425c:	e1a02822 	lsr	r2, r2, #16
10014260:	e6ef2072 	uxtb	r2, r2
10014264:	e5c32000 	strb	r2, [r3]
10014268:	e30a3658 	movw	r3, #42584	; 0xa658
1001426c:	e3413002 	movt	r3, #4098	; 0x1002
10014270:	e5933000 	ldr	r3, [r3]
10014274:	e2833003 	add	r3, r3, #3
10014278:	e51b2010 	ldr	r2, [fp, #-16]
1001427c:	e592200c 	ldr	r2, [r2, #12]
10014280:	e1a02c22 	lsr	r2, r2, #24
10014284:	e6ef2072 	uxtb	r2, r2
10014288:	e5c32000 	strb	r2, [r3]
1001428c:	e30a3658 	movw	r3, #42584	; 0xa658
10014290:	e3413002 	movt	r3, #4098	; 0x1002
10014294:	e5933000 	ldr	r3, [r3]
10014298:	e2832004 	add	r2, r3, #4
1001429c:	e30a3658 	movw	r3, #42584	; 0xa658
100142a0:	e3413002 	movt	r3, #4098	; 0x1002
100142a4:	e5832000 	str	r2, [r3]
                            break;
100142a8:	e1a00000 	nop			; (mov r0, r0)
100142ac:	ea0000ef 	b	10014670 <finsh_compile+0x954>
                /* identifier::var */
                else
                {
                    struct finsh_var* var;

                    var = node->id.var;
100142b0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100142b4:	e5933008 	ldr	r3, [r3, #8]
100142b8:	e50b3014 	str	r3, [fp, #-20]
                    if (var != NULL)
100142bc:	e51b3014 	ldr	r3, [fp, #-20]
100142c0:	e3530000 	cmp	r3, #0
100142c4:	0a0000e9 	beq	10014670 <finsh_compile+0x954>
                    {
                        switch (var->type)
100142c8:	e51b3014 	ldr	r3, [fp, #-20]
100142cc:	e5d33011 	ldrb	r3, [r3, #17]
100142d0:	e2433003 	sub	r3, r3, #3
100142d4:	e353000b 	cmp	r3, #11
100142d8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
100142dc:	ea000c40 	b	100173e4 <finsh_compile+0x36c8>
100142e0:	10014310 	.word	0x10014310
100142e4:	10014310 	.word	0x10014310
100142e8:	10014550 	.word	0x10014550
100142ec:	10014430 	.word	0x10014430
100142f0:	10014430 	.word	0x10014430
100142f4:	10014550 	.word	0x10014550
100142f8:	10014550 	.word	0x10014550
100142fc:	10014550 	.word	0x10014550
10014300:	10014550 	.word	0x10014550
10014304:	10014550 	.word	0x10014550
10014308:	10014550 	.word	0x10014550
1001430c:	10014550 	.word	0x10014550
                        {
                        case finsh_type_char:
                        case finsh_type_uchar:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10014310:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014314:	e5d33002 	ldrb	r3, [r3, #2]
10014318:	e2033008 	and	r3, r3, #8
1001431c:	e3530000 	cmp	r3, #0
10014320:	0a00000c 	beq	10014358 <finsh_compile+0x63c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10014324:	e30a3658 	movw	r3, #42584	; 0xa658
10014328:	e3413002 	movt	r3, #4098	; 0x1002
1001432c:	e5933000 	ldr	r3, [r3]
10014330:	e3a02024 	mov	r2, #36	; 0x24
10014334:	e5c32000 	strb	r2, [r3]
10014338:	e30a3658 	movw	r3, #42584	; 0xa658
1001433c:	e3413002 	movt	r3, #4098	; 0x1002
10014340:	e5933000 	ldr	r3, [r3]
10014344:	e2832001 	add	r2, r3, #1
10014348:	e30a3658 	movw	r3, #42584	; 0xa658
1001434c:	e3413002 	movt	r3, #4098	; 0x1002
10014350:	e5832000 	str	r2, [r3]
10014354:	ea00000b 	b	10014388 <finsh_compile+0x66c>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10014358:	e30a3658 	movw	r3, #42584	; 0xa658
1001435c:	e3413002 	movt	r3, #4098	; 0x1002
10014360:	e5933000 	ldr	r3, [r3]
10014364:	e3a02025 	mov	r2, #37	; 0x25
10014368:	e5c32000 	strb	r2, [r3]
1001436c:	e30a3658 	movw	r3, #42584	; 0xa658
10014370:	e3413002 	movt	r3, #4098	; 0x1002
10014374:	e5933000 	ldr	r3, [r3]
10014378:	e2832001 	add	r2, r3, #1
1001437c:	e30a3658 	movw	r3, #42584	; 0xa658
10014380:	e3413002 	movt	r3, #4098	; 0x1002
10014384:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.char_value));
10014388:	e30a3658 	movw	r3, #42584	; 0xa658
1001438c:	e3413002 	movt	r3, #4098	; 0x1002
10014390:	e5933000 	ldr	r3, [r3]
10014394:	e51b2014 	ldr	r2, [fp, #-20]
10014398:	e2822014 	add	r2, r2, #20
1001439c:	e6ef2072 	uxtb	r2, r2
100143a0:	e5c32000 	strb	r2, [r3]
100143a4:	e30a3658 	movw	r3, #42584	; 0xa658
100143a8:	e3413002 	movt	r3, #4098	; 0x1002
100143ac:	e5933000 	ldr	r3, [r3]
100143b0:	e2833001 	add	r3, r3, #1
100143b4:	e51b2014 	ldr	r2, [fp, #-20]
100143b8:	e2822014 	add	r2, r2, #20
100143bc:	e1a02422 	lsr	r2, r2, #8
100143c0:	e6ef2072 	uxtb	r2, r2
100143c4:	e5c32000 	strb	r2, [r3]
100143c8:	e30a3658 	movw	r3, #42584	; 0xa658
100143cc:	e3413002 	movt	r3, #4098	; 0x1002
100143d0:	e5933000 	ldr	r3, [r3]
100143d4:	e2833002 	add	r3, r3, #2
100143d8:	e51b2014 	ldr	r2, [fp, #-20]
100143dc:	e2822014 	add	r2, r2, #20
100143e0:	e1a02822 	lsr	r2, r2, #16
100143e4:	e6ef2072 	uxtb	r2, r2
100143e8:	e5c32000 	strb	r2, [r3]
100143ec:	e30a3658 	movw	r3, #42584	; 0xa658
100143f0:	e3413002 	movt	r3, #4098	; 0x1002
100143f4:	e5933000 	ldr	r3, [r3]
100143f8:	e2833003 	add	r3, r3, #3
100143fc:	e51b2014 	ldr	r2, [fp, #-20]
10014400:	e2822014 	add	r2, r2, #20
10014404:	e1a02c22 	lsr	r2, r2, #24
10014408:	e6ef2072 	uxtb	r2, r2
1001440c:	e5c32000 	strb	r2, [r3]
10014410:	e30a3658 	movw	r3, #42584	; 0xa658
10014414:	e3413002 	movt	r3, #4098	; 0x1002
10014418:	e5933000 	ldr	r3, [r3]
1001441c:	e2832004 	add	r2, r3, #4
10014420:	e30a3658 	movw	r3, #42584	; 0xa658
10014424:	e3413002 	movt	r3, #4098	; 0x1002
10014428:	e5832000 	str	r2, [r3]
                            break;
1001442c:	ea00008f 	b	10014670 <finsh_compile+0x954>

                        case finsh_type_short:
                        case finsh_type_ushort:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10014430:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014434:	e5d33002 	ldrb	r3, [r3, #2]
10014438:	e2033008 	and	r3, r3, #8
1001443c:	e3530000 	cmp	r3, #0
10014440:	0a00000c 	beq	10014478 <finsh_compile+0x75c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10014444:	e30a3658 	movw	r3, #42584	; 0xa658
10014448:	e3413002 	movt	r3, #4098	; 0x1002
1001444c:	e5933000 	ldr	r3, [r3]
10014450:	e3a02024 	mov	r2, #36	; 0x24
10014454:	e5c32000 	strb	r2, [r3]
10014458:	e30a3658 	movw	r3, #42584	; 0xa658
1001445c:	e3413002 	movt	r3, #4098	; 0x1002
10014460:	e5933000 	ldr	r3, [r3]
10014464:	e2832001 	add	r2, r3, #1
10014468:	e30a3658 	movw	r3, #42584	; 0xa658
1001446c:	e3413002 	movt	r3, #4098	; 0x1002
10014470:	e5832000 	str	r2, [r3]
10014474:	ea00000b 	b	100144a8 <finsh_compile+0x78c>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10014478:	e30a3658 	movw	r3, #42584	; 0xa658
1001447c:	e3413002 	movt	r3, #4098	; 0x1002
10014480:	e5933000 	ldr	r3, [r3]
10014484:	e3a02026 	mov	r2, #38	; 0x26
10014488:	e5c32000 	strb	r2, [r3]
1001448c:	e30a3658 	movw	r3, #42584	; 0xa658
10014490:	e3413002 	movt	r3, #4098	; 0x1002
10014494:	e5933000 	ldr	r3, [r3]
10014498:	e2832001 	add	r2, r3, #1
1001449c:	e30a3658 	movw	r3, #42584	; 0xa658
100144a0:	e3413002 	movt	r3, #4098	; 0x1002
100144a4:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.short_value));
100144a8:	e30a3658 	movw	r3, #42584	; 0xa658
100144ac:	e3413002 	movt	r3, #4098	; 0x1002
100144b0:	e5933000 	ldr	r3, [r3]
100144b4:	e51b2014 	ldr	r2, [fp, #-20]
100144b8:	e2822014 	add	r2, r2, #20
100144bc:	e6ef2072 	uxtb	r2, r2
100144c0:	e5c32000 	strb	r2, [r3]
100144c4:	e30a3658 	movw	r3, #42584	; 0xa658
100144c8:	e3413002 	movt	r3, #4098	; 0x1002
100144cc:	e5933000 	ldr	r3, [r3]
100144d0:	e2833001 	add	r3, r3, #1
100144d4:	e51b2014 	ldr	r2, [fp, #-20]
100144d8:	e2822014 	add	r2, r2, #20
100144dc:	e1a02422 	lsr	r2, r2, #8
100144e0:	e6ef2072 	uxtb	r2, r2
100144e4:	e5c32000 	strb	r2, [r3]
100144e8:	e30a3658 	movw	r3, #42584	; 0xa658
100144ec:	e3413002 	movt	r3, #4098	; 0x1002
100144f0:	e5933000 	ldr	r3, [r3]
100144f4:	e2833002 	add	r3, r3, #2
100144f8:	e51b2014 	ldr	r2, [fp, #-20]
100144fc:	e2822014 	add	r2, r2, #20
10014500:	e1a02822 	lsr	r2, r2, #16
10014504:	e6ef2072 	uxtb	r2, r2
10014508:	e5c32000 	strb	r2, [r3]
1001450c:	e30a3658 	movw	r3, #42584	; 0xa658
10014510:	e3413002 	movt	r3, #4098	; 0x1002
10014514:	e5933000 	ldr	r3, [r3]
10014518:	e2833003 	add	r3, r3, #3
1001451c:	e51b2014 	ldr	r2, [fp, #-20]
10014520:	e2822014 	add	r2, r2, #20
10014524:	e1a02c22 	lsr	r2, r2, #24
10014528:	e6ef2072 	uxtb	r2, r2
1001452c:	e5c32000 	strb	r2, [r3]
10014530:	e30a3658 	movw	r3, #42584	; 0xa658
10014534:	e3413002 	movt	r3, #4098	; 0x1002
10014538:	e5933000 	ldr	r3, [r3]
1001453c:	e2832004 	add	r2, r3, #4
10014540:	e30a3658 	movw	r3, #42584	; 0xa658
10014544:	e3413002 	movt	r3, #4098	; 0x1002
10014548:	e5832000 	str	r2, [r3]
                            break;
1001454c:	ea000047 	b	10014670 <finsh_compile+0x954>
                        case finsh_type_ulong:
                        case finsh_type_charp:
                        case finsh_type_shortp:
                        case finsh_type_intp:
                        case finsh_type_longp:
                            if (node->idtype & FINSH_IDTYPE_ADDRESS)
10014550:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014554:	e5d33002 	ldrb	r3, [r3, #2]
10014558:	e2033008 	and	r3, r3, #8
1001455c:	e3530000 	cmp	r3, #0
10014560:	0a00000c 	beq	10014598 <finsh_compile+0x87c>
                            {
                                /* load address */
                                finsh_code_byte(FINSH_OP_LD_DWORD);
10014564:	e30a3658 	movw	r3, #42584	; 0xa658
10014568:	e3413002 	movt	r3, #4098	; 0x1002
1001456c:	e5933000 	ldr	r3, [r3]
10014570:	e3a02024 	mov	r2, #36	; 0x24
10014574:	e5c32000 	strb	r2, [r3]
10014578:	e30a3658 	movw	r3, #42584	; 0xa658
1001457c:	e3413002 	movt	r3, #4098	; 0x1002
10014580:	e5933000 	ldr	r3, [r3]
10014584:	e2832001 	add	r2, r3, #1
10014588:	e30a3658 	movw	r3, #42584	; 0xa658
1001458c:	e3413002 	movt	r3, #4098	; 0x1002
10014590:	e5832000 	str	r2, [r3]
10014594:	ea00000b 	b	100145c8 <finsh_compile+0x8ac>
                            }
                            else
                            {
                                /* load value */
                                finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10014598:	e30a3658 	movw	r3, #42584	; 0xa658
1001459c:	e3413002 	movt	r3, #4098	; 0x1002
100145a0:	e5933000 	ldr	r3, [r3]
100145a4:	e3a02027 	mov	r2, #39	; 0x27
100145a8:	e5c32000 	strb	r2, [r3]
100145ac:	e30a3658 	movw	r3, #42584	; 0xa658
100145b0:	e3413002 	movt	r3, #4098	; 0x1002
100145b4:	e5933000 	ldr	r3, [r3]
100145b8:	e2832001 	add	r2, r3, #1
100145bc:	e30a3658 	movw	r3, #42584	; 0xa658
100145c0:	e3413002 	movt	r3, #4098	; 0x1002
100145c4:	e5832000 	str	r2, [r3]
                            }

                            finsh_code_dword((long)&(var->value.long_value));
100145c8:	e30a3658 	movw	r3, #42584	; 0xa658
100145cc:	e3413002 	movt	r3, #4098	; 0x1002
100145d0:	e5933000 	ldr	r3, [r3]
100145d4:	e51b2014 	ldr	r2, [fp, #-20]
100145d8:	e2822014 	add	r2, r2, #20
100145dc:	e6ef2072 	uxtb	r2, r2
100145e0:	e5c32000 	strb	r2, [r3]
100145e4:	e30a3658 	movw	r3, #42584	; 0xa658
100145e8:	e3413002 	movt	r3, #4098	; 0x1002
100145ec:	e5933000 	ldr	r3, [r3]
100145f0:	e2833001 	add	r3, r3, #1
100145f4:	e51b2014 	ldr	r2, [fp, #-20]
100145f8:	e2822014 	add	r2, r2, #20
100145fc:	e1a02422 	lsr	r2, r2, #8
10014600:	e6ef2072 	uxtb	r2, r2
10014604:	e5c32000 	strb	r2, [r3]
10014608:	e30a3658 	movw	r3, #42584	; 0xa658
1001460c:	e3413002 	movt	r3, #4098	; 0x1002
10014610:	e5933000 	ldr	r3, [r3]
10014614:	e2833002 	add	r3, r3, #2
10014618:	e51b2014 	ldr	r2, [fp, #-20]
1001461c:	e2822014 	add	r2, r2, #20
10014620:	e1a02822 	lsr	r2, r2, #16
10014624:	e6ef2072 	uxtb	r2, r2
10014628:	e5c32000 	strb	r2, [r3]
1001462c:	e30a3658 	movw	r3, #42584	; 0xa658
10014630:	e3413002 	movt	r3, #4098	; 0x1002
10014634:	e5933000 	ldr	r3, [r3]
10014638:	e2833003 	add	r3, r3, #3
1001463c:	e51b2014 	ldr	r2, [fp, #-20]
10014640:	e2822014 	add	r2, r2, #20
10014644:	e1a02c22 	lsr	r2, r2, #24
10014648:	e6ef2072 	uxtb	r2, r2
1001464c:	e5c32000 	strb	r2, [r3]
10014650:	e30a3658 	movw	r3, #42584	; 0xa658
10014654:	e3413002 	movt	r3, #4098	; 0x1002
10014658:	e5933000 	ldr	r3, [r3]
1001465c:	e2832004 	add	r2, r3, #4
10014660:	e30a3658 	movw	r3, #42584	; 0xa658
10014664:	e3413002 	movt	r3, #4098	; 0x1002
10014668:	e5832000 	str	r2, [r3]
                            break;
1001466c:	e1a00000 	nop			; (mov r0, r0)
                        }
                    }
                }
            }
            break;
10014670:	ea000b5b 	b	100173e4 <finsh_compile+0x36c8>

        /* load const */
        case FINSH_NODE_VALUE_CHAR:
            finsh_code_byte(FINSH_OP_LD_BYTE);
10014674:	e30a3658 	movw	r3, #42584	; 0xa658
10014678:	e3413002 	movt	r3, #4098	; 0x1002
1001467c:	e5933000 	ldr	r3, [r3]
10014680:	e3a02022 	mov	r2, #34	; 0x22
10014684:	e5c32000 	strb	r2, [r3]
10014688:	e30a3658 	movw	r3, #42584	; 0xa658
1001468c:	e3413002 	movt	r3, #4098	; 0x1002
10014690:	e5933000 	ldr	r3, [r3]
10014694:	e2832001 	add	r2, r3, #1
10014698:	e30a3658 	movw	r3, #42584	; 0xa658
1001469c:	e3413002 	movt	r3, #4098	; 0x1002
100146a0:	e5832000 	str	r2, [r3]
            finsh_code_byte(node->value.char_value);
100146a4:	e30a3658 	movw	r3, #42584	; 0xa658
100146a8:	e3413002 	movt	r3, #4098	; 0x1002
100146ac:	e5933000 	ldr	r3, [r3]
100146b0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100146b4:	e5d22004 	ldrb	r2, [r2, #4]
100146b8:	e5c32000 	strb	r2, [r3]
100146bc:	e30a3658 	movw	r3, #42584	; 0xa658
100146c0:	e3413002 	movt	r3, #4098	; 0x1002
100146c4:	e5933000 	ldr	r3, [r3]
100146c8:	e2832001 	add	r2, r3, #1
100146cc:	e30a3658 	movw	r3, #42584	; 0xa658
100146d0:	e3413002 	movt	r3, #4098	; 0x1002
100146d4:	e5832000 	str	r2, [r3]
            break;
100146d8:	ea000b42 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_VALUE_INT:
        case FINSH_NODE_VALUE_LONG:
            finsh_code_byte(FINSH_OP_LD_DWORD);
100146dc:	e30a3658 	movw	r3, #42584	; 0xa658
100146e0:	e3413002 	movt	r3, #4098	; 0x1002
100146e4:	e5933000 	ldr	r3, [r3]
100146e8:	e3a02024 	mov	r2, #36	; 0x24
100146ec:	e5c32000 	strb	r2, [r3]
100146f0:	e30a3658 	movw	r3, #42584	; 0xa658
100146f4:	e3413002 	movt	r3, #4098	; 0x1002
100146f8:	e5933000 	ldr	r3, [r3]
100146fc:	e2832001 	add	r2, r3, #1
10014700:	e30a3658 	movw	r3, #42584	; 0xa658
10014704:	e3413002 	movt	r3, #4098	; 0x1002
10014708:	e5832000 	str	r2, [r3]
            finsh_code_dword(node->value.long_value);
1001470c:	e30a3658 	movw	r3, #42584	; 0xa658
10014710:	e3413002 	movt	r3, #4098	; 0x1002
10014714:	e5933000 	ldr	r3, [r3]
10014718:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001471c:	e5922004 	ldr	r2, [r2, #4]
10014720:	e6ef2072 	uxtb	r2, r2
10014724:	e5c32000 	strb	r2, [r3]
10014728:	e30a3658 	movw	r3, #42584	; 0xa658
1001472c:	e3413002 	movt	r3, #4098	; 0x1002
10014730:	e5933000 	ldr	r3, [r3]
10014734:	e2833001 	add	r3, r3, #1
10014738:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001473c:	e5922004 	ldr	r2, [r2, #4]
10014740:	e1a02422 	lsr	r2, r2, #8
10014744:	e6ef2072 	uxtb	r2, r2
10014748:	e5c32000 	strb	r2, [r3]
1001474c:	e30a3658 	movw	r3, #42584	; 0xa658
10014750:	e3413002 	movt	r3, #4098	; 0x1002
10014754:	e5933000 	ldr	r3, [r3]
10014758:	e2833002 	add	r3, r3, #2
1001475c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10014760:	e5922004 	ldr	r2, [r2, #4]
10014764:	e1a02822 	lsr	r2, r2, #16
10014768:	e6ef2072 	uxtb	r2, r2
1001476c:	e5c32000 	strb	r2, [r3]
10014770:	e30a3658 	movw	r3, #42584	; 0xa658
10014774:	e3413002 	movt	r3, #4098	; 0x1002
10014778:	e5933000 	ldr	r3, [r3]
1001477c:	e2833003 	add	r3, r3, #3
10014780:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10014784:	e5922004 	ldr	r2, [r2, #4]
10014788:	e1a02c22 	lsr	r2, r2, #24
1001478c:	e6ef2072 	uxtb	r2, r2
10014790:	e5c32000 	strb	r2, [r3]
10014794:	e30a3658 	movw	r3, #42584	; 0xa658
10014798:	e3413002 	movt	r3, #4098	; 0x1002
1001479c:	e5933000 	ldr	r3, [r3]
100147a0:	e2832004 	add	r2, r3, #4
100147a4:	e30a3658 	movw	r3, #42584	; 0xa658
100147a8:	e3413002 	movt	r3, #4098	; 0x1002
100147ac:	e5832000 	str	r2, [r3]
            break;
100147b0:	ea000b0c 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_VALUE_NULL:
        case FINSH_NODE_VALUE_STRING:
            finsh_code_byte(FINSH_OP_LD_DWORD);
100147b4:	e30a3658 	movw	r3, #42584	; 0xa658
100147b8:	e3413002 	movt	r3, #4098	; 0x1002
100147bc:	e5933000 	ldr	r3, [r3]
100147c0:	e3a02024 	mov	r2, #36	; 0x24
100147c4:	e5c32000 	strb	r2, [r3]
100147c8:	e30a3658 	movw	r3, #42584	; 0xa658
100147cc:	e3413002 	movt	r3, #4098	; 0x1002
100147d0:	e5933000 	ldr	r3, [r3]
100147d4:	e2832001 	add	r2, r3, #1
100147d8:	e30a3658 	movw	r3, #42584	; 0xa658
100147dc:	e3413002 	movt	r3, #4098	; 0x1002
100147e0:	e5832000 	str	r2, [r3]
            finsh_code_dword((u_long)node->value.ptr);
100147e4:	e30a3658 	movw	r3, #42584	; 0xa658
100147e8:	e3413002 	movt	r3, #4098	; 0x1002
100147ec:	e5933000 	ldr	r3, [r3]
100147f0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
100147f4:	e5922004 	ldr	r2, [r2, #4]
100147f8:	e6ef2072 	uxtb	r2, r2
100147fc:	e5c32000 	strb	r2, [r3]
10014800:	e30a3658 	movw	r3, #42584	; 0xa658
10014804:	e3413002 	movt	r3, #4098	; 0x1002
10014808:	e5933000 	ldr	r3, [r3]
1001480c:	e2833001 	add	r3, r3, #1
10014810:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10014814:	e5922004 	ldr	r2, [r2, #4]
10014818:	e1a02422 	lsr	r2, r2, #8
1001481c:	e6ef2072 	uxtb	r2, r2
10014820:	e5c32000 	strb	r2, [r3]
10014824:	e30a3658 	movw	r3, #42584	; 0xa658
10014828:	e3413002 	movt	r3, #4098	; 0x1002
1001482c:	e5933000 	ldr	r3, [r3]
10014830:	e2833002 	add	r3, r3, #2
10014834:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10014838:	e5922004 	ldr	r2, [r2, #4]
1001483c:	e1a02822 	lsr	r2, r2, #16
10014840:	e6ef2072 	uxtb	r2, r2
10014844:	e5c32000 	strb	r2, [r3]
10014848:	e30a3658 	movw	r3, #42584	; 0xa658
1001484c:	e3413002 	movt	r3, #4098	; 0x1002
10014850:	e5933000 	ldr	r3, [r3]
10014854:	e2833003 	add	r3, r3, #3
10014858:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
1001485c:	e5922004 	ldr	r2, [r2, #4]
10014860:	e1a02c22 	lsr	r2, r2, #24
10014864:	e6ef2072 	uxtb	r2, r2
10014868:	e5c32000 	strb	r2, [r3]
1001486c:	e30a3658 	movw	r3, #42584	; 0xa658
10014870:	e3413002 	movt	r3, #4098	; 0x1002
10014874:	e5933000 	ldr	r3, [r3]
10014878:	e2832004 	add	r2, r3, #4
1001487c:	e30a3658 	movw	r3, #42584	; 0xa658
10014880:	e3413002 	movt	r3, #4098	; 0x1002
10014884:	e5832000 	str	r2, [r3]
            break;
10014888:	ea000ad6 	b	100173e8 <finsh_compile+0x36cc>

        /* arithmetic operation */
        case FINSH_NODE_SYS_ADD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_ADD_BYTE);
1001488c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014890:	e5d33001 	ldrb	r3, [r3, #1]
10014894:	e3530001 	cmp	r3, #1
10014898:	1a00000c 	bne	100148d0 <finsh_compile+0xbb4>
1001489c:	e30a3658 	movw	r3, #42584	; 0xa658
100148a0:	e3413002 	movt	r3, #4098	; 0x1002
100148a4:	e5933000 	ldr	r3, [r3]
100148a8:	e3a02001 	mov	r2, #1
100148ac:	e5c32000 	strb	r2, [r3]
100148b0:	e30a3658 	movw	r3, #42584	; 0xa658
100148b4:	e3413002 	movt	r3, #4098	; 0x1002
100148b8:	e5933000 	ldr	r3, [r3]
100148bc:	e2832001 	add	r2, r3, #1
100148c0:	e30a3658 	movw	r3, #42584	; 0xa658
100148c4:	e3413002 	movt	r3, #4098	; 0x1002
100148c8:	e5832000 	str	r2, [r3]
100148cc:	ea000021 	b	10014958 <finsh_compile+0xc3c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_ADD_WORD);
100148d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100148d4:	e5d33001 	ldrb	r3, [r3, #1]
100148d8:	e3530002 	cmp	r3, #2
100148dc:	1a00000c 	bne	10014914 <finsh_compile+0xbf8>
100148e0:	e30a3658 	movw	r3, #42584	; 0xa658
100148e4:	e3413002 	movt	r3, #4098	; 0x1002
100148e8:	e5933000 	ldr	r3, [r3]
100148ec:	e3a02002 	mov	r2, #2
100148f0:	e5c32000 	strb	r2, [r3]
100148f4:	e30a3658 	movw	r3, #42584	; 0xa658
100148f8:	e3413002 	movt	r3, #4098	; 0x1002
100148fc:	e5933000 	ldr	r3, [r3]
10014900:	e2832001 	add	r2, r3, #1
10014904:	e30a3658 	movw	r3, #42584	; 0xa658
10014908:	e3413002 	movt	r3, #4098	; 0x1002
1001490c:	e5832000 	str	r2, [r3]
10014910:	ea000010 	b	10014958 <finsh_compile+0xc3c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_ADD_DWORD);
10014914:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014918:	e5d33001 	ldrb	r3, [r3, #1]
1001491c:	e3530003 	cmp	r3, #3
10014920:	1a00000c 	bne	10014958 <finsh_compile+0xc3c>
10014924:	e30a3658 	movw	r3, #42584	; 0xa658
10014928:	e3413002 	movt	r3, #4098	; 0x1002
1001492c:	e5933000 	ldr	r3, [r3]
10014930:	e3a02003 	mov	r2, #3
10014934:	e5c32000 	strb	r2, [r3]
10014938:	e30a3658 	movw	r3, #42584	; 0xa658
1001493c:	e3413002 	movt	r3, #4098	; 0x1002
10014940:	e5933000 	ldr	r3, [r3]
10014944:	e2832001 	add	r2, r3, #1
10014948:	e30a3658 	movw	r3, #42584	; 0xa658
1001494c:	e3413002 	movt	r3, #4098	; 0x1002
10014950:	e5832000 	str	r2, [r3]
            break;
10014954:	ea000aa3 	b	100173e8 <finsh_compile+0x36cc>
10014958:	ea000aa2 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SUB:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SUB_BYTE);
1001495c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014960:	e5d33001 	ldrb	r3, [r3, #1]
10014964:	e3530001 	cmp	r3, #1
10014968:	1a00000c 	bne	100149a0 <finsh_compile+0xc84>
1001496c:	e30a3658 	movw	r3, #42584	; 0xa658
10014970:	e3413002 	movt	r3, #4098	; 0x1002
10014974:	e5933000 	ldr	r3, [r3]
10014978:	e3a02004 	mov	r2, #4
1001497c:	e5c32000 	strb	r2, [r3]
10014980:	e30a3658 	movw	r3, #42584	; 0xa658
10014984:	e3413002 	movt	r3, #4098	; 0x1002
10014988:	e5933000 	ldr	r3, [r3]
1001498c:	e2832001 	add	r2, r3, #1
10014990:	e30a3658 	movw	r3, #42584	; 0xa658
10014994:	e3413002 	movt	r3, #4098	; 0x1002
10014998:	e5832000 	str	r2, [r3]
1001499c:	ea000021 	b	10014a28 <finsh_compile+0xd0c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SUB_WORD);
100149a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100149a4:	e5d33001 	ldrb	r3, [r3, #1]
100149a8:	e3530002 	cmp	r3, #2
100149ac:	1a00000c 	bne	100149e4 <finsh_compile+0xcc8>
100149b0:	e30a3658 	movw	r3, #42584	; 0xa658
100149b4:	e3413002 	movt	r3, #4098	; 0x1002
100149b8:	e5933000 	ldr	r3, [r3]
100149bc:	e3a02005 	mov	r2, #5
100149c0:	e5c32000 	strb	r2, [r3]
100149c4:	e30a3658 	movw	r3, #42584	; 0xa658
100149c8:	e3413002 	movt	r3, #4098	; 0x1002
100149cc:	e5933000 	ldr	r3, [r3]
100149d0:	e2832001 	add	r2, r3, #1
100149d4:	e30a3658 	movw	r3, #42584	; 0xa658
100149d8:	e3413002 	movt	r3, #4098	; 0x1002
100149dc:	e5832000 	str	r2, [r3]
100149e0:	ea000010 	b	10014a28 <finsh_compile+0xd0c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SUB_DWORD);
100149e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100149e8:	e5d33001 	ldrb	r3, [r3, #1]
100149ec:	e3530003 	cmp	r3, #3
100149f0:	1a00000c 	bne	10014a28 <finsh_compile+0xd0c>
100149f4:	e30a3658 	movw	r3, #42584	; 0xa658
100149f8:	e3413002 	movt	r3, #4098	; 0x1002
100149fc:	e5933000 	ldr	r3, [r3]
10014a00:	e3a02006 	mov	r2, #6
10014a04:	e5c32000 	strb	r2, [r3]
10014a08:	e30a3658 	movw	r3, #42584	; 0xa658
10014a0c:	e3413002 	movt	r3, #4098	; 0x1002
10014a10:	e5933000 	ldr	r3, [r3]
10014a14:	e2832001 	add	r2, r3, #1
10014a18:	e30a3658 	movw	r3, #42584	; 0xa658
10014a1c:	e3413002 	movt	r3, #4098	; 0x1002
10014a20:	e5832000 	str	r2, [r3]
            break;
10014a24:	ea000a6f 	b	100173e8 <finsh_compile+0x36cc>
10014a28:	ea000a6e 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_MUL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MUL_BYTE);
10014a2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014a30:	e5d33001 	ldrb	r3, [r3, #1]
10014a34:	e3530001 	cmp	r3, #1
10014a38:	1a00000c 	bne	10014a70 <finsh_compile+0xd54>
10014a3c:	e30a3658 	movw	r3, #42584	; 0xa658
10014a40:	e3413002 	movt	r3, #4098	; 0x1002
10014a44:	e5933000 	ldr	r3, [r3]
10014a48:	e3a0200d 	mov	r2, #13
10014a4c:	e5c32000 	strb	r2, [r3]
10014a50:	e30a3658 	movw	r3, #42584	; 0xa658
10014a54:	e3413002 	movt	r3, #4098	; 0x1002
10014a58:	e5933000 	ldr	r3, [r3]
10014a5c:	e2832001 	add	r2, r3, #1
10014a60:	e30a3658 	movw	r3, #42584	; 0xa658
10014a64:	e3413002 	movt	r3, #4098	; 0x1002
10014a68:	e5832000 	str	r2, [r3]
10014a6c:	ea000021 	b	10014af8 <finsh_compile+0xddc>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MUL_WORD);
10014a70:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014a74:	e5d33001 	ldrb	r3, [r3, #1]
10014a78:	e3530002 	cmp	r3, #2
10014a7c:	1a00000c 	bne	10014ab4 <finsh_compile+0xd98>
10014a80:	e30a3658 	movw	r3, #42584	; 0xa658
10014a84:	e3413002 	movt	r3, #4098	; 0x1002
10014a88:	e5933000 	ldr	r3, [r3]
10014a8c:	e3a0200e 	mov	r2, #14
10014a90:	e5c32000 	strb	r2, [r3]
10014a94:	e30a3658 	movw	r3, #42584	; 0xa658
10014a98:	e3413002 	movt	r3, #4098	; 0x1002
10014a9c:	e5933000 	ldr	r3, [r3]
10014aa0:	e2832001 	add	r2, r3, #1
10014aa4:	e30a3658 	movw	r3, #42584	; 0xa658
10014aa8:	e3413002 	movt	r3, #4098	; 0x1002
10014aac:	e5832000 	str	r2, [r3]
10014ab0:	ea000010 	b	10014af8 <finsh_compile+0xddc>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MUL_DWORD);
10014ab4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014ab8:	e5d33001 	ldrb	r3, [r3, #1]
10014abc:	e3530003 	cmp	r3, #3
10014ac0:	1a00000c 	bne	10014af8 <finsh_compile+0xddc>
10014ac4:	e30a3658 	movw	r3, #42584	; 0xa658
10014ac8:	e3413002 	movt	r3, #4098	; 0x1002
10014acc:	e5933000 	ldr	r3, [r3]
10014ad0:	e3a0200f 	mov	r2, #15
10014ad4:	e5c32000 	strb	r2, [r3]
10014ad8:	e30a3658 	movw	r3, #42584	; 0xa658
10014adc:	e3413002 	movt	r3, #4098	; 0x1002
10014ae0:	e5933000 	ldr	r3, [r3]
10014ae4:	e2832001 	add	r2, r3, #1
10014ae8:	e30a3658 	movw	r3, #42584	; 0xa658
10014aec:	e3413002 	movt	r3, #4098	; 0x1002
10014af0:	e5832000 	str	r2, [r3]
            break;
10014af4:	ea000a3b 	b	100173e8 <finsh_compile+0x36cc>
10014af8:	ea000a3a 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_DIV:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_DIV_BYTE);
10014afc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014b00:	e5d33001 	ldrb	r3, [r3, #1]
10014b04:	e3530001 	cmp	r3, #1
10014b08:	1a00000c 	bne	10014b40 <finsh_compile+0xe24>
10014b0c:	e30a3658 	movw	r3, #42584	; 0xa658
10014b10:	e3413002 	movt	r3, #4098	; 0x1002
10014b14:	e5933000 	ldr	r3, [r3]
10014b18:	e3a02007 	mov	r2, #7
10014b1c:	e5c32000 	strb	r2, [r3]
10014b20:	e30a3658 	movw	r3, #42584	; 0xa658
10014b24:	e3413002 	movt	r3, #4098	; 0x1002
10014b28:	e5933000 	ldr	r3, [r3]
10014b2c:	e2832001 	add	r2, r3, #1
10014b30:	e30a3658 	movw	r3, #42584	; 0xa658
10014b34:	e3413002 	movt	r3, #4098	; 0x1002
10014b38:	e5832000 	str	r2, [r3]
10014b3c:	ea000021 	b	10014bc8 <finsh_compile+0xeac>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_DIV_WORD);
10014b40:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014b44:	e5d33001 	ldrb	r3, [r3, #1]
10014b48:	e3530002 	cmp	r3, #2
10014b4c:	1a00000c 	bne	10014b84 <finsh_compile+0xe68>
10014b50:	e30a3658 	movw	r3, #42584	; 0xa658
10014b54:	e3413002 	movt	r3, #4098	; 0x1002
10014b58:	e5933000 	ldr	r3, [r3]
10014b5c:	e3a02008 	mov	r2, #8
10014b60:	e5c32000 	strb	r2, [r3]
10014b64:	e30a3658 	movw	r3, #42584	; 0xa658
10014b68:	e3413002 	movt	r3, #4098	; 0x1002
10014b6c:	e5933000 	ldr	r3, [r3]
10014b70:	e2832001 	add	r2, r3, #1
10014b74:	e30a3658 	movw	r3, #42584	; 0xa658
10014b78:	e3413002 	movt	r3, #4098	; 0x1002
10014b7c:	e5832000 	str	r2, [r3]
10014b80:	ea000010 	b	10014bc8 <finsh_compile+0xeac>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_DIV_DWORD);
10014b84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014b88:	e5d33001 	ldrb	r3, [r3, #1]
10014b8c:	e3530003 	cmp	r3, #3
10014b90:	1a00000c 	bne	10014bc8 <finsh_compile+0xeac>
10014b94:	e30a3658 	movw	r3, #42584	; 0xa658
10014b98:	e3413002 	movt	r3, #4098	; 0x1002
10014b9c:	e5933000 	ldr	r3, [r3]
10014ba0:	e3a02009 	mov	r2, #9
10014ba4:	e5c32000 	strb	r2, [r3]
10014ba8:	e30a3658 	movw	r3, #42584	; 0xa658
10014bac:	e3413002 	movt	r3, #4098	; 0x1002
10014bb0:	e5933000 	ldr	r3, [r3]
10014bb4:	e2832001 	add	r2, r3, #1
10014bb8:	e30a3658 	movw	r3, #42584	; 0xa658
10014bbc:	e3413002 	movt	r3, #4098	; 0x1002
10014bc0:	e5832000 	str	r2, [r3]
            break;
10014bc4:	ea000a07 	b	100173e8 <finsh_compile+0x36cc>
10014bc8:	ea000a06 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_MOD:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_MOD_BYTE);
10014bcc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014bd0:	e5d33001 	ldrb	r3, [r3, #1]
10014bd4:	e3530001 	cmp	r3, #1
10014bd8:	1a00000c 	bne	10014c10 <finsh_compile+0xef4>
10014bdc:	e30a3658 	movw	r3, #42584	; 0xa658
10014be0:	e3413002 	movt	r3, #4098	; 0x1002
10014be4:	e5933000 	ldr	r3, [r3]
10014be8:	e3a0200a 	mov	r2, #10
10014bec:	e5c32000 	strb	r2, [r3]
10014bf0:	e30a3658 	movw	r3, #42584	; 0xa658
10014bf4:	e3413002 	movt	r3, #4098	; 0x1002
10014bf8:	e5933000 	ldr	r3, [r3]
10014bfc:	e2832001 	add	r2, r3, #1
10014c00:	e30a3658 	movw	r3, #42584	; 0xa658
10014c04:	e3413002 	movt	r3, #4098	; 0x1002
10014c08:	e5832000 	str	r2, [r3]
10014c0c:	ea000021 	b	10014c98 <finsh_compile+0xf7c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_MOD_WORD);
10014c10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014c14:	e5d33001 	ldrb	r3, [r3, #1]
10014c18:	e3530002 	cmp	r3, #2
10014c1c:	1a00000c 	bne	10014c54 <finsh_compile+0xf38>
10014c20:	e30a3658 	movw	r3, #42584	; 0xa658
10014c24:	e3413002 	movt	r3, #4098	; 0x1002
10014c28:	e5933000 	ldr	r3, [r3]
10014c2c:	e3a0200b 	mov	r2, #11
10014c30:	e5c32000 	strb	r2, [r3]
10014c34:	e30a3658 	movw	r3, #42584	; 0xa658
10014c38:	e3413002 	movt	r3, #4098	; 0x1002
10014c3c:	e5933000 	ldr	r3, [r3]
10014c40:	e2832001 	add	r2, r3, #1
10014c44:	e30a3658 	movw	r3, #42584	; 0xa658
10014c48:	e3413002 	movt	r3, #4098	; 0x1002
10014c4c:	e5832000 	str	r2, [r3]
10014c50:	ea000010 	b	10014c98 <finsh_compile+0xf7c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_MOD_DWORD);
10014c54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014c58:	e5d33001 	ldrb	r3, [r3, #1]
10014c5c:	e3530003 	cmp	r3, #3
10014c60:	1a00000c 	bne	10014c98 <finsh_compile+0xf7c>
10014c64:	e30a3658 	movw	r3, #42584	; 0xa658
10014c68:	e3413002 	movt	r3, #4098	; 0x1002
10014c6c:	e5933000 	ldr	r3, [r3]
10014c70:	e3a0200c 	mov	r2, #12
10014c74:	e5c32000 	strb	r2, [r3]
10014c78:	e30a3658 	movw	r3, #42584	; 0xa658
10014c7c:	e3413002 	movt	r3, #4098	; 0x1002
10014c80:	e5933000 	ldr	r3, [r3]
10014c84:	e2832001 	add	r2, r3, #1
10014c88:	e30a3658 	movw	r3, #42584	; 0xa658
10014c8c:	e3413002 	movt	r3, #4098	; 0x1002
10014c90:	e5832000 	str	r2, [r3]
            break;
10014c94:	ea0009d3 	b	100173e8 <finsh_compile+0x36cc>
10014c98:	ea0009d2 	b	100173e8 <finsh_compile+0x36cc>

        /* bit operation */
        case FINSH_NODE_SYS_AND:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_AND_BYTE);
10014c9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014ca0:	e5d33001 	ldrb	r3, [r3, #1]
10014ca4:	e3530001 	cmp	r3, #1
10014ca8:	1a00000c 	bne	10014ce0 <finsh_compile+0xfc4>
10014cac:	e30a3658 	movw	r3, #42584	; 0xa658
10014cb0:	e3413002 	movt	r3, #4098	; 0x1002
10014cb4:	e5933000 	ldr	r3, [r3]
10014cb8:	e3a02010 	mov	r2, #16
10014cbc:	e5c32000 	strb	r2, [r3]
10014cc0:	e30a3658 	movw	r3, #42584	; 0xa658
10014cc4:	e3413002 	movt	r3, #4098	; 0x1002
10014cc8:	e5933000 	ldr	r3, [r3]
10014ccc:	e2832001 	add	r2, r3, #1
10014cd0:	e30a3658 	movw	r3, #42584	; 0xa658
10014cd4:	e3413002 	movt	r3, #4098	; 0x1002
10014cd8:	e5832000 	str	r2, [r3]
10014cdc:	ea000021 	b	10014d68 <finsh_compile+0x104c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_AND_WORD);
10014ce0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014ce4:	e5d33001 	ldrb	r3, [r3, #1]
10014ce8:	e3530002 	cmp	r3, #2
10014cec:	1a00000c 	bne	10014d24 <finsh_compile+0x1008>
10014cf0:	e30a3658 	movw	r3, #42584	; 0xa658
10014cf4:	e3413002 	movt	r3, #4098	; 0x1002
10014cf8:	e5933000 	ldr	r3, [r3]
10014cfc:	e3a02011 	mov	r2, #17
10014d00:	e5c32000 	strb	r2, [r3]
10014d04:	e30a3658 	movw	r3, #42584	; 0xa658
10014d08:	e3413002 	movt	r3, #4098	; 0x1002
10014d0c:	e5933000 	ldr	r3, [r3]
10014d10:	e2832001 	add	r2, r3, #1
10014d14:	e30a3658 	movw	r3, #42584	; 0xa658
10014d18:	e3413002 	movt	r3, #4098	; 0x1002
10014d1c:	e5832000 	str	r2, [r3]
10014d20:	ea000010 	b	10014d68 <finsh_compile+0x104c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_AND_DWORD);
10014d24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014d28:	e5d33001 	ldrb	r3, [r3, #1]
10014d2c:	e3530003 	cmp	r3, #3
10014d30:	1a00000c 	bne	10014d68 <finsh_compile+0x104c>
10014d34:	e30a3658 	movw	r3, #42584	; 0xa658
10014d38:	e3413002 	movt	r3, #4098	; 0x1002
10014d3c:	e5933000 	ldr	r3, [r3]
10014d40:	e3a02012 	mov	r2, #18
10014d44:	e5c32000 	strb	r2, [r3]
10014d48:	e30a3658 	movw	r3, #42584	; 0xa658
10014d4c:	e3413002 	movt	r3, #4098	; 0x1002
10014d50:	e5933000 	ldr	r3, [r3]
10014d54:	e2832001 	add	r2, r3, #1
10014d58:	e30a3658 	movw	r3, #42584	; 0xa658
10014d5c:	e3413002 	movt	r3, #4098	; 0x1002
10014d60:	e5832000 	str	r2, [r3]
            break;
10014d64:	ea00099f 	b	100173e8 <finsh_compile+0x36cc>
10014d68:	ea00099e 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_OR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_OR_BYTE);
10014d6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014d70:	e5d33001 	ldrb	r3, [r3, #1]
10014d74:	e3530001 	cmp	r3, #1
10014d78:	1a00000c 	bne	10014db0 <finsh_compile+0x1094>
10014d7c:	e30a3658 	movw	r3, #42584	; 0xa658
10014d80:	e3413002 	movt	r3, #4098	; 0x1002
10014d84:	e5933000 	ldr	r3, [r3]
10014d88:	e3a02013 	mov	r2, #19
10014d8c:	e5c32000 	strb	r2, [r3]
10014d90:	e30a3658 	movw	r3, #42584	; 0xa658
10014d94:	e3413002 	movt	r3, #4098	; 0x1002
10014d98:	e5933000 	ldr	r3, [r3]
10014d9c:	e2832001 	add	r2, r3, #1
10014da0:	e30a3658 	movw	r3, #42584	; 0xa658
10014da4:	e3413002 	movt	r3, #4098	; 0x1002
10014da8:	e5832000 	str	r2, [r3]
10014dac:	ea000021 	b	10014e38 <finsh_compile+0x111c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_OR_WORD);
10014db0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014db4:	e5d33001 	ldrb	r3, [r3, #1]
10014db8:	e3530002 	cmp	r3, #2
10014dbc:	1a00000c 	bne	10014df4 <finsh_compile+0x10d8>
10014dc0:	e30a3658 	movw	r3, #42584	; 0xa658
10014dc4:	e3413002 	movt	r3, #4098	; 0x1002
10014dc8:	e5933000 	ldr	r3, [r3]
10014dcc:	e3a02014 	mov	r2, #20
10014dd0:	e5c32000 	strb	r2, [r3]
10014dd4:	e30a3658 	movw	r3, #42584	; 0xa658
10014dd8:	e3413002 	movt	r3, #4098	; 0x1002
10014ddc:	e5933000 	ldr	r3, [r3]
10014de0:	e2832001 	add	r2, r3, #1
10014de4:	e30a3658 	movw	r3, #42584	; 0xa658
10014de8:	e3413002 	movt	r3, #4098	; 0x1002
10014dec:	e5832000 	str	r2, [r3]
10014df0:	ea000010 	b	10014e38 <finsh_compile+0x111c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_OR_DWORD);
10014df4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014df8:	e5d33001 	ldrb	r3, [r3, #1]
10014dfc:	e3530003 	cmp	r3, #3
10014e00:	1a00000c 	bne	10014e38 <finsh_compile+0x111c>
10014e04:	e30a3658 	movw	r3, #42584	; 0xa658
10014e08:	e3413002 	movt	r3, #4098	; 0x1002
10014e0c:	e5933000 	ldr	r3, [r3]
10014e10:	e3a02015 	mov	r2, #21
10014e14:	e5c32000 	strb	r2, [r3]
10014e18:	e30a3658 	movw	r3, #42584	; 0xa658
10014e1c:	e3413002 	movt	r3, #4098	; 0x1002
10014e20:	e5933000 	ldr	r3, [r3]
10014e24:	e2832001 	add	r2, r3, #1
10014e28:	e30a3658 	movw	r3, #42584	; 0xa658
10014e2c:	e3413002 	movt	r3, #4098	; 0x1002
10014e30:	e5832000 	str	r2, [r3]
            break;
10014e34:	ea00096b 	b	100173e8 <finsh_compile+0x36cc>
10014e38:	ea00096a 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_XOR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_XOR_BYTE);
10014e3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014e40:	e5d33001 	ldrb	r3, [r3, #1]
10014e44:	e3530001 	cmp	r3, #1
10014e48:	1a00000c 	bne	10014e80 <finsh_compile+0x1164>
10014e4c:	e30a3658 	movw	r3, #42584	; 0xa658
10014e50:	e3413002 	movt	r3, #4098	; 0x1002
10014e54:	e5933000 	ldr	r3, [r3]
10014e58:	e3a02016 	mov	r2, #22
10014e5c:	e5c32000 	strb	r2, [r3]
10014e60:	e30a3658 	movw	r3, #42584	; 0xa658
10014e64:	e3413002 	movt	r3, #4098	; 0x1002
10014e68:	e5933000 	ldr	r3, [r3]
10014e6c:	e2832001 	add	r2, r3, #1
10014e70:	e30a3658 	movw	r3, #42584	; 0xa658
10014e74:	e3413002 	movt	r3, #4098	; 0x1002
10014e78:	e5832000 	str	r2, [r3]
10014e7c:	ea000021 	b	10014f08 <finsh_compile+0x11ec>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_XOR_WORD);
10014e80:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014e84:	e5d33001 	ldrb	r3, [r3, #1]
10014e88:	e3530002 	cmp	r3, #2
10014e8c:	1a00000c 	bne	10014ec4 <finsh_compile+0x11a8>
10014e90:	e30a3658 	movw	r3, #42584	; 0xa658
10014e94:	e3413002 	movt	r3, #4098	; 0x1002
10014e98:	e5933000 	ldr	r3, [r3]
10014e9c:	e3a02017 	mov	r2, #23
10014ea0:	e5c32000 	strb	r2, [r3]
10014ea4:	e30a3658 	movw	r3, #42584	; 0xa658
10014ea8:	e3413002 	movt	r3, #4098	; 0x1002
10014eac:	e5933000 	ldr	r3, [r3]
10014eb0:	e2832001 	add	r2, r3, #1
10014eb4:	e30a3658 	movw	r3, #42584	; 0xa658
10014eb8:	e3413002 	movt	r3, #4098	; 0x1002
10014ebc:	e5832000 	str	r2, [r3]
10014ec0:	ea000010 	b	10014f08 <finsh_compile+0x11ec>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_XOR_DWORD);
10014ec4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014ec8:	e5d33001 	ldrb	r3, [r3, #1]
10014ecc:	e3530003 	cmp	r3, #3
10014ed0:	1a00000c 	bne	10014f08 <finsh_compile+0x11ec>
10014ed4:	e30a3658 	movw	r3, #42584	; 0xa658
10014ed8:	e3413002 	movt	r3, #4098	; 0x1002
10014edc:	e5933000 	ldr	r3, [r3]
10014ee0:	e3a02018 	mov	r2, #24
10014ee4:	e5c32000 	strb	r2, [r3]
10014ee8:	e30a3658 	movw	r3, #42584	; 0xa658
10014eec:	e3413002 	movt	r3, #4098	; 0x1002
10014ef0:	e5933000 	ldr	r3, [r3]
10014ef4:	e2832001 	add	r2, r3, #1
10014ef8:	e30a3658 	movw	r3, #42584	; 0xa658
10014efc:	e3413002 	movt	r3, #4098	; 0x1002
10014f00:	e5832000 	str	r2, [r3]
            break;
10014f04:	ea000937 	b	100173e8 <finsh_compile+0x36cc>
10014f08:	ea000936 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_BITWISE:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_BITWISE_BYTE);
10014f0c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014f10:	e5d33001 	ldrb	r3, [r3, #1]
10014f14:	e3530001 	cmp	r3, #1
10014f18:	1a00000c 	bne	10014f50 <finsh_compile+0x1234>
10014f1c:	e30a3658 	movw	r3, #42584	; 0xa658
10014f20:	e3413002 	movt	r3, #4098	; 0x1002
10014f24:	e5933000 	ldr	r3, [r3]
10014f28:	e3a02019 	mov	r2, #25
10014f2c:	e5c32000 	strb	r2, [r3]
10014f30:	e30a3658 	movw	r3, #42584	; 0xa658
10014f34:	e3413002 	movt	r3, #4098	; 0x1002
10014f38:	e5933000 	ldr	r3, [r3]
10014f3c:	e2832001 	add	r2, r3, #1
10014f40:	e30a3658 	movw	r3, #42584	; 0xa658
10014f44:	e3413002 	movt	r3, #4098	; 0x1002
10014f48:	e5832000 	str	r2, [r3]
10014f4c:	ea000021 	b	10014fd8 <finsh_compile+0x12bc>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_BITWISE_WORD);
10014f50:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014f54:	e5d33001 	ldrb	r3, [r3, #1]
10014f58:	e3530002 	cmp	r3, #2
10014f5c:	1a00000c 	bne	10014f94 <finsh_compile+0x1278>
10014f60:	e30a3658 	movw	r3, #42584	; 0xa658
10014f64:	e3413002 	movt	r3, #4098	; 0x1002
10014f68:	e5933000 	ldr	r3, [r3]
10014f6c:	e3a0201a 	mov	r2, #26
10014f70:	e5c32000 	strb	r2, [r3]
10014f74:	e30a3658 	movw	r3, #42584	; 0xa658
10014f78:	e3413002 	movt	r3, #4098	; 0x1002
10014f7c:	e5933000 	ldr	r3, [r3]
10014f80:	e2832001 	add	r2, r3, #1
10014f84:	e30a3658 	movw	r3, #42584	; 0xa658
10014f88:	e3413002 	movt	r3, #4098	; 0x1002
10014f8c:	e5832000 	str	r2, [r3]
10014f90:	ea000010 	b	10014fd8 <finsh_compile+0x12bc>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_BITWISE_DWORD);
10014f94:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014f98:	e5d33001 	ldrb	r3, [r3, #1]
10014f9c:	e3530003 	cmp	r3, #3
10014fa0:	1a00000c 	bne	10014fd8 <finsh_compile+0x12bc>
10014fa4:	e30a3658 	movw	r3, #42584	; 0xa658
10014fa8:	e3413002 	movt	r3, #4098	; 0x1002
10014fac:	e5933000 	ldr	r3, [r3]
10014fb0:	e3a0201b 	mov	r2, #27
10014fb4:	e5c32000 	strb	r2, [r3]
10014fb8:	e30a3658 	movw	r3, #42584	; 0xa658
10014fbc:	e3413002 	movt	r3, #4098	; 0x1002
10014fc0:	e5933000 	ldr	r3, [r3]
10014fc4:	e2832001 	add	r2, r3, #1
10014fc8:	e30a3658 	movw	r3, #42584	; 0xa658
10014fcc:	e3413002 	movt	r3, #4098	; 0x1002
10014fd0:	e5832000 	str	r2, [r3]
            break;
10014fd4:	ea000903 	b	100173e8 <finsh_compile+0x36cc>
10014fd8:	ea000902 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SHL:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHL_BYTE);
10014fdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10014fe0:	e5d33001 	ldrb	r3, [r3, #1]
10014fe4:	e3530001 	cmp	r3, #1
10014fe8:	1a00000c 	bne	10015020 <finsh_compile+0x1304>
10014fec:	e30a3658 	movw	r3, #42584	; 0xa658
10014ff0:	e3413002 	movt	r3, #4098	; 0x1002
10014ff4:	e5933000 	ldr	r3, [r3]
10014ff8:	e3a0201c 	mov	r2, #28
10014ffc:	e5c32000 	strb	r2, [r3]
10015000:	e30a3658 	movw	r3, #42584	; 0xa658
10015004:	e3413002 	movt	r3, #4098	; 0x1002
10015008:	e5933000 	ldr	r3, [r3]
1001500c:	e2832001 	add	r2, r3, #1
10015010:	e30a3658 	movw	r3, #42584	; 0xa658
10015014:	e3413002 	movt	r3, #4098	; 0x1002
10015018:	e5832000 	str	r2, [r3]
1001501c:	ea000021 	b	100150a8 <finsh_compile+0x138c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHL_WORD);
10015020:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015024:	e5d33001 	ldrb	r3, [r3, #1]
10015028:	e3530002 	cmp	r3, #2
1001502c:	1a00000c 	bne	10015064 <finsh_compile+0x1348>
10015030:	e30a3658 	movw	r3, #42584	; 0xa658
10015034:	e3413002 	movt	r3, #4098	; 0x1002
10015038:	e5933000 	ldr	r3, [r3]
1001503c:	e3a0201d 	mov	r2, #29
10015040:	e5c32000 	strb	r2, [r3]
10015044:	e30a3658 	movw	r3, #42584	; 0xa658
10015048:	e3413002 	movt	r3, #4098	; 0x1002
1001504c:	e5933000 	ldr	r3, [r3]
10015050:	e2832001 	add	r2, r3, #1
10015054:	e30a3658 	movw	r3, #42584	; 0xa658
10015058:	e3413002 	movt	r3, #4098	; 0x1002
1001505c:	e5832000 	str	r2, [r3]
10015060:	ea000010 	b	100150a8 <finsh_compile+0x138c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHL_DWORD);
10015064:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015068:	e5d33001 	ldrb	r3, [r3, #1]
1001506c:	e3530003 	cmp	r3, #3
10015070:	1a00000c 	bne	100150a8 <finsh_compile+0x138c>
10015074:	e30a3658 	movw	r3, #42584	; 0xa658
10015078:	e3413002 	movt	r3, #4098	; 0x1002
1001507c:	e5933000 	ldr	r3, [r3]
10015080:	e3a0201e 	mov	r2, #30
10015084:	e5c32000 	strb	r2, [r3]
10015088:	e30a3658 	movw	r3, #42584	; 0xa658
1001508c:	e3413002 	movt	r3, #4098	; 0x1002
10015090:	e5933000 	ldr	r3, [r3]
10015094:	e2832001 	add	r2, r3, #1
10015098:	e30a3658 	movw	r3, #42584	; 0xa658
1001509c:	e3413002 	movt	r3, #4098	; 0x1002
100150a0:	e5832000 	str	r2, [r3]
            break;
100150a4:	ea0008cf 	b	100173e8 <finsh_compile+0x36cc>
100150a8:	ea0008ce 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_SHR:
            if (node->data_type == FINSH_DATA_TYPE_BYTE) finsh_code_byte(FINSH_OP_SHR_BYTE);
100150ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100150b0:	e5d33001 	ldrb	r3, [r3, #1]
100150b4:	e3530001 	cmp	r3, #1
100150b8:	1a00000c 	bne	100150f0 <finsh_compile+0x13d4>
100150bc:	e30a3658 	movw	r3, #42584	; 0xa658
100150c0:	e3413002 	movt	r3, #4098	; 0x1002
100150c4:	e5933000 	ldr	r3, [r3]
100150c8:	e3a0201f 	mov	r2, #31
100150cc:	e5c32000 	strb	r2, [r3]
100150d0:	e30a3658 	movw	r3, #42584	; 0xa658
100150d4:	e3413002 	movt	r3, #4098	; 0x1002
100150d8:	e5933000 	ldr	r3, [r3]
100150dc:	e2832001 	add	r2, r3, #1
100150e0:	e30a3658 	movw	r3, #42584	; 0xa658
100150e4:	e3413002 	movt	r3, #4098	; 0x1002
100150e8:	e5832000 	str	r2, [r3]
100150ec:	ea000021 	b	10015178 <finsh_compile+0x145c>
            else if (node->data_type == FINSH_DATA_TYPE_WORD) finsh_code_byte(FINSH_OP_SHR_WORD);
100150f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100150f4:	e5d33001 	ldrb	r3, [r3, #1]
100150f8:	e3530002 	cmp	r3, #2
100150fc:	1a00000c 	bne	10015134 <finsh_compile+0x1418>
10015100:	e30a3658 	movw	r3, #42584	; 0xa658
10015104:	e3413002 	movt	r3, #4098	; 0x1002
10015108:	e5933000 	ldr	r3, [r3]
1001510c:	e3a02020 	mov	r2, #32
10015110:	e5c32000 	strb	r2, [r3]
10015114:	e30a3658 	movw	r3, #42584	; 0xa658
10015118:	e3413002 	movt	r3, #4098	; 0x1002
1001511c:	e5933000 	ldr	r3, [r3]
10015120:	e2832001 	add	r2, r3, #1
10015124:	e30a3658 	movw	r3, #42584	; 0xa658
10015128:	e3413002 	movt	r3, #4098	; 0x1002
1001512c:	e5832000 	str	r2, [r3]
10015130:	ea000010 	b	10015178 <finsh_compile+0x145c>
            else if (node->data_type == FINSH_DATA_TYPE_DWORD) finsh_code_byte(FINSH_OP_SHR_DWORD);
10015134:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015138:	e5d33001 	ldrb	r3, [r3, #1]
1001513c:	e3530003 	cmp	r3, #3
10015140:	1a00000c 	bne	10015178 <finsh_compile+0x145c>
10015144:	e30a3658 	movw	r3, #42584	; 0xa658
10015148:	e3413002 	movt	r3, #4098	; 0x1002
1001514c:	e5933000 	ldr	r3, [r3]
10015150:	e3a02021 	mov	r2, #33	; 0x21
10015154:	e5c32000 	strb	r2, [r3]
10015158:	e30a3658 	movw	r3, #42584	; 0xa658
1001515c:	e3413002 	movt	r3, #4098	; 0x1002
10015160:	e5933000 	ldr	r3, [r3]
10015164:	e2832001 	add	r2, r3, #1
10015168:	e30a3658 	movw	r3, #42584	; 0xa658
1001516c:	e3413002 	movt	r3, #4098	; 0x1002
10015170:	e5832000 	str	r2, [r3]
            break;
10015174:	ea00089b 	b	100173e8 <finsh_compile+0x36cc>
10015178:	ea00089a 	b	100173e8 <finsh_compile+0x36cc>
        case FINSH_NODE_SYS_FUNC:
            {
                int parameters;
                struct finsh_node* sibling;

                parameters = 0;
1001517c:	e3a03000 	mov	r3, #0
10015180:	e50b3008 	str	r3, [fp, #-8]
                if (finsh_node_child(node) != NULL)
10015184:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015188:	e5933010 	ldr	r3, [r3, #16]
1001518c:	e3530000 	cmp	r3, #0
10015190:	0a000027 	beq	10015234 <finsh_compile+0x1518>
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
10015194:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015198:	e5933010 	ldr	r3, [r3, #16]
1001519c:	e593300c 	ldr	r3, [r3, #12]
100151a0:	e50b300c 	str	r3, [fp, #-12]
                    while (sibling != NULL)
100151a4:	ea000005 	b	100151c0 <finsh_compile+0x14a4>
                    {
                        parameters ++;
100151a8:	e51b3008 	ldr	r3, [fp, #-8]
100151ac:	e2833001 	add	r3, r3, #1
100151b0:	e50b3008 	str	r3, [fp, #-8]
                        sibling = finsh_node_sibling(sibling);
100151b4:	e51b300c 	ldr	r3, [fp, #-12]
100151b8:	e593300c 	ldr	r3, [r3, #12]
100151bc:	e50b300c 	str	r3, [fp, #-12]

                parameters = 0;
                if (finsh_node_child(node) != NULL)
                {
                    sibling = finsh_node_sibling(finsh_node_child(node));
                    while (sibling != NULL)
100151c0:	e51b300c 	ldr	r3, [fp, #-12]
100151c4:	e3530000 	cmp	r3, #0
100151c8:	1afffff6 	bne	100151a8 <finsh_compile+0x148c>

                    /* load address of function */
                    // finsh_code_dword((long)&(node->var->value.ptr));

                    /* syscall parameters */
                    finsh_code_byte(FINSH_OP_SYSCALL);
100151cc:	e30a3658 	movw	r3, #42584	; 0xa658
100151d0:	e3413002 	movt	r3, #4098	; 0x1002
100151d4:	e5933000 	ldr	r3, [r3]
100151d8:	e3a0202c 	mov	r2, #44	; 0x2c
100151dc:	e5c32000 	strb	r2, [r3]
100151e0:	e30a3658 	movw	r3, #42584	; 0xa658
100151e4:	e3413002 	movt	r3, #4098	; 0x1002
100151e8:	e5933000 	ldr	r3, [r3]
100151ec:	e2832001 	add	r2, r3, #1
100151f0:	e30a3658 	movw	r3, #42584	; 0xa658
100151f4:	e3413002 	movt	r3, #4098	; 0x1002
100151f8:	e5832000 	str	r2, [r3]
                    finsh_code_byte(parameters);
100151fc:	e30a3658 	movw	r3, #42584	; 0xa658
10015200:	e3413002 	movt	r3, #4098	; 0x1002
10015204:	e5933000 	ldr	r3, [r3]
10015208:	e51b2008 	ldr	r2, [fp, #-8]
1001520c:	e6ef2072 	uxtb	r2, r2
10015210:	e5c32000 	strb	r2, [r3]
10015214:	e30a3658 	movw	r3, #42584	; 0xa658
10015218:	e3413002 	movt	r3, #4098	; 0x1002
1001521c:	e5933000 	ldr	r3, [r3]
10015220:	e2832001 	add	r2, r3, #1
10015224:	e30a3658 	movw	r3, #42584	; 0xa658
10015228:	e3413002 	movt	r3, #4098	; 0x1002
1001522c:	e5832000 	str	r2, [r3]
                }
            }
            break;
10015230:	ea00086c 	b	100173e8 <finsh_compile+0x36cc>
10015234:	ea00086b 	b	100173e8 <finsh_compile+0x36cc>

        /* assign expression */
        case FINSH_NODE_SYS_ASSIGN:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10015238:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001523c:	e5933010 	ldr	r3, [r3, #16]
10015240:	e3530000 	cmp	r3, #0
10015244:	0a00005c 	beq	100153bc <finsh_compile+0x16a0>
10015248:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001524c:	e5933010 	ldr	r3, [r3, #16]
10015250:	e5d33000 	ldrb	r3, [r3]
10015254:	e3530001 	cmp	r3, #1
10015258:	1a000057 	bne	100153bc <finsh_compile+0x16a0>
            {
                switch (finsh_node_child(node)->data_type)
1001525c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015260:	e5933010 	ldr	r3, [r3, #16]
10015264:	e5d33001 	ldrb	r3, [r3, #1]
10015268:	e3530002 	cmp	r3, #2
1001526c:	0a00001c 	beq	100152e4 <finsh_compile+0x15c8>
10015270:	e3530003 	cmp	r3, #3
10015274:	0a000033 	beq	10015348 <finsh_compile+0x162c>
10015278:	e3530001 	cmp	r3, #1
1001527c:	1a00004a 	bne	100153ac <finsh_compile+0x1690>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
10015280:	e30a3658 	movw	r3, #42584	; 0xa658
10015284:	e3413002 	movt	r3, #4098	; 0x1002
10015288:	e5933000 	ldr	r3, [r3]
1001528c:	e3a02028 	mov	r2, #40	; 0x28
10015290:	e5c32000 	strb	r2, [r3]
10015294:	e30a3658 	movw	r3, #42584	; 0xa658
10015298:	e3413002 	movt	r3, #4098	; 0x1002
1001529c:	e5933000 	ldr	r3, [r3]
100152a0:	e2832001 	add	r2, r3, #1
100152a4:	e30a3658 	movw	r3, #42584	; 0xa658
100152a8:	e3413002 	movt	r3, #4098	; 0x1002
100152ac:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
100152b0:	e30a3658 	movw	r3, #42584	; 0xa658
100152b4:	e3413002 	movt	r3, #4098	; 0x1002
100152b8:	e5933000 	ldr	r3, [r3]
100152bc:	e3a0202d 	mov	r2, #45	; 0x2d
100152c0:	e5c32000 	strb	r2, [r3]
100152c4:	e30a3658 	movw	r3, #42584	; 0xa658
100152c8:	e3413002 	movt	r3, #4098	; 0x1002
100152cc:	e5933000 	ldr	r3, [r3]
100152d0:	e2832001 	add	r2, r3, #1
100152d4:	e30a3658 	movw	r3, #42584	; 0xa658
100152d8:	e3413002 	movt	r3, #4098	; 0x1002
100152dc:	e5832000 	str	r2, [r3]
                    break;
100152e0:	ea000034 	b	100153b8 <finsh_compile+0x169c>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
100152e4:	e30a3658 	movw	r3, #42584	; 0xa658
100152e8:	e3413002 	movt	r3, #4098	; 0x1002
100152ec:	e5933000 	ldr	r3, [r3]
100152f0:	e3a02029 	mov	r2, #41	; 0x29
100152f4:	e5c32000 	strb	r2, [r3]
100152f8:	e30a3658 	movw	r3, #42584	; 0xa658
100152fc:	e3413002 	movt	r3, #4098	; 0x1002
10015300:	e5933000 	ldr	r3, [r3]
10015304:	e2832001 	add	r2, r3, #1
10015308:	e30a3658 	movw	r3, #42584	; 0xa658
1001530c:	e3413002 	movt	r3, #4098	; 0x1002
10015310:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
10015314:	e30a3658 	movw	r3, #42584	; 0xa658
10015318:	e3413002 	movt	r3, #4098	; 0x1002
1001531c:	e5933000 	ldr	r3, [r3]
10015320:	e3a0202e 	mov	r2, #46	; 0x2e
10015324:	e5c32000 	strb	r2, [r3]
10015328:	e30a3658 	movw	r3, #42584	; 0xa658
1001532c:	e3413002 	movt	r3, #4098	; 0x1002
10015330:	e5933000 	ldr	r3, [r3]
10015334:	e2832001 	add	r2, r3, #1
10015338:	e30a3658 	movw	r3, #42584	; 0xa658
1001533c:	e3413002 	movt	r3, #4098	; 0x1002
10015340:	e5832000 	str	r2, [r3]
                    break;
10015344:	ea00001b 	b	100153b8 <finsh_compile+0x169c>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10015348:	e30a3658 	movw	r3, #42584	; 0xa658
1001534c:	e3413002 	movt	r3, #4098	; 0x1002
10015350:	e5933000 	ldr	r3, [r3]
10015354:	e3a0202a 	mov	r2, #42	; 0x2a
10015358:	e5c32000 	strb	r2, [r3]
1001535c:	e30a3658 	movw	r3, #42584	; 0xa658
10015360:	e3413002 	movt	r3, #4098	; 0x1002
10015364:	e5933000 	ldr	r3, [r3]
10015368:	e2832001 	add	r2, r3, #1
1001536c:	e30a3658 	movw	r3, #42584	; 0xa658
10015370:	e3413002 	movt	r3, #4098	; 0x1002
10015374:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10015378:	e30a3658 	movw	r3, #42584	; 0xa658
1001537c:	e3413002 	movt	r3, #4098	; 0x1002
10015380:	e5933000 	ldr	r3, [r3]
10015384:	e3a0202f 	mov	r2, #47	; 0x2f
10015388:	e5c32000 	strb	r2, [r3]
1001538c:	e30a3658 	movw	r3, #42584	; 0xa658
10015390:	e3413002 	movt	r3, #4098	; 0x1002
10015394:	e5933000 	ldr	r3, [r3]
10015398:	e2832001 	add	r2, r3, #1
1001539c:	e30a3658 	movw	r3, #42584	; 0xa658
100153a0:	e3413002 	movt	r3, #4098	; 0x1002
100153a4:	e5832000 	str	r2, [r3]
                    break;
100153a8:	ea000002 	b	100153b8 <finsh_compile+0x169c>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
100153ac:	e3a00003 	mov	r0, #3
100153b0:	eb00093f 	bl	100178b4 <finsh_error_set>
                }
            }
100153b4:	ea00005d 	b	10015530 <finsh_compile+0x1814>
100153b8:	ea00005c 	b	10015530 <finsh_compile+0x1814>
            else if (finsh_node_child(node)->node_type == FINSH_NODE_SYS_GETVALUE)
100153bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100153c0:	e5933010 	ldr	r3, [r3, #16]
100153c4:	e5d33000 	ldrb	r3, [r3]
100153c8:	e3530019 	cmp	r3, #25
100153cc:	1a000057 	bne	10015530 <finsh_compile+0x1814>
            {
                switch ((finsh_node_child(node)->data_type) & 0x0F)
100153d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100153d4:	e5933010 	ldr	r3, [r3, #16]
100153d8:	e5d33001 	ldrb	r3, [r3, #1]
100153dc:	e203300f 	and	r3, r3, #15
100153e0:	e3530002 	cmp	r3, #2
100153e4:	0a00001c 	beq	1001545c <finsh_compile+0x1740>
100153e8:	e3530003 	cmp	r3, #3
100153ec:	0a000033 	beq	100154c0 <finsh_compile+0x17a4>
100153f0:	e3530001 	cmp	r3, #1
100153f4:	1a00004a 	bne	10015524 <finsh_compile+0x1808>
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_ST_BYTE);
100153f8:	e30a3658 	movw	r3, #42584	; 0xa658
100153fc:	e3413002 	movt	r3, #4098	; 0x1002
10015400:	e5933000 	ldr	r3, [r3]
10015404:	e3a02028 	mov	r2, #40	; 0x28
10015408:	e5c32000 	strb	r2, [r3]
1001540c:	e30a3658 	movw	r3, #42584	; 0xa658
10015410:	e3413002 	movt	r3, #4098	; 0x1002
10015414:	e5933000 	ldr	r3, [r3]
10015418:	e2832001 	add	r2, r3, #1
1001541c:	e30a3658 	movw	r3, #42584	; 0xa658
10015420:	e3413002 	movt	r3, #4098	; 0x1002
10015424:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
10015428:	e30a3658 	movw	r3, #42584	; 0xa658
1001542c:	e3413002 	movt	r3, #4098	; 0x1002
10015430:	e5933000 	ldr	r3, [r3]
10015434:	e3a0202d 	mov	r2, #45	; 0x2d
10015438:	e5c32000 	strb	r2, [r3]
1001543c:	e30a3658 	movw	r3, #42584	; 0xa658
10015440:	e3413002 	movt	r3, #4098	; 0x1002
10015444:	e5933000 	ldr	r3, [r3]
10015448:	e2832001 	add	r2, r3, #1
1001544c:	e30a3658 	movw	r3, #42584	; 0xa658
10015450:	e3413002 	movt	r3, #4098	; 0x1002
10015454:	e5832000 	str	r2, [r3]
                    break;
10015458:	ea000034 	b	10015530 <finsh_compile+0x1814>

                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_ST_WORD);
1001545c:	e30a3658 	movw	r3, #42584	; 0xa658
10015460:	e3413002 	movt	r3, #4098	; 0x1002
10015464:	e5933000 	ldr	r3, [r3]
10015468:	e3a02029 	mov	r2, #41	; 0x29
1001546c:	e5c32000 	strb	r2, [r3]
10015470:	e30a3658 	movw	r3, #42584	; 0xa658
10015474:	e3413002 	movt	r3, #4098	; 0x1002
10015478:	e5933000 	ldr	r3, [r3]
1001547c:	e2832001 	add	r2, r3, #1
10015480:	e30a3658 	movw	r3, #42584	; 0xa658
10015484:	e3413002 	movt	r3, #4098	; 0x1002
10015488:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
1001548c:	e30a3658 	movw	r3, #42584	; 0xa658
10015490:	e3413002 	movt	r3, #4098	; 0x1002
10015494:	e5933000 	ldr	r3, [r3]
10015498:	e3a0202e 	mov	r2, #46	; 0x2e
1001549c:	e5c32000 	strb	r2, [r3]
100154a0:	e30a3658 	movw	r3, #42584	; 0xa658
100154a4:	e3413002 	movt	r3, #4098	; 0x1002
100154a8:	e5933000 	ldr	r3, [r3]
100154ac:	e2832001 	add	r2, r3, #1
100154b0:	e30a3658 	movw	r3, #42584	; 0xa658
100154b4:	e3413002 	movt	r3, #4098	; 0x1002
100154b8:	e5832000 	str	r2, [r3]
                    break;
100154bc:	ea00001b 	b	10015530 <finsh_compile+0x1814>

                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_ST_DWORD);
100154c0:	e30a3658 	movw	r3, #42584	; 0xa658
100154c4:	e3413002 	movt	r3, #4098	; 0x1002
100154c8:	e5933000 	ldr	r3, [r3]
100154cc:	e3a0202a 	mov	r2, #42	; 0x2a
100154d0:	e5c32000 	strb	r2, [r3]
100154d4:	e30a3658 	movw	r3, #42584	; 0xa658
100154d8:	e3413002 	movt	r3, #4098	; 0x1002
100154dc:	e5933000 	ldr	r3, [r3]
100154e0:	e2832001 	add	r2, r3, #1
100154e4:	e30a3658 	movw	r3, #42584	; 0xa658
100154e8:	e3413002 	movt	r3, #4098	; 0x1002
100154ec:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
100154f0:	e30a3658 	movw	r3, #42584	; 0xa658
100154f4:	e3413002 	movt	r3, #4098	; 0x1002
100154f8:	e5933000 	ldr	r3, [r3]
100154fc:	e3a0202f 	mov	r2, #47	; 0x2f
10015500:	e5c32000 	strb	r2, [r3]
10015504:	e30a3658 	movw	r3, #42584	; 0xa658
10015508:	e3413002 	movt	r3, #4098	; 0x1002
1001550c:	e5933000 	ldr	r3, [r3]
10015510:	e2832001 	add	r2, r3, #1
10015514:	e30a3658 	movw	r3, #42584	; 0xa658
10015518:	e3413002 	movt	r3, #4098	; 0x1002
1001551c:	e5832000 	str	r2, [r3]
                    break;
10015520:	ea000002 	b	10015530 <finsh_compile+0x1814>

                default:
                    finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
10015524:	e3a00003 	mov	r0, #3
10015528:	eb0008e1 	bl	100178b4 <finsh_error_set>
                }
            }
            break;
1001552c:	ea0007ad 	b	100173e8 <finsh_compile+0x36cc>
10015530:	ea0007ac 	b	100173e8 <finsh_compile+0x36cc>

        /* pre-increase */
        case FINSH_NODE_SYS_PREINC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10015534:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015538:	e5933010 	ldr	r3, [r3, #16]
1001553c:	e3530000 	cmp	r3, #0
10015540:	0a00017f 	beq	10015b44 <finsh_compile+0x1e28>
10015544:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015548:	e5933010 	ldr	r3, [r3, #16]
1001554c:	e5d33000 	ldrb	r3, [r3]
10015550:	e3530001 	cmp	r3, #1
10015554:	1a00017a 	bne	10015b44 <finsh_compile+0x1e28>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
10015558:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001555c:	e5933010 	ldr	r3, [r3, #16]
10015560:	e5933008 	ldr	r3, [r3, #8]
10015564:	e50b3018 	str	r3, [fp, #-24]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
10015568:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001556c:	e5d33001 	ldrb	r3, [r3, #1]
10015570:	e3530002 	cmp	r3, #2
10015574:	0a000076 	beq	10015754 <finsh_compile+0x1a38>
10015578:	e3530003 	cmp	r3, #3
1001557c:	0a0000ec 	beq	10015934 <finsh_compile+0x1c18>
10015580:	e3530001 	cmp	r3, #1
10015584:	0a000000 	beq	1001558c <finsh_compile+0x1870>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
10015588:	ea000796 	b	100173e8 <finsh_compile+0x36cc>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
1001558c:	e30a3658 	movw	r3, #42584	; 0xa658
10015590:	e3413002 	movt	r3, #4098	; 0x1002
10015594:	e5933000 	ldr	r3, [r3]
10015598:	e3a02025 	mov	r2, #37	; 0x25
1001559c:	e5c32000 	strb	r2, [r3]
100155a0:	e30a3658 	movw	r3, #42584	; 0xa658
100155a4:	e3413002 	movt	r3, #4098	; 0x1002
100155a8:	e5933000 	ldr	r3, [r3]
100155ac:	e2832001 	add	r2, r3, #1
100155b0:	e30a3658 	movw	r3, #42584	; 0xa658
100155b4:	e3413002 	movt	r3, #4098	; 0x1002
100155b8:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
100155bc:	e30a3658 	movw	r3, #42584	; 0xa658
100155c0:	e3413002 	movt	r3, #4098	; 0x1002
100155c4:	e5933000 	ldr	r3, [r3]
100155c8:	e51b2018 	ldr	r2, [fp, #-24]
100155cc:	e2822014 	add	r2, r2, #20
100155d0:	e6ef2072 	uxtb	r2, r2
100155d4:	e5c32000 	strb	r2, [r3]
100155d8:	e30a3658 	movw	r3, #42584	; 0xa658
100155dc:	e3413002 	movt	r3, #4098	; 0x1002
100155e0:	e5933000 	ldr	r3, [r3]
100155e4:	e2833001 	add	r3, r3, #1
100155e8:	e51b2018 	ldr	r2, [fp, #-24]
100155ec:	e2822014 	add	r2, r2, #20
100155f0:	e1a02422 	lsr	r2, r2, #8
100155f4:	e6ef2072 	uxtb	r2, r2
100155f8:	e5c32000 	strb	r2, [r3]
100155fc:	e30a3658 	movw	r3, #42584	; 0xa658
10015600:	e3413002 	movt	r3, #4098	; 0x1002
10015604:	e5933000 	ldr	r3, [r3]
10015608:	e2833002 	add	r3, r3, #2
1001560c:	e51b2018 	ldr	r2, [fp, #-24]
10015610:	e2822014 	add	r2, r2, #20
10015614:	e1a02822 	lsr	r2, r2, #16
10015618:	e6ef2072 	uxtb	r2, r2
1001561c:	e5c32000 	strb	r2, [r3]
10015620:	e30a3658 	movw	r3, #42584	; 0xa658
10015624:	e3413002 	movt	r3, #4098	; 0x1002
10015628:	e5933000 	ldr	r3, [r3]
1001562c:	e2833003 	add	r3, r3, #3
10015630:	e51b2018 	ldr	r2, [fp, #-24]
10015634:	e2822014 	add	r2, r2, #20
10015638:	e1a02c22 	lsr	r2, r2, #24
1001563c:	e6ef2072 	uxtb	r2, r2
10015640:	e5c32000 	strb	r2, [r3]
10015644:	e30a3658 	movw	r3, #42584	; 0xa658
10015648:	e3413002 	movt	r3, #4098	; 0x1002
1001564c:	e5933000 	ldr	r3, [r3]
10015650:	e2832004 	add	r2, r3, #4
10015654:	e30a3658 	movw	r3, #42584	; 0xa658
10015658:	e3413002 	movt	r3, #4098	; 0x1002
1001565c:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
10015660:	e30a3658 	movw	r3, #42584	; 0xa658
10015664:	e3413002 	movt	r3, #4098	; 0x1002
10015668:	e5933000 	ldr	r3, [r3]
1001566c:	e3a02022 	mov	r2, #34	; 0x22
10015670:	e5c32000 	strb	r2, [r3]
10015674:	e30a3658 	movw	r3, #42584	; 0xa658
10015678:	e3413002 	movt	r3, #4098	; 0x1002
1001567c:	e5933000 	ldr	r3, [r3]
10015680:	e2832001 	add	r2, r3, #1
10015684:	e30a3658 	movw	r3, #42584	; 0xa658
10015688:	e3413002 	movt	r3, #4098	; 0x1002
1001568c:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
10015690:	e30a3658 	movw	r3, #42584	; 0xa658
10015694:	e3413002 	movt	r3, #4098	; 0x1002
10015698:	e5933000 	ldr	r3, [r3]
1001569c:	e3a02001 	mov	r2, #1
100156a0:	e5c32000 	strb	r2, [r3]
100156a4:	e30a3658 	movw	r3, #42584	; 0xa658
100156a8:	e3413002 	movt	r3, #4098	; 0x1002
100156ac:	e5933000 	ldr	r3, [r3]
100156b0:	e2832001 	add	r2, r3, #1
100156b4:	e30a3658 	movw	r3, #42584	; 0xa658
100156b8:	e3413002 	movt	r3, #4098	; 0x1002
100156bc:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
100156c0:	e30a3658 	movw	r3, #42584	; 0xa658
100156c4:	e3413002 	movt	r3, #4098	; 0x1002
100156c8:	e5933000 	ldr	r3, [r3]
100156cc:	e3a02001 	mov	r2, #1
100156d0:	e5c32000 	strb	r2, [r3]
100156d4:	e30a3658 	movw	r3, #42584	; 0xa658
100156d8:	e3413002 	movt	r3, #4098	; 0x1002
100156dc:	e5933000 	ldr	r3, [r3]
100156e0:	e2832001 	add	r2, r3, #1
100156e4:	e30a3658 	movw	r3, #42584	; 0xa658
100156e8:	e3413002 	movt	r3, #4098	; 0x1002
100156ec:	e5832000 	str	r2, [r3]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
100156f0:	e30a3658 	movw	r3, #42584	; 0xa658
100156f4:	e3413002 	movt	r3, #4098	; 0x1002
100156f8:	e5933000 	ldr	r3, [r3]
100156fc:	e3a02028 	mov	r2, #40	; 0x28
10015700:	e5c32000 	strb	r2, [r3]
10015704:	e30a3658 	movw	r3, #42584	; 0xa658
10015708:	e3413002 	movt	r3, #4098	; 0x1002
1001570c:	e5933000 	ldr	r3, [r3]
10015710:	e2832001 	add	r2, r3, #1
10015714:	e30a3658 	movw	r3, #42584	; 0xa658
10015718:	e3413002 	movt	r3, #4098	; 0x1002
1001571c:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10015720:	e30a3658 	movw	r3, #42584	; 0xa658
10015724:	e3413002 	movt	r3, #4098	; 0x1002
10015728:	e5933000 	ldr	r3, [r3]
1001572c:	e3a0202f 	mov	r2, #47	; 0x2f
10015730:	e5c32000 	strb	r2, [r3]
10015734:	e30a3658 	movw	r3, #42584	; 0xa658
10015738:	e3413002 	movt	r3, #4098	; 0x1002
1001573c:	e5933000 	ldr	r3, [r3]
10015740:	e2832001 	add	r2, r3, #1
10015744:	e30a3658 	movw	r3, #42584	; 0xa658
10015748:	e3413002 	movt	r3, #4098	; 0x1002
1001574c:	e5832000 	str	r2, [r3]

                    break;
10015750:	ea0000fb 	b	10015b44 <finsh_compile+0x1e28>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10015754:	e30a3658 	movw	r3, #42584	; 0xa658
10015758:	e3413002 	movt	r3, #4098	; 0x1002
1001575c:	e5933000 	ldr	r3, [r3]
10015760:	e3a02026 	mov	r2, #38	; 0x26
10015764:	e5c32000 	strb	r2, [r3]
10015768:	e30a3658 	movw	r3, #42584	; 0xa658
1001576c:	e3413002 	movt	r3, #4098	; 0x1002
10015770:	e5933000 	ldr	r3, [r3]
10015774:	e2832001 	add	r2, r3, #1
10015778:	e30a3658 	movw	r3, #42584	; 0xa658
1001577c:	e3413002 	movt	r3, #4098	; 0x1002
10015780:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10015784:	e30a3658 	movw	r3, #42584	; 0xa658
10015788:	e3413002 	movt	r3, #4098	; 0x1002
1001578c:	e5933000 	ldr	r3, [r3]
10015790:	e51b2018 	ldr	r2, [fp, #-24]
10015794:	e2822014 	add	r2, r2, #20
10015798:	e6ef2072 	uxtb	r2, r2
1001579c:	e5c32000 	strb	r2, [r3]
100157a0:	e30a3658 	movw	r3, #42584	; 0xa658
100157a4:	e3413002 	movt	r3, #4098	; 0x1002
100157a8:	e5933000 	ldr	r3, [r3]
100157ac:	e2833001 	add	r3, r3, #1
100157b0:	e51b2018 	ldr	r2, [fp, #-24]
100157b4:	e2822014 	add	r2, r2, #20
100157b8:	e1a02422 	lsr	r2, r2, #8
100157bc:	e6ef2072 	uxtb	r2, r2
100157c0:	e5c32000 	strb	r2, [r3]
100157c4:	e30a3658 	movw	r3, #42584	; 0xa658
100157c8:	e3413002 	movt	r3, #4098	; 0x1002
100157cc:	e5933000 	ldr	r3, [r3]
100157d0:	e2833002 	add	r3, r3, #2
100157d4:	e51b2018 	ldr	r2, [fp, #-24]
100157d8:	e2822014 	add	r2, r2, #20
100157dc:	e1a02822 	lsr	r2, r2, #16
100157e0:	e6ef2072 	uxtb	r2, r2
100157e4:	e5c32000 	strb	r2, [r3]
100157e8:	e30a3658 	movw	r3, #42584	; 0xa658
100157ec:	e3413002 	movt	r3, #4098	; 0x1002
100157f0:	e5933000 	ldr	r3, [r3]
100157f4:	e2833003 	add	r3, r3, #3
100157f8:	e51b2018 	ldr	r2, [fp, #-24]
100157fc:	e2822014 	add	r2, r2, #20
10015800:	e1a02c22 	lsr	r2, r2, #24
10015804:	e6ef2072 	uxtb	r2, r2
10015808:	e5c32000 	strb	r2, [r3]
1001580c:	e30a3658 	movw	r3, #42584	; 0xa658
10015810:	e3413002 	movt	r3, #4098	; 0x1002
10015814:	e5933000 	ldr	r3, [r3]
10015818:	e2832004 	add	r2, r3, #4
1001581c:	e30a3658 	movw	r3, #42584	; 0xa658
10015820:	e3413002 	movt	r3, #4098	; 0x1002
10015824:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
10015828:	e30a3658 	movw	r3, #42584	; 0xa658
1001582c:	e3413002 	movt	r3, #4098	; 0x1002
10015830:	e5933000 	ldr	r3, [r3]
10015834:	e3a02023 	mov	r2, #35	; 0x23
10015838:	e5c32000 	strb	r2, [r3]
1001583c:	e30a3658 	movw	r3, #42584	; 0xa658
10015840:	e3413002 	movt	r3, #4098	; 0x1002
10015844:	e5933000 	ldr	r3, [r3]
10015848:	e2832001 	add	r2, r3, #1
1001584c:	e30a3658 	movw	r3, #42584	; 0xa658
10015850:	e3413002 	movt	r3, #4098	; 0x1002
10015854:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
10015858:	e30a3658 	movw	r3, #42584	; 0xa658
1001585c:	e3413002 	movt	r3, #4098	; 0x1002
10015860:	e5933000 	ldr	r3, [r3]
10015864:	e3a02001 	mov	r2, #1
10015868:	e5c32000 	strb	r2, [r3]
1001586c:	e30a3658 	movw	r3, #42584	; 0xa658
10015870:	e3413002 	movt	r3, #4098	; 0x1002
10015874:	e5933000 	ldr	r3, [r3]
10015878:	e2833001 	add	r3, r3, #1
1001587c:	e3a02000 	mov	r2, #0
10015880:	e5c32000 	strb	r2, [r3]
10015884:	e30a3658 	movw	r3, #42584	; 0xa658
10015888:	e3413002 	movt	r3, #4098	; 0x1002
1001588c:	e5933000 	ldr	r3, [r3]
10015890:	e2832002 	add	r2, r3, #2
10015894:	e30a3658 	movw	r3, #42584	; 0xa658
10015898:	e3413002 	movt	r3, #4098	; 0x1002
1001589c:	e5832000 	str	r2, [r3]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
100158a0:	e30a3658 	movw	r3, #42584	; 0xa658
100158a4:	e3413002 	movt	r3, #4098	; 0x1002
100158a8:	e5933000 	ldr	r3, [r3]
100158ac:	e3a02002 	mov	r2, #2
100158b0:	e5c32000 	strb	r2, [r3]
100158b4:	e30a3658 	movw	r3, #42584	; 0xa658
100158b8:	e3413002 	movt	r3, #4098	; 0x1002
100158bc:	e5933000 	ldr	r3, [r3]
100158c0:	e2832001 	add	r2, r3, #1
100158c4:	e30a3658 	movw	r3, #42584	; 0xa658
100158c8:	e3413002 	movt	r3, #4098	; 0x1002
100158cc:	e5832000 	str	r2, [r3]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
100158d0:	e30a3658 	movw	r3, #42584	; 0xa658
100158d4:	e3413002 	movt	r3, #4098	; 0x1002
100158d8:	e5933000 	ldr	r3, [r3]
100158dc:	e3a02029 	mov	r2, #41	; 0x29
100158e0:	e5c32000 	strb	r2, [r3]
100158e4:	e30a3658 	movw	r3, #42584	; 0xa658
100158e8:	e3413002 	movt	r3, #4098	; 0x1002
100158ec:	e5933000 	ldr	r3, [r3]
100158f0:	e2832001 	add	r2, r3, #1
100158f4:	e30a3658 	movw	r3, #42584	; 0xa658
100158f8:	e3413002 	movt	r3, #4098	; 0x1002
100158fc:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10015900:	e30a3658 	movw	r3, #42584	; 0xa658
10015904:	e3413002 	movt	r3, #4098	; 0x1002
10015908:	e5933000 	ldr	r3, [r3]
1001590c:	e3a0202f 	mov	r2, #47	; 0x2f
10015910:	e5c32000 	strb	r2, [r3]
10015914:	e30a3658 	movw	r3, #42584	; 0xa658
10015918:	e3413002 	movt	r3, #4098	; 0x1002
1001591c:	e5933000 	ldr	r3, [r3]
10015920:	e2832001 	add	r2, r3, #1
10015924:	e30a3658 	movw	r3, #42584	; 0xa658
10015928:	e3413002 	movt	r3, #4098	; 0x1002
1001592c:	e5832000 	str	r2, [r3]

                    break;
10015930:	ea000083 	b	10015b44 <finsh_compile+0x1e28>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10015934:	e30a3658 	movw	r3, #42584	; 0xa658
10015938:	e3413002 	movt	r3, #4098	; 0x1002
1001593c:	e5933000 	ldr	r3, [r3]
10015940:	e3a02027 	mov	r2, #39	; 0x27
10015944:	e5c32000 	strb	r2, [r3]
10015948:	e30a3658 	movw	r3, #42584	; 0xa658
1001594c:	e3413002 	movt	r3, #4098	; 0x1002
10015950:	e5933000 	ldr	r3, [r3]
10015954:	e2832001 	add	r2, r3, #1
10015958:	e30a3658 	movw	r3, #42584	; 0xa658
1001595c:	e3413002 	movt	r3, #4098	; 0x1002
10015960:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10015964:	e30a3658 	movw	r3, #42584	; 0xa658
10015968:	e3413002 	movt	r3, #4098	; 0x1002
1001596c:	e5933000 	ldr	r3, [r3]
10015970:	e51b2018 	ldr	r2, [fp, #-24]
10015974:	e2822014 	add	r2, r2, #20
10015978:	e6ef2072 	uxtb	r2, r2
1001597c:	e5c32000 	strb	r2, [r3]
10015980:	e30a3658 	movw	r3, #42584	; 0xa658
10015984:	e3413002 	movt	r3, #4098	; 0x1002
10015988:	e5933000 	ldr	r3, [r3]
1001598c:	e2833001 	add	r3, r3, #1
10015990:	e51b2018 	ldr	r2, [fp, #-24]
10015994:	e2822014 	add	r2, r2, #20
10015998:	e1a02422 	lsr	r2, r2, #8
1001599c:	e6ef2072 	uxtb	r2, r2
100159a0:	e5c32000 	strb	r2, [r3]
100159a4:	e30a3658 	movw	r3, #42584	; 0xa658
100159a8:	e3413002 	movt	r3, #4098	; 0x1002
100159ac:	e5933000 	ldr	r3, [r3]
100159b0:	e2833002 	add	r3, r3, #2
100159b4:	e51b2018 	ldr	r2, [fp, #-24]
100159b8:	e2822014 	add	r2, r2, #20
100159bc:	e1a02822 	lsr	r2, r2, #16
100159c0:	e6ef2072 	uxtb	r2, r2
100159c4:	e5c32000 	strb	r2, [r3]
100159c8:	e30a3658 	movw	r3, #42584	; 0xa658
100159cc:	e3413002 	movt	r3, #4098	; 0x1002
100159d0:	e5933000 	ldr	r3, [r3]
100159d4:	e2833003 	add	r3, r3, #3
100159d8:	e51b2018 	ldr	r2, [fp, #-24]
100159dc:	e2822014 	add	r2, r2, #20
100159e0:	e1a02c22 	lsr	r2, r2, #24
100159e4:	e6ef2072 	uxtb	r2, r2
100159e8:	e5c32000 	strb	r2, [r3]
100159ec:	e30a3658 	movw	r3, #42584	; 0xa658
100159f0:	e3413002 	movt	r3, #4098	; 0x1002
100159f4:	e5933000 	ldr	r3, [r3]
100159f8:	e2832004 	add	r2, r3, #4
100159fc:	e30a3658 	movw	r3, #42584	; 0xa658
10015a00:	e3413002 	movt	r3, #4098	; 0x1002
10015a04:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10015a08:	e30a3658 	movw	r3, #42584	; 0xa658
10015a0c:	e3413002 	movt	r3, #4098	; 0x1002
10015a10:	e5933000 	ldr	r3, [r3]
10015a14:	e3a02024 	mov	r2, #36	; 0x24
10015a18:	e5c32000 	strb	r2, [r3]
10015a1c:	e30a3658 	movw	r3, #42584	; 0xa658
10015a20:	e3413002 	movt	r3, #4098	; 0x1002
10015a24:	e5933000 	ldr	r3, [r3]
10015a28:	e2832001 	add	r2, r3, #1
10015a2c:	e30a3658 	movw	r3, #42584	; 0xa658
10015a30:	e3413002 	movt	r3, #4098	; 0x1002
10015a34:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
10015a38:	e30a3658 	movw	r3, #42584	; 0xa658
10015a3c:	e3413002 	movt	r3, #4098	; 0x1002
10015a40:	e5933000 	ldr	r3, [r3]
10015a44:	e3a02001 	mov	r2, #1
10015a48:	e5c32000 	strb	r2, [r3]
10015a4c:	e30a3658 	movw	r3, #42584	; 0xa658
10015a50:	e3413002 	movt	r3, #4098	; 0x1002
10015a54:	e5933000 	ldr	r3, [r3]
10015a58:	e2833001 	add	r3, r3, #1
10015a5c:	e3a02000 	mov	r2, #0
10015a60:	e5c32000 	strb	r2, [r3]
10015a64:	e30a3658 	movw	r3, #42584	; 0xa658
10015a68:	e3413002 	movt	r3, #4098	; 0x1002
10015a6c:	e5933000 	ldr	r3, [r3]
10015a70:	e2833002 	add	r3, r3, #2
10015a74:	e3a02000 	mov	r2, #0
10015a78:	e5c32000 	strb	r2, [r3]
10015a7c:	e30a3658 	movw	r3, #42584	; 0xa658
10015a80:	e3413002 	movt	r3, #4098	; 0x1002
10015a84:	e5933000 	ldr	r3, [r3]
10015a88:	e2833003 	add	r3, r3, #3
10015a8c:	e3a02000 	mov	r2, #0
10015a90:	e5c32000 	strb	r2, [r3]
10015a94:	e30a3658 	movw	r3, #42584	; 0xa658
10015a98:	e3413002 	movt	r3, #4098	; 0x1002
10015a9c:	e5933000 	ldr	r3, [r3]
10015aa0:	e2832004 	add	r2, r3, #4
10015aa4:	e30a3658 	movw	r3, #42584	; 0xa658
10015aa8:	e3413002 	movt	r3, #4098	; 0x1002
10015aac:	e5832000 	str	r2, [r3]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
10015ab0:	e30a3658 	movw	r3, #42584	; 0xa658
10015ab4:	e3413002 	movt	r3, #4098	; 0x1002
10015ab8:	e5933000 	ldr	r3, [r3]
10015abc:	e3a02003 	mov	r2, #3
10015ac0:	e5c32000 	strb	r2, [r3]
10015ac4:	e30a3658 	movw	r3, #42584	; 0xa658
10015ac8:	e3413002 	movt	r3, #4098	; 0x1002
10015acc:	e5933000 	ldr	r3, [r3]
10015ad0:	e2832001 	add	r2, r3, #1
10015ad4:	e30a3658 	movw	r3, #42584	; 0xa658
10015ad8:	e3413002 	movt	r3, #4098	; 0x1002
10015adc:	e5832000 	str	r2, [r3]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10015ae0:	e30a3658 	movw	r3, #42584	; 0xa658
10015ae4:	e3413002 	movt	r3, #4098	; 0x1002
10015ae8:	e5933000 	ldr	r3, [r3]
10015aec:	e3a0202a 	mov	r2, #42	; 0x2a
10015af0:	e5c32000 	strb	r2, [r3]
10015af4:	e30a3658 	movw	r3, #42584	; 0xa658
10015af8:	e3413002 	movt	r3, #4098	; 0x1002
10015afc:	e5933000 	ldr	r3, [r3]
10015b00:	e2832001 	add	r2, r3, #1
10015b04:	e30a3658 	movw	r3, #42584	; 0xa658
10015b08:	e3413002 	movt	r3, #4098	; 0x1002
10015b0c:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10015b10:	e30a3658 	movw	r3, #42584	; 0xa658
10015b14:	e3413002 	movt	r3, #4098	; 0x1002
10015b18:	e5933000 	ldr	r3, [r3]
10015b1c:	e3a0202f 	mov	r2, #47	; 0x2f
10015b20:	e5c32000 	strb	r2, [r3]
10015b24:	e30a3658 	movw	r3, #42584	; 0xa658
10015b28:	e3413002 	movt	r3, #4098	; 0x1002
10015b2c:	e5933000 	ldr	r3, [r3]
10015b30:	e2832001 	add	r2, r3, #1
10015b34:	e30a3658 	movw	r3, #42584	; 0xa658
10015b38:	e3413002 	movt	r3, #4098	; 0x1002
10015b3c:	e5832000 	str	r2, [r3]

                    break;
10015b40:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
10015b44:	ea000627 	b	100173e8 <finsh_compile+0x36cc>

        /* pre-decrease */
        case FINSH_NODE_SYS_PREDEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
10015b48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015b4c:	e5933010 	ldr	r3, [r3, #16]
10015b50:	e3530000 	cmp	r3, #0
10015b54:	0a00017f 	beq	10016158 <finsh_compile+0x243c>
10015b58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015b5c:	e5933010 	ldr	r3, [r3, #16]
10015b60:	e5d33000 	ldrb	r3, [r3]
10015b64:	e3530001 	cmp	r3, #1
10015b68:	1a00017a 	bne	10016158 <finsh_compile+0x243c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
10015b6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015b70:	e5933010 	ldr	r3, [r3, #16]
10015b74:	e5933008 	ldr	r3, [r3, #8]
10015b78:	e50b301c 	str	r3, [fp, #-28]

                /* ld_dword &id */
                // finsh_code_byte(FINSH_OP_LD_DWORD);

                switch (node->data_type)
10015b7c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10015b80:	e5d33001 	ldrb	r3, [r3, #1]
10015b84:	e3530002 	cmp	r3, #2
10015b88:	0a000076 	beq	10015d68 <finsh_compile+0x204c>
10015b8c:	e3530003 	cmp	r3, #3
10015b90:	0a0000ec 	beq	10015f48 <finsh_compile+0x222c>
10015b94:	e3530001 	cmp	r3, #1
10015b98:	0a000000 	beq	10015ba0 <finsh_compile+0x1e84>
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);

                    break;
                }
            }
            break;
10015b9c:	ea000611 	b	100173e8 <finsh_compile+0x36cc>
                case FINSH_DATA_TYPE_BYTE:
                    /* address */
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10015ba0:	e30a3658 	movw	r3, #42584	; 0xa658
10015ba4:	e3413002 	movt	r3, #4098	; 0x1002
10015ba8:	e5933000 	ldr	r3, [r3]
10015bac:	e3a02025 	mov	r2, #37	; 0x25
10015bb0:	e5c32000 	strb	r2, [r3]
10015bb4:	e30a3658 	movw	r3, #42584	; 0xa658
10015bb8:	e3413002 	movt	r3, #4098	; 0x1002
10015bbc:	e5933000 	ldr	r3, [r3]
10015bc0:	e2832001 	add	r2, r3, #1
10015bc4:	e30a3658 	movw	r3, #42584	; 0xa658
10015bc8:	e3413002 	movt	r3, #4098	; 0x1002
10015bcc:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10015bd0:	e30a3658 	movw	r3, #42584	; 0xa658
10015bd4:	e3413002 	movt	r3, #4098	; 0x1002
10015bd8:	e5933000 	ldr	r3, [r3]
10015bdc:	e51b201c 	ldr	r2, [fp, #-28]
10015be0:	e2822014 	add	r2, r2, #20
10015be4:	e6ef2072 	uxtb	r2, r2
10015be8:	e5c32000 	strb	r2, [r3]
10015bec:	e30a3658 	movw	r3, #42584	; 0xa658
10015bf0:	e3413002 	movt	r3, #4098	; 0x1002
10015bf4:	e5933000 	ldr	r3, [r3]
10015bf8:	e2833001 	add	r3, r3, #1
10015bfc:	e51b201c 	ldr	r2, [fp, #-28]
10015c00:	e2822014 	add	r2, r2, #20
10015c04:	e1a02422 	lsr	r2, r2, #8
10015c08:	e6ef2072 	uxtb	r2, r2
10015c0c:	e5c32000 	strb	r2, [r3]
10015c10:	e30a3658 	movw	r3, #42584	; 0xa658
10015c14:	e3413002 	movt	r3, #4098	; 0x1002
10015c18:	e5933000 	ldr	r3, [r3]
10015c1c:	e2833002 	add	r3, r3, #2
10015c20:	e51b201c 	ldr	r2, [fp, #-28]
10015c24:	e2822014 	add	r2, r2, #20
10015c28:	e1a02822 	lsr	r2, r2, #16
10015c2c:	e6ef2072 	uxtb	r2, r2
10015c30:	e5c32000 	strb	r2, [r3]
10015c34:	e30a3658 	movw	r3, #42584	; 0xa658
10015c38:	e3413002 	movt	r3, #4098	; 0x1002
10015c3c:	e5933000 	ldr	r3, [r3]
10015c40:	e2833003 	add	r3, r3, #3
10015c44:	e51b201c 	ldr	r2, [fp, #-28]
10015c48:	e2822014 	add	r2, r2, #20
10015c4c:	e1a02c22 	lsr	r2, r2, #24
10015c50:	e6ef2072 	uxtb	r2, r2
10015c54:	e5c32000 	strb	r2, [r3]
10015c58:	e30a3658 	movw	r3, #42584	; 0xa658
10015c5c:	e3413002 	movt	r3, #4098	; 0x1002
10015c60:	e5933000 	ldr	r3, [r3]
10015c64:	e2832004 	add	r2, r3, #4
10015c68:	e30a3658 	movw	r3, #42584	; 0xa658
10015c6c:	e3413002 	movt	r3, #4098	; 0x1002
10015c70:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
10015c74:	e30a3658 	movw	r3, #42584	; 0xa658
10015c78:	e3413002 	movt	r3, #4098	; 0x1002
10015c7c:	e5933000 	ldr	r3, [r3]
10015c80:	e3a02022 	mov	r2, #34	; 0x22
10015c84:	e5c32000 	strb	r2, [r3]
10015c88:	e30a3658 	movw	r3, #42584	; 0xa658
10015c8c:	e3413002 	movt	r3, #4098	; 0x1002
10015c90:	e5933000 	ldr	r3, [r3]
10015c94:	e2832001 	add	r2, r3, #1
10015c98:	e30a3658 	movw	r3, #42584	; 0xa658
10015c9c:	e3413002 	movt	r3, #4098	; 0x1002
10015ca0:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
10015ca4:	e30a3658 	movw	r3, #42584	; 0xa658
10015ca8:	e3413002 	movt	r3, #4098	; 0x1002
10015cac:	e5933000 	ldr	r3, [r3]
10015cb0:	e3a02001 	mov	r2, #1
10015cb4:	e5c32000 	strb	r2, [r3]
10015cb8:	e30a3658 	movw	r3, #42584	; 0xa658
10015cbc:	e3413002 	movt	r3, #4098	; 0x1002
10015cc0:	e5933000 	ldr	r3, [r3]
10015cc4:	e2832001 	add	r2, r3, #1
10015cc8:	e30a3658 	movw	r3, #42584	; 0xa658
10015ccc:	e3413002 	movt	r3, #4098	; 0x1002
10015cd0:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
10015cd4:	e30a3658 	movw	r3, #42584	; 0xa658
10015cd8:	e3413002 	movt	r3, #4098	; 0x1002
10015cdc:	e5933000 	ldr	r3, [r3]
10015ce0:	e3a02004 	mov	r2, #4
10015ce4:	e5c32000 	strb	r2, [r3]
10015ce8:	e30a3658 	movw	r3, #42584	; 0xa658
10015cec:	e3413002 	movt	r3, #4098	; 0x1002
10015cf0:	e5933000 	ldr	r3, [r3]
10015cf4:	e2832001 	add	r2, r3, #1
10015cf8:	e30a3658 	movw	r3, #42584	; 0xa658
10015cfc:	e3413002 	movt	r3, #4098	; 0x1002
10015d00:	e5832000 	str	r2, [r3]
                    /* st_byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
10015d04:	e30a3658 	movw	r3, #42584	; 0xa658
10015d08:	e3413002 	movt	r3, #4098	; 0x1002
10015d0c:	e5933000 	ldr	r3, [r3]
10015d10:	e3a02028 	mov	r2, #40	; 0x28
10015d14:	e5c32000 	strb	r2, [r3]
10015d18:	e30a3658 	movw	r3, #42584	; 0xa658
10015d1c:	e3413002 	movt	r3, #4098	; 0x1002
10015d20:	e5933000 	ldr	r3, [r3]
10015d24:	e2832001 	add	r2, r3, #1
10015d28:	e30a3658 	movw	r3, #42584	; 0xa658
10015d2c:	e3413002 	movt	r3, #4098	; 0x1002
10015d30:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10015d34:	e30a3658 	movw	r3, #42584	; 0xa658
10015d38:	e3413002 	movt	r3, #4098	; 0x1002
10015d3c:	e5933000 	ldr	r3, [r3]
10015d40:	e3a0202f 	mov	r2, #47	; 0x2f
10015d44:	e5c32000 	strb	r2, [r3]
10015d48:	e30a3658 	movw	r3, #42584	; 0xa658
10015d4c:	e3413002 	movt	r3, #4098	; 0x1002
10015d50:	e5933000 	ldr	r3, [r3]
10015d54:	e2832001 	add	r2, r3, #1
10015d58:	e30a3658 	movw	r3, #42584	; 0xa658
10015d5c:	e3413002 	movt	r3, #4098	; 0x1002
10015d60:	e5832000 	str	r2, [r3]

                    break;
10015d64:	ea0000fb 	b	10016158 <finsh_compile+0x243c>
                case FINSH_DATA_TYPE_WORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10015d68:	e30a3658 	movw	r3, #42584	; 0xa658
10015d6c:	e3413002 	movt	r3, #4098	; 0x1002
10015d70:	e5933000 	ldr	r3, [r3]
10015d74:	e3a02026 	mov	r2, #38	; 0x26
10015d78:	e5c32000 	strb	r2, [r3]
10015d7c:	e30a3658 	movw	r3, #42584	; 0xa658
10015d80:	e3413002 	movt	r3, #4098	; 0x1002
10015d84:	e5933000 	ldr	r3, [r3]
10015d88:	e2832001 	add	r2, r3, #1
10015d8c:	e30a3658 	movw	r3, #42584	; 0xa658
10015d90:	e3413002 	movt	r3, #4098	; 0x1002
10015d94:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10015d98:	e30a3658 	movw	r3, #42584	; 0xa658
10015d9c:	e3413002 	movt	r3, #4098	; 0x1002
10015da0:	e5933000 	ldr	r3, [r3]
10015da4:	e51b201c 	ldr	r2, [fp, #-28]
10015da8:	e2822014 	add	r2, r2, #20
10015dac:	e6ef2072 	uxtb	r2, r2
10015db0:	e5c32000 	strb	r2, [r3]
10015db4:	e30a3658 	movw	r3, #42584	; 0xa658
10015db8:	e3413002 	movt	r3, #4098	; 0x1002
10015dbc:	e5933000 	ldr	r3, [r3]
10015dc0:	e2833001 	add	r3, r3, #1
10015dc4:	e51b201c 	ldr	r2, [fp, #-28]
10015dc8:	e2822014 	add	r2, r2, #20
10015dcc:	e1a02422 	lsr	r2, r2, #8
10015dd0:	e6ef2072 	uxtb	r2, r2
10015dd4:	e5c32000 	strb	r2, [r3]
10015dd8:	e30a3658 	movw	r3, #42584	; 0xa658
10015ddc:	e3413002 	movt	r3, #4098	; 0x1002
10015de0:	e5933000 	ldr	r3, [r3]
10015de4:	e2833002 	add	r3, r3, #2
10015de8:	e51b201c 	ldr	r2, [fp, #-28]
10015dec:	e2822014 	add	r2, r2, #20
10015df0:	e1a02822 	lsr	r2, r2, #16
10015df4:	e6ef2072 	uxtb	r2, r2
10015df8:	e5c32000 	strb	r2, [r3]
10015dfc:	e30a3658 	movw	r3, #42584	; 0xa658
10015e00:	e3413002 	movt	r3, #4098	; 0x1002
10015e04:	e5933000 	ldr	r3, [r3]
10015e08:	e2833003 	add	r3, r3, #3
10015e0c:	e51b201c 	ldr	r2, [fp, #-28]
10015e10:	e2822014 	add	r2, r2, #20
10015e14:	e1a02c22 	lsr	r2, r2, #24
10015e18:	e6ef2072 	uxtb	r2, r2
10015e1c:	e5c32000 	strb	r2, [r3]
10015e20:	e30a3658 	movw	r3, #42584	; 0xa658
10015e24:	e3413002 	movt	r3, #4098	; 0x1002
10015e28:	e5933000 	ldr	r3, [r3]
10015e2c:	e2832004 	add	r2, r3, #4
10015e30:	e30a3658 	movw	r3, #42584	; 0xa658
10015e34:	e3413002 	movt	r3, #4098	; 0x1002
10015e38:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
10015e3c:	e30a3658 	movw	r3, #42584	; 0xa658
10015e40:	e3413002 	movt	r3, #4098	; 0x1002
10015e44:	e5933000 	ldr	r3, [r3]
10015e48:	e3a02023 	mov	r2, #35	; 0x23
10015e4c:	e5c32000 	strb	r2, [r3]
10015e50:	e30a3658 	movw	r3, #42584	; 0xa658
10015e54:	e3413002 	movt	r3, #4098	; 0x1002
10015e58:	e5933000 	ldr	r3, [r3]
10015e5c:	e2832001 	add	r2, r3, #1
10015e60:	e30a3658 	movw	r3, #42584	; 0xa658
10015e64:	e3413002 	movt	r3, #4098	; 0x1002
10015e68:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
10015e6c:	e30a3658 	movw	r3, #42584	; 0xa658
10015e70:	e3413002 	movt	r3, #4098	; 0x1002
10015e74:	e5933000 	ldr	r3, [r3]
10015e78:	e3a02001 	mov	r2, #1
10015e7c:	e5c32000 	strb	r2, [r3]
10015e80:	e30a3658 	movw	r3, #42584	; 0xa658
10015e84:	e3413002 	movt	r3, #4098	; 0x1002
10015e88:	e5933000 	ldr	r3, [r3]
10015e8c:	e2833001 	add	r3, r3, #1
10015e90:	e3a02000 	mov	r2, #0
10015e94:	e5c32000 	strb	r2, [r3]
10015e98:	e30a3658 	movw	r3, #42584	; 0xa658
10015e9c:	e3413002 	movt	r3, #4098	; 0x1002
10015ea0:	e5933000 	ldr	r3, [r3]
10015ea4:	e2832002 	add	r2, r3, #2
10015ea8:	e30a3658 	movw	r3, #42584	; 0xa658
10015eac:	e3413002 	movt	r3, #4098	; 0x1002
10015eb0:	e5832000 	str	r2, [r3]

                    /* add_word */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
10015eb4:	e30a3658 	movw	r3, #42584	; 0xa658
10015eb8:	e3413002 	movt	r3, #4098	; 0x1002
10015ebc:	e5933000 	ldr	r3, [r3]
10015ec0:	e3a02005 	mov	r2, #5
10015ec4:	e5c32000 	strb	r2, [r3]
10015ec8:	e30a3658 	movw	r3, #42584	; 0xa658
10015ecc:	e3413002 	movt	r3, #4098	; 0x1002
10015ed0:	e5933000 	ldr	r3, [r3]
10015ed4:	e2832001 	add	r2, r3, #1
10015ed8:	e30a3658 	movw	r3, #42584	; 0xa658
10015edc:	e3413002 	movt	r3, #4098	; 0x1002
10015ee0:	e5832000 	str	r2, [r3]
                    /* st_word */
                    finsh_code_byte(FINSH_OP_ST_WORD);
10015ee4:	e30a3658 	movw	r3, #42584	; 0xa658
10015ee8:	e3413002 	movt	r3, #4098	; 0x1002
10015eec:	e5933000 	ldr	r3, [r3]
10015ef0:	e3a02029 	mov	r2, #41	; 0x29
10015ef4:	e5c32000 	strb	r2, [r3]
10015ef8:	e30a3658 	movw	r3, #42584	; 0xa658
10015efc:	e3413002 	movt	r3, #4098	; 0x1002
10015f00:	e5933000 	ldr	r3, [r3]
10015f04:	e2832001 	add	r2, r3, #1
10015f08:	e30a3658 	movw	r3, #42584	; 0xa658
10015f0c:	e3413002 	movt	r3, #4098	; 0x1002
10015f10:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10015f14:	e30a3658 	movw	r3, #42584	; 0xa658
10015f18:	e3413002 	movt	r3, #4098	; 0x1002
10015f1c:	e5933000 	ldr	r3, [r3]
10015f20:	e3a0202f 	mov	r2, #47	; 0x2f
10015f24:	e5c32000 	strb	r2, [r3]
10015f28:	e30a3658 	movw	r3, #42584	; 0xa658
10015f2c:	e3413002 	movt	r3, #4098	; 0x1002
10015f30:	e5933000 	ldr	r3, [r3]
10015f34:	e2832001 	add	r2, r3, #1
10015f38:	e30a3658 	movw	r3, #42584	; 0xa658
10015f3c:	e3413002 	movt	r3, #4098	; 0x1002
10015f40:	e5832000 	str	r2, [r3]

                    break;
10015f44:	ea000083 	b	10016158 <finsh_compile+0x243c>
                case FINSH_DATA_TYPE_DWORD:
                    /* address */
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10015f48:	e30a3658 	movw	r3, #42584	; 0xa658
10015f4c:	e3413002 	movt	r3, #4098	; 0x1002
10015f50:	e5933000 	ldr	r3, [r3]
10015f54:	e3a02027 	mov	r2, #39	; 0x27
10015f58:	e5c32000 	strb	r2, [r3]
10015f5c:	e30a3658 	movw	r3, #42584	; 0xa658
10015f60:	e3413002 	movt	r3, #4098	; 0x1002
10015f64:	e5933000 	ldr	r3, [r3]
10015f68:	e2832001 	add	r2, r3, #1
10015f6c:	e30a3658 	movw	r3, #42584	; 0xa658
10015f70:	e3413002 	movt	r3, #4098	; 0x1002
10015f74:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10015f78:	e30a3658 	movw	r3, #42584	; 0xa658
10015f7c:	e3413002 	movt	r3, #4098	; 0x1002
10015f80:	e5933000 	ldr	r3, [r3]
10015f84:	e51b201c 	ldr	r2, [fp, #-28]
10015f88:	e2822014 	add	r2, r2, #20
10015f8c:	e6ef2072 	uxtb	r2, r2
10015f90:	e5c32000 	strb	r2, [r3]
10015f94:	e30a3658 	movw	r3, #42584	; 0xa658
10015f98:	e3413002 	movt	r3, #4098	; 0x1002
10015f9c:	e5933000 	ldr	r3, [r3]
10015fa0:	e2833001 	add	r3, r3, #1
10015fa4:	e51b201c 	ldr	r2, [fp, #-28]
10015fa8:	e2822014 	add	r2, r2, #20
10015fac:	e1a02422 	lsr	r2, r2, #8
10015fb0:	e6ef2072 	uxtb	r2, r2
10015fb4:	e5c32000 	strb	r2, [r3]
10015fb8:	e30a3658 	movw	r3, #42584	; 0xa658
10015fbc:	e3413002 	movt	r3, #4098	; 0x1002
10015fc0:	e5933000 	ldr	r3, [r3]
10015fc4:	e2833002 	add	r3, r3, #2
10015fc8:	e51b201c 	ldr	r2, [fp, #-28]
10015fcc:	e2822014 	add	r2, r2, #20
10015fd0:	e1a02822 	lsr	r2, r2, #16
10015fd4:	e6ef2072 	uxtb	r2, r2
10015fd8:	e5c32000 	strb	r2, [r3]
10015fdc:	e30a3658 	movw	r3, #42584	; 0xa658
10015fe0:	e3413002 	movt	r3, #4098	; 0x1002
10015fe4:	e5933000 	ldr	r3, [r3]
10015fe8:	e2833003 	add	r3, r3, #3
10015fec:	e51b201c 	ldr	r2, [fp, #-28]
10015ff0:	e2822014 	add	r2, r2, #20
10015ff4:	e1a02c22 	lsr	r2, r2, #24
10015ff8:	e6ef2072 	uxtb	r2, r2
10015ffc:	e5c32000 	strb	r2, [r3]
10016000:	e30a3658 	movw	r3, #42584	; 0xa658
10016004:	e3413002 	movt	r3, #4098	; 0x1002
10016008:	e5933000 	ldr	r3, [r3]
1001600c:	e2832004 	add	r2, r3, #4
10016010:	e30a3658 	movw	r3, #42584	; 0xa658
10016014:	e3413002 	movt	r3, #4098	; 0x1002
10016018:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
1001601c:	e30a3658 	movw	r3, #42584	; 0xa658
10016020:	e3413002 	movt	r3, #4098	; 0x1002
10016024:	e5933000 	ldr	r3, [r3]
10016028:	e3a02024 	mov	r2, #36	; 0x24
1001602c:	e5c32000 	strb	r2, [r3]
10016030:	e30a3658 	movw	r3, #42584	; 0xa658
10016034:	e3413002 	movt	r3, #4098	; 0x1002
10016038:	e5933000 	ldr	r3, [r3]
1001603c:	e2832001 	add	r2, r3, #1
10016040:	e30a3658 	movw	r3, #42584	; 0xa658
10016044:	e3413002 	movt	r3, #4098	; 0x1002
10016048:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
1001604c:	e30a3658 	movw	r3, #42584	; 0xa658
10016050:	e3413002 	movt	r3, #4098	; 0x1002
10016054:	e5933000 	ldr	r3, [r3]
10016058:	e3a02001 	mov	r2, #1
1001605c:	e5c32000 	strb	r2, [r3]
10016060:	e30a3658 	movw	r3, #42584	; 0xa658
10016064:	e3413002 	movt	r3, #4098	; 0x1002
10016068:	e5933000 	ldr	r3, [r3]
1001606c:	e2833001 	add	r3, r3, #1
10016070:	e3a02000 	mov	r2, #0
10016074:	e5c32000 	strb	r2, [r3]
10016078:	e30a3658 	movw	r3, #42584	; 0xa658
1001607c:	e3413002 	movt	r3, #4098	; 0x1002
10016080:	e5933000 	ldr	r3, [r3]
10016084:	e2833002 	add	r3, r3, #2
10016088:	e3a02000 	mov	r2, #0
1001608c:	e5c32000 	strb	r2, [r3]
10016090:	e30a3658 	movw	r3, #42584	; 0xa658
10016094:	e3413002 	movt	r3, #4098	; 0x1002
10016098:	e5933000 	ldr	r3, [r3]
1001609c:	e2833003 	add	r3, r3, #3
100160a0:	e3a02000 	mov	r2, #0
100160a4:	e5c32000 	strb	r2, [r3]
100160a8:	e30a3658 	movw	r3, #42584	; 0xa658
100160ac:	e3413002 	movt	r3, #4098	; 0x1002
100160b0:	e5933000 	ldr	r3, [r3]
100160b4:	e2832004 	add	r2, r3, #4
100160b8:	e30a3658 	movw	r3, #42584	; 0xa658
100160bc:	e3413002 	movt	r3, #4098	; 0x1002
100160c0:	e5832000 	str	r2, [r3]

                    /* add_dword */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
100160c4:	e30a3658 	movw	r3, #42584	; 0xa658
100160c8:	e3413002 	movt	r3, #4098	; 0x1002
100160cc:	e5933000 	ldr	r3, [r3]
100160d0:	e3a02006 	mov	r2, #6
100160d4:	e5c32000 	strb	r2, [r3]
100160d8:	e30a3658 	movw	r3, #42584	; 0xa658
100160dc:	e3413002 	movt	r3, #4098	; 0x1002
100160e0:	e5933000 	ldr	r3, [r3]
100160e4:	e2832001 	add	r2, r3, #1
100160e8:	e30a3658 	movw	r3, #42584	; 0xa658
100160ec:	e3413002 	movt	r3, #4098	; 0x1002
100160f0:	e5832000 	str	r2, [r3]
                    /* st_dword */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
100160f4:	e30a3658 	movw	r3, #42584	; 0xa658
100160f8:	e3413002 	movt	r3, #4098	; 0x1002
100160fc:	e5933000 	ldr	r3, [r3]
10016100:	e3a0202a 	mov	r2, #42	; 0x2a
10016104:	e5c32000 	strb	r2, [r3]
10016108:	e30a3658 	movw	r3, #42584	; 0xa658
1001610c:	e3413002 	movt	r3, #4098	; 0x1002
10016110:	e5933000 	ldr	r3, [r3]
10016114:	e2832001 	add	r2, r3, #1
10016118:	e30a3658 	movw	r3, #42584	; 0xa658
1001611c:	e3413002 	movt	r3, #4098	; 0x1002
10016120:	e5832000 	str	r2, [r3]

                    /* load value again */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10016124:	e30a3658 	movw	r3, #42584	; 0xa658
10016128:	e3413002 	movt	r3, #4098	; 0x1002
1001612c:	e5933000 	ldr	r3, [r3]
10016130:	e3a0202f 	mov	r2, #47	; 0x2f
10016134:	e5c32000 	strb	r2, [r3]
10016138:	e30a3658 	movw	r3, #42584	; 0xa658
1001613c:	e3413002 	movt	r3, #4098	; 0x1002
10016140:	e5933000 	ldr	r3, [r3]
10016144:	e2832001 	add	r2, r3, #1
10016148:	e30a3658 	movw	r3, #42584	; 0xa658
1001614c:	e3413002 	movt	r3, #4098	; 0x1002
10016150:	e5832000 	str	r2, [r3]

                    break;
10016154:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
10016158:	ea0004a2 	b	100173e8 <finsh_compile+0x36cc>

        /* increase */
        case FINSH_NODE_SYS_INC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
1001615c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016160:	e5933010 	ldr	r3, [r3, #16]
10016164:	e3530000 	cmp	r3, #0
10016168:	0a00021e 	beq	100169e8 <finsh_compile+0x2ccc>
1001616c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016170:	e5933010 	ldr	r3, [r3, #16]
10016174:	e5d33000 	ldrb	r3, [r3]
10016178:	e3530001 	cmp	r3, #1
1001617c:	1a000219 	bne	100169e8 <finsh_compile+0x2ccc>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
10016180:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016184:	e5933010 	ldr	r3, [r3, #16]
10016188:	e5933008 	ldr	r3, [r3, #8]
1001618c:	e50b3020 	str	r3, [fp, #-32]

                switch (node->data_type)
10016190:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016194:	e5d33001 	ldrb	r3, [r3, #1]
10016198:	e3530002 	cmp	r3, #2
1001619c:	0a0000ab 	beq	10016450 <finsh_compile+0x2734>
100161a0:	e3530003 	cmp	r3, #3
100161a4:	0a000156 	beq	10016704 <finsh_compile+0x29e8>
100161a8:	e3530001 	cmp	r3, #1
100161ac:	0a000000 	beq	100161b4 <finsh_compile+0x2498>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
100161b0:	ea00048c 	b	100173e8 <finsh_compile+0x36cc>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
100161b4:	e30a3658 	movw	r3, #42584	; 0xa658
100161b8:	e3413002 	movt	r3, #4098	; 0x1002
100161bc:	e5933000 	ldr	r3, [r3]
100161c0:	e3a02024 	mov	r2, #36	; 0x24
100161c4:	e5c32000 	strb	r2, [r3]
100161c8:	e30a3658 	movw	r3, #42584	; 0xa658
100161cc:	e3413002 	movt	r3, #4098	; 0x1002
100161d0:	e5933000 	ldr	r3, [r3]
100161d4:	e2832001 	add	r2, r3, #1
100161d8:	e30a3658 	movw	r3, #42584	; 0xa658
100161dc:	e3413002 	movt	r3, #4098	; 0x1002
100161e0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
100161e4:	e30a3658 	movw	r3, #42584	; 0xa658
100161e8:	e3413002 	movt	r3, #4098	; 0x1002
100161ec:	e5933000 	ldr	r3, [r3]
100161f0:	e51b2020 	ldr	r2, [fp, #-32]
100161f4:	e2822014 	add	r2, r2, #20
100161f8:	e6ef2072 	uxtb	r2, r2
100161fc:	e5c32000 	strb	r2, [r3]
10016200:	e30a3658 	movw	r3, #42584	; 0xa658
10016204:	e3413002 	movt	r3, #4098	; 0x1002
10016208:	e5933000 	ldr	r3, [r3]
1001620c:	e2833001 	add	r3, r3, #1
10016210:	e51b2020 	ldr	r2, [fp, #-32]
10016214:	e2822014 	add	r2, r2, #20
10016218:	e1a02422 	lsr	r2, r2, #8
1001621c:	e6ef2072 	uxtb	r2, r2
10016220:	e5c32000 	strb	r2, [r3]
10016224:	e30a3658 	movw	r3, #42584	; 0xa658
10016228:	e3413002 	movt	r3, #4098	; 0x1002
1001622c:	e5933000 	ldr	r3, [r3]
10016230:	e2833002 	add	r3, r3, #2
10016234:	e51b2020 	ldr	r2, [fp, #-32]
10016238:	e2822014 	add	r2, r2, #20
1001623c:	e1a02822 	lsr	r2, r2, #16
10016240:	e6ef2072 	uxtb	r2, r2
10016244:	e5c32000 	strb	r2, [r3]
10016248:	e30a3658 	movw	r3, #42584	; 0xa658
1001624c:	e3413002 	movt	r3, #4098	; 0x1002
10016250:	e5933000 	ldr	r3, [r3]
10016254:	e2833003 	add	r3, r3, #3
10016258:	e51b2020 	ldr	r2, [fp, #-32]
1001625c:	e2822014 	add	r2, r2, #20
10016260:	e1a02c22 	lsr	r2, r2, #24
10016264:	e6ef2072 	uxtb	r2, r2
10016268:	e5c32000 	strb	r2, [r3]
1001626c:	e30a3658 	movw	r3, #42584	; 0xa658
10016270:	e3413002 	movt	r3, #4098	; 0x1002
10016274:	e5933000 	ldr	r3, [r3]
10016278:	e2832004 	add	r2, r3, #4
1001627c:	e30a3658 	movw	r3, #42584	; 0xa658
10016280:	e3413002 	movt	r3, #4098	; 0x1002
10016284:	e5832000 	str	r2, [r3]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10016288:	e30a3658 	movw	r3, #42584	; 0xa658
1001628c:	e3413002 	movt	r3, #4098	; 0x1002
10016290:	e5933000 	ldr	r3, [r3]
10016294:	e3a02025 	mov	r2, #37	; 0x25
10016298:	e5c32000 	strb	r2, [r3]
1001629c:	e30a3658 	movw	r3, #42584	; 0xa658
100162a0:	e3413002 	movt	r3, #4098	; 0x1002
100162a4:	e5933000 	ldr	r3, [r3]
100162a8:	e2832001 	add	r2, r3, #1
100162ac:	e30a3658 	movw	r3, #42584	; 0xa658
100162b0:	e3413002 	movt	r3, #4098	; 0x1002
100162b4:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
100162b8:	e30a3658 	movw	r3, #42584	; 0xa658
100162bc:	e3413002 	movt	r3, #4098	; 0x1002
100162c0:	e5933000 	ldr	r3, [r3]
100162c4:	e51b2020 	ldr	r2, [fp, #-32]
100162c8:	e2822014 	add	r2, r2, #20
100162cc:	e6ef2072 	uxtb	r2, r2
100162d0:	e5c32000 	strb	r2, [r3]
100162d4:	e30a3658 	movw	r3, #42584	; 0xa658
100162d8:	e3413002 	movt	r3, #4098	; 0x1002
100162dc:	e5933000 	ldr	r3, [r3]
100162e0:	e2833001 	add	r3, r3, #1
100162e4:	e51b2020 	ldr	r2, [fp, #-32]
100162e8:	e2822014 	add	r2, r2, #20
100162ec:	e1a02422 	lsr	r2, r2, #8
100162f0:	e6ef2072 	uxtb	r2, r2
100162f4:	e5c32000 	strb	r2, [r3]
100162f8:	e30a3658 	movw	r3, #42584	; 0xa658
100162fc:	e3413002 	movt	r3, #4098	; 0x1002
10016300:	e5933000 	ldr	r3, [r3]
10016304:	e2833002 	add	r3, r3, #2
10016308:	e51b2020 	ldr	r2, [fp, #-32]
1001630c:	e2822014 	add	r2, r2, #20
10016310:	e1a02822 	lsr	r2, r2, #16
10016314:	e6ef2072 	uxtb	r2, r2
10016318:	e5c32000 	strb	r2, [r3]
1001631c:	e30a3658 	movw	r3, #42584	; 0xa658
10016320:	e3413002 	movt	r3, #4098	; 0x1002
10016324:	e5933000 	ldr	r3, [r3]
10016328:	e2833003 	add	r3, r3, #3
1001632c:	e51b2020 	ldr	r2, [fp, #-32]
10016330:	e2822014 	add	r2, r2, #20
10016334:	e1a02c22 	lsr	r2, r2, #24
10016338:	e6ef2072 	uxtb	r2, r2
1001633c:	e5c32000 	strb	r2, [r3]
10016340:	e30a3658 	movw	r3, #42584	; 0xa658
10016344:	e3413002 	movt	r3, #4098	; 0x1002
10016348:	e5933000 	ldr	r3, [r3]
1001634c:	e2832004 	add	r2, r3, #4
10016350:	e30a3658 	movw	r3, #42584	; 0xa658
10016354:	e3413002 	movt	r3, #4098	; 0x1002
10016358:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
1001635c:	e30a3658 	movw	r3, #42584	; 0xa658
10016360:	e3413002 	movt	r3, #4098	; 0x1002
10016364:	e5933000 	ldr	r3, [r3]
10016368:	e3a02022 	mov	r2, #34	; 0x22
1001636c:	e5c32000 	strb	r2, [r3]
10016370:	e30a3658 	movw	r3, #42584	; 0xa658
10016374:	e3413002 	movt	r3, #4098	; 0x1002
10016378:	e5933000 	ldr	r3, [r3]
1001637c:	e2832001 	add	r2, r3, #1
10016380:	e30a3658 	movw	r3, #42584	; 0xa658
10016384:	e3413002 	movt	r3, #4098	; 0x1002
10016388:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
1001638c:	e30a3658 	movw	r3, #42584	; 0xa658
10016390:	e3413002 	movt	r3, #4098	; 0x1002
10016394:	e5933000 	ldr	r3, [r3]
10016398:	e3a02001 	mov	r2, #1
1001639c:	e5c32000 	strb	r2, [r3]
100163a0:	e30a3658 	movw	r3, #42584	; 0xa658
100163a4:	e3413002 	movt	r3, #4098	; 0x1002
100163a8:	e5933000 	ldr	r3, [r3]
100163ac:	e2832001 	add	r2, r3, #1
100163b0:	e30a3658 	movw	r3, #42584	; 0xa658
100163b4:	e3413002 	movt	r3, #4098	; 0x1002
100163b8:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_BYTE);
100163bc:	e30a3658 	movw	r3, #42584	; 0xa658
100163c0:	e3413002 	movt	r3, #4098	; 0x1002
100163c4:	e5933000 	ldr	r3, [r3]
100163c8:	e3a02001 	mov	r2, #1
100163cc:	e5c32000 	strb	r2, [r3]
100163d0:	e30a3658 	movw	r3, #42584	; 0xa658
100163d4:	e3413002 	movt	r3, #4098	; 0x1002
100163d8:	e5933000 	ldr	r3, [r3]
100163dc:	e2832001 	add	r2, r3, #1
100163e0:	e30a3658 	movw	r3, #42584	; 0xa658
100163e4:	e3413002 	movt	r3, #4098	; 0x1002
100163e8:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
100163ec:	e30a3658 	movw	r3, #42584	; 0xa658
100163f0:	e3413002 	movt	r3, #4098	; 0x1002
100163f4:	e5933000 	ldr	r3, [r3]
100163f8:	e3a02028 	mov	r2, #40	; 0x28
100163fc:	e5c32000 	strb	r2, [r3]
10016400:	e30a3658 	movw	r3, #42584	; 0xa658
10016404:	e3413002 	movt	r3, #4098	; 0x1002
10016408:	e5933000 	ldr	r3, [r3]
1001640c:	e2832001 	add	r2, r3, #1
10016410:	e30a3658 	movw	r3, #42584	; 0xa658
10016414:	e3413002 	movt	r3, #4098	; 0x1002
10016418:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
1001641c:	e30a3658 	movw	r3, #42584	; 0xa658
10016420:	e3413002 	movt	r3, #4098	; 0x1002
10016424:	e5933000 	ldr	r3, [r3]
10016428:	e3a0202b 	mov	r2, #43	; 0x2b
1001642c:	e5c32000 	strb	r2, [r3]
10016430:	e30a3658 	movw	r3, #42584	; 0xa658
10016434:	e3413002 	movt	r3, #4098	; 0x1002
10016438:	e5933000 	ldr	r3, [r3]
1001643c:	e2832001 	add	r2, r3, #1
10016440:	e30a3658 	movw	r3, #42584	; 0xa658
10016444:	e3413002 	movt	r3, #4098	; 0x1002
10016448:	e5832000 	str	r2, [r3]
                    break;
1001644c:	ea000165 	b	100169e8 <finsh_compile+0x2ccc>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10016450:	e30a3658 	movw	r3, #42584	; 0xa658
10016454:	e3413002 	movt	r3, #4098	; 0x1002
10016458:	e5933000 	ldr	r3, [r3]
1001645c:	e3a02024 	mov	r2, #36	; 0x24
10016460:	e5c32000 	strb	r2, [r3]
10016464:	e30a3658 	movw	r3, #42584	; 0xa658
10016468:	e3413002 	movt	r3, #4098	; 0x1002
1001646c:	e5933000 	ldr	r3, [r3]
10016470:	e2832001 	add	r2, r3, #1
10016474:	e30a3658 	movw	r3, #42584	; 0xa658
10016478:	e3413002 	movt	r3, #4098	; 0x1002
1001647c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10016480:	e30a3658 	movw	r3, #42584	; 0xa658
10016484:	e3413002 	movt	r3, #4098	; 0x1002
10016488:	e5933000 	ldr	r3, [r3]
1001648c:	e51b2020 	ldr	r2, [fp, #-32]
10016490:	e2822014 	add	r2, r2, #20
10016494:	e6ef2072 	uxtb	r2, r2
10016498:	e5c32000 	strb	r2, [r3]
1001649c:	e30a3658 	movw	r3, #42584	; 0xa658
100164a0:	e3413002 	movt	r3, #4098	; 0x1002
100164a4:	e5933000 	ldr	r3, [r3]
100164a8:	e2833001 	add	r3, r3, #1
100164ac:	e51b2020 	ldr	r2, [fp, #-32]
100164b0:	e2822014 	add	r2, r2, #20
100164b4:	e1a02422 	lsr	r2, r2, #8
100164b8:	e6ef2072 	uxtb	r2, r2
100164bc:	e5c32000 	strb	r2, [r3]
100164c0:	e30a3658 	movw	r3, #42584	; 0xa658
100164c4:	e3413002 	movt	r3, #4098	; 0x1002
100164c8:	e5933000 	ldr	r3, [r3]
100164cc:	e2833002 	add	r3, r3, #2
100164d0:	e51b2020 	ldr	r2, [fp, #-32]
100164d4:	e2822014 	add	r2, r2, #20
100164d8:	e1a02822 	lsr	r2, r2, #16
100164dc:	e6ef2072 	uxtb	r2, r2
100164e0:	e5c32000 	strb	r2, [r3]
100164e4:	e30a3658 	movw	r3, #42584	; 0xa658
100164e8:	e3413002 	movt	r3, #4098	; 0x1002
100164ec:	e5933000 	ldr	r3, [r3]
100164f0:	e2833003 	add	r3, r3, #3
100164f4:	e51b2020 	ldr	r2, [fp, #-32]
100164f8:	e2822014 	add	r2, r2, #20
100164fc:	e1a02c22 	lsr	r2, r2, #24
10016500:	e6ef2072 	uxtb	r2, r2
10016504:	e5c32000 	strb	r2, [r3]
10016508:	e30a3658 	movw	r3, #42584	; 0xa658
1001650c:	e3413002 	movt	r3, #4098	; 0x1002
10016510:	e5933000 	ldr	r3, [r3]
10016514:	e2832004 	add	r2, r3, #4
10016518:	e30a3658 	movw	r3, #42584	; 0xa658
1001651c:	e3413002 	movt	r3, #4098	; 0x1002
10016520:	e5832000 	str	r2, [r3]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10016524:	e30a3658 	movw	r3, #42584	; 0xa658
10016528:	e3413002 	movt	r3, #4098	; 0x1002
1001652c:	e5933000 	ldr	r3, [r3]
10016530:	e3a02026 	mov	r2, #38	; 0x26
10016534:	e5c32000 	strb	r2, [r3]
10016538:	e30a3658 	movw	r3, #42584	; 0xa658
1001653c:	e3413002 	movt	r3, #4098	; 0x1002
10016540:	e5933000 	ldr	r3, [r3]
10016544:	e2832001 	add	r2, r3, #1
10016548:	e30a3658 	movw	r3, #42584	; 0xa658
1001654c:	e3413002 	movt	r3, #4098	; 0x1002
10016550:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10016554:	e30a3658 	movw	r3, #42584	; 0xa658
10016558:	e3413002 	movt	r3, #4098	; 0x1002
1001655c:	e5933000 	ldr	r3, [r3]
10016560:	e51b2020 	ldr	r2, [fp, #-32]
10016564:	e2822014 	add	r2, r2, #20
10016568:	e6ef2072 	uxtb	r2, r2
1001656c:	e5c32000 	strb	r2, [r3]
10016570:	e30a3658 	movw	r3, #42584	; 0xa658
10016574:	e3413002 	movt	r3, #4098	; 0x1002
10016578:	e5933000 	ldr	r3, [r3]
1001657c:	e2833001 	add	r3, r3, #1
10016580:	e51b2020 	ldr	r2, [fp, #-32]
10016584:	e2822014 	add	r2, r2, #20
10016588:	e1a02422 	lsr	r2, r2, #8
1001658c:	e6ef2072 	uxtb	r2, r2
10016590:	e5c32000 	strb	r2, [r3]
10016594:	e30a3658 	movw	r3, #42584	; 0xa658
10016598:	e3413002 	movt	r3, #4098	; 0x1002
1001659c:	e5933000 	ldr	r3, [r3]
100165a0:	e2833002 	add	r3, r3, #2
100165a4:	e51b2020 	ldr	r2, [fp, #-32]
100165a8:	e2822014 	add	r2, r2, #20
100165ac:	e1a02822 	lsr	r2, r2, #16
100165b0:	e6ef2072 	uxtb	r2, r2
100165b4:	e5c32000 	strb	r2, [r3]
100165b8:	e30a3658 	movw	r3, #42584	; 0xa658
100165bc:	e3413002 	movt	r3, #4098	; 0x1002
100165c0:	e5933000 	ldr	r3, [r3]
100165c4:	e2833003 	add	r3, r3, #3
100165c8:	e51b2020 	ldr	r2, [fp, #-32]
100165cc:	e2822014 	add	r2, r2, #20
100165d0:	e1a02c22 	lsr	r2, r2, #24
100165d4:	e6ef2072 	uxtb	r2, r2
100165d8:	e5c32000 	strb	r2, [r3]
100165dc:	e30a3658 	movw	r3, #42584	; 0xa658
100165e0:	e3413002 	movt	r3, #4098	; 0x1002
100165e4:	e5933000 	ldr	r3, [r3]
100165e8:	e2832004 	add	r2, r3, #4
100165ec:	e30a3658 	movw	r3, #42584	; 0xa658
100165f0:	e3413002 	movt	r3, #4098	; 0x1002
100165f4:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
100165f8:	e30a3658 	movw	r3, #42584	; 0xa658
100165fc:	e3413002 	movt	r3, #4098	; 0x1002
10016600:	e5933000 	ldr	r3, [r3]
10016604:	e3a02023 	mov	r2, #35	; 0x23
10016608:	e5c32000 	strb	r2, [r3]
1001660c:	e30a3658 	movw	r3, #42584	; 0xa658
10016610:	e3413002 	movt	r3, #4098	; 0x1002
10016614:	e5933000 	ldr	r3, [r3]
10016618:	e2832001 	add	r2, r3, #1
1001661c:	e30a3658 	movw	r3, #42584	; 0xa658
10016620:	e3413002 	movt	r3, #4098	; 0x1002
10016624:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
10016628:	e30a3658 	movw	r3, #42584	; 0xa658
1001662c:	e3413002 	movt	r3, #4098	; 0x1002
10016630:	e5933000 	ldr	r3, [r3]
10016634:	e3a02001 	mov	r2, #1
10016638:	e5c32000 	strb	r2, [r3]
1001663c:	e30a3658 	movw	r3, #42584	; 0xa658
10016640:	e3413002 	movt	r3, #4098	; 0x1002
10016644:	e5933000 	ldr	r3, [r3]
10016648:	e2833001 	add	r3, r3, #1
1001664c:	e3a02000 	mov	r2, #0
10016650:	e5c32000 	strb	r2, [r3]
10016654:	e30a3658 	movw	r3, #42584	; 0xa658
10016658:	e3413002 	movt	r3, #4098	; 0x1002
1001665c:	e5933000 	ldr	r3, [r3]
10016660:	e2832002 	add	r2, r3, #2
10016664:	e30a3658 	movw	r3, #42584	; 0xa658
10016668:	e3413002 	movt	r3, #4098	; 0x1002
1001666c:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_WORD);
10016670:	e30a3658 	movw	r3, #42584	; 0xa658
10016674:	e3413002 	movt	r3, #4098	; 0x1002
10016678:	e5933000 	ldr	r3, [r3]
1001667c:	e3a02002 	mov	r2, #2
10016680:	e5c32000 	strb	r2, [r3]
10016684:	e30a3658 	movw	r3, #42584	; 0xa658
10016688:	e3413002 	movt	r3, #4098	; 0x1002
1001668c:	e5933000 	ldr	r3, [r3]
10016690:	e2832001 	add	r2, r3, #1
10016694:	e30a3658 	movw	r3, #42584	; 0xa658
10016698:	e3413002 	movt	r3, #4098	; 0x1002
1001669c:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
100166a0:	e30a3658 	movw	r3, #42584	; 0xa658
100166a4:	e3413002 	movt	r3, #4098	; 0x1002
100166a8:	e5933000 	ldr	r3, [r3]
100166ac:	e3a02029 	mov	r2, #41	; 0x29
100166b0:	e5c32000 	strb	r2, [r3]
100166b4:	e30a3658 	movw	r3, #42584	; 0xa658
100166b8:	e3413002 	movt	r3, #4098	; 0x1002
100166bc:	e5933000 	ldr	r3, [r3]
100166c0:	e2832001 	add	r2, r3, #1
100166c4:	e30a3658 	movw	r3, #42584	; 0xa658
100166c8:	e3413002 	movt	r3, #4098	; 0x1002
100166cc:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
100166d0:	e30a3658 	movw	r3, #42584	; 0xa658
100166d4:	e3413002 	movt	r3, #4098	; 0x1002
100166d8:	e5933000 	ldr	r3, [r3]
100166dc:	e3a0202b 	mov	r2, #43	; 0x2b
100166e0:	e5c32000 	strb	r2, [r3]
100166e4:	e30a3658 	movw	r3, #42584	; 0xa658
100166e8:	e3413002 	movt	r3, #4098	; 0x1002
100166ec:	e5933000 	ldr	r3, [r3]
100166f0:	e2832001 	add	r2, r3, #1
100166f4:	e30a3658 	movw	r3, #42584	; 0xa658
100166f8:	e3413002 	movt	r3, #4098	; 0x1002
100166fc:	e5832000 	str	r2, [r3]
                    break;
10016700:	ea0000b8 	b	100169e8 <finsh_compile+0x2ccc>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10016704:	e30a3658 	movw	r3, #42584	; 0xa658
10016708:	e3413002 	movt	r3, #4098	; 0x1002
1001670c:	e5933000 	ldr	r3, [r3]
10016710:	e3a02024 	mov	r2, #36	; 0x24
10016714:	e5c32000 	strb	r2, [r3]
10016718:	e30a3658 	movw	r3, #42584	; 0xa658
1001671c:	e3413002 	movt	r3, #4098	; 0x1002
10016720:	e5933000 	ldr	r3, [r3]
10016724:	e2832001 	add	r2, r3, #1
10016728:	e30a3658 	movw	r3, #42584	; 0xa658
1001672c:	e3413002 	movt	r3, #4098	; 0x1002
10016730:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10016734:	e30a3658 	movw	r3, #42584	; 0xa658
10016738:	e3413002 	movt	r3, #4098	; 0x1002
1001673c:	e5933000 	ldr	r3, [r3]
10016740:	e51b2020 	ldr	r2, [fp, #-32]
10016744:	e2822014 	add	r2, r2, #20
10016748:	e6ef2072 	uxtb	r2, r2
1001674c:	e5c32000 	strb	r2, [r3]
10016750:	e30a3658 	movw	r3, #42584	; 0xa658
10016754:	e3413002 	movt	r3, #4098	; 0x1002
10016758:	e5933000 	ldr	r3, [r3]
1001675c:	e2833001 	add	r3, r3, #1
10016760:	e51b2020 	ldr	r2, [fp, #-32]
10016764:	e2822014 	add	r2, r2, #20
10016768:	e1a02422 	lsr	r2, r2, #8
1001676c:	e6ef2072 	uxtb	r2, r2
10016770:	e5c32000 	strb	r2, [r3]
10016774:	e30a3658 	movw	r3, #42584	; 0xa658
10016778:	e3413002 	movt	r3, #4098	; 0x1002
1001677c:	e5933000 	ldr	r3, [r3]
10016780:	e2833002 	add	r3, r3, #2
10016784:	e51b2020 	ldr	r2, [fp, #-32]
10016788:	e2822014 	add	r2, r2, #20
1001678c:	e1a02822 	lsr	r2, r2, #16
10016790:	e6ef2072 	uxtb	r2, r2
10016794:	e5c32000 	strb	r2, [r3]
10016798:	e30a3658 	movw	r3, #42584	; 0xa658
1001679c:	e3413002 	movt	r3, #4098	; 0x1002
100167a0:	e5933000 	ldr	r3, [r3]
100167a4:	e2833003 	add	r3, r3, #3
100167a8:	e51b2020 	ldr	r2, [fp, #-32]
100167ac:	e2822014 	add	r2, r2, #20
100167b0:	e1a02c22 	lsr	r2, r2, #24
100167b4:	e6ef2072 	uxtb	r2, r2
100167b8:	e5c32000 	strb	r2, [r3]
100167bc:	e30a3658 	movw	r3, #42584	; 0xa658
100167c0:	e3413002 	movt	r3, #4098	; 0x1002
100167c4:	e5933000 	ldr	r3, [r3]
100167c8:	e2832004 	add	r2, r3, #4
100167cc:	e30a3658 	movw	r3, #42584	; 0xa658
100167d0:	e3413002 	movt	r3, #4098	; 0x1002
100167d4:	e5832000 	str	r2, [r3]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
100167d8:	e30a3658 	movw	r3, #42584	; 0xa658
100167dc:	e3413002 	movt	r3, #4098	; 0x1002
100167e0:	e5933000 	ldr	r3, [r3]
100167e4:	e3a02027 	mov	r2, #39	; 0x27
100167e8:	e5c32000 	strb	r2, [r3]
100167ec:	e30a3658 	movw	r3, #42584	; 0xa658
100167f0:	e3413002 	movt	r3, #4098	; 0x1002
100167f4:	e5933000 	ldr	r3, [r3]
100167f8:	e2832001 	add	r2, r3, #1
100167fc:	e30a3658 	movw	r3, #42584	; 0xa658
10016800:	e3413002 	movt	r3, #4098	; 0x1002
10016804:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10016808:	e30a3658 	movw	r3, #42584	; 0xa658
1001680c:	e3413002 	movt	r3, #4098	; 0x1002
10016810:	e5933000 	ldr	r3, [r3]
10016814:	e51b2020 	ldr	r2, [fp, #-32]
10016818:	e2822014 	add	r2, r2, #20
1001681c:	e6ef2072 	uxtb	r2, r2
10016820:	e5c32000 	strb	r2, [r3]
10016824:	e30a3658 	movw	r3, #42584	; 0xa658
10016828:	e3413002 	movt	r3, #4098	; 0x1002
1001682c:	e5933000 	ldr	r3, [r3]
10016830:	e2833001 	add	r3, r3, #1
10016834:	e51b2020 	ldr	r2, [fp, #-32]
10016838:	e2822014 	add	r2, r2, #20
1001683c:	e1a02422 	lsr	r2, r2, #8
10016840:	e6ef2072 	uxtb	r2, r2
10016844:	e5c32000 	strb	r2, [r3]
10016848:	e30a3658 	movw	r3, #42584	; 0xa658
1001684c:	e3413002 	movt	r3, #4098	; 0x1002
10016850:	e5933000 	ldr	r3, [r3]
10016854:	e2833002 	add	r3, r3, #2
10016858:	e51b2020 	ldr	r2, [fp, #-32]
1001685c:	e2822014 	add	r2, r2, #20
10016860:	e1a02822 	lsr	r2, r2, #16
10016864:	e6ef2072 	uxtb	r2, r2
10016868:	e5c32000 	strb	r2, [r3]
1001686c:	e30a3658 	movw	r3, #42584	; 0xa658
10016870:	e3413002 	movt	r3, #4098	; 0x1002
10016874:	e5933000 	ldr	r3, [r3]
10016878:	e2833003 	add	r3, r3, #3
1001687c:	e51b2020 	ldr	r2, [fp, #-32]
10016880:	e2822014 	add	r2, r2, #20
10016884:	e1a02c22 	lsr	r2, r2, #24
10016888:	e6ef2072 	uxtb	r2, r2
1001688c:	e5c32000 	strb	r2, [r3]
10016890:	e30a3658 	movw	r3, #42584	; 0xa658
10016894:	e3413002 	movt	r3, #4098	; 0x1002
10016898:	e5933000 	ldr	r3, [r3]
1001689c:	e2832004 	add	r2, r3, #4
100168a0:	e30a3658 	movw	r3, #42584	; 0xa658
100168a4:	e3413002 	movt	r3, #4098	; 0x1002
100168a8:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
100168ac:	e30a3658 	movw	r3, #42584	; 0xa658
100168b0:	e3413002 	movt	r3, #4098	; 0x1002
100168b4:	e5933000 	ldr	r3, [r3]
100168b8:	e3a02024 	mov	r2, #36	; 0x24
100168bc:	e5c32000 	strb	r2, [r3]
100168c0:	e30a3658 	movw	r3, #42584	; 0xa658
100168c4:	e3413002 	movt	r3, #4098	; 0x1002
100168c8:	e5933000 	ldr	r3, [r3]
100168cc:	e2832001 	add	r2, r3, #1
100168d0:	e30a3658 	movw	r3, #42584	; 0xa658
100168d4:	e3413002 	movt	r3, #4098	; 0x1002
100168d8:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
100168dc:	e30a3658 	movw	r3, #42584	; 0xa658
100168e0:	e3413002 	movt	r3, #4098	; 0x1002
100168e4:	e5933000 	ldr	r3, [r3]
100168e8:	e3a02001 	mov	r2, #1
100168ec:	e5c32000 	strb	r2, [r3]
100168f0:	e30a3658 	movw	r3, #42584	; 0xa658
100168f4:	e3413002 	movt	r3, #4098	; 0x1002
100168f8:	e5933000 	ldr	r3, [r3]
100168fc:	e2833001 	add	r3, r3, #1
10016900:	e3a02000 	mov	r2, #0
10016904:	e5c32000 	strb	r2, [r3]
10016908:	e30a3658 	movw	r3, #42584	; 0xa658
1001690c:	e3413002 	movt	r3, #4098	; 0x1002
10016910:	e5933000 	ldr	r3, [r3]
10016914:	e2833002 	add	r3, r3, #2
10016918:	e3a02000 	mov	r2, #0
1001691c:	e5c32000 	strb	r2, [r3]
10016920:	e30a3658 	movw	r3, #42584	; 0xa658
10016924:	e3413002 	movt	r3, #4098	; 0x1002
10016928:	e5933000 	ldr	r3, [r3]
1001692c:	e2833003 	add	r3, r3, #3
10016930:	e3a02000 	mov	r2, #0
10016934:	e5c32000 	strb	r2, [r3]
10016938:	e30a3658 	movw	r3, #42584	; 0xa658
1001693c:	e3413002 	movt	r3, #4098	; 0x1002
10016940:	e5933000 	ldr	r3, [r3]
10016944:	e2832004 	add	r2, r3, #4
10016948:	e30a3658 	movw	r3, #42584	; 0xa658
1001694c:	e3413002 	movt	r3, #4098	; 0x1002
10016950:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_ADD_DWORD);
10016954:	e30a3658 	movw	r3, #42584	; 0xa658
10016958:	e3413002 	movt	r3, #4098	; 0x1002
1001695c:	e5933000 	ldr	r3, [r3]
10016960:	e3a02003 	mov	r2, #3
10016964:	e5c32000 	strb	r2, [r3]
10016968:	e30a3658 	movw	r3, #42584	; 0xa658
1001696c:	e3413002 	movt	r3, #4098	; 0x1002
10016970:	e5933000 	ldr	r3, [r3]
10016974:	e2832001 	add	r2, r3, #1
10016978:	e30a3658 	movw	r3, #42584	; 0xa658
1001697c:	e3413002 	movt	r3, #4098	; 0x1002
10016980:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10016984:	e30a3658 	movw	r3, #42584	; 0xa658
10016988:	e3413002 	movt	r3, #4098	; 0x1002
1001698c:	e5933000 	ldr	r3, [r3]
10016990:	e3a0202a 	mov	r2, #42	; 0x2a
10016994:	e5c32000 	strb	r2, [r3]
10016998:	e30a3658 	movw	r3, #42584	; 0xa658
1001699c:	e3413002 	movt	r3, #4098	; 0x1002
100169a0:	e5933000 	ldr	r3, [r3]
100169a4:	e2832001 	add	r2, r3, #1
100169a8:	e30a3658 	movw	r3, #42584	; 0xa658
100169ac:	e3413002 	movt	r3, #4098	; 0x1002
100169b0:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
100169b4:	e30a3658 	movw	r3, #42584	; 0xa658
100169b8:	e3413002 	movt	r3, #4098	; 0x1002
100169bc:	e5933000 	ldr	r3, [r3]
100169c0:	e3a0202b 	mov	r2, #43	; 0x2b
100169c4:	e5c32000 	strb	r2, [r3]
100169c8:	e30a3658 	movw	r3, #42584	; 0xa658
100169cc:	e3413002 	movt	r3, #4098	; 0x1002
100169d0:	e5933000 	ldr	r3, [r3]
100169d4:	e2832001 	add	r2, r3, #1
100169d8:	e30a3658 	movw	r3, #42584	; 0xa658
100169dc:	e3413002 	movt	r3, #4098	; 0x1002
100169e0:	e5832000 	str	r2, [r3]
                    break;
100169e4:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
100169e8:	ea00027e 	b	100173e8 <finsh_compile+0x36cc>

        /* decrease */
        case FINSH_NODE_SYS_DEC:
            if (finsh_node_child(node) && finsh_node_child(node)->node_type == FINSH_NODE_ID)
100169ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100169f0:	e5933010 	ldr	r3, [r3, #16]
100169f4:	e3530000 	cmp	r3, #0
100169f8:	0a00021e 	beq	10017278 <finsh_compile+0x355c>
100169fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016a00:	e5933010 	ldr	r3, [r3, #16]
10016a04:	e5d33000 	ldrb	r3, [r3]
10016a08:	e3530001 	cmp	r3, #1
10016a0c:	1a000219 	bne	10017278 <finsh_compile+0x355c>
            {
                struct finsh_var* var;
                var = finsh_node_child(node)->id.var;
10016a10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016a14:	e5933010 	ldr	r3, [r3, #16]
10016a18:	e5933008 	ldr	r3, [r3, #8]
10016a1c:	e50b3024 	str	r3, [fp, #-36]	; 0x24

                switch (node->data_type)
10016a20:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10016a24:	e5d33001 	ldrb	r3, [r3, #1]
10016a28:	e3530002 	cmp	r3, #2
10016a2c:	0a0000ab 	beq	10016ce0 <finsh_compile+0x2fc4>
10016a30:	e3530003 	cmp	r3, #3
10016a34:	0a000156 	beq	10016f94 <finsh_compile+0x3278>
10016a38:	e3530001 	cmp	r3, #1
10016a3c:	0a000000 	beq	10016a44 <finsh_compile+0x2d28>
                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
                    break;
                }
            }
            break;
10016a40:	ea000268 	b	100173e8 <finsh_compile+0x36cc>
                    /* ld_value_byte &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
                    // finsh_code_dword((long)&(var->value.char_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10016a44:	e30a3658 	movw	r3, #42584	; 0xa658
10016a48:	e3413002 	movt	r3, #4098	; 0x1002
10016a4c:	e5933000 	ldr	r3, [r3]
10016a50:	e3a02024 	mov	r2, #36	; 0x24
10016a54:	e5c32000 	strb	r2, [r3]
10016a58:	e30a3658 	movw	r3, #42584	; 0xa658
10016a5c:	e3413002 	movt	r3, #4098	; 0x1002
10016a60:	e5933000 	ldr	r3, [r3]
10016a64:	e2832001 	add	r2, r3, #1
10016a68:	e30a3658 	movw	r3, #42584	; 0xa658
10016a6c:	e3413002 	movt	r3, #4098	; 0x1002
10016a70:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10016a74:	e30a3658 	movw	r3, #42584	; 0xa658
10016a78:	e3413002 	movt	r3, #4098	; 0x1002
10016a7c:	e5933000 	ldr	r3, [r3]
10016a80:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016a84:	e2822014 	add	r2, r2, #20
10016a88:	e6ef2072 	uxtb	r2, r2
10016a8c:	e5c32000 	strb	r2, [r3]
10016a90:	e30a3658 	movw	r3, #42584	; 0xa658
10016a94:	e3413002 	movt	r3, #4098	; 0x1002
10016a98:	e5933000 	ldr	r3, [r3]
10016a9c:	e2833001 	add	r3, r3, #1
10016aa0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016aa4:	e2822014 	add	r2, r2, #20
10016aa8:	e1a02422 	lsr	r2, r2, #8
10016aac:	e6ef2072 	uxtb	r2, r2
10016ab0:	e5c32000 	strb	r2, [r3]
10016ab4:	e30a3658 	movw	r3, #42584	; 0xa658
10016ab8:	e3413002 	movt	r3, #4098	; 0x1002
10016abc:	e5933000 	ldr	r3, [r3]
10016ac0:	e2833002 	add	r3, r3, #2
10016ac4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016ac8:	e2822014 	add	r2, r2, #20
10016acc:	e1a02822 	lsr	r2, r2, #16
10016ad0:	e6ef2072 	uxtb	r2, r2
10016ad4:	e5c32000 	strb	r2, [r3]
10016ad8:	e30a3658 	movw	r3, #42584	; 0xa658
10016adc:	e3413002 	movt	r3, #4098	; 0x1002
10016ae0:	e5933000 	ldr	r3, [r3]
10016ae4:	e2833003 	add	r3, r3, #3
10016ae8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016aec:	e2822014 	add	r2, r2, #20
10016af0:	e1a02c22 	lsr	r2, r2, #24
10016af4:	e6ef2072 	uxtb	r2, r2
10016af8:	e5c32000 	strb	r2, [r3]
10016afc:	e30a3658 	movw	r3, #42584	; 0xa658
10016b00:	e3413002 	movt	r3, #4098	; 0x1002
10016b04:	e5933000 	ldr	r3, [r3]
10016b08:	e2832004 	add	r2, r3, #4
10016b0c:	e30a3658 	movw	r3, #42584	; 0xa658
10016b10:	e3413002 	movt	r3, #4098	; 0x1002
10016b14:	e5832000 	str	r2, [r3]

                    /* ld_value_byte &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE);
10016b18:	e30a3658 	movw	r3, #42584	; 0xa658
10016b1c:	e3413002 	movt	r3, #4098	; 0x1002
10016b20:	e5933000 	ldr	r3, [r3]
10016b24:	e3a02025 	mov	r2, #37	; 0x25
10016b28:	e5c32000 	strb	r2, [r3]
10016b2c:	e30a3658 	movw	r3, #42584	; 0xa658
10016b30:	e3413002 	movt	r3, #4098	; 0x1002
10016b34:	e5933000 	ldr	r3, [r3]
10016b38:	e2832001 	add	r2, r3, #1
10016b3c:	e30a3658 	movw	r3, #42584	; 0xa658
10016b40:	e3413002 	movt	r3, #4098	; 0x1002
10016b44:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.char_value));
10016b48:	e30a3658 	movw	r3, #42584	; 0xa658
10016b4c:	e3413002 	movt	r3, #4098	; 0x1002
10016b50:	e5933000 	ldr	r3, [r3]
10016b54:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016b58:	e2822014 	add	r2, r2, #20
10016b5c:	e6ef2072 	uxtb	r2, r2
10016b60:	e5c32000 	strb	r2, [r3]
10016b64:	e30a3658 	movw	r3, #42584	; 0xa658
10016b68:	e3413002 	movt	r3, #4098	; 0x1002
10016b6c:	e5933000 	ldr	r3, [r3]
10016b70:	e2833001 	add	r3, r3, #1
10016b74:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016b78:	e2822014 	add	r2, r2, #20
10016b7c:	e1a02422 	lsr	r2, r2, #8
10016b80:	e6ef2072 	uxtb	r2, r2
10016b84:	e5c32000 	strb	r2, [r3]
10016b88:	e30a3658 	movw	r3, #42584	; 0xa658
10016b8c:	e3413002 	movt	r3, #4098	; 0x1002
10016b90:	e5933000 	ldr	r3, [r3]
10016b94:	e2833002 	add	r3, r3, #2
10016b98:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016b9c:	e2822014 	add	r2, r2, #20
10016ba0:	e1a02822 	lsr	r2, r2, #16
10016ba4:	e6ef2072 	uxtb	r2, r2
10016ba8:	e5c32000 	strb	r2, [r3]
10016bac:	e30a3658 	movw	r3, #42584	; 0xa658
10016bb0:	e3413002 	movt	r3, #4098	; 0x1002
10016bb4:	e5933000 	ldr	r3, [r3]
10016bb8:	e2833003 	add	r3, r3, #3
10016bbc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016bc0:	e2822014 	add	r2, r2, #20
10016bc4:	e1a02c22 	lsr	r2, r2, #24
10016bc8:	e6ef2072 	uxtb	r2, r2
10016bcc:	e5c32000 	strb	r2, [r3]
10016bd0:	e30a3658 	movw	r3, #42584	; 0xa658
10016bd4:	e3413002 	movt	r3, #4098	; 0x1002
10016bd8:	e5933000 	ldr	r3, [r3]
10016bdc:	e2832004 	add	r2, r3, #4
10016be0:	e30a3658 	movw	r3, #42584	; 0xa658
10016be4:	e3413002 	movt	r3, #4098	; 0x1002
10016be8:	e5832000 	str	r2, [r3]

                    /* ld_byte 1 */
                    finsh_code_byte(FINSH_OP_LD_BYTE);
10016bec:	e30a3658 	movw	r3, #42584	; 0xa658
10016bf0:	e3413002 	movt	r3, #4098	; 0x1002
10016bf4:	e5933000 	ldr	r3, [r3]
10016bf8:	e3a02022 	mov	r2, #34	; 0x22
10016bfc:	e5c32000 	strb	r2, [r3]
10016c00:	e30a3658 	movw	r3, #42584	; 0xa658
10016c04:	e3413002 	movt	r3, #4098	; 0x1002
10016c08:	e5933000 	ldr	r3, [r3]
10016c0c:	e2832001 	add	r2, r3, #1
10016c10:	e30a3658 	movw	r3, #42584	; 0xa658
10016c14:	e3413002 	movt	r3, #4098	; 0x1002
10016c18:	e5832000 	str	r2, [r3]
                    finsh_code_byte(1);
10016c1c:	e30a3658 	movw	r3, #42584	; 0xa658
10016c20:	e3413002 	movt	r3, #4098	; 0x1002
10016c24:	e5933000 	ldr	r3, [r3]
10016c28:	e3a02001 	mov	r2, #1
10016c2c:	e5c32000 	strb	r2, [r3]
10016c30:	e30a3658 	movw	r3, #42584	; 0xa658
10016c34:	e3413002 	movt	r3, #4098	; 0x1002
10016c38:	e5933000 	ldr	r3, [r3]
10016c3c:	e2832001 	add	r2, r3, #1
10016c40:	e30a3658 	movw	r3, #42584	; 0xa658
10016c44:	e3413002 	movt	r3, #4098	; 0x1002
10016c48:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_BYTE);
10016c4c:	e30a3658 	movw	r3, #42584	; 0xa658
10016c50:	e3413002 	movt	r3, #4098	; 0x1002
10016c54:	e5933000 	ldr	r3, [r3]
10016c58:	e3a02004 	mov	r2, #4
10016c5c:	e5c32000 	strb	r2, [r3]
10016c60:	e30a3658 	movw	r3, #42584	; 0xa658
10016c64:	e3413002 	movt	r3, #4098	; 0x1002
10016c68:	e5933000 	ldr	r3, [r3]
10016c6c:	e2832001 	add	r2, r3, #1
10016c70:	e30a3658 	movw	r3, #42584	; 0xa658
10016c74:	e3413002 	movt	r3, #4098	; 0x1002
10016c78:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_BYTE);
10016c7c:	e30a3658 	movw	r3, #42584	; 0xa658
10016c80:	e3413002 	movt	r3, #4098	; 0x1002
10016c84:	e5933000 	ldr	r3, [r3]
10016c88:	e3a02028 	mov	r2, #40	; 0x28
10016c8c:	e5c32000 	strb	r2, [r3]
10016c90:	e30a3658 	movw	r3, #42584	; 0xa658
10016c94:	e3413002 	movt	r3, #4098	; 0x1002
10016c98:	e5933000 	ldr	r3, [r3]
10016c9c:	e2832001 	add	r2, r3, #1
10016ca0:	e30a3658 	movw	r3, #42584	; 0xa658
10016ca4:	e3413002 	movt	r3, #4098	; 0x1002
10016ca8:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10016cac:	e30a3658 	movw	r3, #42584	; 0xa658
10016cb0:	e3413002 	movt	r3, #4098	; 0x1002
10016cb4:	e5933000 	ldr	r3, [r3]
10016cb8:	e3a0202b 	mov	r2, #43	; 0x2b
10016cbc:	e5c32000 	strb	r2, [r3]
10016cc0:	e30a3658 	movw	r3, #42584	; 0xa658
10016cc4:	e3413002 	movt	r3, #4098	; 0x1002
10016cc8:	e5933000 	ldr	r3, [r3]
10016ccc:	e2832001 	add	r2, r3, #1
10016cd0:	e30a3658 	movw	r3, #42584	; 0xa658
10016cd4:	e3413002 	movt	r3, #4098	; 0x1002
10016cd8:	e5832000 	str	r2, [r3]
                    break;
10016cdc:	ea000165 	b	10017278 <finsh_compile+0x355c>
                    /* ld_value_word &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
                    // finsh_code_dword((long)&(var->value.short_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10016ce0:	e30a3658 	movw	r3, #42584	; 0xa658
10016ce4:	e3413002 	movt	r3, #4098	; 0x1002
10016ce8:	e5933000 	ldr	r3, [r3]
10016cec:	e3a02024 	mov	r2, #36	; 0x24
10016cf0:	e5c32000 	strb	r2, [r3]
10016cf4:	e30a3658 	movw	r3, #42584	; 0xa658
10016cf8:	e3413002 	movt	r3, #4098	; 0x1002
10016cfc:	e5933000 	ldr	r3, [r3]
10016d00:	e2832001 	add	r2, r3, #1
10016d04:	e30a3658 	movw	r3, #42584	; 0xa658
10016d08:	e3413002 	movt	r3, #4098	; 0x1002
10016d0c:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10016d10:	e30a3658 	movw	r3, #42584	; 0xa658
10016d14:	e3413002 	movt	r3, #4098	; 0x1002
10016d18:	e5933000 	ldr	r3, [r3]
10016d1c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016d20:	e2822014 	add	r2, r2, #20
10016d24:	e6ef2072 	uxtb	r2, r2
10016d28:	e5c32000 	strb	r2, [r3]
10016d2c:	e30a3658 	movw	r3, #42584	; 0xa658
10016d30:	e3413002 	movt	r3, #4098	; 0x1002
10016d34:	e5933000 	ldr	r3, [r3]
10016d38:	e2833001 	add	r3, r3, #1
10016d3c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016d40:	e2822014 	add	r2, r2, #20
10016d44:	e1a02422 	lsr	r2, r2, #8
10016d48:	e6ef2072 	uxtb	r2, r2
10016d4c:	e5c32000 	strb	r2, [r3]
10016d50:	e30a3658 	movw	r3, #42584	; 0xa658
10016d54:	e3413002 	movt	r3, #4098	; 0x1002
10016d58:	e5933000 	ldr	r3, [r3]
10016d5c:	e2833002 	add	r3, r3, #2
10016d60:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016d64:	e2822014 	add	r2, r2, #20
10016d68:	e1a02822 	lsr	r2, r2, #16
10016d6c:	e6ef2072 	uxtb	r2, r2
10016d70:	e5c32000 	strb	r2, [r3]
10016d74:	e30a3658 	movw	r3, #42584	; 0xa658
10016d78:	e3413002 	movt	r3, #4098	; 0x1002
10016d7c:	e5933000 	ldr	r3, [r3]
10016d80:	e2833003 	add	r3, r3, #3
10016d84:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016d88:	e2822014 	add	r2, r2, #20
10016d8c:	e1a02c22 	lsr	r2, r2, #24
10016d90:	e6ef2072 	uxtb	r2, r2
10016d94:	e5c32000 	strb	r2, [r3]
10016d98:	e30a3658 	movw	r3, #42584	; 0xa658
10016d9c:	e3413002 	movt	r3, #4098	; 0x1002
10016da0:	e5933000 	ldr	r3, [r3]
10016da4:	e2832004 	add	r2, r3, #4
10016da8:	e30a3658 	movw	r3, #42584	; 0xa658
10016dac:	e3413002 	movt	r3, #4098	; 0x1002
10016db0:	e5832000 	str	r2, [r3]

                    /* ld_value_word &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD);
10016db4:	e30a3658 	movw	r3, #42584	; 0xa658
10016db8:	e3413002 	movt	r3, #4098	; 0x1002
10016dbc:	e5933000 	ldr	r3, [r3]
10016dc0:	e3a02026 	mov	r2, #38	; 0x26
10016dc4:	e5c32000 	strb	r2, [r3]
10016dc8:	e30a3658 	movw	r3, #42584	; 0xa658
10016dcc:	e3413002 	movt	r3, #4098	; 0x1002
10016dd0:	e5933000 	ldr	r3, [r3]
10016dd4:	e2832001 	add	r2, r3, #1
10016dd8:	e30a3658 	movw	r3, #42584	; 0xa658
10016ddc:	e3413002 	movt	r3, #4098	; 0x1002
10016de0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.short_value));
10016de4:	e30a3658 	movw	r3, #42584	; 0xa658
10016de8:	e3413002 	movt	r3, #4098	; 0x1002
10016dec:	e5933000 	ldr	r3, [r3]
10016df0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016df4:	e2822014 	add	r2, r2, #20
10016df8:	e6ef2072 	uxtb	r2, r2
10016dfc:	e5c32000 	strb	r2, [r3]
10016e00:	e30a3658 	movw	r3, #42584	; 0xa658
10016e04:	e3413002 	movt	r3, #4098	; 0x1002
10016e08:	e5933000 	ldr	r3, [r3]
10016e0c:	e2833001 	add	r3, r3, #1
10016e10:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016e14:	e2822014 	add	r2, r2, #20
10016e18:	e1a02422 	lsr	r2, r2, #8
10016e1c:	e6ef2072 	uxtb	r2, r2
10016e20:	e5c32000 	strb	r2, [r3]
10016e24:	e30a3658 	movw	r3, #42584	; 0xa658
10016e28:	e3413002 	movt	r3, #4098	; 0x1002
10016e2c:	e5933000 	ldr	r3, [r3]
10016e30:	e2833002 	add	r3, r3, #2
10016e34:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016e38:	e2822014 	add	r2, r2, #20
10016e3c:	e1a02822 	lsr	r2, r2, #16
10016e40:	e6ef2072 	uxtb	r2, r2
10016e44:	e5c32000 	strb	r2, [r3]
10016e48:	e30a3658 	movw	r3, #42584	; 0xa658
10016e4c:	e3413002 	movt	r3, #4098	; 0x1002
10016e50:	e5933000 	ldr	r3, [r3]
10016e54:	e2833003 	add	r3, r3, #3
10016e58:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016e5c:	e2822014 	add	r2, r2, #20
10016e60:	e1a02c22 	lsr	r2, r2, #24
10016e64:	e6ef2072 	uxtb	r2, r2
10016e68:	e5c32000 	strb	r2, [r3]
10016e6c:	e30a3658 	movw	r3, #42584	; 0xa658
10016e70:	e3413002 	movt	r3, #4098	; 0x1002
10016e74:	e5933000 	ldr	r3, [r3]
10016e78:	e2832004 	add	r2, r3, #4
10016e7c:	e30a3658 	movw	r3, #42584	; 0xa658
10016e80:	e3413002 	movt	r3, #4098	; 0x1002
10016e84:	e5832000 	str	r2, [r3]

                    /* ld_word 1 */
                    finsh_code_byte(FINSH_OP_LD_WORD);
10016e88:	e30a3658 	movw	r3, #42584	; 0xa658
10016e8c:	e3413002 	movt	r3, #4098	; 0x1002
10016e90:	e5933000 	ldr	r3, [r3]
10016e94:	e3a02023 	mov	r2, #35	; 0x23
10016e98:	e5c32000 	strb	r2, [r3]
10016e9c:	e30a3658 	movw	r3, #42584	; 0xa658
10016ea0:	e3413002 	movt	r3, #4098	; 0x1002
10016ea4:	e5933000 	ldr	r3, [r3]
10016ea8:	e2832001 	add	r2, r3, #1
10016eac:	e30a3658 	movw	r3, #42584	; 0xa658
10016eb0:	e3413002 	movt	r3, #4098	; 0x1002
10016eb4:	e5832000 	str	r2, [r3]
                    finsh_code_word(1);
10016eb8:	e30a3658 	movw	r3, #42584	; 0xa658
10016ebc:	e3413002 	movt	r3, #4098	; 0x1002
10016ec0:	e5933000 	ldr	r3, [r3]
10016ec4:	e3a02001 	mov	r2, #1
10016ec8:	e5c32000 	strb	r2, [r3]
10016ecc:	e30a3658 	movw	r3, #42584	; 0xa658
10016ed0:	e3413002 	movt	r3, #4098	; 0x1002
10016ed4:	e5933000 	ldr	r3, [r3]
10016ed8:	e2833001 	add	r3, r3, #1
10016edc:	e3a02000 	mov	r2, #0
10016ee0:	e5c32000 	strb	r2, [r3]
10016ee4:	e30a3658 	movw	r3, #42584	; 0xa658
10016ee8:	e3413002 	movt	r3, #4098	; 0x1002
10016eec:	e5933000 	ldr	r3, [r3]
10016ef0:	e2832002 	add	r2, r3, #2
10016ef4:	e30a3658 	movw	r3, #42584	; 0xa658
10016ef8:	e3413002 	movt	r3, #4098	; 0x1002
10016efc:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_WORD);
10016f00:	e30a3658 	movw	r3, #42584	; 0xa658
10016f04:	e3413002 	movt	r3, #4098	; 0x1002
10016f08:	e5933000 	ldr	r3, [r3]
10016f0c:	e3a02005 	mov	r2, #5
10016f10:	e5c32000 	strb	r2, [r3]
10016f14:	e30a3658 	movw	r3, #42584	; 0xa658
10016f18:	e3413002 	movt	r3, #4098	; 0x1002
10016f1c:	e5933000 	ldr	r3, [r3]
10016f20:	e2832001 	add	r2, r3, #1
10016f24:	e30a3658 	movw	r3, #42584	; 0xa658
10016f28:	e3413002 	movt	r3, #4098	; 0x1002
10016f2c:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_WORD);
10016f30:	e30a3658 	movw	r3, #42584	; 0xa658
10016f34:	e3413002 	movt	r3, #4098	; 0x1002
10016f38:	e5933000 	ldr	r3, [r3]
10016f3c:	e3a02029 	mov	r2, #41	; 0x29
10016f40:	e5c32000 	strb	r2, [r3]
10016f44:	e30a3658 	movw	r3, #42584	; 0xa658
10016f48:	e3413002 	movt	r3, #4098	; 0x1002
10016f4c:	e5933000 	ldr	r3, [r3]
10016f50:	e2832001 	add	r2, r3, #1
10016f54:	e30a3658 	movw	r3, #42584	; 0xa658
10016f58:	e3413002 	movt	r3, #4098	; 0x1002
10016f5c:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10016f60:	e30a3658 	movw	r3, #42584	; 0xa658
10016f64:	e3413002 	movt	r3, #4098	; 0x1002
10016f68:	e5933000 	ldr	r3, [r3]
10016f6c:	e3a0202b 	mov	r2, #43	; 0x2b
10016f70:	e5c32000 	strb	r2, [r3]
10016f74:	e30a3658 	movw	r3, #42584	; 0xa658
10016f78:	e3413002 	movt	r3, #4098	; 0x1002
10016f7c:	e5933000 	ldr	r3, [r3]
10016f80:	e2832001 	add	r2, r3, #1
10016f84:	e30a3658 	movw	r3, #42584	; 0xa658
10016f88:	e3413002 	movt	r3, #4098	; 0x1002
10016f8c:	e5832000 	str	r2, [r3]
                    break;
10016f90:	ea0000b8 	b	10017278 <finsh_compile+0x355c>
                    /* ld_value_dword &id */
                    // finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
                    // finsh_code_dword((long)&(var->value.long_value));

                    /* ld_dword &id */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
10016f94:	e30a3658 	movw	r3, #42584	; 0xa658
10016f98:	e3413002 	movt	r3, #4098	; 0x1002
10016f9c:	e5933000 	ldr	r3, [r3]
10016fa0:	e3a02024 	mov	r2, #36	; 0x24
10016fa4:	e5c32000 	strb	r2, [r3]
10016fa8:	e30a3658 	movw	r3, #42584	; 0xa658
10016fac:	e3413002 	movt	r3, #4098	; 0x1002
10016fb0:	e5933000 	ldr	r3, [r3]
10016fb4:	e2832001 	add	r2, r3, #1
10016fb8:	e30a3658 	movw	r3, #42584	; 0xa658
10016fbc:	e3413002 	movt	r3, #4098	; 0x1002
10016fc0:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10016fc4:	e30a3658 	movw	r3, #42584	; 0xa658
10016fc8:	e3413002 	movt	r3, #4098	; 0x1002
10016fcc:	e5933000 	ldr	r3, [r3]
10016fd0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016fd4:	e2822014 	add	r2, r2, #20
10016fd8:	e6ef2072 	uxtb	r2, r2
10016fdc:	e5c32000 	strb	r2, [r3]
10016fe0:	e30a3658 	movw	r3, #42584	; 0xa658
10016fe4:	e3413002 	movt	r3, #4098	; 0x1002
10016fe8:	e5933000 	ldr	r3, [r3]
10016fec:	e2833001 	add	r3, r3, #1
10016ff0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10016ff4:	e2822014 	add	r2, r2, #20
10016ff8:	e1a02422 	lsr	r2, r2, #8
10016ffc:	e6ef2072 	uxtb	r2, r2
10017000:	e5c32000 	strb	r2, [r3]
10017004:	e30a3658 	movw	r3, #42584	; 0xa658
10017008:	e3413002 	movt	r3, #4098	; 0x1002
1001700c:	e5933000 	ldr	r3, [r3]
10017010:	e2833002 	add	r3, r3, #2
10017014:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10017018:	e2822014 	add	r2, r2, #20
1001701c:	e1a02822 	lsr	r2, r2, #16
10017020:	e6ef2072 	uxtb	r2, r2
10017024:	e5c32000 	strb	r2, [r3]
10017028:	e30a3658 	movw	r3, #42584	; 0xa658
1001702c:	e3413002 	movt	r3, #4098	; 0x1002
10017030:	e5933000 	ldr	r3, [r3]
10017034:	e2833003 	add	r3, r3, #3
10017038:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
1001703c:	e2822014 	add	r2, r2, #20
10017040:	e1a02c22 	lsr	r2, r2, #24
10017044:	e6ef2072 	uxtb	r2, r2
10017048:	e5c32000 	strb	r2, [r3]
1001704c:	e30a3658 	movw	r3, #42584	; 0xa658
10017050:	e3413002 	movt	r3, #4098	; 0x1002
10017054:	e5933000 	ldr	r3, [r3]
10017058:	e2832004 	add	r2, r3, #4
1001705c:	e30a3658 	movw	r3, #42584	; 0xa658
10017060:	e3413002 	movt	r3, #4098	; 0x1002
10017064:	e5832000 	str	r2, [r3]

                    /* ld_value_dword &id */
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD);
10017068:	e30a3658 	movw	r3, #42584	; 0xa658
1001706c:	e3413002 	movt	r3, #4098	; 0x1002
10017070:	e5933000 	ldr	r3, [r3]
10017074:	e3a02027 	mov	r2, #39	; 0x27
10017078:	e5c32000 	strb	r2, [r3]
1001707c:	e30a3658 	movw	r3, #42584	; 0xa658
10017080:	e3413002 	movt	r3, #4098	; 0x1002
10017084:	e5933000 	ldr	r3, [r3]
10017088:	e2832001 	add	r2, r3, #1
1001708c:	e30a3658 	movw	r3, #42584	; 0xa658
10017090:	e3413002 	movt	r3, #4098	; 0x1002
10017094:	e5832000 	str	r2, [r3]
                    finsh_code_dword((long)&(var->value.long_value));
10017098:	e30a3658 	movw	r3, #42584	; 0xa658
1001709c:	e3413002 	movt	r3, #4098	; 0x1002
100170a0:	e5933000 	ldr	r3, [r3]
100170a4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100170a8:	e2822014 	add	r2, r2, #20
100170ac:	e6ef2072 	uxtb	r2, r2
100170b0:	e5c32000 	strb	r2, [r3]
100170b4:	e30a3658 	movw	r3, #42584	; 0xa658
100170b8:	e3413002 	movt	r3, #4098	; 0x1002
100170bc:	e5933000 	ldr	r3, [r3]
100170c0:	e2833001 	add	r3, r3, #1
100170c4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100170c8:	e2822014 	add	r2, r2, #20
100170cc:	e1a02422 	lsr	r2, r2, #8
100170d0:	e6ef2072 	uxtb	r2, r2
100170d4:	e5c32000 	strb	r2, [r3]
100170d8:	e30a3658 	movw	r3, #42584	; 0xa658
100170dc:	e3413002 	movt	r3, #4098	; 0x1002
100170e0:	e5933000 	ldr	r3, [r3]
100170e4:	e2833002 	add	r3, r3, #2
100170e8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
100170ec:	e2822014 	add	r2, r2, #20
100170f0:	e1a02822 	lsr	r2, r2, #16
100170f4:	e6ef2072 	uxtb	r2, r2
100170f8:	e5c32000 	strb	r2, [r3]
100170fc:	e30a3658 	movw	r3, #42584	; 0xa658
10017100:	e3413002 	movt	r3, #4098	; 0x1002
10017104:	e5933000 	ldr	r3, [r3]
10017108:	e2833003 	add	r3, r3, #3
1001710c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
10017110:	e2822014 	add	r2, r2, #20
10017114:	e1a02c22 	lsr	r2, r2, #24
10017118:	e6ef2072 	uxtb	r2, r2
1001711c:	e5c32000 	strb	r2, [r3]
10017120:	e30a3658 	movw	r3, #42584	; 0xa658
10017124:	e3413002 	movt	r3, #4098	; 0x1002
10017128:	e5933000 	ldr	r3, [r3]
1001712c:	e2832004 	add	r2, r3, #4
10017130:	e30a3658 	movw	r3, #42584	; 0xa658
10017134:	e3413002 	movt	r3, #4098	; 0x1002
10017138:	e5832000 	str	r2, [r3]

                    /* ld_dword 1 */
                    finsh_code_byte(FINSH_OP_LD_DWORD);
1001713c:	e30a3658 	movw	r3, #42584	; 0xa658
10017140:	e3413002 	movt	r3, #4098	; 0x1002
10017144:	e5933000 	ldr	r3, [r3]
10017148:	e3a02024 	mov	r2, #36	; 0x24
1001714c:	e5c32000 	strb	r2, [r3]
10017150:	e30a3658 	movw	r3, #42584	; 0xa658
10017154:	e3413002 	movt	r3, #4098	; 0x1002
10017158:	e5933000 	ldr	r3, [r3]
1001715c:	e2832001 	add	r2, r3, #1
10017160:	e30a3658 	movw	r3, #42584	; 0xa658
10017164:	e3413002 	movt	r3, #4098	; 0x1002
10017168:	e5832000 	str	r2, [r3]
                    finsh_code_dword(1);
1001716c:	e30a3658 	movw	r3, #42584	; 0xa658
10017170:	e3413002 	movt	r3, #4098	; 0x1002
10017174:	e5933000 	ldr	r3, [r3]
10017178:	e3a02001 	mov	r2, #1
1001717c:	e5c32000 	strb	r2, [r3]
10017180:	e30a3658 	movw	r3, #42584	; 0xa658
10017184:	e3413002 	movt	r3, #4098	; 0x1002
10017188:	e5933000 	ldr	r3, [r3]
1001718c:	e2833001 	add	r3, r3, #1
10017190:	e3a02000 	mov	r2, #0
10017194:	e5c32000 	strb	r2, [r3]
10017198:	e30a3658 	movw	r3, #42584	; 0xa658
1001719c:	e3413002 	movt	r3, #4098	; 0x1002
100171a0:	e5933000 	ldr	r3, [r3]
100171a4:	e2833002 	add	r3, r3, #2
100171a8:	e3a02000 	mov	r2, #0
100171ac:	e5c32000 	strb	r2, [r3]
100171b0:	e30a3658 	movw	r3, #42584	; 0xa658
100171b4:	e3413002 	movt	r3, #4098	; 0x1002
100171b8:	e5933000 	ldr	r3, [r3]
100171bc:	e2833003 	add	r3, r3, #3
100171c0:	e3a02000 	mov	r2, #0
100171c4:	e5c32000 	strb	r2, [r3]
100171c8:	e30a3658 	movw	r3, #42584	; 0xa658
100171cc:	e3413002 	movt	r3, #4098	; 0x1002
100171d0:	e5933000 	ldr	r3, [r3]
100171d4:	e2832004 	add	r2, r3, #4
100171d8:	e30a3658 	movw	r3, #42584	; 0xa658
100171dc:	e3413002 	movt	r3, #4098	; 0x1002
100171e0:	e5832000 	str	r2, [r3]

                    /* add_byte */
                    finsh_code_byte(FINSH_OP_SUB_DWORD);
100171e4:	e30a3658 	movw	r3, #42584	; 0xa658
100171e8:	e3413002 	movt	r3, #4098	; 0x1002
100171ec:	e5933000 	ldr	r3, [r3]
100171f0:	e3a02006 	mov	r2, #6
100171f4:	e5c32000 	strb	r2, [r3]
100171f8:	e30a3658 	movw	r3, #42584	; 0xa658
100171fc:	e3413002 	movt	r3, #4098	; 0x1002
10017200:	e5933000 	ldr	r3, [r3]
10017204:	e2832001 	add	r2, r3, #1
10017208:	e30a3658 	movw	r3, #42584	; 0xa658
1001720c:	e3413002 	movt	r3, #4098	; 0x1002
10017210:	e5832000 	str	r2, [r3]
                    /* get byte */
                    finsh_code_byte(FINSH_OP_ST_DWORD);
10017214:	e30a3658 	movw	r3, #42584	; 0xa658
10017218:	e3413002 	movt	r3, #4098	; 0x1002
1001721c:	e5933000 	ldr	r3, [r3]
10017220:	e3a0202a 	mov	r2, #42	; 0x2a
10017224:	e5c32000 	strb	r2, [r3]
10017228:	e30a3658 	movw	r3, #42584	; 0xa658
1001722c:	e3413002 	movt	r3, #4098	; 0x1002
10017230:	e5933000 	ldr	r3, [r3]
10017234:	e2832001 	add	r2, r3, #1
10017238:	e30a3658 	movw	r3, #42584	; 0xa658
1001723c:	e3413002 	movt	r3, #4098	; 0x1002
10017240:	e5832000 	str	r2, [r3]

                    /* pop */
                    finsh_code_byte(FINSH_OP_POP);
10017244:	e30a3658 	movw	r3, #42584	; 0xa658
10017248:	e3413002 	movt	r3, #4098	; 0x1002
1001724c:	e5933000 	ldr	r3, [r3]
10017250:	e3a0202b 	mov	r2, #43	; 0x2b
10017254:	e5c32000 	strb	r2, [r3]
10017258:	e30a3658 	movw	r3, #42584	; 0xa658
1001725c:	e3413002 	movt	r3, #4098	; 0x1002
10017260:	e5933000 	ldr	r3, [r3]
10017264:	e2832001 	add	r2, r3, #1
10017268:	e30a3658 	movw	r3, #42584	; 0xa658
1001726c:	e3413002 	movt	r3, #4098	; 0x1002
10017270:	e5832000 	str	r2, [r3]
                    break;
10017274:	e1a00000 	nop			; (mov r0, r0)
                }
            }
            break;
10017278:	ea00005a 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_NULL:
            finsh_code_dword(0);
1001727c:	e30a3658 	movw	r3, #42584	; 0xa658
10017280:	e3413002 	movt	r3, #4098	; 0x1002
10017284:	e5933000 	ldr	r3, [r3]
10017288:	e3a02000 	mov	r2, #0
1001728c:	e5c32000 	strb	r2, [r3]
10017290:	e30a3658 	movw	r3, #42584	; 0xa658
10017294:	e3413002 	movt	r3, #4098	; 0x1002
10017298:	e5933000 	ldr	r3, [r3]
1001729c:	e2833001 	add	r3, r3, #1
100172a0:	e3a02000 	mov	r2, #0
100172a4:	e5c32000 	strb	r2, [r3]
100172a8:	e30a3658 	movw	r3, #42584	; 0xa658
100172ac:	e3413002 	movt	r3, #4098	; 0x1002
100172b0:	e5933000 	ldr	r3, [r3]
100172b4:	e2833002 	add	r3, r3, #2
100172b8:	e3a02000 	mov	r2, #0
100172bc:	e5c32000 	strb	r2, [r3]
100172c0:	e30a3658 	movw	r3, #42584	; 0xa658
100172c4:	e3413002 	movt	r3, #4098	; 0x1002
100172c8:	e5933000 	ldr	r3, [r3]
100172cc:	e2833003 	add	r3, r3, #3
100172d0:	e3a02000 	mov	r2, #0
100172d4:	e5c32000 	strb	r2, [r3]
100172d8:	e30a3658 	movw	r3, #42584	; 0xa658
100172dc:	e3413002 	movt	r3, #4098	; 0x1002
100172e0:	e5933000 	ldr	r3, [r3]
100172e4:	e2832004 	add	r2, r3, #4
100172e8:	e30a3658 	movw	r3, #42584	; 0xa658
100172ec:	e3413002 	movt	r3, #4098	; 0x1002
100172f0:	e5832000 	str	r2, [r3]
            break;
100172f4:	ea00003b 	b	100173e8 <finsh_compile+0x36cc>

        case FINSH_NODE_SYS_GETVALUE:
            if (node->idtype & FINSH_IDTYPE_ADDRESS)
100172f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100172fc:	e5d33002 	ldrb	r3, [r3, #2]
10017300:	e2033008 	and	r3, r3, #8
10017304:	e3530000 	cmp	r3, #0
10017308:	1a00002f 	bne	100173cc <finsh_compile+0x36b0>
            {
                /* nothing will be generated */
            }
            else
            {
                switch (node->data_type)
1001730c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10017310:	e5d33001 	ldrb	r3, [r3, #1]
10017314:	e3530002 	cmp	r3, #2
10017318:	0a000011 	beq	10017364 <finsh_compile+0x3648>
1001731c:	e3530003 	cmp	r3, #3
10017320:	0a00001c 	beq	10017398 <finsh_compile+0x367c>
10017324:	e3530001 	cmp	r3, #1
10017328:	0a000000 	beq	10017330 <finsh_compile+0x3614>
                    break;
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
                    break;
                default:
                    break;
1001732c:	ea000026 	b	100173cc <finsh_compile+0x36b0>
            else
            {
                switch (node->data_type)
                {
                case FINSH_DATA_TYPE_BYTE:
                    finsh_code_byte(FINSH_OP_LD_VALUE_BYTE_STACK);
10017330:	e30a3658 	movw	r3, #42584	; 0xa658
10017334:	e3413002 	movt	r3, #4098	; 0x1002
10017338:	e5933000 	ldr	r3, [r3]
1001733c:	e3a0202d 	mov	r2, #45	; 0x2d
10017340:	e5c32000 	strb	r2, [r3]
10017344:	e30a3658 	movw	r3, #42584	; 0xa658
10017348:	e3413002 	movt	r3, #4098	; 0x1002
1001734c:	e5933000 	ldr	r3, [r3]
10017350:	e2832001 	add	r2, r3, #1
10017354:	e30a3658 	movw	r3, #42584	; 0xa658
10017358:	e3413002 	movt	r3, #4098	; 0x1002
1001735c:	e5832000 	str	r2, [r3]
                    break;
10017360:	ea000019 	b	100173cc <finsh_compile+0x36b0>
                case FINSH_DATA_TYPE_WORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_WORD_STACK);
10017364:	e30a3658 	movw	r3, #42584	; 0xa658
10017368:	e3413002 	movt	r3, #4098	; 0x1002
1001736c:	e5933000 	ldr	r3, [r3]
10017370:	e3a0202e 	mov	r2, #46	; 0x2e
10017374:	e5c32000 	strb	r2, [r3]
10017378:	e30a3658 	movw	r3, #42584	; 0xa658
1001737c:	e3413002 	movt	r3, #4098	; 0x1002
10017380:	e5933000 	ldr	r3, [r3]
10017384:	e2832001 	add	r2, r3, #1
10017388:	e30a3658 	movw	r3, #42584	; 0xa658
1001738c:	e3413002 	movt	r3, #4098	; 0x1002
10017390:	e5832000 	str	r2, [r3]
                    break;
10017394:	ea00000c 	b	100173cc <finsh_compile+0x36b0>
                case FINSH_DATA_TYPE_DWORD:
                    finsh_code_byte(FINSH_OP_LD_VALUE_DWORD_STACK);
10017398:	e30a3658 	movw	r3, #42584	; 0xa658
1001739c:	e3413002 	movt	r3, #4098	; 0x1002
100173a0:	e5933000 	ldr	r3, [r3]
100173a4:	e3a0202f 	mov	r2, #47	; 0x2f
100173a8:	e5c32000 	strb	r2, [r3]
100173ac:	e30a3658 	movw	r3, #42584	; 0xa658
100173b0:	e3413002 	movt	r3, #4098	; 0x1002
100173b4:	e5933000 	ldr	r3, [r3]
100173b8:	e2832001 	add	r2, r3, #1
100173bc:	e30a3658 	movw	r3, #42584	; 0xa658
100173c0:	e3413002 	movt	r3, #4098	; 0x1002
100173c4:	e5832000 	str	r2, [r3]
                    break;
100173c8:	e1a00000 	nop			; (mov r0, r0)
                default:
                    break;
                }
            }
            break;
100173cc:	ea000005 	b	100173e8 <finsh_compile+0x36cc>
        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;

        default:
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
100173d0:	e3a00008 	mov	r0, #8
100173d4:	eb000136 	bl	100178b4 <finsh_error_set>
            break;
100173d8:	ea000002 	b	100173e8 <finsh_compile+0x36cc>
            }
            break;

        case FINSH_NODE_SYS_GETADDR:
            /* nothing will be generated */
            break;
100173dc:	e1a00000 	nop			; (mov r0, r0)
100173e0:	ea000000 	b	100173e8 <finsh_compile+0x36cc>
                            break;
                        }
                    }
                }
            }
            break;
100173e4:	e1a00000 	nop			; (mov r0, r0)
            finsh_error_set(FINSH_ERROR_UNKNOWN_NODE);
            break;
        }

        /* compile sibling node */
        if (finsh_node_sibling(node) != NULL)
100173e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100173ec:	e593300c 	ldr	r3, [r3, #12]
100173f0:	e3530000 	cmp	r3, #0
100173f4:	0a000003 	beq	10017408 <finsh_compile+0x36ec>
            finsh_compile(finsh_node_sibling(node));
100173f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
100173fc:	e593300c 	ldr	r3, [r3, #12]
10017400:	e1a00003 	mov	r0, r3
10017404:	ebfff244 	bl	10013d1c <finsh_compile>
    }

    return 0;
10017408:	e3a03000 	mov	r3, #0
}
1001740c:	e1a00003 	mov	r0, r3
10017410:	e24bd004 	sub	sp, fp, #4
10017414:	e8bd8800 	pop	{fp, pc}

10017418 <finsh_type_check>:

static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
10017418:	e92d4800 	push	{fp, lr}
1001741c:	e28db004 	add	fp, sp, #4
10017420:	e24dd010 	sub	sp, sp, #16
10017424:	e50b0010 	str	r0, [fp, #-16]
10017428:	e1a03001 	mov	r3, r1
1001742c:	e54b3011 	strb	r3, [fp, #-17]
    if (node != NULL)
10017430:	e51b3010 	ldr	r3, [fp, #-16]
10017434:	e3530000 	cmp	r3, #0
10017438:	0a0000d0 	beq	10017780 <finsh_type_check+0x368>
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
1001743c:	e51b3010 	ldr	r3, [fp, #-16]
10017440:	e5d33000 	ldrb	r3, [r3]
10017444:	e3530013 	cmp	r3, #19
10017448:	0a00000b 	beq	1001747c <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREINC ||
1001744c:	e51b3010 	ldr	r3, [fp, #-16]
10017450:	e5d33000 	ldrb	r3, [r3]
static int finsh_type_check(struct finsh_node* node, u_char is_addr)
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
10017454:	e3530015 	cmp	r3, #21
10017458:	0a000007 	beq	1001747c <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
1001745c:	e51b3010 	ldr	r3, [fp, #-16]
10017460:	e5d33000 	ldrb	r3, [r3]
{
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
10017464:	e3530016 	cmp	r3, #22
10017468:	0a000003 	beq	1001747c <finsh_type_check+0x64>
            node->node_type == FINSH_NODE_SYS_PREDEC ||
            node->node_type == FINSH_NODE_SYS_GETADDR)
1001746c:	e51b3010 	ldr	r3, [fp, #-16]
10017470:	e5d33000 	ldrb	r3, [r3]
    if (node != NULL)
    {
        /* address & value */
        if (node->node_type == FINSH_NODE_SYS_ASSIGN ||
            node->node_type == FINSH_NODE_SYS_PREINC ||
            node->node_type == FINSH_NODE_SYS_PREDEC ||
10017474:	e353001a 	cmp	r3, #26
10017478:	1a000005 	bne	10017494 <finsh_type_check+0x7c>
            node->node_type == FINSH_NODE_SYS_GETADDR)
        {
            /* address */
            finsh_type_check(finsh_node_child(node), FINSH_IDTYPE_ADDRESS);
1001747c:	e51b3010 	ldr	r3, [fp, #-16]
10017480:	e5933010 	ldr	r3, [r3, #16]
10017484:	e1a00003 	mov	r0, r3
10017488:	e3a01008 	mov	r1, #8
1001748c:	ebffffe1 	bl	10017418 <finsh_type_check>
10017490:	ea000012 	b	100174e0 <finsh_type_check+0xc8>
        }
        else if (node->node_type == FINSH_NODE_SYS_GETVALUE && is_addr)
10017494:	e51b3010 	ldr	r3, [fp, #-16]
10017498:	e5d33000 	ldrb	r3, [r3]
1001749c:	e3530019 	cmp	r3, #25
100174a0:	1a000008 	bne	100174c8 <finsh_type_check+0xb0>
100174a4:	e55b3011 	ldrb	r3, [fp, #-17]
100174a8:	e3530000 	cmp	r3, #0
100174ac:	0a000005 	beq	100174c8 <finsh_type_check+0xb0>
        {
            /* change the attribute of getvalue in left expr */
            finsh_type_check(finsh_node_child(node), 0);
100174b0:	e51b3010 	ldr	r3, [fp, #-16]
100174b4:	e5933010 	ldr	r3, [r3, #16]
100174b8:	e1a00003 	mov	r0, r3
100174bc:	e3a01000 	mov	r1, #0
100174c0:	ebffffd4 	bl	10017418 <finsh_type_check>
100174c4:	ea000005 	b	100174e0 <finsh_type_check+0xc8>
        }
        else
        {
            /* transfer 'av' to child node */
            finsh_type_check(finsh_node_child(node), is_addr);
100174c8:	e51b3010 	ldr	r3, [fp, #-16]
100174cc:	e5932010 	ldr	r2, [r3, #16]
100174d0:	e55b3011 	ldrb	r3, [fp, #-17]
100174d4:	e1a00002 	mov	r0, r2
100174d8:	e1a01003 	mov	r1, r3
100174dc:	ebffffcd 	bl	10017418 <finsh_type_check>
        }

        /* always does not load address in sibling */
        finsh_type_check(finsh_node_sibling(node), FINSH_NODE_VALUE);
100174e0:	e51b3010 	ldr	r3, [fp, #-16]
100174e4:	e593300c 	ldr	r3, [r3, #12]
100174e8:	e1a00003 	mov	r0, r3
100174ec:	e3a01000 	mov	r1, #0
100174f0:	ebffffc8 	bl	10017418 <finsh_type_check>

        /** set attribute of current node */

        /* make sure the current node is address or value */
        if (node->idtype != FINSH_IDTYPE_SYSCALL) node->idtype |= is_addr;
100174f4:	e51b3010 	ldr	r3, [fp, #-16]
100174f8:	e5d33002 	ldrb	r3, [r3, #2]
100174fc:	e3530004 	cmp	r3, #4
10017500:	0a000006 	beq	10017520 <finsh_type_check+0x108>
10017504:	e51b3010 	ldr	r3, [fp, #-16]
10017508:	e5d32002 	ldrb	r2, [r3, #2]
1001750c:	e55b3011 	ldrb	r3, [fp, #-17]
10017510:	e1823003 	orr	r3, r2, r3
10017514:	e6ef2073 	uxtb	r2, r3
10017518:	e51b3010 	ldr	r3, [fp, #-16]
1001751c:	e5c32002 	strb	r2, [r3, #2]

        if (finsh_node_child(node) != NULL)
10017520:	e51b3010 	ldr	r3, [fp, #-16]
10017524:	e5933010 	ldr	r3, [r3, #16]
10017528:	e3530000 	cmp	r3, #0
1001752c:	0a000006 	beq	1001754c <finsh_type_check+0x134>
        {
            node->data_type = finsh_node_child(node)->data_type;
10017530:	e51b3010 	ldr	r3, [fp, #-16]
10017534:	e5933010 	ldr	r3, [r3, #16]
10017538:	e5d32001 	ldrb	r2, [r3, #1]
1001753c:	e51b3010 	ldr	r3, [fp, #-16]
10017540:	e5c32001 	strb	r2, [r3, #1]
            return 0;
10017544:	e3a03000 	mov	r3, #0
10017548:	ea00008d 	b	10017784 <finsh_type_check+0x36c>
        }

        if (node->node_type == FINSH_NODE_ID)
1001754c:	e51b3010 	ldr	r3, [fp, #-16]
10017550:	e5d33000 	ldrb	r3, [r3]
10017554:	e3530001 	cmp	r3, #1
10017558:	1a00006d 	bne	10017714 <finsh_type_check+0x2fc>
        {
            if (node->idtype & FINSH_IDTYPE_VAR)
1001755c:	e51b3010 	ldr	r3, [fp, #-16]
10017560:	e5d33002 	ldrb	r3, [r3, #2]
10017564:	e2033001 	and	r3, r3, #1
10017568:	e3530000 	cmp	r3, #0
1001756c:	0a000031 	beq	10017638 <finsh_type_check+0x220>
            {
                struct finsh_var* var;

                var = node->id.var;
10017570:	e51b3010 	ldr	r3, [fp, #-16]
10017574:	e5933008 	ldr	r3, [r3, #8]
10017578:	e50b3008 	str	r3, [fp, #-8]
                if (var != NULL)
1001757c:	e51b3008 	ldr	r3, [fp, #-8]
10017580:	e3530000 	cmp	r3, #0
10017584:	0a00002a 	beq	10017634 <finsh_type_check+0x21c>
                {
                    switch (var->type)
10017588:	e51b3008 	ldr	r3, [fp, #-8]
1001758c:	e5d33011 	ldrb	r3, [r3, #17]
10017590:	e2433001 	sub	r3, r3, #1
10017594:	e353000d 	cmp	r3, #13
10017598:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001759c:	ea000021 	b	10017628 <finsh_type_check+0x210>
100175a0:	100175d8 	.word	0x100175d8
100175a4:	10017618 	.word	0x10017618
100175a8:	100175e8 	.word	0x100175e8
100175ac:	100175e8 	.word	0x100175e8
100175b0:	10017618 	.word	0x10017618
100175b4:	100175f8 	.word	0x100175f8
100175b8:	100175f8 	.word	0x100175f8
100175bc:	10017618 	.word	0x10017618
100175c0:	10017608 	.word	0x10017608
100175c4:	10017608 	.word	0x10017608
100175c8:	10017618 	.word	0x10017618
100175cc:	10017608 	.word	0x10017608
100175d0:	10017608 	.word	0x10017608
100175d4:	10017618 	.word	0x10017618
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
100175d8:	e51b3010 	ldr	r3, [fp, #-16]
100175dc:	e3a02000 	mov	r2, #0
100175e0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100175e4:	ea000012 	b	10017634 <finsh_type_check+0x21c>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
100175e8:	e51b3010 	ldr	r3, [fp, #-16]
100175ec:	e3a02001 	mov	r2, #1
100175f0:	e5c32001 	strb	r2, [r3, #1]
                        break;
100175f4:	ea00000e 	b	10017634 <finsh_type_check+0x21c>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
100175f8:	e51b3010 	ldr	r3, [fp, #-16]
100175fc:	e3a02002 	mov	r2, #2
10017600:	e5c32001 	strb	r2, [r3, #1]
                        break;
10017604:	ea00000a 	b	10017634 <finsh_type_check+0x21c>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
10017608:	e51b3010 	ldr	r3, [fp, #-16]
1001760c:	e3a02003 	mov	r2, #3
10017610:	e5c32001 	strb	r2, [r3, #1]
                        break;
10017614:	ea000006 	b	10017634 <finsh_type_check+0x21c>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
10017618:	e51b3010 	ldr	r3, [fp, #-16]
1001761c:	e3a02003 	mov	r2, #3
10017620:	e5c32001 	strb	r2, [r3, #1]
                        break;
10017624:	ea000002 	b	10017634 <finsh_type_check+0x21c>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
10017628:	e3a00003 	mov	r0, #3
1001762c:	eb0000a0 	bl	100178b4 <finsh_error_set>
                        break;
10017630:	e1a00000 	nop			; (mov r0, r0)
10017634:	ea000051 	b	10017780 <finsh_type_check+0x368>
                    }
                }
            }
            else if (node->idtype & FINSH_IDTYPE_SYSVAR)
10017638:	e51b3010 	ldr	r3, [fp, #-16]
1001763c:	e5d33002 	ldrb	r3, [r3, #2]
10017640:	e2033002 	and	r3, r3, #2
10017644:	e3530000 	cmp	r3, #0
10017648:	0a000030 	beq	10017710 <finsh_type_check+0x2f8>
            {
                struct finsh_sysvar *sysvar;

                sysvar = node->id.sysvar;
1001764c:	e51b3010 	ldr	r3, [fp, #-16]
10017650:	e5933008 	ldr	r3, [r3, #8]
10017654:	e50b300c 	str	r3, [fp, #-12]
                if (sysvar != NULL)
10017658:	e51b300c 	ldr	r3, [fp, #-12]
1001765c:	e3530000 	cmp	r3, #0
10017660:	0a00002a 	beq	10017710 <finsh_type_check+0x2f8>
                {
                    switch (sysvar->type)
10017664:	e51b300c 	ldr	r3, [fp, #-12]
10017668:	e5d33008 	ldrb	r3, [r3, #8]
1001766c:	e2433001 	sub	r3, r3, #1
10017670:	e353000d 	cmp	r3, #13
10017674:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10017678:	ea000021 	b	10017704 <finsh_type_check+0x2ec>
1001767c:	100176b4 	.word	0x100176b4
10017680:	100176f4 	.word	0x100176f4
10017684:	100176c4 	.word	0x100176c4
10017688:	100176c4 	.word	0x100176c4
1001768c:	100176f4 	.word	0x100176f4
10017690:	100176d4 	.word	0x100176d4
10017694:	100176d4 	.word	0x100176d4
10017698:	100176f4 	.word	0x100176f4
1001769c:	100176e4 	.word	0x100176e4
100176a0:	100176e4 	.word	0x100176e4
100176a4:	100176f4 	.word	0x100176f4
100176a8:	100176e4 	.word	0x100176e4
100176ac:	100176e4 	.word	0x100176e4
100176b0:	100176f4 	.word	0x100176f4
                    {
                    case finsh_type_void:
                        node->data_type = FINSH_DATA_TYPE_VOID;
100176b4:	e51b3010 	ldr	r3, [fp, #-16]
100176b8:	e3a02000 	mov	r2, #0
100176bc:	e5c32001 	strb	r2, [r3, #1]
                        break;
100176c0:	ea000012 	b	10017710 <finsh_type_check+0x2f8>

                    case finsh_type_char:
                    case finsh_type_uchar:
                        node->data_type = FINSH_DATA_TYPE_BYTE;
100176c4:	e51b3010 	ldr	r3, [fp, #-16]
100176c8:	e3a02001 	mov	r2, #1
100176cc:	e5c32001 	strb	r2, [r3, #1]
                        break;
100176d0:	ea00000e 	b	10017710 <finsh_type_check+0x2f8>

                    case finsh_type_short:
                    case finsh_type_ushort:
                        node->data_type = FINSH_DATA_TYPE_WORD;
100176d4:	e51b3010 	ldr	r3, [fp, #-16]
100176d8:	e3a02002 	mov	r2, #2
100176dc:	e5c32001 	strb	r2, [r3, #1]
                        break;
100176e0:	ea00000a 	b	10017710 <finsh_type_check+0x2f8>

                    case finsh_type_int:
                    case finsh_type_uint:
                    case finsh_type_long:
                    case finsh_type_ulong:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
100176e4:	e51b3010 	ldr	r3, [fp, #-16]
100176e8:	e3a02003 	mov	r2, #3
100176ec:	e5c32001 	strb	r2, [r3, #1]
                        break;
100176f0:	ea000006 	b	10017710 <finsh_type_check+0x2f8>
                    case finsh_type_charp:
                    case finsh_type_voidp:
                    case finsh_type_shortp:
                    case finsh_type_intp:
                    case finsh_type_longp:
                        node->data_type = FINSH_DATA_TYPE_DWORD;
100176f4:	e51b3010 	ldr	r3, [fp, #-16]
100176f8:	e3a02003 	mov	r2, #3
100176fc:	e5c32001 	strb	r2, [r3, #1]
                        break;
10017700:	ea000002 	b	10017710 <finsh_type_check+0x2f8>

                    default:
                        finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
10017704:	e3a00003 	mov	r0, #3
10017708:	eb000069 	bl	100178b4 <finsh_error_set>
                        break;
1001770c:	e1a00000 	nop			; (mov r0, r0)
10017710:	ea00001a 	b	10017780 <finsh_type_check+0x368>
                    }
                }
            }
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
10017714:	e51b3010 	ldr	r3, [fp, #-16]
10017718:	e5d33000 	ldrb	r3, [r3]
1001771c:	e3530002 	cmp	r3, #2
10017720:	1a000003 	bne	10017734 <finsh_type_check+0x31c>
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
10017724:	e51b3010 	ldr	r3, [fp, #-16]
10017728:	e3a02001 	mov	r2, #1
1001772c:	e5c32001 	strb	r2, [r3, #1]
10017730:	ea000012 	b	10017780 <finsh_type_check+0x368>
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
10017734:	e51b3010 	ldr	r3, [fp, #-16]
10017738:	e5d33000 	ldrb	r3, [r3]
1001773c:	e3530003 	cmp	r3, #3
10017740:	0a00000b 	beq	10017774 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
10017744:	e51b3010 	ldr	r3, [fp, #-16]
10017748:	e5d33000 	ldrb	r3, [r3]
        }
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
1001774c:	e3530004 	cmp	r3, #4
10017750:	0a000007 	beq	10017774 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
10017754:	e51b3010 	ldr	r3, [fp, #-16]
10017758:	e5d33000 	ldrb	r3, [r3]
        else if (node->node_type == FINSH_NODE_VALUE_CHAR)
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
1001775c:	e3530005 	cmp	r3, #5
10017760:	0a000003 	beq	10017774 <finsh_type_check+0x35c>
            node->node_type == FINSH_NODE_VALUE_STRING  ||
            node->node_type == FINSH_NODE_VALUE_NULL)
10017764:	e51b3010 	ldr	r3, [fp, #-16]
10017768:	e5d33000 	ldrb	r3, [r3]
        {
            node->data_type = FINSH_DATA_TYPE_BYTE;
        }
        else if (node->node_type == FINSH_NODE_VALUE_INT ||
            node->node_type == FINSH_NODE_VALUE_LONG    ||
            node->node_type == FINSH_NODE_VALUE_STRING  ||
1001776c:	e3530006 	cmp	r3, #6
10017770:	1a000002 	bne	10017780 <finsh_type_check+0x368>
            node->node_type == FINSH_NODE_VALUE_NULL)
        {
            node->data_type = FINSH_DATA_TYPE_DWORD;
10017774:	e51b3010 	ldr	r3, [fp, #-16]
10017778:	e3a02003 	mov	r2, #3
1001777c:	e5c32001 	strb	r2, [r3, #1]
        }
    }
    return 0;
10017780:	e3a03000 	mov	r3, #0
}
10017784:	e1a00003 	mov	r0, r3
10017788:	e24bd004 	sub	sp, fp, #4
1001778c:	e8bd8800 	pop	{fp, pc}

10017790 <finsh_compiler_run>:

int finsh_compiler_run(struct finsh_node* node)
{
10017790:	e92d4800 	push	{fp, lr}
10017794:	e28db004 	add	fp, sp, #4
10017798:	e24dd010 	sub	sp, sp, #16
1001779c:	e50b0010 	str	r0, [fp, #-16]
    struct finsh_node* sibling;

    /* type check */
    finsh_type_check(node, FINSH_NODE_VALUE);
100177a0:	e51b0010 	ldr	r0, [fp, #-16]
100177a4:	e3a01000 	mov	r1, #0
100177a8:	ebffff1a 	bl	10017418 <finsh_type_check>

    /* clean text segment and vm stack */
    memset(&text_segment[0], 0, sizeof(text_segment));
100177ac:	e30a08e8 	movw	r0, #43240	; 0xa8e8
100177b0:	e3410002 	movt	r0, #4098	; 0x1002
100177b4:	e3a01000 	mov	r1, #0
100177b8:	e3a02080 	mov	r2, #128	; 0x80
100177bc:	fa001846 	blx	1001d8dc <memset>
    memset(&finsh_vm_stack[0], 0, sizeof(finsh_vm_stack[0]));
100177c0:	e30a0968 	movw	r0, #43368	; 0xa968
100177c4:	e3410002 	movt	r0, #4098	; 0x1002
100177c8:	e3a01000 	mov	r1, #0
100177cc:	e3a02004 	mov	r2, #4
100177d0:	fa001841 	blx	1001d8dc <memset>

    /* reset compile stack pointer and pc */
    finsh_compile_sp = &finsh_vm_stack[0];
100177d4:	e30a365c 	movw	r3, #42588	; 0xa65c
100177d8:	e3413002 	movt	r3, #4098	; 0x1002
100177dc:	e30a2968 	movw	r2, #43368	; 0xa968
100177e0:	e3412002 	movt	r2, #4098	; 0x1002
100177e4:	e5832000 	str	r2, [r3]
    finsh_compile_pc = &text_segment[0];
100177e8:	e30a3658 	movw	r3, #42584	; 0xa658
100177ec:	e3413002 	movt	r3, #4098	; 0x1002
100177f0:	e30a28e8 	movw	r2, #43240	; 0xa8e8
100177f4:	e3412002 	movt	r2, #4098	; 0x1002
100177f8:	e5832000 	str	r2, [r3]

    /* compile node */
    sibling = node;
100177fc:	e51b3010 	ldr	r3, [fp, #-16]
10017800:	e50b3008 	str	r3, [fp, #-8]
    while (sibling != NULL)
10017804:	ea000018 	b	1001786c <finsh_compiler_run+0xdc>
    {
        struct finsh_node* current_node;
        current_node = sibling;
10017808:	e51b3008 	ldr	r3, [fp, #-8]
1001780c:	e50b300c 	str	r3, [fp, #-12]

        /* get sibling node */
        sibling = current_node->sibling;
10017810:	e51b300c 	ldr	r3, [fp, #-12]
10017814:	e593300c 	ldr	r3, [r3, #12]
10017818:	e50b3008 	str	r3, [fp, #-8]

        /* clean sibling node */
        current_node->sibling = NULL;
1001781c:	e51b300c 	ldr	r3, [fp, #-12]
10017820:	e3a02000 	mov	r2, #0
10017824:	e583200c 	str	r2, [r3, #12]
        finsh_compile(current_node);
10017828:	e51b000c 	ldr	r0, [fp, #-12]
1001782c:	ebfff13a 	bl	10013d1c <finsh_compile>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
10017830:	e51b3008 	ldr	r3, [fp, #-8]
10017834:	e3530000 	cmp	r3, #0
10017838:	0a00000b 	beq	1001786c <finsh_compiler_run+0xdc>
1001783c:	e30a3658 	movw	r3, #42584	; 0xa658
10017840:	e3413002 	movt	r3, #4098	; 0x1002
10017844:	e5933000 	ldr	r3, [r3]
10017848:	e3a0202b 	mov	r2, #43	; 0x2b
1001784c:	e5c32000 	strb	r2, [r3]
10017850:	e30a3658 	movw	r3, #42584	; 0xa658
10017854:	e3413002 	movt	r3, #4098	; 0x1002
10017858:	e5933000 	ldr	r3, [r3]
1001785c:	e2832001 	add	r2, r3, #1
10017860:	e30a3658 	movw	r3, #42584	; 0xa658
10017864:	e3413002 	movt	r3, #4098	; 0x1002
10017868:	e5832000 	str	r2, [r3]
    finsh_compile_sp = &finsh_vm_stack[0];
    finsh_compile_pc = &text_segment[0];

    /* compile node */
    sibling = node;
    while (sibling != NULL)
1001786c:	e51b3008 	ldr	r3, [fp, #-8]
10017870:	e3530000 	cmp	r3, #0
10017874:	1affffe3 	bne	10017808 <finsh_compiler_run+0x78>

        /* pop current value */
        if (sibling != NULL) finsh_code_byte(FINSH_OP_POP);
    }

    return 0;
10017878:	e3a03000 	mov	r3, #0
}
1001787c:	e1a00003 	mov	r0, r3
10017880:	e24bd004 	sub	sp, fp, #4
10017884:	e8bd8800 	pop	{fp, pc}

10017888 <finsh_error_init>:
	"Unknown symbol",
	"Null node"
};

int finsh_error_init()
{
10017888:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001788c:	e28db000 	add	fp, sp, #0
	global_errno = FINSH_ERROR_OK;
10017890:	e30a3660 	movw	r3, #42592	; 0xa660
10017894:	e3413002 	movt	r3, #4098	; 0x1002
10017898:	e3a02000 	mov	r2, #0
1001789c:	e5c32000 	strb	r2, [r3]

	return 0;
100178a0:	e3a03000 	mov	r3, #0
}
100178a4:	e1a00003 	mov	r0, r3
100178a8:	e24bd000 	sub	sp, fp, #0
100178ac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100178b0:	e12fff1e 	bx	lr

100178b4 <finsh_error_set>:

int finsh_error_set(u_char type)
{
100178b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100178b8:	e28db000 	add	fp, sp, #0
100178bc:	e24dd00c 	sub	sp, sp, #12
100178c0:	e1a03000 	mov	r3, r0
100178c4:	e54b3005 	strb	r3, [fp, #-5]
	global_errno = type;
100178c8:	e30a3660 	movw	r3, #42592	; 0xa660
100178cc:	e3413002 	movt	r3, #4098	; 0x1002
100178d0:	e55b2005 	ldrb	r2, [fp, #-5]
100178d4:	e5c32000 	strb	r2, [r3]

	return 0;
100178d8:	e3a03000 	mov	r3, #0
}
100178dc:	e1a00003 	mov	r0, r3
100178e0:	e24bd000 	sub	sp, fp, #0
100178e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100178e8:	e12fff1e 	bx	lr

100178ec <finsh_errno>:

u_char finsh_errno()
{
100178ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100178f0:	e28db000 	add	fp, sp, #0
	return global_errno;
100178f4:	e30a3660 	movw	r3, #42592	; 0xa660
100178f8:	e3413002 	movt	r3, #4098	; 0x1002
100178fc:	e5d33000 	ldrb	r3, [r3]
}
10017900:	e1a00003 	mov	r0, r3
10017904:	e24bd000 	sub	sp, fp, #0
10017908:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001790c:	e12fff1e 	bx	lr

10017910 <finsh_error_string>:

const char* finsh_error_string(u_char type)
{
10017910:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017914:	e28db000 	add	fp, sp, #0
10017918:	e24dd00c 	sub	sp, sp, #12
1001791c:	e1a03000 	mov	r3, r0
10017920:	e54b3005 	strb	r3, [fp, #-5]
	return finsh_error_string_table[type];
10017924:	e55b2005 	ldrb	r2, [fp, #-5]
10017928:	e3003a4c 	movw	r3, #2636	; 0xa4c
1001792c:	e3413002 	movt	r3, #4098	; 0x1002
10017930:	e7933102 	ldr	r3, [r3, r2, lsl #2]
}
10017934:	e1a00003 	mov	r0, r3
10017938:	e24bd000 	sub	sp, fp, #0
1001793c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017940:	e12fff1e 	bx	lr

10017944 <finsh_heap_init>:
static void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header);
static void finsh_block_split(struct finsh_block_header* header, size_t size);
static void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header);

int finsh_heap_init(void)
{
10017944:	e92d4800 	push	{fp, lr}
10017948:	e28db004 	add	fp, sp, #4
	/* clear heap to zero */
	memset(&finsh_heap[0], 0, sizeof(finsh_heap));
1001794c:	e30a0664 	movw	r0, #42596	; 0xa664
10017950:	e3410002 	movt	r0, #4098	; 0x1002
10017954:	e3a01000 	mov	r1, #0
10017958:	e3a02080 	mov	r2, #128	; 0x80
1001795c:	fa0017de 	blx	1001d8dc <memset>

	/* init free and alloc list */
    free_list           = BLOCK_HEADER(&finsh_heap[0]);
10017960:	e3093d6c 	movw	r3, #40300	; 0x9d6c
10017964:	e3413002 	movt	r3, #4098	; 0x1002
10017968:	e30a2664 	movw	r2, #42596	; 0xa664
1001796c:	e3412002 	movt	r2, #4098	; 0x1002
10017970:	e5832000 	str	r2, [r3]
	free_list->length   = FINSH_HEAP_MAX - sizeof(struct finsh_block_header);
10017974:	e3093d6c 	movw	r3, #40300	; 0x9d6c
10017978:	e3413002 	movt	r3, #4098	; 0x1002
1001797c:	e5933000 	ldr	r3, [r3]
10017980:	e3a02078 	mov	r2, #120	; 0x78
10017984:	e5832000 	str	r2, [r3]
    free_list->next     = NULL;
10017988:	e3093d6c 	movw	r3, #40300	; 0x9d6c
1001798c:	e3413002 	movt	r3, #4098	; 0x1002
10017990:	e5933000 	ldr	r3, [r3]
10017994:	e3a02000 	mov	r2, #0
10017998:	e5832004 	str	r2, [r3, #4]

    allocate_list       = NULL;
1001799c:	e3093d70 	movw	r3, #40304	; 0x9d70
100179a0:	e3413002 	movt	r3, #4098	; 0x1002
100179a4:	e3a02000 	mov	r2, #0
100179a8:	e5832000 	str	r2, [r3]

    return 0;
100179ac:	e3a03000 	mov	r3, #0
}
100179b0:	e1a00003 	mov	r0, r3
100179b4:	e8bd8800 	pop	{fp, pc}

100179b8 <finsh_heap_allocate>:

/**
 * allocate a block from heap
 */
void* finsh_heap_allocate(size_t size)
{
100179b8:	e92d4800 	push	{fp, lr}
100179bc:	e28db004 	add	fp, sp, #4
100179c0:	e24dd010 	sub	sp, sp, #16
100179c4:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);
100179c8:	e51b3010 	ldr	r3, [fp, #-16]
100179cc:	e2833003 	add	r3, r3, #3
100179d0:	e3c33003 	bic	r3, r3, #3
100179d4:	e50b3010 	str	r3, [fp, #-16]

    /* find the first fit block */
    for (header = free_list;
100179d8:	e3093d6c 	movw	r3, #40300	; 0x9d6c
100179dc:	e3413002 	movt	r3, #4098	; 0x1002
100179e0:	e5933000 	ldr	r3, [r3]
100179e4:	e50b3008 	str	r3, [fp, #-8]
100179e8:	ea000002 	b	100179f8 <finsh_heap_allocate+0x40>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
        header = header->next) ;
100179ec:	e51b3008 	ldr	r3, [fp, #-8]
100179f0:	e5933004 	ldr	r3, [r3, #4]
100179f4:	e50b3008 	str	r3, [fp, #-8]
	struct finsh_block_header* header;

	size = HEAP_ALIGN_SIZE(size);

    /* find the first fit block */
    for (header = free_list;
100179f8:	e51b3008 	ldr	r3, [fp, #-8]
100179fc:	e3530000 	cmp	r3, #0
10017a00:	0a000005 	beq	10017a1c <finsh_heap_allocate+0x64>
        ((header != NULL) && (header->length <= size + sizeof(struct finsh_block_header)));
10017a04:	e51b3008 	ldr	r3, [fp, #-8]
10017a08:	e5932000 	ldr	r2, [r3]
10017a0c:	e51b3010 	ldr	r3, [fp, #-16]
10017a10:	e2833008 	add	r3, r3, #8
10017a14:	e1520003 	cmp	r2, r3
10017a18:	9afffff3 	bls	100179ec <finsh_heap_allocate+0x34>
        header = header->next) ;

	if (header == NULL)
10017a1c:	e51b3008 	ldr	r3, [fp, #-8]
10017a20:	e3530000 	cmp	r3, #0
10017a24:	1a000016 	bne	10017a84 <finsh_heap_allocate+0xcc>
	{
		finsh_heap_gc();
10017a28:	eb000043 	bl	10017b3c <finsh_heap_gc>

		/* find the first fit block */
		for (header = free_list;
10017a2c:	e3093d6c 	movw	r3, #40300	; 0x9d6c
10017a30:	e3413002 	movt	r3, #4098	; 0x1002
10017a34:	e5933000 	ldr	r3, [r3]
10017a38:	e50b3008 	str	r3, [fp, #-8]
10017a3c:	ea000002 	b	10017a4c <finsh_heap_allocate+0x94>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
			header = header->next) ;
10017a40:	e51b3008 	ldr	r3, [fp, #-8]
10017a44:	e5933004 	ldr	r3, [r3, #4]
10017a48:	e50b3008 	str	r3, [fp, #-8]
	if (header == NULL)
	{
		finsh_heap_gc();

		/* find the first fit block */
		for (header = free_list;
10017a4c:	e51b3008 	ldr	r3, [fp, #-8]
10017a50:	e3530000 	cmp	r3, #0
10017a54:	0a000005 	beq	10017a70 <finsh_heap_allocate+0xb8>
			((header != NULL) && (header->length < size + sizeof(struct finsh_block_header)));
10017a58:	e51b3008 	ldr	r3, [fp, #-8]
10017a5c:	e5932000 	ldr	r2, [r3]
10017a60:	e51b3010 	ldr	r3, [fp, #-16]
10017a64:	e2833008 	add	r3, r3, #8
10017a68:	e1520003 	cmp	r2, r3
10017a6c:	3afffff3 	bcc	10017a40 <finsh_heap_allocate+0x88>
			header = header->next) ;

		/* there is no memory */
		if (header == NULL) return NULL;
10017a70:	e51b3008 	ldr	r3, [fp, #-8]
10017a74:	e3530000 	cmp	r3, #0
10017a78:	1a000001 	bne	10017a84 <finsh_heap_allocate+0xcc>
10017a7c:	e3a03000 	mov	r3, #0
10017a80:	ea000015 	b	10017adc <finsh_heap_allocate+0x124>
	}

    /* split block */
	finsh_block_split(header, size);
10017a84:	e51b0008 	ldr	r0, [fp, #-8]
10017a88:	e51b1010 	ldr	r1, [fp, #-16]
10017a8c:	eb0000d4 	bl	10017de4 <finsh_block_split>

	/* remove from free list */
	finsh_block_remove(&free_list, header);
10017a90:	e3090d6c 	movw	r0, #40300	; 0x9d6c
10017a94:	e3410002 	movt	r0, #4098	; 0x1002
10017a98:	e51b1008 	ldr	r1, [fp, #-8]
10017a9c:	eb0000a5 	bl	10017d38 <finsh_block_remove>
	header->next = NULL;
10017aa0:	e51b3008 	ldr	r3, [fp, #-8]
10017aa4:	e3a02000 	mov	r2, #0
10017aa8:	e5832004 	str	r2, [r3, #4]

    /* insert to allocate list */
    finsh_block_insert(&allocate_list, header);
10017aac:	e3090d70 	movw	r0, #40304	; 0x9d70
10017ab0:	e3410002 	movt	r0, #4098	; 0x1002
10017ab4:	e51b1008 	ldr	r1, [fp, #-8]
10017ab8:	eb000060 	bl	10017c40 <finsh_block_insert>

	memset(finsh_block_get_data(header), 0, size);
10017abc:	e51b3008 	ldr	r3, [fp, #-8]
10017ac0:	e2833008 	add	r3, r3, #8
10017ac4:	e1a00003 	mov	r0, r3
10017ac8:	e3a01000 	mov	r1, #0
10017acc:	e51b2010 	ldr	r2, [fp, #-16]
10017ad0:	fa001781 	blx	1001d8dc <memset>

	return finsh_block_get_data(header);
10017ad4:	e51b3008 	ldr	r3, [fp, #-8]
10017ad8:	e2833008 	add	r3, r3, #8
}
10017adc:	e1a00003 	mov	r0, r3
10017ae0:	e24bd004 	sub	sp, fp, #4
10017ae4:	e8bd8800 	pop	{fp, pc}

10017ae8 <finsh_heap_free>:

/**
 * release the allocated block
 */
void  finsh_heap_free(void*ptr)
{
10017ae8:	e92d4800 	push	{fp, lr}
10017aec:	e28db004 	add	fp, sp, #4
10017af0:	e24dd010 	sub	sp, sp, #16
10017af4:	e50b0010 	str	r0, [fp, #-16]
    struct finsh_block_header* header;

    /* get block header */
	header = finsh_block_get_header(ptr);
10017af8:	e51b3010 	ldr	r3, [fp, #-16]
10017afc:	e2433008 	sub	r3, r3, #8
10017b00:	e50b3008 	str	r3, [fp, #-8]

    /* remove from allocate list */
	finsh_block_remove(&allocate_list, header);
10017b04:	e3090d70 	movw	r0, #40304	; 0x9d70
10017b08:	e3410002 	movt	r0, #4098	; 0x1002
10017b0c:	e51b1008 	ldr	r1, [fp, #-8]
10017b10:	eb000088 	bl	10017d38 <finsh_block_remove>

	/* insert to free list */
	finsh_block_insert(&free_list, header);
10017b14:	e3090d6c 	movw	r0, #40300	; 0x9d6c
10017b18:	e3410002 	movt	r0, #4098	; 0x1002
10017b1c:	e51b1008 	ldr	r1, [fp, #-8]
10017b20:	eb000046 	bl	10017c40 <finsh_block_insert>
	finsh_block_merge(&free_list, header);
10017b24:	e3090d6c 	movw	r0, #40300	; 0x9d6c
10017b28:	e3410002 	movt	r0, #4098	; 0x1002
10017b2c:	e51b1008 	ldr	r1, [fp, #-8]
10017b30:	eb0000c9 	bl	10017e5c <finsh_block_merge>
}
10017b34:	e24bd004 	sub	sp, fp, #4
10017b38:	e8bd8800 	pop	{fp, pc}

10017b3c <finsh_heap_gc>:

/**
 * garbage collector
 */
static void finsh_heap_gc(void)
{
10017b3c:	e92d4800 	push	{fp, lr}
10017b40:	e28db004 	add	fp, sp, #4
10017b44:	e24dd010 	sub	sp, sp, #16
	int i;
	struct finsh_block_header *header, *temp;

	temp = NULL;
10017b48:	e3a03000 	mov	r3, #0
10017b4c:	e50b3010 	str	r3, [fp, #-16]

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
10017b50:	e3093d70 	movw	r3, #40304	; 0x9d70
10017b54:	e3413002 	movt	r3, #4098	; 0x1002
10017b58:	e5933000 	ldr	r3, [r3]
10017b5c:	e50b300c 	str	r3, [fp, #-12]
10017b60:	ea000031 	b	10017c2c <finsh_heap_gc+0xf0>
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
10017b64:	e3a03000 	mov	r3, #0
10017b68:	e50b3008 	str	r3, [fp, #-8]
10017b6c:	ea00001f 	b	10017bf0 <finsh_heap_gc+0xb4>
    	{
    		if (global_variable[i].type != finsh_type_unknown)
10017b70:	e30a2828 	movw	r2, #43048	; 0xa828
10017b74:	e3412002 	movt	r2, #4098	; 0x1002
10017b78:	e51b3008 	ldr	r3, [fp, #-8]
10017b7c:	e1a01003 	mov	r1, r3
10017b80:	e1a03181 	lsl	r3, r1, #3
10017b84:	e1a01003 	mov	r1, r3
10017b88:	e1a03101 	lsl	r3, r1, #2
10017b8c:	e0613003 	rsb	r3, r1, r3
10017b90:	e0823003 	add	r3, r2, r3
10017b94:	e2833010 	add	r3, r3, #16
10017b98:	e5d33001 	ldrb	r3, [r3, #1]
10017b9c:	e3530000 	cmp	r3, #0
10017ba0:	0a00000f 	beq	10017be4 <finsh_heap_gc+0xa8>
    		{
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
10017ba4:	e30a2828 	movw	r2, #43048	; 0xa828
10017ba8:	e3412002 	movt	r2, #4098	; 0x1002
10017bac:	e51b3008 	ldr	r3, [fp, #-8]
10017bb0:	e1a01003 	mov	r1, r3
10017bb4:	e1a03181 	lsl	r3, r1, #3
10017bb8:	e1a01003 	mov	r1, r3
10017bbc:	e1a03101 	lsl	r3, r1, #2
10017bc0:	e0613003 	rsb	r3, r1, r3
10017bc4:	e0823003 	add	r3, r2, r3
10017bc8:	e2833010 	add	r3, r3, #16
10017bcc:	e5932004 	ldr	r2, [r3, #4]
10017bd0:	e51b300c 	ldr	r3, [fp, #-12]
10017bd4:	e2833008 	add	r3, r3, #8
10017bd8:	e1520003 	cmp	r2, r3
10017bdc:	1a000000 	bne	10017be4 <finsh_heap_gc+0xa8>
					break;
10017be0:	ea000005 	b	10017bfc <finsh_heap_gc+0xc0>
	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
    {
    	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
10017be4:	e51b3008 	ldr	r3, [fp, #-8]
10017be8:	e2833001 	add	r3, r3, #1
10017bec:	e50b3008 	str	r3, [fp, #-8]
10017bf0:	e51b3008 	ldr	r3, [fp, #-8]
10017bf4:	e3530007 	cmp	r3, #7
10017bf8:	daffffdc 	ble	10017b70 <finsh_heap_gc+0x34>
    			if (global_variable[i].value.ptr == finsh_block_get_data(header))
					break;
    		}
    	}

		temp   = header;
10017bfc:	e51b300c 	ldr	r3, [fp, #-12]
10017c00:	e50b3010 	str	r3, [fp, #-16]
		header = header->next;
10017c04:	e51b300c 	ldr	r3, [fp, #-12]
10017c08:	e5933004 	ldr	r3, [r3, #4]
10017c0c:	e50b300c 	str	r3, [fp, #-12]

		/* this block is an unused block, release it */
    	if (i == FINSH_VARIABLE_MAX)
10017c10:	e51b3008 	ldr	r3, [fp, #-8]
10017c14:	e3530008 	cmp	r3, #8
10017c18:	1a000003 	bne	10017c2c <finsh_heap_gc+0xf0>
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
10017c1c:	e51b3010 	ldr	r3, [fp, #-16]
10017c20:	e2833008 	add	r3, r3, #8
10017c24:	e1a00003 	mov	r0, r3
10017c28:	ebffffae 	bl	10017ae8 <finsh_heap_free>
	struct finsh_block_header *header, *temp;

	temp = NULL;

    /* find the first fit block */
    for (header = allocate_list; header != NULL; )
10017c2c:	e51b300c 	ldr	r3, [fp, #-12]
10017c30:	e3530000 	cmp	r3, #0
10017c34:	1affffca 	bne	10017b64 <finsh_heap_gc+0x28>
    	if (i == FINSH_VARIABLE_MAX)
    	{
    		finsh_heap_free(finsh_block_get_data(temp));
    	}
    }
}
10017c38:	e24bd004 	sub	sp, fp, #4
10017c3c:	e8bd8800 	pop	{fp, pc}

10017c40 <finsh_block_insert>:

/**
 * insert a block to list
 */
void finsh_block_insert(struct finsh_block_header** list, struct finsh_block_header* header)
{
10017c40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017c44:	e28db000 	add	fp, sp, #0
10017c48:	e24dd014 	sub	sp, sp, #20
10017c4c:	e50b0010 	str	r0, [fp, #-16]
10017c50:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* node;

    if (*list == NULL)
10017c54:	e51b3010 	ldr	r3, [fp, #-16]
10017c58:	e5933000 	ldr	r3, [r3]
10017c5c:	e3530000 	cmp	r3, #0
10017c60:	1a000003 	bne	10017c74 <finsh_block_insert+0x34>
    {
        *list = header;
10017c64:	e51b3010 	ldr	r3, [fp, #-16]
10017c68:	e51b2014 	ldr	r2, [fp, #-20]
10017c6c:	e5832000 	str	r2, [r3]
        return;
10017c70:	ea00002d 	b	10017d2c <finsh_block_insert+0xec>
    }

    /* find out insert point */
	node = *list;
10017c74:	e51b3010 	ldr	r3, [fp, #-16]
10017c78:	e5933000 	ldr	r3, [r3]
10017c7c:	e50b3008 	str	r3, [fp, #-8]

	if (node > header)
10017c80:	e51b2008 	ldr	r2, [fp, #-8]
10017c84:	e51b3014 	ldr	r3, [fp, #-20]
10017c88:	e1520003 	cmp	r2, r3
10017c8c:	9a000006 	bls	10017cac <finsh_block_insert+0x6c>
	{
		/* insert node in the header of list */
		header->next = node;
10017c90:	e51b3014 	ldr	r3, [fp, #-20]
10017c94:	e51b2008 	ldr	r2, [fp, #-8]
10017c98:	e5832004 	str	r2, [r3, #4]
		*list = header;
10017c9c:	e51b3010 	ldr	r3, [fp, #-16]
10017ca0:	e51b2014 	ldr	r2, [fp, #-20]
10017ca4:	e5832000 	str	r2, [r3]

		return;
10017ca8:	ea00001f 	b	10017d2c <finsh_block_insert+0xec>
	}
	else
	{
		for (node = *list; node; node = node->next)
10017cac:	e51b3010 	ldr	r3, [fp, #-16]
10017cb0:	e5933000 	ldr	r3, [r3]
10017cb4:	e50b3008 	str	r3, [fp, #-8]
10017cb8:	ea00000d 	b	10017cf4 <finsh_block_insert+0xb4>
		{
    		if (node->next > header) break;
10017cbc:	e51b3008 	ldr	r3, [fp, #-8]
10017cc0:	e5932004 	ldr	r2, [r3, #4]
10017cc4:	e51b3014 	ldr	r3, [fp, #-20]
10017cc8:	e1520003 	cmp	r2, r3
10017ccc:	9a000000 	bls	10017cd4 <finsh_block_insert+0x94>
10017cd0:	ea00000a 	b	10017d00 <finsh_block_insert+0xc0>

    		if (node->next == NULL) break;
10017cd4:	e51b3008 	ldr	r3, [fp, #-8]
10017cd8:	e5933004 	ldr	r3, [r3, #4]
10017cdc:	e3530000 	cmp	r3, #0
10017ce0:	1a000000 	bne	10017ce8 <finsh_block_insert+0xa8>
10017ce4:	ea000005 	b	10017d00 <finsh_block_insert+0xc0>

		return;
	}
	else
	{
		for (node = *list; node; node = node->next)
10017ce8:	e51b3008 	ldr	r3, [fp, #-8]
10017cec:	e5933004 	ldr	r3, [r3, #4]
10017cf0:	e50b3008 	str	r3, [fp, #-8]
10017cf4:	e51b3008 	ldr	r3, [fp, #-8]
10017cf8:	e3530000 	cmp	r3, #0
10017cfc:	1affffee 	bne	10017cbc <finsh_block_insert+0x7c>
    		if (node->next == NULL) break;
		}
	}

    /* insert node */
    if (node->next != NULL) header->next = node->next;
10017d00:	e51b3008 	ldr	r3, [fp, #-8]
10017d04:	e5933004 	ldr	r3, [r3, #4]
10017d08:	e3530000 	cmp	r3, #0
10017d0c:	0a000003 	beq	10017d20 <finsh_block_insert+0xe0>
10017d10:	e51b3008 	ldr	r3, [fp, #-8]
10017d14:	e5932004 	ldr	r2, [r3, #4]
10017d18:	e51b3014 	ldr	r3, [fp, #-20]
10017d1c:	e5832004 	str	r2, [r3, #4]
    node->next      = header;
10017d20:	e51b3008 	ldr	r3, [fp, #-8]
10017d24:	e51b2014 	ldr	r2, [fp, #-20]
10017d28:	e5832004 	str	r2, [r3, #4]
}
10017d2c:	e24bd000 	sub	sp, fp, #0
10017d30:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017d34:	e12fff1e 	bx	lr

10017d38 <finsh_block_remove>:

/**
 * remove block from list
 */
void finsh_block_remove(struct finsh_block_header** list, struct finsh_block_header* header)
{
10017d38:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017d3c:	e28db000 	add	fp, sp, #0
10017d40:	e24dd014 	sub	sp, sp, #20
10017d44:	e50b0010 	str	r0, [fp, #-16]
10017d48:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* node;

    node = *list;
10017d4c:	e51b3010 	ldr	r3, [fp, #-16]
10017d50:	e5933000 	ldr	r3, [r3]
10017d54:	e50b3008 	str	r3, [fp, #-8]
    if (node == header)
10017d58:	e51b2008 	ldr	r2, [fp, #-8]
10017d5c:	e51b3014 	ldr	r3, [fp, #-20]
10017d60:	e1520003 	cmp	r2, r3
10017d64:	1a000007 	bne	10017d88 <finsh_block_remove+0x50>
    {
        /* remove list header */
        *list = header->next;
10017d68:	e51b3014 	ldr	r3, [fp, #-20]
10017d6c:	e5932004 	ldr	r2, [r3, #4]
10017d70:	e51b3010 	ldr	r3, [fp, #-16]
10017d74:	e5832000 	str	r2, [r3]
        header->next = NULL;
10017d78:	e51b3014 	ldr	r3, [fp, #-20]
10017d7c:	e3a02000 	mov	r2, #0
10017d80:	e5832004 	str	r2, [r3, #4]

        return;
10017d84:	ea000013 	b	10017dd8 <finsh_block_remove+0xa0>
    }

    for (node = *list; node != NULL; node = node->next)
10017d88:	e51b3010 	ldr	r3, [fp, #-16]
10017d8c:	e5933000 	ldr	r3, [r3]
10017d90:	e50b3008 	str	r3, [fp, #-8]
10017d94:	ea00000c 	b	10017dcc <finsh_block_remove+0x94>
    {
        if (node->next == header)
10017d98:	e51b3008 	ldr	r3, [fp, #-8]
10017d9c:	e5932004 	ldr	r2, [r3, #4]
10017da0:	e51b3014 	ldr	r3, [fp, #-20]
10017da4:	e1520003 	cmp	r2, r3
10017da8:	1a000004 	bne	10017dc0 <finsh_block_remove+0x88>
        {
            node->next = header->next;
10017dac:	e51b3014 	ldr	r3, [fp, #-20]
10017db0:	e5932004 	ldr	r2, [r3, #4]
10017db4:	e51b3008 	ldr	r3, [fp, #-8]
10017db8:	e5832004 	str	r2, [r3, #4]
            break;
10017dbc:	ea000005 	b	10017dd8 <finsh_block_remove+0xa0>
        header->next = NULL;

        return;
    }

    for (node = *list; node != NULL; node = node->next)
10017dc0:	e51b3008 	ldr	r3, [fp, #-8]
10017dc4:	e5933004 	ldr	r3, [r3, #4]
10017dc8:	e50b3008 	str	r3, [fp, #-8]
10017dcc:	e51b3008 	ldr	r3, [fp, #-8]
10017dd0:	e3530000 	cmp	r3, #0
10017dd4:	1affffef 	bne	10017d98 <finsh_block_remove+0x60>
        {
            node->next = header->next;
            break;
        }
    }
}
10017dd8:	e24bd000 	sub	sp, fp, #0
10017ddc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017de0:	e12fff1e 	bx	lr

10017de4 <finsh_block_split>:

/**
 * split block
 */
void finsh_block_split(struct finsh_block_header* header, size_t size)
{
10017de4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017de8:	e28db000 	add	fp, sp, #0
10017dec:	e24dd014 	sub	sp, sp, #20
10017df0:	e50b0010 	str	r0, [fp, #-16]
10017df4:	e50b1014 	str	r1, [fp, #-20]

    /*
     * split header into two node:
     * header->next->...
     */
    next = BLOCK_HEADER((u_char*)header + sizeof(struct finsh_block_header) + size);
10017df8:	e51b3014 	ldr	r3, [fp, #-20]
10017dfc:	e2833008 	add	r3, r3, #8
10017e00:	e51b2010 	ldr	r2, [fp, #-16]
10017e04:	e0823003 	add	r3, r2, r3
10017e08:	e50b3008 	str	r3, [fp, #-8]
    next->length = header->length - sizeof(struct finsh_block_header) - size;
10017e0c:	e51b3010 	ldr	r3, [fp, #-16]
10017e10:	e5932000 	ldr	r2, [r3]
10017e14:	e51b3014 	ldr	r3, [fp, #-20]
10017e18:	e0633002 	rsb	r3, r3, r2
10017e1c:	e2432008 	sub	r2, r3, #8
10017e20:	e51b3008 	ldr	r3, [fp, #-8]
10017e24:	e5832000 	str	r2, [r3]
    header->length = size;
10017e28:	e51b3010 	ldr	r3, [fp, #-16]
10017e2c:	e51b2014 	ldr	r2, [fp, #-20]
10017e30:	e5832000 	str	r2, [r3]
    next->next = header->next;
10017e34:	e51b3010 	ldr	r3, [fp, #-16]
10017e38:	e5932004 	ldr	r2, [r3, #4]
10017e3c:	e51b3008 	ldr	r3, [fp, #-8]
10017e40:	e5832004 	str	r2, [r3, #4]

    header->next = next;
10017e44:	e51b3010 	ldr	r3, [fp, #-16]
10017e48:	e51b2008 	ldr	r2, [fp, #-8]
10017e4c:	e5832004 	str	r2, [r3, #4]
}
10017e50:	e24bd000 	sub	sp, fp, #0
10017e54:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10017e58:	e12fff1e 	bx	lr

10017e5c <finsh_block_merge>:

void finsh_block_merge(struct finsh_block_header** list, struct finsh_block_header* header)
{
10017e5c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10017e60:	e28db000 	add	fp, sp, #0
10017e64:	e24dd014 	sub	sp, sp, #20
10017e68:	e50b0010 	str	r0, [fp, #-16]
10017e6c:	e50b1014 	str	r1, [fp, #-20]
    struct finsh_block_header* prev_node;
    struct finsh_block_header* next_node;

    next_node = header->next;
10017e70:	e51b3014 	ldr	r3, [fp, #-20]
10017e74:	e5933004 	ldr	r3, [r3, #4]
10017e78:	e50b300c 	str	r3, [fp, #-12]

    if (*list == header) prev_node = NULL;
10017e7c:	e51b3010 	ldr	r3, [fp, #-16]
10017e80:	e5932000 	ldr	r2, [r3]
10017e84:	e51b3014 	ldr	r3, [fp, #-20]
10017e88:	e1520003 	cmp	r2, r3
10017e8c:	1a000002 	bne	10017e9c <finsh_block_merge+0x40>
10017e90:	e3a03000 	mov	r3, #0
10017e94:	e50b3008 	str	r3, [fp, #-8]
10017e98:	ea00000f 	b	10017edc <finsh_block_merge+0x80>
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
10017e9c:	e51b3010 	ldr	r3, [fp, #-16]
10017ea0:	e5933000 	ldr	r3, [r3]
10017ea4:	e50b3008 	str	r3, [fp, #-8]
10017ea8:	ea000008 	b	10017ed0 <finsh_block_merge+0x74>
        {
            if (prev_node->next == header)
10017eac:	e51b3008 	ldr	r3, [fp, #-8]
10017eb0:	e5932004 	ldr	r2, [r3, #4]
10017eb4:	e51b3014 	ldr	r3, [fp, #-20]
10017eb8:	e1520003 	cmp	r2, r3
10017ebc:	1a000000 	bne	10017ec4 <finsh_block_merge+0x68>
                break;
10017ec0:	ea000005 	b	10017edc <finsh_block_merge+0x80>

    if (*list == header) prev_node = NULL;
    else
    {
        /* find out the previous header */
        for (prev_node = *list; prev_node; prev_node =prev_node->next)
10017ec4:	e51b3008 	ldr	r3, [fp, #-8]
10017ec8:	e5933004 	ldr	r3, [r3, #4]
10017ecc:	e50b3008 	str	r3, [fp, #-8]
10017ed0:	e51b3008 	ldr	r3, [fp, #-8]
10017ed4:	e3530000 	cmp	r3, #0
10017ed8:	1afffff3 	bne	10017eac <finsh_block_merge+0x50>
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
10017edc:	e51b3008 	ldr	r3, [fp, #-8]
10017ee0:	e3530000 	cmp	r3, #0
10017ee4:	0a00002f 	beq	10017fa8 <finsh_block_merge+0x14c>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
10017ee8:	e51b3008 	ldr	r3, [fp, #-8]
10017eec:	e5933000 	ldr	r3, [r3]
10017ef0:	e2833008 	add	r3, r3, #8
10017ef4:	e51b2008 	ldr	r2, [fp, #-8]
10017ef8:	e0822003 	add	r2, r2, r3
    }

    /* try merge node */

    /* merge to previous node */
    if (prev_node != NULL &&
10017efc:	e51b3014 	ldr	r3, [fp, #-20]
10017f00:	e1520003 	cmp	r2, r3
10017f04:	1a000027 	bne	10017fa8 <finsh_block_merge+0x14c>
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
10017f08:	e51b300c 	ldr	r3, [fp, #-12]
10017f0c:	e3530000 	cmp	r3, #0
10017f10:	0a000017 	beq	10017f74 <finsh_block_merge+0x118>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
10017f14:	e51b3014 	ldr	r3, [fp, #-20]
10017f18:	e5933000 	ldr	r3, [r3]
10017f1c:	e2833008 	add	r3, r3, #8
10017f20:	e51b2014 	ldr	r2, [fp, #-20]
10017f24:	e0822003 	add	r2, r2, r3
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
10017f28:	e51b300c 	ldr	r3, [fp, #-12]
10017f2c:	e1520003 	cmp	r2, r3
10017f30:	1a00000f 	bne	10017f74 <finsh_block_merge+0x118>
            ((u_char*)header + header->length + sizeof(struct finsh_block_header)
            == (u_char*)next_node))
        {
            /* merge three node */
        	prev_node->length += header->length + next_node->length +
10017f34:	e51b3008 	ldr	r3, [fp, #-8]
10017f38:	e5932000 	ldr	r2, [r3]
10017f3c:	e51b3014 	ldr	r3, [fp, #-20]
10017f40:	e5931000 	ldr	r1, [r3]
10017f44:	e51b300c 	ldr	r3, [fp, #-12]
10017f48:	e5933000 	ldr	r3, [r3]
10017f4c:	e0813003 	add	r3, r1, r3
10017f50:	e0823003 	add	r3, r2, r3
10017f54:	e2832010 	add	r2, r3, #16
10017f58:	e51b3008 	ldr	r3, [fp, #-8]
10017f5c:	e5832000 	str	r2, [r3]
                2 * sizeof(struct finsh_block_header);

            prev_node->next = next_node->next;
10017f60:	e51b300c 	ldr	r3, [fp, #-12]
10017f64:	e5932004 	ldr	r2, [r3, #4]
10017f68:	e51b3008 	ldr	r3, [fp, #-8]
10017f6c:	e5832004 	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
10017f70:	ea000023 	b	10018004 <finsh_block_merge+0x1a8>

            prev_node->next = next_node->next;
        }
        else
        {
            prev_node->length += header->length + sizeof(struct finsh_block_header);
10017f74:	e51b3008 	ldr	r3, [fp, #-8]
10017f78:	e5932000 	ldr	r2, [r3]
10017f7c:	e51b3014 	ldr	r3, [fp, #-20]
10017f80:	e5933000 	ldr	r3, [r3]
10017f84:	e0823003 	add	r3, r2, r3
10017f88:	e2832008 	add	r2, r3, #8
10017f8c:	e51b3008 	ldr	r3, [fp, #-8]
10017f90:	e5832000 	str	r2, [r3]
            prev_node->next = header->next;
10017f94:	e51b3014 	ldr	r3, [fp, #-20]
10017f98:	e5932004 	ldr	r2, [r3, #4]
10017f9c:	e51b3008 	ldr	r3, [fp, #-8]
10017fa0:	e5832004 	str	r2, [r3, #4]
    if (prev_node != NULL &&
        ((u_char*)prev_node + prev_node->length + sizeof(struct finsh_block_header)
        == (u_char*)header))
    {
        /* is it close to next node? */
        if ((next_node != NULL) &&
10017fa4:	ea000016 	b	10018004 <finsh_block_merge+0x1a8>
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
10017fa8:	e51b300c 	ldr	r3, [fp, #-12]
10017fac:	e3530000 	cmp	r3, #0
10017fb0:	0a000013 	beq	10018004 <finsh_block_merge+0x1a8>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
10017fb4:	e51b3014 	ldr	r3, [fp, #-20]
10017fb8:	e5933000 	ldr	r3, [r3]
10017fbc:	e2833008 	add	r3, r3, #8
10017fc0:	e51b2014 	ldr	r2, [fp, #-20]
10017fc4:	e0822003 	add	r2, r2, r3
            prev_node->length += header->length + sizeof(struct finsh_block_header);
            prev_node->next = header->next;
        }
    }
    else /* merge to last node */
    if ( (next_node != NULL) &&
10017fc8:	e51b300c 	ldr	r3, [fp, #-12]
10017fcc:	e1520003 	cmp	r2, r3
10017fd0:	1a00000b 	bne	10018004 <finsh_block_merge+0x1a8>
        ((u_char*)header + header->length + sizeof(struct finsh_block_header)
        == (u_char*)next_node))
    {
        header->length += next_node->length + sizeof(struct finsh_block_header);
10017fd4:	e51b3014 	ldr	r3, [fp, #-20]
10017fd8:	e5932000 	ldr	r2, [r3]
10017fdc:	e51b300c 	ldr	r3, [fp, #-12]
10017fe0:	e5933000 	ldr	r3, [r3]
10017fe4:	e0823003 	add	r3, r2, r3
10017fe8:	e2832008 	add	r2, r3, #8
10017fec:	e51b3014 	ldr	r3, [fp, #-20]
10017ff0:	e5832000 	str	r2, [r3]
        header->next = next_node->next;
10017ff4:	e51b300c 	ldr	r3, [fp, #-12]
10017ff8:	e5932004 	ldr	r2, [r3, #4]
10017ffc:	e51b3014 	ldr	r3, [fp, #-20]
10018000:	e5832004 	str	r2, [r3, #4]
    }
}
10018004:	e24bd000 	sub	sp, fp, #0
10018008:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001800c:	e12fff1e 	bx	lr

10018010 <finsh_init>:
#include "finsh_var.h"
#include "finsh_error.h"
#include "finsh_heap.h"

int finsh_init(struct finsh_parser* parser)
{
10018010:	e92d4800 	push	{fp, lr}
10018014:	e28db004 	add	fp, sp, #4
10018018:	e24dd008 	sub	sp, sp, #8
1001801c:	e50b0008 	str	r0, [fp, #-8]
	finsh_parser_init(parser);
10018020:	e51b0008 	ldr	r0, [fp, #-8]
10018024:	eb000e1b 	bl	1001b898 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
10018028:	eb000027 	bl	100180cc <finsh_node_init>
	finsh_var_init();
1001802c:	eb000e25 	bl	1001b8c8 <finsh_var_init>
	finsh_error_init();
10018030:	ebfffe14 	bl	10017888 <finsh_error_init>
	finsh_heap_init();
10018034:	ebfffe42 	bl	10017944 <finsh_heap_init>

	return 0;
10018038:	e3a03000 	mov	r3, #0
}
1001803c:	e1a00003 	mov	r0, r3
10018040:	e24bd004 	sub	sp, fp, #4
10018044:	e8bd8800 	pop	{fp, pc}

10018048 <finsh_stack_bottom>:

long finsh_stack_bottom()
{
10018048:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001804c:	e28db000 	add	fp, sp, #0
    return finsh_vm_stack[0].long_value;
10018050:	e30a3968 	movw	r3, #43368	; 0xa968
10018054:	e3413002 	movt	r3, #4098	; 0x1002
10018058:	e5933000 	ldr	r3, [r3]
}
1001805c:	e1a00003 	mov	r0, r3
10018060:	e24bd000 	sub	sp, fp, #0
10018064:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018068:	e12fff1e 	bx	lr

1001806c <finsh_flush>:

int finsh_flush(struct finsh_parser* parser)
{
1001806c:	e92d4800 	push	{fp, lr}
10018070:	e28db004 	add	fp, sp, #4
10018074:	e24dd008 	sub	sp, sp, #8
10018078:	e50b0008 	str	r0, [fp, #-8]
	finsh_parser_init(parser);
1001807c:	e51b0008 	ldr	r0, [fp, #-8]
10018080:	eb000e04 	bl	1001b898 <finsh_parser_init>

	/* finsh init */
	finsh_node_init();
10018084:	eb000010 	bl	100180cc <finsh_node_init>
	finsh_error_init();
10018088:	ebfffdfe 	bl	10017888 <finsh_error_init>

	return 0;
1001808c:	e3a03000 	mov	r3, #0
}
10018090:	e1a00003 	mov	r0, r3
10018094:	e24bd004 	sub	sp, fp, #4
10018098:	e8bd8800 	pop	{fp, pc}

1001809c <finsh_reset>:

int finsh_reset(struct finsh_parser* parser)
{
1001809c:	e92d4800 	push	{fp, lr}
100180a0:	e28db004 	add	fp, sp, #4
100180a4:	e24dd008 	sub	sp, sp, #8
100180a8:	e50b0008 	str	r0, [fp, #-8]
	/* finsh init */
	finsh_node_init();
100180ac:	eb000006 	bl	100180cc <finsh_node_init>
	finsh_var_init();
100180b0:	eb000e04 	bl	1001b8c8 <finsh_var_init>
	finsh_error_init();
100180b4:	ebfffdf3 	bl	10017888 <finsh_error_init>
	finsh_heap_init();
100180b8:	ebfffe21 	bl	10017944 <finsh_heap_init>

	return 0;
100180bc:	e3a03000 	mov	r3, #0
}
100180c0:	e1a00003 	mov	r0, r3
100180c4:	e24bd004 	sub	sp, fp, #4
100180c8:	e8bd8800 	pop	{fp, pc}

100180cc <finsh_node_init>:
#include "finsh_heap.h"

struct finsh_node global_node_table[FINSH_NODE_MAX];

int finsh_node_init()
{
100180cc:	e92d4800 	push	{fp, lr}
100180d0:	e28db004 	add	fp, sp, #4
	memset(global_node_table, 0, sizeof(global_node_table));
100180d4:	e30a06e4 	movw	r0, #42724	; 0xa6e4
100180d8:	e3410002 	movt	r0, #4098	; 0x1002
100180dc:	e3a01000 	mov	r1, #0
100180e0:	e3a02d05 	mov	r2, #320	; 0x140
100180e4:	fa0015fc 	blx	1001d8dc <memset>

	return 0;
100180e8:	e3a03000 	mov	r3, #0
}
100180ec:	e1a00003 	mov	r0, r3
100180f0:	e8bd8800 	pop	{fp, pc}

100180f4 <finsh_node_allocate>:

struct finsh_node* finsh_node_allocate(u_char type)
{
100180f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100180f8:	e28db000 	add	fp, sp, #0
100180fc:	e24dd014 	sub	sp, sp, #20
10018100:	e1a03000 	mov	r3, r0
10018104:	e54b300d 	strb	r3, [fp, #-13]
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
10018108:	e3a03000 	mov	r3, #0
1001810c:	e50b3008 	str	r3, [fp, #-8]
10018110:	ea00000d 	b	1001814c <finsh_node_allocate+0x58>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
10018114:	e30a26e4 	movw	r2, #42724	; 0xa6e4
10018118:	e3412002 	movt	r2, #4098	; 0x1002
1001811c:	e51b3008 	ldr	r3, [fp, #-8]
10018120:	e1a03103 	lsl	r3, r3, #2
10018124:	e1a01103 	lsl	r1, r3, #2
10018128:	e0833001 	add	r3, r3, r1
1001812c:	e0823003 	add	r3, r2, r3
10018130:	e5d33000 	ldrb	r3, [r3]
10018134:	e3530000 	cmp	r3, #0
10018138:	1a000000 	bne	10018140 <finsh_node_allocate+0x4c>
1001813c:	ea000005 	b	10018158 <finsh_node_allocate+0x64>
struct finsh_node* finsh_node_allocate(u_char type)
{
	int i;

	/* find an empty entry */
	for (i = 0; i < FINSH_NODE_MAX; i ++)
10018140:	e51b3008 	ldr	r3, [fp, #-8]
10018144:	e2833001 	add	r3, r3, #1
10018148:	e50b3008 	str	r3, [fp, #-8]
1001814c:	e51b3008 	ldr	r3, [fp, #-8]
10018150:	e353000f 	cmp	r3, #15
10018154:	daffffee 	ble	10018114 <finsh_node_allocate+0x20>
	{
		if (global_node_table[i].node_type == FINSH_NODE_UNKNOWN) break;
	}

	if (i == FINSH_NODE_MAX) return NULL;
10018158:	e51b3008 	ldr	r3, [fp, #-8]
1001815c:	e3530010 	cmp	r3, #16
10018160:	1a000001 	bne	1001816c <finsh_node_allocate+0x78>
10018164:	e3a03000 	mov	r3, #0
10018168:	ea00000f 	b	100181ac <finsh_node_allocate+0xb8>

	/* fill type field */
	global_node_table[i].node_type = type;
1001816c:	e30a26e4 	movw	r2, #42724	; 0xa6e4
10018170:	e3412002 	movt	r2, #4098	; 0x1002
10018174:	e51b3008 	ldr	r3, [fp, #-8]
10018178:	e1a03103 	lsl	r3, r3, #2
1001817c:	e1a01103 	lsl	r1, r3, #2
10018180:	e0833001 	add	r3, r3, r1
10018184:	e0823003 	add	r3, r2, r3
10018188:	e55b200d 	ldrb	r2, [fp, #-13]
1001818c:	e5c32000 	strb	r2, [r3]

	/* return this allocated node */
	return &global_node_table[i];
10018190:	e51b3008 	ldr	r3, [fp, #-8]
10018194:	e1a03103 	lsl	r3, r3, #2
10018198:	e1a02103 	lsl	r2, r3, #2
1001819c:	e0833002 	add	r3, r3, r2
100181a0:	e30a26e4 	movw	r2, #42724	; 0xa6e4
100181a4:	e3412002 	movt	r2, #4098	; 0x1002
100181a8:	e0833002 	add	r3, r3, r2
}
100181ac:	e1a00003 	mov	r0, r3
100181b0:	e24bd000 	sub	sp, fp, #0
100181b4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100181b8:	e12fff1e 	bx	lr

100181bc <finsh_node_new_id>:

struct finsh_node* finsh_node_new_id(char* id)
{
100181bc:	e92d4800 	push	{fp, lr}
100181c0:	e28db004 	add	fp, sp, #4
100181c4:	e24dd018 	sub	sp, sp, #24
100181c8:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_node* node;
	void*  symbol;
	unsigned char type;

	symbol	= NULL;
100181cc:	e3a03000 	mov	r3, #0
100181d0:	e50b300c 	str	r3, [fp, #-12]
	type	= 0;
100181d4:	e3a03000 	mov	r3, #0
100181d8:	e54b300d 	strb	r3, [fp, #-13]
	node	= NULL;
100181dc:	e3a03000 	mov	r3, #0
100181e0:	e50b3008 	str	r3, [fp, #-8]

	/* lookup variable firstly */
	symbol = (void*)finsh_var_lookup(id);
100181e4:	e51b0018 	ldr	r0, [fp, #-24]
100181e8:	eb000e4c 	bl	1001bb20 <finsh_var_lookup>
100181ec:	e50b000c 	str	r0, [fp, #-12]
	if (symbol == NULL)
100181f0:	e51b300c 	ldr	r3, [fp, #-12]
100181f4:	e3530000 	cmp	r3, #0
100181f8:	1a000011 	bne	10018244 <finsh_node_new_id+0x88>
	{
		/* then lookup system variable */
		symbol = (void*)finsh_sysvar_lookup(id);
100181fc:	e51b0018 	ldr	r0, [fp, #-24]
10018200:	eb000ea5 	bl	1001bc9c <finsh_sysvar_lookup>
10018204:	e50b000c 	str	r0, [fp, #-12]
		if (symbol == NULL)
10018208:	e51b300c 	ldr	r3, [fp, #-12]
1001820c:	e3530000 	cmp	r3, #0
10018210:	1a000008 	bne	10018238 <finsh_node_new_id+0x7c>
		{
			/* then lookup system call */
			symbol = (void*)finsh_syscall_lookup(id);
10018214:	e51b0018 	ldr	r0, [fp, #-24]
10018218:	eb000f34 	bl	1001bef0 <finsh_syscall_lookup>
1001821c:	e50b000c 	str	r0, [fp, #-12]
			if (symbol != NULL) type = FINSH_IDTYPE_SYSCALL;
10018220:	e51b300c 	ldr	r3, [fp, #-12]
10018224:	e3530000 	cmp	r3, #0
10018228:	0a000007 	beq	1001824c <finsh_node_new_id+0x90>
1001822c:	e3a03004 	mov	r3, #4
10018230:	e54b300d 	strb	r3, [fp, #-13]
10018234:	ea000004 	b	1001824c <finsh_node_new_id+0x90>
		}
		else type = FINSH_IDTYPE_SYSVAR;
10018238:	e3a03002 	mov	r3, #2
1001823c:	e54b300d 	strb	r3, [fp, #-13]
10018240:	ea000001 	b	1001824c <finsh_node_new_id+0x90>
	}
	else type = FINSH_IDTYPE_VAR;
10018244:	e3a03001 	mov	r3, #1
10018248:	e54b300d 	strb	r3, [fp, #-13]

	if (symbol != NULL)
1001824c:	e51b300c 	ldr	r3, [fp, #-12]
10018250:	e3530000 	cmp	r3, #0
10018254:	0a000020 	beq	100182dc <finsh_node_new_id+0x120>
	{
		/* allocate a new node */
		node = finsh_node_allocate(FINSH_NODE_ID);
10018258:	e3a00001 	mov	r0, #1
1001825c:	ebffffa4 	bl	100180f4 <finsh_node_allocate>
10018260:	e50b0008 	str	r0, [fp, #-8]

		/* allocate node error */
		if (node == NULL)
10018264:	e51b3008 	ldr	r3, [fp, #-8]
10018268:	e3530000 	cmp	r3, #0
1001826c:	1a000003 	bne	10018280 <finsh_node_new_id+0xc4>
		{
			finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10018270:	e3a00006 	mov	r0, #6
10018274:	ebfffd8e 	bl	100178b4 <finsh_error_set>
			return NULL;
10018278:	e3a03000 	mov	r3, #0
1001827c:	ea000019 	b	100182e8 <finsh_node_new_id+0x12c>
		}

		/* fill node value according type */
		switch (type)
10018280:	e55b300d 	ldrb	r3, [fp, #-13]
10018284:	e3530002 	cmp	r3, #2
10018288:	0a000007 	beq	100182ac <finsh_node_new_id+0xf0>
1001828c:	e3530004 	cmp	r3, #4
10018290:	0a000009 	beq	100182bc <finsh_node_new_id+0x100>
10018294:	e3530001 	cmp	r3, #1
10018298:	1a00000b 	bne	100182cc <finsh_node_new_id+0x110>
		{
		case FINSH_IDTYPE_VAR:
			node->id.var = (struct finsh_var*)symbol;
1001829c:	e51b3008 	ldr	r3, [fp, #-8]
100182a0:	e51b200c 	ldr	r2, [fp, #-12]
100182a4:	e5832008 	str	r2, [r3, #8]
			break;
100182a8:	ea000007 	b	100182cc <finsh_node_new_id+0x110>

		case FINSH_IDTYPE_SYSVAR:
			node->id.sysvar = (struct finsh_sysvar*)symbol;
100182ac:	e51b3008 	ldr	r3, [fp, #-8]
100182b0:	e51b200c 	ldr	r2, [fp, #-12]
100182b4:	e5832008 	str	r2, [r3, #8]
			break;
100182b8:	ea000003 	b	100182cc <finsh_node_new_id+0x110>

		case FINSH_IDTYPE_SYSCALL:
			node->id.syscall = (struct finsh_syscall*)symbol;
100182bc:	e51b3008 	ldr	r3, [fp, #-8]
100182c0:	e51b200c 	ldr	r2, [fp, #-12]
100182c4:	e5832008 	str	r2, [r3, #8]
			break;
100182c8:	e1a00000 	nop			; (mov r0, r0)
		}
		/* fill identifier type */
		node->idtype = type;
100182cc:	e51b3008 	ldr	r3, [fp, #-8]
100182d0:	e55b200d 	ldrb	r2, [fp, #-13]
100182d4:	e5c32002 	strb	r2, [r3, #2]
100182d8:	ea000001 	b	100182e4 <finsh_node_new_id+0x128>
	}
	else finsh_error_set(FINSH_ERROR_UNKNOWN_SYMBOL);
100182dc:	e3a0000d 	mov	r0, #13
100182e0:	ebfffd73 	bl	100178b4 <finsh_error_set>

	return node;
100182e4:	e51b3008 	ldr	r3, [fp, #-8]
}
100182e8:	e1a00003 	mov	r0, r3
100182ec:	e24bd004 	sub	sp, fp, #4
100182f0:	e8bd8800 	pop	{fp, pc}

100182f4 <finsh_node_new_char>:

struct finsh_node* finsh_node_new_char(char c)
{
100182f4:	e92d4800 	push	{fp, lr}
100182f8:	e28db004 	add	fp, sp, #4
100182fc:	e24dd010 	sub	sp, sp, #16
10018300:	e1a03000 	mov	r3, r0
10018304:	e54b300d 	strb	r3, [fp, #-13]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_CHAR);
10018308:	e3a00002 	mov	r0, #2
1001830c:	ebffff78 	bl	100180f4 <finsh_node_allocate>
10018310:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
10018314:	e51b3008 	ldr	r3, [fp, #-8]
10018318:	e3530000 	cmp	r3, #0
1001831c:	1a000003 	bne	10018330 <finsh_node_new_char+0x3c>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10018320:	e3a00006 	mov	r0, #6
10018324:	ebfffd62 	bl	100178b4 <finsh_error_set>
		return NULL;
10018328:	e3a03000 	mov	r3, #0
1001832c:	ea000003 	b	10018340 <finsh_node_new_char+0x4c>
	}

	node->value.char_value = c;
10018330:	e51b3008 	ldr	r3, [fp, #-8]
10018334:	e55b200d 	ldrb	r2, [fp, #-13]
10018338:	e5c32004 	strb	r2, [r3, #4]
	return node;
1001833c:	e51b3008 	ldr	r3, [fp, #-8]
}
10018340:	e1a00003 	mov	r0, r3
10018344:	e24bd004 	sub	sp, fp, #4
10018348:	e8bd8800 	pop	{fp, pc}

1001834c <finsh_node_new_int>:

struct finsh_node* finsh_node_new_int(int i)
{
1001834c:	e92d4800 	push	{fp, lr}
10018350:	e28db004 	add	fp, sp, #4
10018354:	e24dd010 	sub	sp, sp, #16
10018358:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_INT);
1001835c:	e3a00003 	mov	r0, #3
10018360:	ebffff63 	bl	100180f4 <finsh_node_allocate>
10018364:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
10018368:	e51b3008 	ldr	r3, [fp, #-8]
1001836c:	e3530000 	cmp	r3, #0
10018370:	1a000003 	bne	10018384 <finsh_node_new_int+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
10018374:	e3a00006 	mov	r0, #6
10018378:	ebfffd4d 	bl	100178b4 <finsh_error_set>
		return NULL;
1001837c:	e3a03000 	mov	r3, #0
10018380:	ea000003 	b	10018394 <finsh_node_new_int+0x48>
	}

	node->value.int_value = i;
10018384:	e51b3008 	ldr	r3, [fp, #-8]
10018388:	e51b2010 	ldr	r2, [fp, #-16]
1001838c:	e5832004 	str	r2, [r3, #4]
	return node;
10018390:	e51b3008 	ldr	r3, [fp, #-8]
}
10018394:	e1a00003 	mov	r0, r3
10018398:	e24bd004 	sub	sp, fp, #4
1001839c:	e8bd8800 	pop	{fp, pc}

100183a0 <finsh_node_new_long>:

struct finsh_node* finsh_node_new_long(long l)
{
100183a0:	e92d4800 	push	{fp, lr}
100183a4:	e28db004 	add	fp, sp, #4
100183a8:	e24dd010 	sub	sp, sp, #16
100183ac:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_LONG);
100183b0:	e3a00004 	mov	r0, #4
100183b4:	ebffff4e 	bl	100180f4 <finsh_node_allocate>
100183b8:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
100183bc:	e51b3008 	ldr	r3, [fp, #-8]
100183c0:	e3530000 	cmp	r3, #0
100183c4:	1a000003 	bne	100183d8 <finsh_node_new_long+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
100183c8:	e3a00006 	mov	r0, #6
100183cc:	ebfffd38 	bl	100178b4 <finsh_error_set>
		return NULL;
100183d0:	e3a03000 	mov	r3, #0
100183d4:	ea000003 	b	100183e8 <finsh_node_new_long+0x48>
	}

	node->value.long_value = l;
100183d8:	e51b3008 	ldr	r3, [fp, #-8]
100183dc:	e51b2010 	ldr	r2, [fp, #-16]
100183e0:	e5832004 	str	r2, [r3, #4]
	return node;
100183e4:	e51b3008 	ldr	r3, [fp, #-8]
}
100183e8:	e1a00003 	mov	r0, r3
100183ec:	e24bd004 	sub	sp, fp, #4
100183f0:	e8bd8800 	pop	{fp, pc}

100183f4 <finsh_node_new_string>:

struct finsh_node* finsh_node_new_string(char* s)
{
100183f4:	e92d4810 	push	{r4, fp, lr}
100183f8:	e28db008 	add	fp, sp, #8
100183fc:	e24dd014 	sub	sp, sp, #20
10018400:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_STRING);
10018404:	e3a00005 	mov	r0, #5
10018408:	ebffff39 	bl	100180f4 <finsh_node_allocate>
1001840c:	e50b0010 	str	r0, [fp, #-16]
	if (node == NULL)
10018410:	e51b3010 	ldr	r3, [fp, #-16]
10018414:	e3530000 	cmp	r3, #0
10018418:	1a000003 	bne	1001842c <finsh_node_new_string+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
1001841c:	e3a00006 	mov	r0, #6
10018420:	ebfffd23 	bl	100178b4 <finsh_error_set>
		return NULL;
10018424:	e3a03000 	mov	r3, #0
10018428:	ea00001a 	b	10018498 <finsh_node_new_string+0xa4>
	}

	/* make string */
	node->value.ptr = finsh_heap_allocate(strlen(s) + 1);
1001842c:	e51b0018 	ldr	r0, [fp, #-24]
10018430:	fa00160e 	blx	1001dc70 <strlen>
10018434:	e1a03000 	mov	r3, r0
10018438:	e2833001 	add	r3, r3, #1
1001843c:	e1a00003 	mov	r0, r3
10018440:	ebfffd5c 	bl	100179b8 <finsh_heap_allocate>
10018444:	e1a02000 	mov	r2, r0
10018448:	e51b3010 	ldr	r3, [fp, #-16]
1001844c:	e5832004 	str	r2, [r3, #4]
	strncpy(node->value.ptr, s, strlen(s));
10018450:	e51b3010 	ldr	r3, [fp, #-16]
10018454:	e5934004 	ldr	r4, [r3, #4]
10018458:	e51b0018 	ldr	r0, [fp, #-24]
1001845c:	fa001603 	blx	1001dc70 <strlen>
10018460:	e1a03000 	mov	r3, r0
10018464:	e1a00004 	mov	r0, r4
10018468:	e51b1018 	ldr	r1, [fp, #-24]
1001846c:	e1a02003 	mov	r2, r3
10018470:	fa00163b 	blx	1001dd64 <strncpy>
	((u_char*)node->value.ptr)[strlen(s)] = '\0';
10018474:	e51b3010 	ldr	r3, [fp, #-16]
10018478:	e5934004 	ldr	r4, [r3, #4]
1001847c:	e51b0018 	ldr	r0, [fp, #-24]
10018480:	fa0015fa 	blx	1001dc70 <strlen>
10018484:	e1a03000 	mov	r3, r0
10018488:	e0843003 	add	r3, r4, r3
1001848c:	e3a02000 	mov	r2, #0
10018490:	e5c32000 	strb	r2, [r3]

	return node;
10018494:	e51b3010 	ldr	r3, [fp, #-16]
}
10018498:	e1a00003 	mov	r0, r3
1001849c:	e24bd008 	sub	sp, fp, #8
100184a0:	e8bd8810 	pop	{r4, fp, pc}

100184a4 <finsh_node_new_ptr>:

struct finsh_node* finsh_node_new_ptr(void* ptr)
{
100184a4:	e92d4800 	push	{fp, lr}
100184a8:	e28db004 	add	fp, sp, #4
100184ac:	e24dd010 	sub	sp, sp, #16
100184b0:	e50b0010 	str	r0, [fp, #-16]
	struct finsh_node* node;

	node = finsh_node_allocate(FINSH_NODE_VALUE_NULL);
100184b4:	e3a00006 	mov	r0, #6
100184b8:	ebffff0d 	bl	100180f4 <finsh_node_allocate>
100184bc:	e50b0008 	str	r0, [fp, #-8]
	if (node == NULL)
100184c0:	e51b3008 	ldr	r3, [fp, #-8]
100184c4:	e3530000 	cmp	r3, #0
100184c8:	1a000003 	bne	100184dc <finsh_node_new_ptr+0x38>
	{
		finsh_error_set(FINSH_ERROR_MEMORY_FULL);
100184cc:	e3a00006 	mov	r0, #6
100184d0:	ebfffcf7 	bl	100178b4 <finsh_error_set>
		return NULL;
100184d4:	e3a03000 	mov	r3, #0
100184d8:	ea000003 	b	100184ec <finsh_node_new_ptr+0x48>
	}

	node->value.ptr = ptr;
100184dc:	e51b3008 	ldr	r3, [fp, #-8]
100184e0:	e51b2010 	ldr	r2, [fp, #-16]
100184e4:	e5832004 	str	r2, [r3, #4]
	return node;
100184e8:	e51b3008 	ldr	r3, [fp, #-8]
}
100184ec:	e1a00003 	mov	r0, r3
100184f0:	e24bd004 	sub	sp, fp, #4
100184f4:	e8bd8800 	pop	{fp, pc}

100184f8 <OP_no_op>:
        finsh_sp--; \
    }while (0)

/* --- noop --- */
void OP_no_op()
{
100184f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100184fc:	e28db000 	add	fp, sp, #0
	/* none */
	return ;
10018500:	e1a00000 	nop			; (mov r0, r0)
}
10018504:	e24bd000 	sub	sp, fp, #0
10018508:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001850c:	e12fff1e 	bx	lr

10018510 <OP_add_byte>:

/* --- add --- */
void OP_add_byte()
{
10018510:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018514:	e28db000 	add	fp, sp, #0
    OP_BIN_BYTE(+);
10018518:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001851c:	e3413002 	movt	r3, #4098	; 0x1002
10018520:	e5933000 	ldr	r3, [r3]
10018524:	e2432008 	sub	r2, r3, #8
10018528:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001852c:	e3413002 	movt	r3, #4098	; 0x1002
10018530:	e5933000 	ldr	r3, [r3]
10018534:	e2433008 	sub	r3, r3, #8
10018538:	e5d31000 	ldrb	r1, [r3]
1001853c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018540:	e3413002 	movt	r3, #4098	; 0x1002
10018544:	e5933000 	ldr	r3, [r3]
10018548:	e2433004 	sub	r3, r3, #4
1001854c:	e5d33000 	ldrb	r3, [r3]
10018550:	e0813003 	add	r3, r1, r3
10018554:	e6ef3073 	uxtb	r3, r3
10018558:	e5c23000 	strb	r3, [r2]
1001855c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018560:	e3413002 	movt	r3, #4098	; 0x1002
10018564:	e5933000 	ldr	r3, [r3]
10018568:	e2432004 	sub	r2, r3, #4
1001856c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018570:	e3413002 	movt	r3, #4098	; 0x1002
10018574:	e5832000 	str	r2, [r3]

	return ;
10018578:	e1a00000 	nop			; (mov r0, r0)
}
1001857c:	e24bd000 	sub	sp, fp, #0
10018580:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018584:	e12fff1e 	bx	lr

10018588 <OP_add_word>:

void OP_add_word()
{
10018588:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001858c:	e28db000 	add	fp, sp, #0
    OP_BIN_WORD(+);
10018590:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018594:	e3413002 	movt	r3, #4098	; 0x1002
10018598:	e5933000 	ldr	r3, [r3]
1001859c:	e2432008 	sub	r2, r3, #8
100185a0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100185a4:	e3413002 	movt	r3, #4098	; 0x1002
100185a8:	e5933000 	ldr	r3, [r3]
100185ac:	e2433008 	sub	r3, r3, #8
100185b0:	e1d330b0 	ldrh	r3, [r3]
100185b4:	e6ff1073 	uxth	r1, r3
100185b8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100185bc:	e3413002 	movt	r3, #4098	; 0x1002
100185c0:	e5933000 	ldr	r3, [r3]
100185c4:	e2433004 	sub	r3, r3, #4
100185c8:	e1d330b0 	ldrh	r3, [r3]
100185cc:	e6ff3073 	uxth	r3, r3
100185d0:	e0813003 	add	r3, r1, r3
100185d4:	e6ff3073 	uxth	r3, r3
100185d8:	e6ff3073 	uxth	r3, r3
100185dc:	e1c230b0 	strh	r3, [r2]
100185e0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100185e4:	e3413002 	movt	r3, #4098	; 0x1002
100185e8:	e5933000 	ldr	r3, [r3]
100185ec:	e2432004 	sub	r2, r3, #4
100185f0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100185f4:	e3413002 	movt	r3, #4098	; 0x1002
100185f8:	e5832000 	str	r2, [r3]

	return ;
100185fc:	e1a00000 	nop			; (mov r0, r0)
}
10018600:	e24bd000 	sub	sp, fp, #0
10018604:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018608:	e12fff1e 	bx	lr

1001860c <OP_add_dword>:

void OP_add_dword()
{
1001860c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018610:	e28db000 	add	fp, sp, #0
    OP_BIN_DWORD(+);
10018614:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018618:	e3413002 	movt	r3, #4098	; 0x1002
1001861c:	e5933000 	ldr	r3, [r3]
10018620:	e2432008 	sub	r2, r3, #8
10018624:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018628:	e3413002 	movt	r3, #4098	; 0x1002
1001862c:	e5933000 	ldr	r3, [r3]
10018630:	e2433008 	sub	r3, r3, #8
10018634:	e5931000 	ldr	r1, [r3]
10018638:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001863c:	e3413002 	movt	r3, #4098	; 0x1002
10018640:	e5933000 	ldr	r3, [r3]
10018644:	e2433004 	sub	r3, r3, #4
10018648:	e5933000 	ldr	r3, [r3]
1001864c:	e0813003 	add	r3, r1, r3
10018650:	e5823000 	str	r3, [r2]
10018654:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018658:	e3413002 	movt	r3, #4098	; 0x1002
1001865c:	e5933000 	ldr	r3, [r3]
10018660:	e2432004 	sub	r2, r3, #4
10018664:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018668:	e3413002 	movt	r3, #4098	; 0x1002
1001866c:	e5832000 	str	r2, [r3]

	return ;
10018670:	e1a00000 	nop			; (mov r0, r0)
}
10018674:	e24bd000 	sub	sp, fp, #0
10018678:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001867c:	e12fff1e 	bx	lr

10018680 <OP_sub_byte>:

/* --- sub --- */
void OP_sub_byte()
{
10018680:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018684:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(-);
10018688:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001868c:	e3413002 	movt	r3, #4098	; 0x1002
10018690:	e5933000 	ldr	r3, [r3]
10018694:	e2432008 	sub	r2, r3, #8
10018698:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001869c:	e3413002 	movt	r3, #4098	; 0x1002
100186a0:	e5933000 	ldr	r3, [r3]
100186a4:	e2433008 	sub	r3, r3, #8
100186a8:	e5d31000 	ldrb	r1, [r3]
100186ac:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100186b0:	e3413002 	movt	r3, #4098	; 0x1002
100186b4:	e5933000 	ldr	r3, [r3]
100186b8:	e2433004 	sub	r3, r3, #4
100186bc:	e5d33000 	ldrb	r3, [r3]
100186c0:	e0633001 	rsb	r3, r3, r1
100186c4:	e6ef3073 	uxtb	r3, r3
100186c8:	e5c23000 	strb	r3, [r2]
100186cc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100186d0:	e3413002 	movt	r3, #4098	; 0x1002
100186d4:	e5933000 	ldr	r3, [r3]
100186d8:	e2432004 	sub	r2, r3, #4
100186dc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100186e0:	e3413002 	movt	r3, #4098	; 0x1002
100186e4:	e5832000 	str	r2, [r3]

	return ;
100186e8:	e1a00000 	nop			; (mov r0, r0)
}
100186ec:	e24bd000 	sub	sp, fp, #0
100186f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100186f4:	e12fff1e 	bx	lr

100186f8 <OP_sub_word>:

void OP_sub_word()
{
100186f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100186fc:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(-);
10018700:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018704:	e3413002 	movt	r3, #4098	; 0x1002
10018708:	e5933000 	ldr	r3, [r3]
1001870c:	e2432008 	sub	r2, r3, #8
10018710:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018714:	e3413002 	movt	r3, #4098	; 0x1002
10018718:	e5933000 	ldr	r3, [r3]
1001871c:	e2433008 	sub	r3, r3, #8
10018720:	e1d330b0 	ldrh	r3, [r3]
10018724:	e6ff1073 	uxth	r1, r3
10018728:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001872c:	e3413002 	movt	r3, #4098	; 0x1002
10018730:	e5933000 	ldr	r3, [r3]
10018734:	e2433004 	sub	r3, r3, #4
10018738:	e1d330b0 	ldrh	r3, [r3]
1001873c:	e6ff3073 	uxth	r3, r3
10018740:	e0633001 	rsb	r3, r3, r1
10018744:	e6ff3073 	uxth	r3, r3
10018748:	e6ff3073 	uxth	r3, r3
1001874c:	e1c230b0 	strh	r3, [r2]
10018750:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018754:	e3413002 	movt	r3, #4098	; 0x1002
10018758:	e5933000 	ldr	r3, [r3]
1001875c:	e2432004 	sub	r2, r3, #4
10018760:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018764:	e3413002 	movt	r3, #4098	; 0x1002
10018768:	e5832000 	str	r2, [r3]

	return ;
1001876c:	e1a00000 	nop			; (mov r0, r0)
}
10018770:	e24bd000 	sub	sp, fp, #0
10018774:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018778:	e12fff1e 	bx	lr

1001877c <OP_sub_dword>:

void OP_sub_dword()
{
1001877c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018780:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(-);
10018784:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018788:	e3413002 	movt	r3, #4098	; 0x1002
1001878c:	e5933000 	ldr	r3, [r3]
10018790:	e2432008 	sub	r2, r3, #8
10018794:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018798:	e3413002 	movt	r3, #4098	; 0x1002
1001879c:	e5933000 	ldr	r3, [r3]
100187a0:	e2433008 	sub	r3, r3, #8
100187a4:	e5931000 	ldr	r1, [r3]
100187a8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100187ac:	e3413002 	movt	r3, #4098	; 0x1002
100187b0:	e5933000 	ldr	r3, [r3]
100187b4:	e2433004 	sub	r3, r3, #4
100187b8:	e5933000 	ldr	r3, [r3]
100187bc:	e0633001 	rsb	r3, r3, r1
100187c0:	e5823000 	str	r3, [r2]
100187c4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100187c8:	e3413002 	movt	r3, #4098	; 0x1002
100187cc:	e5933000 	ldr	r3, [r3]
100187d0:	e2432004 	sub	r2, r3, #4
100187d4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100187d8:	e3413002 	movt	r3, #4098	; 0x1002
100187dc:	e5832000 	str	r2, [r3]

	return ;
100187e0:	e1a00000 	nop			; (mov r0, r0)
}
100187e4:	e24bd000 	sub	sp, fp, #0
100187e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100187ec:	e12fff1e 	bx	lr

100187f0 <OP_div_byte>:

/* --- div --- */
void OP_div_byte()
{
100187f0:	e92d4818 	push	{r3, r4, fp, lr}
100187f4:	e28db00c 	add	fp, sp, #12
	OP_BIN_BYTE(/);
100187f8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100187fc:	e3413002 	movt	r3, #4098	; 0x1002
10018800:	e5933000 	ldr	r3, [r3]
10018804:	e2434008 	sub	r4, r3, #8
10018808:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001880c:	e3413002 	movt	r3, #4098	; 0x1002
10018810:	e5933000 	ldr	r3, [r3]
10018814:	e2433008 	sub	r3, r3, #8
10018818:	e5d32000 	ldrb	r2, [r3]
1001881c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018820:	e3413002 	movt	r3, #4098	; 0x1002
10018824:	e5933000 	ldr	r3, [r3]
10018828:	e2433004 	sub	r3, r3, #4
1001882c:	e5d33000 	ldrb	r3, [r3]
10018830:	e1a00002 	mov	r0, r2
10018834:	e1a01003 	mov	r1, r3
10018838:	fa0012b0 	blx	1001d300 <__aeabi_uidiv>
1001883c:	e1a03000 	mov	r3, r0
10018840:	e6ef3073 	uxtb	r3, r3
10018844:	e5c43000 	strb	r3, [r4]
10018848:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001884c:	e3413002 	movt	r3, #4098	; 0x1002
10018850:	e5933000 	ldr	r3, [r3]
10018854:	e2432004 	sub	r2, r3, #4
10018858:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001885c:	e3413002 	movt	r3, #4098	; 0x1002
10018860:	e5832000 	str	r2, [r3]

	return ;
10018864:	e1a00000 	nop			; (mov r0, r0)
}
10018868:	e8bd8818 	pop	{r3, r4, fp, pc}

1001886c <OP_div_word>:

void OP_div_word()
{
1001886c:	e92d4818 	push	{r3, r4, fp, lr}
10018870:	e28db00c 	add	fp, sp, #12
	OP_BIN_WORD(/);
10018874:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018878:	e3413002 	movt	r3, #4098	; 0x1002
1001887c:	e5933000 	ldr	r3, [r3]
10018880:	e2434008 	sub	r4, r3, #8
10018884:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018888:	e3413002 	movt	r3, #4098	; 0x1002
1001888c:	e5933000 	ldr	r3, [r3]
10018890:	e2433008 	sub	r3, r3, #8
10018894:	e1d330b0 	ldrh	r3, [r3]
10018898:	e6bf2073 	sxth	r2, r3
1001889c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100188a0:	e3413002 	movt	r3, #4098	; 0x1002
100188a4:	e5933000 	ldr	r3, [r3]
100188a8:	e2433004 	sub	r3, r3, #4
100188ac:	e1d330b0 	ldrh	r3, [r3]
100188b0:	e6bf3073 	sxth	r3, r3
100188b4:	e1a00002 	mov	r0, r2
100188b8:	e1a01003 	mov	r1, r3
100188bc:	fa00132d 	blx	1001d578 <__aeabi_idiv>
100188c0:	e1a03000 	mov	r3, r0
100188c4:	e6ff3073 	uxth	r3, r3
100188c8:	e1c430b0 	strh	r3, [r4]
100188cc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100188d0:	e3413002 	movt	r3, #4098	; 0x1002
100188d4:	e5933000 	ldr	r3, [r3]
100188d8:	e2432004 	sub	r2, r3, #4
100188dc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100188e0:	e3413002 	movt	r3, #4098	; 0x1002
100188e4:	e5832000 	str	r2, [r3]

	return ;
100188e8:	e1a00000 	nop			; (mov r0, r0)
}
100188ec:	e8bd8818 	pop	{r3, r4, fp, pc}

100188f0 <OP_div_dword>:

void OP_div_dword()
{
100188f0:	e92d4818 	push	{r3, r4, fp, lr}
100188f4:	e28db00c 	add	fp, sp, #12
	OP_BIN_DWORD(/);
100188f8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100188fc:	e3413002 	movt	r3, #4098	; 0x1002
10018900:	e5933000 	ldr	r3, [r3]
10018904:	e2434008 	sub	r4, r3, #8
10018908:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001890c:	e3413002 	movt	r3, #4098	; 0x1002
10018910:	e5933000 	ldr	r3, [r3]
10018914:	e2433008 	sub	r3, r3, #8
10018918:	e5932000 	ldr	r2, [r3]
1001891c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018920:	e3413002 	movt	r3, #4098	; 0x1002
10018924:	e5933000 	ldr	r3, [r3]
10018928:	e2433004 	sub	r3, r3, #4
1001892c:	e5933000 	ldr	r3, [r3]
10018930:	e1a00002 	mov	r0, r2
10018934:	e1a01003 	mov	r1, r3
10018938:	fa00130e 	blx	1001d578 <__aeabi_idiv>
1001893c:	e1a03000 	mov	r3, r0
10018940:	e5843000 	str	r3, [r4]
10018944:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018948:	e3413002 	movt	r3, #4098	; 0x1002
1001894c:	e5933000 	ldr	r3, [r3]
10018950:	e2432004 	sub	r2, r3, #4
10018954:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018958:	e3413002 	movt	r3, #4098	; 0x1002
1001895c:	e5832000 	str	r2, [r3]

	return ;
10018960:	e1a00000 	nop			; (mov r0, r0)
}
10018964:	e8bd8818 	pop	{r3, r4, fp, pc}

10018968 <OP_mod_byte>:

/* --- mod --- */
void OP_mod_byte()
{
10018968:	e92d4818 	push	{r3, r4, fp, lr}
1001896c:	e28db00c 	add	fp, sp, #12
	OP_BIN_BYTE(%);
10018970:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018974:	e3413002 	movt	r3, #4098	; 0x1002
10018978:	e5933000 	ldr	r3, [r3]
1001897c:	e2434008 	sub	r4, r3, #8
10018980:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018984:	e3413002 	movt	r3, #4098	; 0x1002
10018988:	e5933000 	ldr	r3, [r3]
1001898c:	e2433008 	sub	r3, r3, #8
10018990:	e5d32000 	ldrb	r2, [r3]
10018994:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018998:	e3413002 	movt	r3, #4098	; 0x1002
1001899c:	e5933000 	ldr	r3, [r3]
100189a0:	e2433004 	sub	r3, r3, #4
100189a4:	e5d33000 	ldrb	r3, [r3]
100189a8:	e1a00002 	mov	r0, r2
100189ac:	e1a01003 	mov	r1, r3
100189b0:	fa0012e9 	blx	1001d55c <__aeabi_uidivmod>
100189b4:	e1a03001 	mov	r3, r1
100189b8:	e6ef3073 	uxtb	r3, r3
100189bc:	e5c43000 	strb	r3, [r4]
100189c0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100189c4:	e3413002 	movt	r3, #4098	; 0x1002
100189c8:	e5933000 	ldr	r3, [r3]
100189cc:	e2432004 	sub	r2, r3, #4
100189d0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100189d4:	e3413002 	movt	r3, #4098	; 0x1002
100189d8:	e5832000 	str	r2, [r3]

	return ;
100189dc:	e1a00000 	nop			; (mov r0, r0)
}
100189e0:	e8bd8818 	pop	{r3, r4, fp, pc}

100189e4 <OP_mod_word>:

void OP_mod_word()
{
100189e4:	e92d4818 	push	{r3, r4, fp, lr}
100189e8:	e28db00c 	add	fp, sp, #12
	OP_BIN_WORD(%);
100189ec:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100189f0:	e3413002 	movt	r3, #4098	; 0x1002
100189f4:	e5933000 	ldr	r3, [r3]
100189f8:	e2434008 	sub	r4, r3, #8
100189fc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a00:	e3413002 	movt	r3, #4098	; 0x1002
10018a04:	e5933000 	ldr	r3, [r3]
10018a08:	e2433008 	sub	r3, r3, #8
10018a0c:	e1d330b0 	ldrh	r3, [r3]
10018a10:	e6bf2073 	sxth	r2, r3
10018a14:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a18:	e3413002 	movt	r3, #4098	; 0x1002
10018a1c:	e5933000 	ldr	r3, [r3]
10018a20:	e2433004 	sub	r3, r3, #4
10018a24:	e1d330b0 	ldrh	r3, [r3]
10018a28:	e6bf3073 	sxth	r3, r3
10018a2c:	e1a00002 	mov	r0, r2
10018a30:	e1a01003 	mov	r1, r3
10018a34:	fa001374 	blx	1001d80c <__aeabi_idivmod>
10018a38:	e1a03001 	mov	r3, r1
10018a3c:	e6ff3073 	uxth	r3, r3
10018a40:	e1c430b0 	strh	r3, [r4]
10018a44:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a48:	e3413002 	movt	r3, #4098	; 0x1002
10018a4c:	e5933000 	ldr	r3, [r3]
10018a50:	e2432004 	sub	r2, r3, #4
10018a54:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a58:	e3413002 	movt	r3, #4098	; 0x1002
10018a5c:	e5832000 	str	r2, [r3]

	return ;
10018a60:	e1a00000 	nop			; (mov r0, r0)
}
10018a64:	e8bd8818 	pop	{r3, r4, fp, pc}

10018a68 <OP_mod_dword>:

void OP_mod_dword()
{
10018a68:	e92d4818 	push	{r3, r4, fp, lr}
10018a6c:	e28db00c 	add	fp, sp, #12
	OP_BIN_DWORD(%);
10018a70:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a74:	e3413002 	movt	r3, #4098	; 0x1002
10018a78:	e5933000 	ldr	r3, [r3]
10018a7c:	e2434008 	sub	r4, r3, #8
10018a80:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a84:	e3413002 	movt	r3, #4098	; 0x1002
10018a88:	e5933000 	ldr	r3, [r3]
10018a8c:	e2433008 	sub	r3, r3, #8
10018a90:	e5932000 	ldr	r2, [r3]
10018a94:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018a98:	e3413002 	movt	r3, #4098	; 0x1002
10018a9c:	e5933000 	ldr	r3, [r3]
10018aa0:	e2433004 	sub	r3, r3, #4
10018aa4:	e5933000 	ldr	r3, [r3]
10018aa8:	e1a00002 	mov	r0, r2
10018aac:	e1a01003 	mov	r1, r3
10018ab0:	fa001355 	blx	1001d80c <__aeabi_idivmod>
10018ab4:	e1a03001 	mov	r3, r1
10018ab8:	e5843000 	str	r3, [r4]
10018abc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ac0:	e3413002 	movt	r3, #4098	; 0x1002
10018ac4:	e5933000 	ldr	r3, [r3]
10018ac8:	e2432004 	sub	r2, r3, #4
10018acc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ad0:	e3413002 	movt	r3, #4098	; 0x1002
10018ad4:	e5832000 	str	r2, [r3]

	return ;
10018ad8:	e1a00000 	nop			; (mov r0, r0)
}
10018adc:	e8bd8818 	pop	{r3, r4, fp, pc}

10018ae0 <OP_mul_byte>:

/* --- mul --- */
void OP_mul_byte()
{
10018ae0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018ae4:	e28db000 	add	fp, sp, #0
    OP_BIN_BYTE(*);
10018ae8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018aec:	e3413002 	movt	r3, #4098	; 0x1002
10018af0:	e5933000 	ldr	r3, [r3]
10018af4:	e2432008 	sub	r2, r3, #8
10018af8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018afc:	e3413002 	movt	r3, #4098	; 0x1002
10018b00:	e5933000 	ldr	r3, [r3]
10018b04:	e2433008 	sub	r3, r3, #8
10018b08:	e5d31000 	ldrb	r1, [r3]
10018b0c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018b10:	e3413002 	movt	r3, #4098	; 0x1002
10018b14:	e5933000 	ldr	r3, [r3]
10018b18:	e2433004 	sub	r3, r3, #4
10018b1c:	e5d33000 	ldrb	r3, [r3]
10018b20:	e1630381 	smulbb	r3, r1, r3
10018b24:	e6ef3073 	uxtb	r3, r3
10018b28:	e5c23000 	strb	r3, [r2]
10018b2c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018b30:	e3413002 	movt	r3, #4098	; 0x1002
10018b34:	e5933000 	ldr	r3, [r3]
10018b38:	e2432004 	sub	r2, r3, #4
10018b3c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018b40:	e3413002 	movt	r3, #4098	; 0x1002
10018b44:	e5832000 	str	r2, [r3]

	return ;
10018b48:	e1a00000 	nop			; (mov r0, r0)
}
10018b4c:	e24bd000 	sub	sp, fp, #0
10018b50:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018b54:	e12fff1e 	bx	lr

10018b58 <OP_mul_word>:

void OP_mul_word()
{
10018b58:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018b5c:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(*);
10018b60:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018b64:	e3413002 	movt	r3, #4098	; 0x1002
10018b68:	e5933000 	ldr	r3, [r3]
10018b6c:	e2432008 	sub	r2, r3, #8
10018b70:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018b74:	e3413002 	movt	r3, #4098	; 0x1002
10018b78:	e5933000 	ldr	r3, [r3]
10018b7c:	e2433008 	sub	r3, r3, #8
10018b80:	e1d330b0 	ldrh	r3, [r3]
10018b84:	e6ff1073 	uxth	r1, r3
10018b88:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018b8c:	e3413002 	movt	r3, #4098	; 0x1002
10018b90:	e5933000 	ldr	r3, [r3]
10018b94:	e2433004 	sub	r3, r3, #4
10018b98:	e1d330b0 	ldrh	r3, [r3]
10018b9c:	e6ff3073 	uxth	r3, r3
10018ba0:	e1630381 	smulbb	r3, r1, r3
10018ba4:	e6ff3073 	uxth	r3, r3
10018ba8:	e6ff3073 	uxth	r3, r3
10018bac:	e1c230b0 	strh	r3, [r2]
10018bb0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018bb4:	e3413002 	movt	r3, #4098	; 0x1002
10018bb8:	e5933000 	ldr	r3, [r3]
10018bbc:	e2432004 	sub	r2, r3, #4
10018bc0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018bc4:	e3413002 	movt	r3, #4098	; 0x1002
10018bc8:	e5832000 	str	r2, [r3]

	return ;
10018bcc:	e1a00000 	nop			; (mov r0, r0)
}
10018bd0:	e24bd000 	sub	sp, fp, #0
10018bd4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018bd8:	e12fff1e 	bx	lr

10018bdc <OP_mul_dword>:

void OP_mul_dword()
{
10018bdc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018be0:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(*);
10018be4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018be8:	e3413002 	movt	r3, #4098	; 0x1002
10018bec:	e5933000 	ldr	r3, [r3]
10018bf0:	e2432008 	sub	r2, r3, #8
10018bf4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018bf8:	e3413002 	movt	r3, #4098	; 0x1002
10018bfc:	e5933000 	ldr	r3, [r3]
10018c00:	e2433008 	sub	r3, r3, #8
10018c04:	e5931000 	ldr	r1, [r3]
10018c08:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018c0c:	e3413002 	movt	r3, #4098	; 0x1002
10018c10:	e5933000 	ldr	r3, [r3]
10018c14:	e2433004 	sub	r3, r3, #4
10018c18:	e5933000 	ldr	r3, [r3]
10018c1c:	e0030193 	mul	r3, r3, r1
10018c20:	e5823000 	str	r3, [r2]
10018c24:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018c28:	e3413002 	movt	r3, #4098	; 0x1002
10018c2c:	e5933000 	ldr	r3, [r3]
10018c30:	e2432004 	sub	r2, r3, #4
10018c34:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018c38:	e3413002 	movt	r3, #4098	; 0x1002
10018c3c:	e5832000 	str	r2, [r3]

	return ;
10018c40:	e1a00000 	nop			; (mov r0, r0)
}
10018c44:	e24bd000 	sub	sp, fp, #0
10018c48:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018c4c:	e12fff1e 	bx	lr

10018c50 <OP_and_byte>:

/* --- and --- */
void OP_and_byte()
{
10018c50:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018c54:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(&);
10018c58:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018c5c:	e3413002 	movt	r3, #4098	; 0x1002
10018c60:	e5933000 	ldr	r3, [r3]
10018c64:	e2432008 	sub	r2, r3, #8
10018c68:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018c6c:	e3413002 	movt	r3, #4098	; 0x1002
10018c70:	e5933000 	ldr	r3, [r3]
10018c74:	e2433008 	sub	r3, r3, #8
10018c78:	e5d31000 	ldrb	r1, [r3]
10018c7c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018c80:	e3413002 	movt	r3, #4098	; 0x1002
10018c84:	e5933000 	ldr	r3, [r3]
10018c88:	e2433004 	sub	r3, r3, #4
10018c8c:	e5d33000 	ldrb	r3, [r3]
10018c90:	e0033001 	and	r3, r3, r1
10018c94:	e6ef3073 	uxtb	r3, r3
10018c98:	e5c23000 	strb	r3, [r2]
10018c9c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ca0:	e3413002 	movt	r3, #4098	; 0x1002
10018ca4:	e5933000 	ldr	r3, [r3]
10018ca8:	e2432004 	sub	r2, r3, #4
10018cac:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018cb0:	e3413002 	movt	r3, #4098	; 0x1002
10018cb4:	e5832000 	str	r2, [r3]

	return ;
10018cb8:	e1a00000 	nop			; (mov r0, r0)
}
10018cbc:	e24bd000 	sub	sp, fp, #0
10018cc0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018cc4:	e12fff1e 	bx	lr

10018cc8 <OP_and_word>:

void OP_and_word()
{
10018cc8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018ccc:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(&);
10018cd0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018cd4:	e3413002 	movt	r3, #4098	; 0x1002
10018cd8:	e5933000 	ldr	r3, [r3]
10018cdc:	e2432008 	sub	r2, r3, #8
10018ce0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ce4:	e3413002 	movt	r3, #4098	; 0x1002
10018ce8:	e5933000 	ldr	r3, [r3]
10018cec:	e2433008 	sub	r3, r3, #8
10018cf0:	e1d310b0 	ldrh	r1, [r3]
10018cf4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018cf8:	e3413002 	movt	r3, #4098	; 0x1002
10018cfc:	e5933000 	ldr	r3, [r3]
10018d00:	e2433004 	sub	r3, r3, #4
10018d04:	e1d330b0 	ldrh	r3, [r3]
10018d08:	e0033001 	and	r3, r3, r1
10018d0c:	e6ff3073 	uxth	r3, r3
10018d10:	e1c230b0 	strh	r3, [r2]
10018d14:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d18:	e3413002 	movt	r3, #4098	; 0x1002
10018d1c:	e5933000 	ldr	r3, [r3]
10018d20:	e2432004 	sub	r2, r3, #4
10018d24:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d28:	e3413002 	movt	r3, #4098	; 0x1002
10018d2c:	e5832000 	str	r2, [r3]

	return ;
10018d30:	e1a00000 	nop			; (mov r0, r0)
}
10018d34:	e24bd000 	sub	sp, fp, #0
10018d38:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018d3c:	e12fff1e 	bx	lr

10018d40 <OP_and_dword>:

void OP_and_dword()
{
10018d40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018d44:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(&);
10018d48:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d4c:	e3413002 	movt	r3, #4098	; 0x1002
10018d50:	e5933000 	ldr	r3, [r3]
10018d54:	e2432008 	sub	r2, r3, #8
10018d58:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d5c:	e3413002 	movt	r3, #4098	; 0x1002
10018d60:	e5933000 	ldr	r3, [r3]
10018d64:	e2433008 	sub	r3, r3, #8
10018d68:	e5931000 	ldr	r1, [r3]
10018d6c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d70:	e3413002 	movt	r3, #4098	; 0x1002
10018d74:	e5933000 	ldr	r3, [r3]
10018d78:	e2433004 	sub	r3, r3, #4
10018d7c:	e5933000 	ldr	r3, [r3]
10018d80:	e0033001 	and	r3, r3, r1
10018d84:	e5823000 	str	r3, [r2]
10018d88:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d8c:	e3413002 	movt	r3, #4098	; 0x1002
10018d90:	e5933000 	ldr	r3, [r3]
10018d94:	e2432004 	sub	r2, r3, #4
10018d98:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018d9c:	e3413002 	movt	r3, #4098	; 0x1002
10018da0:	e5832000 	str	r2, [r3]

	return ;
10018da4:	e1a00000 	nop			; (mov r0, r0)
}
10018da8:	e24bd000 	sub	sp, fp, #0
10018dac:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018db0:	e12fff1e 	bx	lr

10018db4 <OP_or_byte>:

/* --- or --- */
void OP_or_byte()
{
10018db4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018db8:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(|);
10018dbc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018dc0:	e3413002 	movt	r3, #4098	; 0x1002
10018dc4:	e5933000 	ldr	r3, [r3]
10018dc8:	e2432008 	sub	r2, r3, #8
10018dcc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018dd0:	e3413002 	movt	r3, #4098	; 0x1002
10018dd4:	e5933000 	ldr	r3, [r3]
10018dd8:	e2433008 	sub	r3, r3, #8
10018ddc:	e5d31000 	ldrb	r1, [r3]
10018de0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018de4:	e3413002 	movt	r3, #4098	; 0x1002
10018de8:	e5933000 	ldr	r3, [r3]
10018dec:	e2433004 	sub	r3, r3, #4
10018df0:	e5d33000 	ldrb	r3, [r3]
10018df4:	e1813003 	orr	r3, r1, r3
10018df8:	e6ef3073 	uxtb	r3, r3
10018dfc:	e5c23000 	strb	r3, [r2]
10018e00:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e04:	e3413002 	movt	r3, #4098	; 0x1002
10018e08:	e5933000 	ldr	r3, [r3]
10018e0c:	e2432004 	sub	r2, r3, #4
10018e10:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e14:	e3413002 	movt	r3, #4098	; 0x1002
10018e18:	e5832000 	str	r2, [r3]

	return ;
10018e1c:	e1a00000 	nop			; (mov r0, r0)
}
10018e20:	e24bd000 	sub	sp, fp, #0
10018e24:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018e28:	e12fff1e 	bx	lr

10018e2c <OP_or_word>:

void OP_or_word()
{
10018e2c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018e30:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(|);
10018e34:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e38:	e3413002 	movt	r3, #4098	; 0x1002
10018e3c:	e5933000 	ldr	r3, [r3]
10018e40:	e2432008 	sub	r2, r3, #8
10018e44:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e48:	e3413002 	movt	r3, #4098	; 0x1002
10018e4c:	e5933000 	ldr	r3, [r3]
10018e50:	e2433008 	sub	r3, r3, #8
10018e54:	e1d310b0 	ldrh	r1, [r3]
10018e58:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e5c:	e3413002 	movt	r3, #4098	; 0x1002
10018e60:	e5933000 	ldr	r3, [r3]
10018e64:	e2433004 	sub	r3, r3, #4
10018e68:	e1d330b0 	ldrh	r3, [r3]
10018e6c:	e1813003 	orr	r3, r1, r3
10018e70:	e6ff3073 	uxth	r3, r3
10018e74:	e1c230b0 	strh	r3, [r2]
10018e78:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e7c:	e3413002 	movt	r3, #4098	; 0x1002
10018e80:	e5933000 	ldr	r3, [r3]
10018e84:	e2432004 	sub	r2, r3, #4
10018e88:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018e8c:	e3413002 	movt	r3, #4098	; 0x1002
10018e90:	e5832000 	str	r2, [r3]

	return ;
10018e94:	e1a00000 	nop			; (mov r0, r0)
}
10018e98:	e24bd000 	sub	sp, fp, #0
10018e9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018ea0:	e12fff1e 	bx	lr

10018ea4 <OP_or_dword>:

void OP_or_dword()
{
10018ea4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018ea8:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(|);
10018eac:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018eb0:	e3413002 	movt	r3, #4098	; 0x1002
10018eb4:	e5933000 	ldr	r3, [r3]
10018eb8:	e2432008 	sub	r2, r3, #8
10018ebc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ec0:	e3413002 	movt	r3, #4098	; 0x1002
10018ec4:	e5933000 	ldr	r3, [r3]
10018ec8:	e2433008 	sub	r3, r3, #8
10018ecc:	e5931000 	ldr	r1, [r3]
10018ed0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ed4:	e3413002 	movt	r3, #4098	; 0x1002
10018ed8:	e5933000 	ldr	r3, [r3]
10018edc:	e2433004 	sub	r3, r3, #4
10018ee0:	e5933000 	ldr	r3, [r3]
10018ee4:	e1813003 	orr	r3, r1, r3
10018ee8:	e5823000 	str	r3, [r2]
10018eec:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ef0:	e3413002 	movt	r3, #4098	; 0x1002
10018ef4:	e5933000 	ldr	r3, [r3]
10018ef8:	e2432004 	sub	r2, r3, #4
10018efc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f00:	e3413002 	movt	r3, #4098	; 0x1002
10018f04:	e5832000 	str	r2, [r3]

	return ;
10018f08:	e1a00000 	nop			; (mov r0, r0)
}
10018f0c:	e24bd000 	sub	sp, fp, #0
10018f10:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018f14:	e12fff1e 	bx	lr

10018f18 <OP_xor_byte>:

/* --- xor --- */
void OP_xor_byte()
{
10018f18:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018f1c:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(^);
10018f20:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f24:	e3413002 	movt	r3, #4098	; 0x1002
10018f28:	e5933000 	ldr	r3, [r3]
10018f2c:	e2432008 	sub	r2, r3, #8
10018f30:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f34:	e3413002 	movt	r3, #4098	; 0x1002
10018f38:	e5933000 	ldr	r3, [r3]
10018f3c:	e2433008 	sub	r3, r3, #8
10018f40:	e5d31000 	ldrb	r1, [r3]
10018f44:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f48:	e3413002 	movt	r3, #4098	; 0x1002
10018f4c:	e5933000 	ldr	r3, [r3]
10018f50:	e2433004 	sub	r3, r3, #4
10018f54:	e5d33000 	ldrb	r3, [r3]
10018f58:	e0233001 	eor	r3, r3, r1
10018f5c:	e6ef3073 	uxtb	r3, r3
10018f60:	e5c23000 	strb	r3, [r2]
10018f64:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f68:	e3413002 	movt	r3, #4098	; 0x1002
10018f6c:	e5933000 	ldr	r3, [r3]
10018f70:	e2432004 	sub	r2, r3, #4
10018f74:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f78:	e3413002 	movt	r3, #4098	; 0x1002
10018f7c:	e5832000 	str	r2, [r3]

	return ;
10018f80:	e1a00000 	nop			; (mov r0, r0)
}
10018f84:	e24bd000 	sub	sp, fp, #0
10018f88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10018f8c:	e12fff1e 	bx	lr

10018f90 <OP_xor_word>:

void OP_xor_word()
{
10018f90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10018f94:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(^);
10018f98:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018f9c:	e3413002 	movt	r3, #4098	; 0x1002
10018fa0:	e5933000 	ldr	r3, [r3]
10018fa4:	e2432008 	sub	r2, r3, #8
10018fa8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018fac:	e3413002 	movt	r3, #4098	; 0x1002
10018fb0:	e5933000 	ldr	r3, [r3]
10018fb4:	e2433008 	sub	r3, r3, #8
10018fb8:	e1d310b0 	ldrh	r1, [r3]
10018fbc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018fc0:	e3413002 	movt	r3, #4098	; 0x1002
10018fc4:	e5933000 	ldr	r3, [r3]
10018fc8:	e2433004 	sub	r3, r3, #4
10018fcc:	e1d330b0 	ldrh	r3, [r3]
10018fd0:	e0233001 	eor	r3, r3, r1
10018fd4:	e6ff3073 	uxth	r3, r3
10018fd8:	e1c230b0 	strh	r3, [r2]
10018fdc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018fe0:	e3413002 	movt	r3, #4098	; 0x1002
10018fe4:	e5933000 	ldr	r3, [r3]
10018fe8:	e2432004 	sub	r2, r3, #4
10018fec:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10018ff0:	e3413002 	movt	r3, #4098	; 0x1002
10018ff4:	e5832000 	str	r2, [r3]

	return ;
10018ff8:	e1a00000 	nop			; (mov r0, r0)
}
10018ffc:	e24bd000 	sub	sp, fp, #0
10019000:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019004:	e12fff1e 	bx	lr

10019008 <OP_xor_dword>:

void OP_xor_dword()
{
10019008:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001900c:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(^);
10019010:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019014:	e3413002 	movt	r3, #4098	; 0x1002
10019018:	e5933000 	ldr	r3, [r3]
1001901c:	e2432008 	sub	r2, r3, #8
10019020:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019024:	e3413002 	movt	r3, #4098	; 0x1002
10019028:	e5933000 	ldr	r3, [r3]
1001902c:	e2433008 	sub	r3, r3, #8
10019030:	e5931000 	ldr	r1, [r3]
10019034:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019038:	e3413002 	movt	r3, #4098	; 0x1002
1001903c:	e5933000 	ldr	r3, [r3]
10019040:	e2433004 	sub	r3, r3, #4
10019044:	e5933000 	ldr	r3, [r3]
10019048:	e0233001 	eor	r3, r3, r1
1001904c:	e5823000 	str	r3, [r2]
10019050:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019054:	e3413002 	movt	r3, #4098	; 0x1002
10019058:	e5933000 	ldr	r3, [r3]
1001905c:	e2432004 	sub	r2, r3, #4
10019060:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019064:	e3413002 	movt	r3, #4098	; 0x1002
10019068:	e5832000 	str	r2, [r3]

	return ;
1001906c:	e1a00000 	nop			; (mov r0, r0)
}
10019070:	e24bd000 	sub	sp, fp, #0
10019074:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019078:	e12fff1e 	bx	lr

1001907c <OP_bw_byte>:

/* --- bw --- */
void OP_bw_byte()
{
1001907c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019080:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->char_value = ~ ((finsh_sp - 1)->char_value);
10019084:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019088:	e3413002 	movt	r3, #4098	; 0x1002
1001908c:	e5933000 	ldr	r3, [r3]
10019090:	e2432004 	sub	r2, r3, #4
10019094:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019098:	e3413002 	movt	r3, #4098	; 0x1002
1001909c:	e5933000 	ldr	r3, [r3]
100190a0:	e2433004 	sub	r3, r3, #4
100190a4:	e5d33000 	ldrb	r3, [r3]
100190a8:	e1e03003 	mvn	r3, r3
100190ac:	e6ef3073 	uxtb	r3, r3
100190b0:	e5c23000 	strb	r3, [r2]

	return ;
100190b4:	e1a00000 	nop			; (mov r0, r0)
}
100190b8:	e24bd000 	sub	sp, fp, #0
100190bc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100190c0:	e12fff1e 	bx	lr

100190c4 <OP_bw_word>:

void OP_bw_word()
{
100190c4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100190c8:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->short_value = ~ ((finsh_sp - 1)->short_value);
100190cc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100190d0:	e3413002 	movt	r3, #4098	; 0x1002
100190d4:	e5933000 	ldr	r3, [r3]
100190d8:	e2432004 	sub	r2, r3, #4
100190dc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100190e0:	e3413002 	movt	r3, #4098	; 0x1002
100190e4:	e5933000 	ldr	r3, [r3]
100190e8:	e2433004 	sub	r3, r3, #4
100190ec:	e1d330b0 	ldrh	r3, [r3]
100190f0:	e1e03003 	mvn	r3, r3
100190f4:	e6ff3073 	uxth	r3, r3
100190f8:	e1c230b0 	strh	r3, [r2]

	return ;
100190fc:	e1a00000 	nop			; (mov r0, r0)
}
10019100:	e24bd000 	sub	sp, fp, #0
10019104:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019108:	e12fff1e 	bx	lr

1001910c <OP_bw_dword>:

void OP_bw_dword()
{
1001910c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019110:	e28db000 	add	fp, sp, #0
	(finsh_sp - 1)->long_value = ~ ((finsh_sp - 1)->long_value);
10019114:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019118:	e3413002 	movt	r3, #4098	; 0x1002
1001911c:	e5933000 	ldr	r3, [r3]
10019120:	e2432004 	sub	r2, r3, #4
10019124:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019128:	e3413002 	movt	r3, #4098	; 0x1002
1001912c:	e5933000 	ldr	r3, [r3]
10019130:	e2433004 	sub	r3, r3, #4
10019134:	e5933000 	ldr	r3, [r3]
10019138:	e1e03003 	mvn	r3, r3
1001913c:	e5823000 	str	r3, [r2]

	return ;
10019140:	e1a00000 	nop			; (mov r0, r0)
}
10019144:	e24bd000 	sub	sp, fp, #0
10019148:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001914c:	e12fff1e 	bx	lr

10019150 <OP_shl_byte>:

/* --- shl --- */
void OP_shl_byte()
{
10019150:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019154:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(<<);
10019158:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001915c:	e3413002 	movt	r3, #4098	; 0x1002
10019160:	e5933000 	ldr	r3, [r3]
10019164:	e2432008 	sub	r2, r3, #8
10019168:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001916c:	e3413002 	movt	r3, #4098	; 0x1002
10019170:	e5933000 	ldr	r3, [r3]
10019174:	e2433008 	sub	r3, r3, #8
10019178:	e5d33000 	ldrb	r3, [r3]
1001917c:	e1a01003 	mov	r1, r3
10019180:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019184:	e3413002 	movt	r3, #4098	; 0x1002
10019188:	e5933000 	ldr	r3, [r3]
1001918c:	e2433004 	sub	r3, r3, #4
10019190:	e5d33000 	ldrb	r3, [r3]
10019194:	e1a03311 	lsl	r3, r1, r3
10019198:	e6ef3073 	uxtb	r3, r3
1001919c:	e5c23000 	strb	r3, [r2]
100191a0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100191a4:	e3413002 	movt	r3, #4098	; 0x1002
100191a8:	e5933000 	ldr	r3, [r3]
100191ac:	e2432004 	sub	r2, r3, #4
100191b0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100191b4:	e3413002 	movt	r3, #4098	; 0x1002
100191b8:	e5832000 	str	r2, [r3]

	return ;
100191bc:	e1a00000 	nop			; (mov r0, r0)
}
100191c0:	e24bd000 	sub	sp, fp, #0
100191c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100191c8:	e12fff1e 	bx	lr

100191cc <OP_shl_word>:

void OP_shl_word()
{
100191cc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100191d0:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(<<);
100191d4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100191d8:	e3413002 	movt	r3, #4098	; 0x1002
100191dc:	e5933000 	ldr	r3, [r3]
100191e0:	e2432008 	sub	r2, r3, #8
100191e4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100191e8:	e3413002 	movt	r3, #4098	; 0x1002
100191ec:	e5933000 	ldr	r3, [r3]
100191f0:	e2433008 	sub	r3, r3, #8
100191f4:	e1d330b0 	ldrh	r3, [r3]
100191f8:	e6bf1073 	sxth	r1, r3
100191fc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019200:	e3413002 	movt	r3, #4098	; 0x1002
10019204:	e5933000 	ldr	r3, [r3]
10019208:	e2433004 	sub	r3, r3, #4
1001920c:	e1d330b0 	ldrh	r3, [r3]
10019210:	e6bf3073 	sxth	r3, r3
10019214:	e1a03311 	lsl	r3, r1, r3
10019218:	e6ff3073 	uxth	r3, r3
1001921c:	e1c230b0 	strh	r3, [r2]
10019220:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019224:	e3413002 	movt	r3, #4098	; 0x1002
10019228:	e5933000 	ldr	r3, [r3]
1001922c:	e2432004 	sub	r2, r3, #4
10019230:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019234:	e3413002 	movt	r3, #4098	; 0x1002
10019238:	e5832000 	str	r2, [r3]

	return ;
1001923c:	e1a00000 	nop			; (mov r0, r0)
}
10019240:	e24bd000 	sub	sp, fp, #0
10019244:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019248:	e12fff1e 	bx	lr

1001924c <OP_shl_dword>:

void OP_shl_dword()
{
1001924c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019250:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(<<);
10019254:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019258:	e3413002 	movt	r3, #4098	; 0x1002
1001925c:	e5933000 	ldr	r3, [r3]
10019260:	e2432008 	sub	r2, r3, #8
10019264:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019268:	e3413002 	movt	r3, #4098	; 0x1002
1001926c:	e5933000 	ldr	r3, [r3]
10019270:	e2433008 	sub	r3, r3, #8
10019274:	e5931000 	ldr	r1, [r3]
10019278:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001927c:	e3413002 	movt	r3, #4098	; 0x1002
10019280:	e5933000 	ldr	r3, [r3]
10019284:	e2433004 	sub	r3, r3, #4
10019288:	e5933000 	ldr	r3, [r3]
1001928c:	e1a03311 	lsl	r3, r1, r3
10019290:	e5823000 	str	r3, [r2]
10019294:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019298:	e3413002 	movt	r3, #4098	; 0x1002
1001929c:	e5933000 	ldr	r3, [r3]
100192a0:	e2432004 	sub	r2, r3, #4
100192a4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100192a8:	e3413002 	movt	r3, #4098	; 0x1002
100192ac:	e5832000 	str	r2, [r3]

	return ;
100192b0:	e1a00000 	nop			; (mov r0, r0)
}
100192b4:	e24bd000 	sub	sp, fp, #0
100192b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100192bc:	e12fff1e 	bx	lr

100192c0 <OP_shr_byte>:

/* --- shr --- */
void OP_shr_byte()
{
100192c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100192c4:	e28db000 	add	fp, sp, #0
	OP_BIN_BYTE(>>);
100192c8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100192cc:	e3413002 	movt	r3, #4098	; 0x1002
100192d0:	e5933000 	ldr	r3, [r3]
100192d4:	e2432008 	sub	r2, r3, #8
100192d8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100192dc:	e3413002 	movt	r3, #4098	; 0x1002
100192e0:	e5933000 	ldr	r3, [r3]
100192e4:	e2433008 	sub	r3, r3, #8
100192e8:	e5d33000 	ldrb	r3, [r3]
100192ec:	e1a01003 	mov	r1, r3
100192f0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100192f4:	e3413002 	movt	r3, #4098	; 0x1002
100192f8:	e5933000 	ldr	r3, [r3]
100192fc:	e2433004 	sub	r3, r3, #4
10019300:	e5d33000 	ldrb	r3, [r3]
10019304:	e1a03351 	asr	r3, r1, r3
10019308:	e6ef3073 	uxtb	r3, r3
1001930c:	e5c23000 	strb	r3, [r2]
10019310:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019314:	e3413002 	movt	r3, #4098	; 0x1002
10019318:	e5933000 	ldr	r3, [r3]
1001931c:	e2432004 	sub	r2, r3, #4
10019320:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019324:	e3413002 	movt	r3, #4098	; 0x1002
10019328:	e5832000 	str	r2, [r3]

	return ;
1001932c:	e1a00000 	nop			; (mov r0, r0)
}
10019330:	e24bd000 	sub	sp, fp, #0
10019334:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019338:	e12fff1e 	bx	lr

1001933c <OP_shr_word>:

void OP_shr_word()
{
1001933c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019340:	e28db000 	add	fp, sp, #0
	OP_BIN_WORD(>>);
10019344:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019348:	e3413002 	movt	r3, #4098	; 0x1002
1001934c:	e5933000 	ldr	r3, [r3]
10019350:	e2432008 	sub	r2, r3, #8
10019354:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019358:	e3413002 	movt	r3, #4098	; 0x1002
1001935c:	e5933000 	ldr	r3, [r3]
10019360:	e2433008 	sub	r3, r3, #8
10019364:	e1d330b0 	ldrh	r3, [r3]
10019368:	e6bf1073 	sxth	r1, r3
1001936c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019370:	e3413002 	movt	r3, #4098	; 0x1002
10019374:	e5933000 	ldr	r3, [r3]
10019378:	e2433004 	sub	r3, r3, #4
1001937c:	e1d330b0 	ldrh	r3, [r3]
10019380:	e6bf3073 	sxth	r3, r3
10019384:	e1a03351 	asr	r3, r1, r3
10019388:	e6ff3073 	uxth	r3, r3
1001938c:	e1c230b0 	strh	r3, [r2]
10019390:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019394:	e3413002 	movt	r3, #4098	; 0x1002
10019398:	e5933000 	ldr	r3, [r3]
1001939c:	e2432004 	sub	r2, r3, #4
100193a0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100193a4:	e3413002 	movt	r3, #4098	; 0x1002
100193a8:	e5832000 	str	r2, [r3]

	return ;
100193ac:	e1a00000 	nop			; (mov r0, r0)
}
100193b0:	e24bd000 	sub	sp, fp, #0
100193b4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100193b8:	e12fff1e 	bx	lr

100193bc <OP_shr_dword>:

void OP_shr_dword()
{
100193bc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100193c0:	e28db000 	add	fp, sp, #0
	OP_BIN_DWORD(>>);
100193c4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100193c8:	e3413002 	movt	r3, #4098	; 0x1002
100193cc:	e5933000 	ldr	r3, [r3]
100193d0:	e2432008 	sub	r2, r3, #8
100193d4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100193d8:	e3413002 	movt	r3, #4098	; 0x1002
100193dc:	e5933000 	ldr	r3, [r3]
100193e0:	e2433008 	sub	r3, r3, #8
100193e4:	e5931000 	ldr	r1, [r3]
100193e8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100193ec:	e3413002 	movt	r3, #4098	; 0x1002
100193f0:	e5933000 	ldr	r3, [r3]
100193f4:	e2433004 	sub	r3, r3, #4
100193f8:	e5933000 	ldr	r3, [r3]
100193fc:	e1a03351 	asr	r3, r1, r3
10019400:	e5823000 	str	r3, [r2]
10019404:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019408:	e3413002 	movt	r3, #4098	; 0x1002
1001940c:	e5933000 	ldr	r3, [r3]
10019410:	e2432004 	sub	r2, r3, #4
10019414:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019418:	e3413002 	movt	r3, #4098	; 0x1002
1001941c:	e5832000 	str	r2, [r3]

	return ;
10019420:	e1a00000 	nop			; (mov r0, r0)
}
10019424:	e24bd000 	sub	sp, fp, #0
10019428:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001942c:	e12fff1e 	bx	lr

10019430 <OP_ld_byte>:

/* --- ld --- */
void OP_ld_byte()
{
10019430:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019434:	e28db000 	add	fp, sp, #0
	finsh_sp->char_value = *finsh_pc;
10019438:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001943c:	e3413002 	movt	r3, #4098	; 0x1002
10019440:	e5932000 	ldr	r2, [r3]
10019444:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019448:	e3413002 	movt	r3, #4098	; 0x1002
1001944c:	e5933000 	ldr	r3, [r3]
10019450:	e5d33000 	ldrb	r3, [r3]
10019454:	e5c23000 	strb	r3, [r2]

	finsh_sp++;
10019458:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001945c:	e3413002 	movt	r3, #4098	; 0x1002
10019460:	e5933000 	ldr	r3, [r3]
10019464:	e2832004 	add	r2, r3, #4
10019468:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001946c:	e3413002 	movt	r3, #4098	; 0x1002
10019470:	e5832000 	str	r2, [r3]
	finsh_pc++;
10019474:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019478:	e3413002 	movt	r3, #4098	; 0x1002
1001947c:	e5933000 	ldr	r3, [r3]
10019480:	e2832001 	add	r2, r3, #1
10019484:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019488:	e3413002 	movt	r3, #4098	; 0x1002
1001948c:	e5832000 	str	r2, [r3]

	return ;
10019490:	e1a00000 	nop			; (mov r0, r0)
}
10019494:	e24bd000 	sub	sp, fp, #0
10019498:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001949c:	e12fff1e 	bx	lr

100194a0 <OP_ld_word>:

void OP_ld_word()
{
100194a0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100194a4:	e28db000 	add	fp, sp, #0
	finsh_sp->short_value = FINSH_GET16(finsh_pc);
100194a8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100194ac:	e3413002 	movt	r3, #4098	; 0x1002
100194b0:	e5932000 	ldr	r2, [r3]
100194b4:	e30a3a68 	movw	r3, #43624	; 0xaa68
100194b8:	e3413002 	movt	r3, #4098	; 0x1002
100194bc:	e5933000 	ldr	r3, [r3]
100194c0:	e5d33000 	ldrb	r3, [r3]
100194c4:	e6ff1073 	uxth	r1, r3
100194c8:	e30a3a68 	movw	r3, #43624	; 0xaa68
100194cc:	e3413002 	movt	r3, #4098	; 0x1002
100194d0:	e5933000 	ldr	r3, [r3]
100194d4:	e2833001 	add	r3, r3, #1
100194d8:	e5d33000 	ldrb	r3, [r3]
100194dc:	e1a03403 	lsl	r3, r3, #8
100194e0:	e6ff3073 	uxth	r3, r3
100194e4:	e1813003 	orr	r3, r1, r3
100194e8:	e6ff3073 	uxth	r3, r3
100194ec:	e1c230b0 	strh	r3, [r2]

	finsh_sp ++;
100194f0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100194f4:	e3413002 	movt	r3, #4098	; 0x1002
100194f8:	e5933000 	ldr	r3, [r3]
100194fc:	e2832004 	add	r2, r3, #4
10019500:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019504:	e3413002 	movt	r3, #4098	; 0x1002
10019508:	e5832000 	str	r2, [r3]
	finsh_pc += 2;
1001950c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019510:	e3413002 	movt	r3, #4098	; 0x1002
10019514:	e5933000 	ldr	r3, [r3]
10019518:	e2832002 	add	r2, r3, #2
1001951c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019520:	e3413002 	movt	r3, #4098	; 0x1002
10019524:	e5832000 	str	r2, [r3]

	return ;
10019528:	e1a00000 	nop			; (mov r0, r0)
}
1001952c:	e24bd000 	sub	sp, fp, #0
10019530:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019534:	e12fff1e 	bx	lr

10019538 <OP_ld_dword>:

void OP_ld_dword()
{
10019538:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001953c:	e28db000 	add	fp, sp, #0
	finsh_sp->long_value = FINSH_GET32(finsh_pc);
10019540:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019544:	e3413002 	movt	r3, #4098	; 0x1002
10019548:	e5932000 	ldr	r2, [r3]
1001954c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019550:	e3413002 	movt	r3, #4098	; 0x1002
10019554:	e5933000 	ldr	r3, [r3]
10019558:	e5d33000 	ldrb	r3, [r3]
1001955c:	e1a01003 	mov	r1, r3
10019560:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019564:	e3413002 	movt	r3, #4098	; 0x1002
10019568:	e5933000 	ldr	r3, [r3]
1001956c:	e2833001 	add	r3, r3, #1
10019570:	e5d33000 	ldrb	r3, [r3]
10019574:	e1a03403 	lsl	r3, r3, #8
10019578:	e1811003 	orr	r1, r1, r3
1001957c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019580:	e3413002 	movt	r3, #4098	; 0x1002
10019584:	e5933000 	ldr	r3, [r3]
10019588:	e2833002 	add	r3, r3, #2
1001958c:	e5d33000 	ldrb	r3, [r3]
10019590:	e1a03803 	lsl	r3, r3, #16
10019594:	e1811003 	orr	r1, r1, r3
10019598:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001959c:	e3413002 	movt	r3, #4098	; 0x1002
100195a0:	e5933000 	ldr	r3, [r3]
100195a4:	e2833003 	add	r3, r3, #3
100195a8:	e5d33000 	ldrb	r3, [r3]
100195ac:	e1a03c03 	lsl	r3, r3, #24
100195b0:	e1813003 	orr	r3, r1, r3
100195b4:	e5823000 	str	r3, [r2]

	finsh_sp ++;
100195b8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100195bc:	e3413002 	movt	r3, #4098	; 0x1002
100195c0:	e5933000 	ldr	r3, [r3]
100195c4:	e2832004 	add	r2, r3, #4
100195c8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100195cc:	e3413002 	movt	r3, #4098	; 0x1002
100195d0:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
100195d4:	e30a3a68 	movw	r3, #43624	; 0xaa68
100195d8:	e3413002 	movt	r3, #4098	; 0x1002
100195dc:	e5933000 	ldr	r3, [r3]
100195e0:	e2832004 	add	r2, r3, #4
100195e4:	e30a3a68 	movw	r3, #43624	; 0xaa68
100195e8:	e3413002 	movt	r3, #4098	; 0x1002
100195ec:	e5832000 	str	r2, [r3]

	return ;
100195f0:	e1a00000 	nop			; (mov r0, r0)
}
100195f4:	e24bd000 	sub	sp, fp, #0
100195f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100195fc:	e12fff1e 	bx	lr

10019600 <OP_ld_value_byte>:

void OP_ld_value_byte()
{
10019600:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019604:	e28db000 	add	fp, sp, #0
10019608:	e24dd00c 	sub	sp, sp, #12
	char* c;

	c = (char*) (FINSH_GET32(finsh_pc));
1001960c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019610:	e3413002 	movt	r3, #4098	; 0x1002
10019614:	e5933000 	ldr	r3, [r3]
10019618:	e5d33000 	ldrb	r3, [r3]
1001961c:	e1a02003 	mov	r2, r3
10019620:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019624:	e3413002 	movt	r3, #4098	; 0x1002
10019628:	e5933000 	ldr	r3, [r3]
1001962c:	e2833001 	add	r3, r3, #1
10019630:	e5d33000 	ldrb	r3, [r3]
10019634:	e1a03403 	lsl	r3, r3, #8
10019638:	e1822003 	orr	r2, r2, r3
1001963c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019640:	e3413002 	movt	r3, #4098	; 0x1002
10019644:	e5933000 	ldr	r3, [r3]
10019648:	e2833002 	add	r3, r3, #2
1001964c:	e5d33000 	ldrb	r3, [r3]
10019650:	e1a03803 	lsl	r3, r3, #16
10019654:	e1822003 	orr	r2, r2, r3
10019658:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001965c:	e3413002 	movt	r3, #4098	; 0x1002
10019660:	e5933000 	ldr	r3, [r3]
10019664:	e2833003 	add	r3, r3, #3
10019668:	e5d33000 	ldrb	r3, [r3]
1001966c:	e1a03c03 	lsl	r3, r3, #24
10019670:	e1823003 	orr	r3, r2, r3
10019674:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->char_value = *c;
10019678:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001967c:	e3413002 	movt	r3, #4098	; 0x1002
10019680:	e5933000 	ldr	r3, [r3]
10019684:	e51b2008 	ldr	r2, [fp, #-8]
10019688:	e5d22000 	ldrb	r2, [r2]
1001968c:	e5c32000 	strb	r2, [r3]

	finsh_sp ++;
10019690:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019694:	e3413002 	movt	r3, #4098	; 0x1002
10019698:	e5933000 	ldr	r3, [r3]
1001969c:	e2832004 	add	r2, r3, #4
100196a0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100196a4:	e3413002 	movt	r3, #4098	; 0x1002
100196a8:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
100196ac:	e30a3a68 	movw	r3, #43624	; 0xaa68
100196b0:	e3413002 	movt	r3, #4098	; 0x1002
100196b4:	e5933000 	ldr	r3, [r3]
100196b8:	e2832004 	add	r2, r3, #4
100196bc:	e30a3a68 	movw	r3, #43624	; 0xaa68
100196c0:	e3413002 	movt	r3, #4098	; 0x1002
100196c4:	e5832000 	str	r2, [r3]

	return;
100196c8:	e1a00000 	nop			; (mov r0, r0)
}
100196cc:	e24bd000 	sub	sp, fp, #0
100196d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100196d4:	e12fff1e 	bx	lr

100196d8 <OP_ld_value_byte_stack>:

void OP_ld_value_byte_stack()
{
100196d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100196dc:	e28db000 	add	fp, sp, #0
100196e0:	e24dd00c 	sub	sp, sp, #12
	char* c;

	c = (char *)(finsh_sp - 1)->long_value;
100196e4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100196e8:	e3413002 	movt	r3, #4098	; 0x1002
100196ec:	e5933000 	ldr	r3, [r3]
100196f0:	e2433004 	sub	r3, r3, #4
100196f4:	e5933000 	ldr	r3, [r3]
100196f8:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->char_value = *c;
100196fc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019700:	e3413002 	movt	r3, #4098	; 0x1002
10019704:	e5933000 	ldr	r3, [r3]
10019708:	e2433004 	sub	r3, r3, #4
1001970c:	e51b2008 	ldr	r2, [fp, #-8]
10019710:	e5d22000 	ldrb	r2, [r2]
10019714:	e5c32000 	strb	r2, [r3]

	return;
10019718:	e1a00000 	nop			; (mov r0, r0)
}
1001971c:	e24bd000 	sub	sp, fp, #0
10019720:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019724:	e12fff1e 	bx	lr

10019728 <OP_ld_value_word>:

void OP_ld_value_word()
{
10019728:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001972c:	e28db000 	add	fp, sp, #0
10019730:	e24dd00c 	sub	sp, sp, #12
	short* s;

	s = (short*) (FINSH_GET32(finsh_pc));
10019734:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019738:	e3413002 	movt	r3, #4098	; 0x1002
1001973c:	e5933000 	ldr	r3, [r3]
10019740:	e5d33000 	ldrb	r3, [r3]
10019744:	e1a02003 	mov	r2, r3
10019748:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001974c:	e3413002 	movt	r3, #4098	; 0x1002
10019750:	e5933000 	ldr	r3, [r3]
10019754:	e2833001 	add	r3, r3, #1
10019758:	e5d33000 	ldrb	r3, [r3]
1001975c:	e1a03403 	lsl	r3, r3, #8
10019760:	e1822003 	orr	r2, r2, r3
10019764:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019768:	e3413002 	movt	r3, #4098	; 0x1002
1001976c:	e5933000 	ldr	r3, [r3]
10019770:	e2833002 	add	r3, r3, #2
10019774:	e5d33000 	ldrb	r3, [r3]
10019778:	e1a03803 	lsl	r3, r3, #16
1001977c:	e1822003 	orr	r2, r2, r3
10019780:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019784:	e3413002 	movt	r3, #4098	; 0x1002
10019788:	e5933000 	ldr	r3, [r3]
1001978c:	e2833003 	add	r3, r3, #3
10019790:	e5d33000 	ldrb	r3, [r3]
10019794:	e1a03c03 	lsl	r3, r3, #24
10019798:	e1823003 	orr	r3, r2, r3
1001979c:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->short_value = *s;
100197a0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100197a4:	e3413002 	movt	r3, #4098	; 0x1002
100197a8:	e5933000 	ldr	r3, [r3]
100197ac:	e51b2008 	ldr	r2, [fp, #-8]
100197b0:	e1d220b0 	ldrh	r2, [r2]
100197b4:	e1c320b0 	strh	r2, [r3]

	finsh_sp ++;
100197b8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100197bc:	e3413002 	movt	r3, #4098	; 0x1002
100197c0:	e5933000 	ldr	r3, [r3]
100197c4:	e2832004 	add	r2, r3, #4
100197c8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100197cc:	e3413002 	movt	r3, #4098	; 0x1002
100197d0:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
100197d4:	e30a3a68 	movw	r3, #43624	; 0xaa68
100197d8:	e3413002 	movt	r3, #4098	; 0x1002
100197dc:	e5933000 	ldr	r3, [r3]
100197e0:	e2832004 	add	r2, r3, #4
100197e4:	e30a3a68 	movw	r3, #43624	; 0xaa68
100197e8:	e3413002 	movt	r3, #4098	; 0x1002
100197ec:	e5832000 	str	r2, [r3]

	return;
100197f0:	e1a00000 	nop			; (mov r0, r0)
}
100197f4:	e24bd000 	sub	sp, fp, #0
100197f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100197fc:	e12fff1e 	bx	lr

10019800 <OP_ld_value_word_stack>:

void OP_ld_value_word_stack()
{
10019800:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019804:	e28db000 	add	fp, sp, #0
10019808:	e24dd00c 	sub	sp, sp, #12
	short* s;

	s = (short *)(finsh_sp - 1)->long_value;
1001980c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019810:	e3413002 	movt	r3, #4098	; 0x1002
10019814:	e5933000 	ldr	r3, [r3]
10019818:	e2433004 	sub	r3, r3, #4
1001981c:	e5933000 	ldr	r3, [r3]
10019820:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->short_value = *s;
10019824:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019828:	e3413002 	movt	r3, #4098	; 0x1002
1001982c:	e5933000 	ldr	r3, [r3]
10019830:	e2433004 	sub	r3, r3, #4
10019834:	e51b2008 	ldr	r2, [fp, #-8]
10019838:	e1d220b0 	ldrh	r2, [r2]
1001983c:	e1c320b0 	strh	r2, [r3]

	return;
10019840:	e1a00000 	nop			; (mov r0, r0)
}
10019844:	e24bd000 	sub	sp, fp, #0
10019848:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001984c:	e12fff1e 	bx	lr

10019850 <OP_ld_value_dword>:

void OP_ld_value_dword()
{
10019850:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019854:	e28db000 	add	fp, sp, #0
10019858:	e24dd00c 	sub	sp, sp, #12
	long* l;

	l = (long*) (FINSH_GET32(finsh_pc));
1001985c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019860:	e3413002 	movt	r3, #4098	; 0x1002
10019864:	e5933000 	ldr	r3, [r3]
10019868:	e5d33000 	ldrb	r3, [r3]
1001986c:	e1a02003 	mov	r2, r3
10019870:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019874:	e3413002 	movt	r3, #4098	; 0x1002
10019878:	e5933000 	ldr	r3, [r3]
1001987c:	e2833001 	add	r3, r3, #1
10019880:	e5d33000 	ldrb	r3, [r3]
10019884:	e1a03403 	lsl	r3, r3, #8
10019888:	e1822003 	orr	r2, r2, r3
1001988c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019890:	e3413002 	movt	r3, #4098	; 0x1002
10019894:	e5933000 	ldr	r3, [r3]
10019898:	e2833002 	add	r3, r3, #2
1001989c:	e5d33000 	ldrb	r3, [r3]
100198a0:	e1a03803 	lsl	r3, r3, #16
100198a4:	e1822003 	orr	r2, r2, r3
100198a8:	e30a3a68 	movw	r3, #43624	; 0xaa68
100198ac:	e3413002 	movt	r3, #4098	; 0x1002
100198b0:	e5933000 	ldr	r3, [r3]
100198b4:	e2833003 	add	r3, r3, #3
100198b8:	e5d33000 	ldrb	r3, [r3]
100198bc:	e1a03c03 	lsl	r3, r3, #24
100198c0:	e1823003 	orr	r3, r2, r3
100198c4:	e50b3008 	str	r3, [fp, #-8]

	finsh_sp->long_value = *l;
100198c8:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100198cc:	e3413002 	movt	r3, #4098	; 0x1002
100198d0:	e5933000 	ldr	r3, [r3]
100198d4:	e51b2008 	ldr	r2, [fp, #-8]
100198d8:	e5922000 	ldr	r2, [r2]
100198dc:	e5832000 	str	r2, [r3]

	finsh_sp ++;
100198e0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100198e4:	e3413002 	movt	r3, #4098	; 0x1002
100198e8:	e5933000 	ldr	r3, [r3]
100198ec:	e2832004 	add	r2, r3, #4
100198f0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100198f4:	e3413002 	movt	r3, #4098	; 0x1002
100198f8:	e5832000 	str	r2, [r3]
	finsh_pc += 4;
100198fc:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019900:	e3413002 	movt	r3, #4098	; 0x1002
10019904:	e5933000 	ldr	r3, [r3]
10019908:	e2832004 	add	r2, r3, #4
1001990c:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019910:	e3413002 	movt	r3, #4098	; 0x1002
10019914:	e5832000 	str	r2, [r3]

	return;
10019918:	e1a00000 	nop			; (mov r0, r0)
}
1001991c:	e24bd000 	sub	sp, fp, #0
10019920:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019924:	e12fff1e 	bx	lr

10019928 <OP_ld_value_dword_stack>:

void OP_ld_value_dword_stack()
{
10019928:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001992c:	e28db000 	add	fp, sp, #0
10019930:	e24dd00c 	sub	sp, sp, #12
	long* l;

	l = (long *)(finsh_sp - 1)->long_value;
10019934:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019938:	e3413002 	movt	r3, #4098	; 0x1002
1001993c:	e5933000 	ldr	r3, [r3]
10019940:	e2433004 	sub	r3, r3, #4
10019944:	e5933000 	ldr	r3, [r3]
10019948:	e50b3008 	str	r3, [fp, #-8]
	(finsh_sp - 1)->long_value = *l;
1001994c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019950:	e3413002 	movt	r3, #4098	; 0x1002
10019954:	e5933000 	ldr	r3, [r3]
10019958:	e2433004 	sub	r3, r3, #4
1001995c:	e51b2008 	ldr	r2, [fp, #-8]
10019960:	e5922000 	ldr	r2, [r2]
10019964:	e5832000 	str	r2, [r3]

	return;
10019968:	e1a00000 	nop			; (mov r0, r0)
}
1001996c:	e24bd000 	sub	sp, fp, #0
10019970:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019974:	e12fff1e 	bx	lr

10019978 <OP_st_byte>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_byte()
{
10019978:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001997c:	e28db000 	add	fp, sp, #0
	*(char*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->char_value;
10019980:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019984:	e3413002 	movt	r3, #4098	; 0x1002
10019988:	e5933000 	ldr	r3, [r3]
1001998c:	e2433008 	sub	r3, r3, #8
10019990:	e5933000 	ldr	r3, [r3]
10019994:	e1a02003 	mov	r2, r3
10019998:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001999c:	e3413002 	movt	r3, #4098	; 0x1002
100199a0:	e5933000 	ldr	r3, [r3]
100199a4:	e2433004 	sub	r3, r3, #4
100199a8:	e5d33000 	ldrb	r3, [r3]
100199ac:	e5c23000 	strb	r3, [r2]
	finsh_sp --;
100199b0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100199b4:	e3413002 	movt	r3, #4098	; 0x1002
100199b8:	e5933000 	ldr	r3, [r3]
100199bc:	e2432004 	sub	r2, r3, #4
100199c0:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100199c4:	e3413002 	movt	r3, #4098	; 0x1002
100199c8:	e5832000 	str	r2, [r3]

	return ;
100199cc:	e1a00000 	nop			; (mov r0, r0)
}
100199d0:	e24bd000 	sub	sp, fp, #0
100199d4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
100199d8:	e12fff1e 	bx	lr

100199dc <OP_st_word>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_word()
{
100199dc:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
100199e0:	e28db000 	add	fp, sp, #0
	*(short*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->short_value;
100199e4:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
100199e8:	e3413002 	movt	r3, #4098	; 0x1002
100199ec:	e5933000 	ldr	r3, [r3]
100199f0:	e2433008 	sub	r3, r3, #8
100199f4:	e5933000 	ldr	r3, [r3]
100199f8:	e1a02003 	mov	r2, r3
100199fc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a00:	e3413002 	movt	r3, #4098	; 0x1002
10019a04:	e5933000 	ldr	r3, [r3]
10019a08:	e2433004 	sub	r3, r3, #4
10019a0c:	e1d330b0 	ldrh	r3, [r3]
10019a10:	e1c230b0 	strh	r3, [r2]
	finsh_sp --;
10019a14:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a18:	e3413002 	movt	r3, #4098	; 0x1002
10019a1c:	e5933000 	ldr	r3, [r3]
10019a20:	e2432004 	sub	r2, r3, #4
10019a24:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a28:	e3413002 	movt	r3, #4098	; 0x1002
10019a2c:	e5832000 	str	r2, [r3]

	return ;
10019a30:	e1a00000 	nop			; (mov r0, r0)
}
10019a34:	e24bd000 	sub	sp, fp, #0
10019a38:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019a3c:	e12fff1e 	bx	lr

10019a40 <OP_st_dword>:
/*
 * 2006-4-16 bernard
 * fixed the sp move bug
 */
void OP_st_dword()
{
10019a40:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019a44:	e28db000 	add	fp, sp, #0
	*(long*)((finsh_sp - 2)->long_value) = (finsh_sp - 1)->long_value;
10019a48:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a4c:	e3413002 	movt	r3, #4098	; 0x1002
10019a50:	e5933000 	ldr	r3, [r3]
10019a54:	e2433008 	sub	r3, r3, #8
10019a58:	e5933000 	ldr	r3, [r3]
10019a5c:	e1a02003 	mov	r2, r3
10019a60:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a64:	e3413002 	movt	r3, #4098	; 0x1002
10019a68:	e5933000 	ldr	r3, [r3]
10019a6c:	e2433004 	sub	r3, r3, #4
10019a70:	e5933000 	ldr	r3, [r3]
10019a74:	e5823000 	str	r3, [r2]
	finsh_sp --;
10019a78:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a7c:	e3413002 	movt	r3, #4098	; 0x1002
10019a80:	e5933000 	ldr	r3, [r3]
10019a84:	e2432004 	sub	r2, r3, #4
10019a88:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019a8c:	e3413002 	movt	r3, #4098	; 0x1002
10019a90:	e5832000 	str	r2, [r3]

	return ;
10019a94:	e1a00000 	nop			; (mov r0, r0)
}
10019a98:	e24bd000 	sub	sp, fp, #0
10019a9c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019aa0:	e12fff1e 	bx	lr

10019aa4 <OP_pop>:

/* --- pop --- */
void OP_pop()
{
10019aa4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
10019aa8:	e28db000 	add	fp, sp, #0
	finsh_sp --;
10019aac:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019ab0:	e3413002 	movt	r3, #4098	; 0x1002
10019ab4:	e5933000 	ldr	r3, [r3]
10019ab8:	e2432004 	sub	r2, r3, #4
10019abc:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019ac0:	e3413002 	movt	r3, #4098	; 0x1002
10019ac4:	e5832000 	str	r2, [r3]
	return ;
10019ac8:	e1a00000 	nop			; (mov r0, r0)
}
10019acc:	e24bd000 	sub	sp, fp, #0
10019ad0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
10019ad4:	e12fff1e 	bx	lr

10019ad8 <OP_call>:

/* --- call --- */
void OP_call()
{
10019ad8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
10019adc:	e28db020 	add	fp, sp, #32
10019ae0:	e24dd094 	sub	sp, sp, #148	; 0x94
	typedef unsigned long var_t;
	typedef var_t (*op_func)();
	op_func f;
	var_t   r;

	parameters = *finsh_pc ++;
10019ae4:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019ae8:	e3413002 	movt	r3, #4098	; 0x1002
10019aec:	e5932000 	ldr	r2, [r3]
10019af0:	e2821001 	add	r1, r2, #1
10019af4:	e30a3a68 	movw	r3, #43624	; 0xaa68
10019af8:	e3413002 	movt	r3, #4098	; 0x1002
10019afc:	e5831000 	str	r1, [r3]
10019b00:	e5d23000 	ldrb	r3, [r2]
10019b04:	e50b3030 	str	r3, [fp, #-48]	; 0x30

	i = 0; finsh_sp --;
10019b08:	e3a03000 	mov	r3, #0
10019b0c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
10019b10:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019b14:	e3413002 	movt	r3, #4098	; 0x1002
10019b18:	e5933000 	ldr	r3, [r3]
10019b1c:	e2432004 	sub	r2, r3, #4
10019b20:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019b24:	e3413002 	movt	r3, #4098	; 0x1002
10019b28:	e5832000 	str	r2, [r3]
	while (i < parameters)
10019b2c:	ea000016 	b	10019b8c <OP_call+0xb4>
	{
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
10019b30:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
10019b34:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10019b38:	e0633002 	rsb	r3, r3, r2
10019b3c:	e2432001 	sub	r2, r3, #1
10019b40:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019b44:	e3413002 	movt	r3, #4098	; 0x1002
10019b48:	e5933000 	ldr	r3, [r3]
10019b4c:	e5933000 	ldr	r3, [r3]
10019b50:	e1a01003 	mov	r1, r3
10019b54:	e1a03102 	lsl	r3, r2, #2
10019b58:	e24b2024 	sub	r2, fp, #36	; 0x24
10019b5c:	e0823003 	add	r3, r2, r3
10019b60:	e5031050 	str	r1, [r3, #-80]	; 0x50
		finsh_sp --;
10019b64:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019b68:	e3413002 	movt	r3, #4098	; 0x1002
10019b6c:	e5933000 	ldr	r3, [r3]
10019b70:	e2432004 	sub	r2, r3, #4
10019b74:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019b78:	e3413002 	movt	r3, #4098	; 0x1002
10019b7c:	e5832000 	str	r2, [r3]
		i++;
10019b80:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
10019b84:	e2833001 	add	r3, r3, #1
10019b88:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	var_t   r;

	parameters = *finsh_pc ++;

	i = 0; finsh_sp --;
	while (i < parameters)
10019b8c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
10019b90:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10019b94:	e1520003 	cmp	r2, r3
10019b98:	3affffe4 	bcc	10019b30 <OP_call+0x58>
		parameterv[parameters - 1 - i] = finsh_sp->long_value;
		finsh_sp --;
		i++;
	}

	f = (op_func)(finsh_sp->long_value);
10019b9c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
10019ba0:	e3413002 	movt	r3, #4098	; 0x1002
10019ba4:	e5933000 	ldr	r3, [r3]
10019ba8:	e5933000 	ldr	r3, [r3]
10019bac:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	switch (parameters)
10019bb0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
10019bb4:	e3530010 	cmp	r3, #16
10019bb8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
10019bbc:	ea00015e 	b	1001a13c <OP_call+0x664>
10019bc0:	10019c04 	.word	0x10019c04
10019bc4:	10019c18 	.word	0x10019c18
10019bc8:	10019c30 	.word	0x10019c30
10019bcc:	10019c50 	.word	0x10019c50
10019bd0:	10019c6c 	.word	0x10019c6c
10019bd4:	10019c8c 	.word	0x10019c8c
10019bd8:	10019cb8 	.word	0x10019cb8
10019bdc:	10019cf0 	.word	0x10019cf0
10019be0:	10019d34 	.word	0x10019d34
10019be4:	10019d84 	.word	0x10019d84
10019be8:	10019ddc 	.word	0x10019ddc
10019bec:	10019e3c 	.word	0x10019e3c
10019bf0:	10019ea4 	.word	0x10019ea4
10019bf4:	10019f14 	.word	0x10019f14
10019bf8:	10019f8c 	.word	0x10019f8c
10019bfc:	1001a010 	.word	0x1001a010
10019c00:	1001a0a0 	.word	0x1001a0a0
	{
	case 0:
		r = f(0);
10019c04:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10019c08:	e3a00000 	mov	r0, #0
10019c0c:	e12fff33 	blx	r3
10019c10:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
10019c14:	ea00014b 	b	1001a148 <OP_call+0x670>

	case 1:
		r = f(parameterv[0]);
10019c18:	e51b2074 	ldr	r2, [fp, #-116]	; 0x74
10019c1c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10019c20:	e1a00002 	mov	r0, r2
10019c24:	e12fff33 	blx	r3
10019c28:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
10019c2c:	ea000145 	b	1001a148 <OP_call+0x670>

	case 2:
		r = f(parameterv[0], parameterv[1]);
10019c30:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
10019c34:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
10019c38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10019c3c:	e1a00001 	mov	r0, r1
10019c40:	e1a01002 	mov	r1, r2
10019c44:	e12fff33 	blx	r3
10019c48:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
10019c4c:	ea00013d 	b	1001a148 <OP_call+0x670>

	case 3:
		r = f(parameterv[0], parameterv[1], parameterv[2]);
10019c50:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
10019c54:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
10019c58:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
10019c5c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
10019c60:	e12fff33 	blx	r3
10019c64:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
10019c68:	ea000136 	b	1001a148 <OP_call+0x670>

	case 4:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3]);
10019c6c:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
10019c70:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
10019c74:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
10019c78:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
10019c7c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019c80:	e12fff3c 	blx	ip
10019c84:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
		break;
10019c88:	ea00012e 	b	1001a148 <OP_call+0x670>

	case 5:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019c8c:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
10019c90:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
10019c94:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
10019c98:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
10019c9c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
10019ca0:	e58d3000 	str	r3, [sp]
10019ca4:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019ca8:	e1a0300e 	mov	r3, lr
10019cac:	e12fff3c 	blx	ip
10019cb0:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4]);
		break;
10019cb4:	ea000123 	b	1001a148 <OP_call+0x670>

	case 6:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019cb8:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
10019cbc:	e51b1070 	ldr	r1, [fp, #-112]	; 0x70
10019cc0:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
10019cc4:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
10019cc8:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
10019ccc:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
10019cd0:	e58d2000 	str	r2, [sp]
10019cd4:	e58d3004 	str	r3, [sp, #4]
10019cd8:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019cdc:	e1a02004 	mov	r2, r4
10019ce0:	e1a0300e 	mov	r3, lr
10019ce4:	e12fff3c 	blx	ip
10019ce8:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5]);
		break;
10019cec:	ea000115 	b	1001a148 <OP_call+0x670>

	case 7:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019cf0:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
10019cf4:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
10019cf8:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
10019cfc:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
10019d00:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
10019d04:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
10019d08:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
10019d0c:	e58d1000 	str	r1, [sp]
10019d10:	e58d2004 	str	r2, [sp, #4]
10019d14:	e58d3008 	str	r3, [sp, #8]
10019d18:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019d1c:	e1a01005 	mov	r1, r5
10019d20:	e1a02004 	mov	r2, r4
10019d24:	e1a0300e 	mov	r3, lr
10019d28:	e12fff3c 	blx	ip
10019d2c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6]);
		break;
10019d30:	ea000104 	b	1001a148 <OP_call+0x670>

	case 8:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019d34:	e51b6074 	ldr	r6, [fp, #-116]	; 0x74
10019d38:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
10019d3c:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
10019d40:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
10019d44:	e51b0064 	ldr	r0, [fp, #-100]	; 0x64
10019d48:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
10019d4c:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
10019d50:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
10019d54:	e58d0000 	str	r0, [sp]
10019d58:	e58d1004 	str	r1, [sp, #4]
10019d5c:	e58d2008 	str	r2, [sp, #8]
10019d60:	e58d300c 	str	r3, [sp, #12]
10019d64:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019d68:	e1a00006 	mov	r0, r6
10019d6c:	e1a01005 	mov	r1, r5
10019d70:	e1a02004 	mov	r2, r4
10019d74:	e1a0300e 	mov	r3, lr
10019d78:	e12fff3c 	blx	ip
10019d7c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7]);
		break;
10019d80:	ea0000f0 	b	1001a148 <OP_call+0x670>

	case 9:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019d84:	e51b6074 	ldr	r6, [fp, #-116]	; 0x74
10019d88:	e51b5070 	ldr	r5, [fp, #-112]	; 0x70
10019d8c:	e51b406c 	ldr	r4, [fp, #-108]	; 0x6c
10019d90:	e51be068 	ldr	lr, [fp, #-104]	; 0x68
10019d94:	e51bc064 	ldr	ip, [fp, #-100]	; 0x64
10019d98:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
10019d9c:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
10019da0:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
10019da4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
10019da8:	e58dc000 	str	ip, [sp]
10019dac:	e58d0004 	str	r0, [sp, #4]
10019db0:	e58d1008 	str	r1, [sp, #8]
10019db4:	e58d200c 	str	r2, [sp, #12]
10019db8:	e58d3010 	str	r3, [sp, #16]
10019dbc:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019dc0:	e1a00006 	mov	r0, r6
10019dc4:	e1a01005 	mov	r1, r5
10019dc8:	e1a02004 	mov	r2, r4
10019dcc:	e1a0300e 	mov	r3, lr
10019dd0:	e12fff3c 	blx	ip
10019dd4:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8]);
		break;
10019dd8:	ea0000da 	b	1001a148 <OP_call+0x670>

	case 10:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019ddc:	e51b7074 	ldr	r7, [fp, #-116]	; 0x74
10019de0:	e51b6070 	ldr	r6, [fp, #-112]	; 0x70
10019de4:	e51b506c 	ldr	r5, [fp, #-108]	; 0x6c
10019de8:	e51b4068 	ldr	r4, [fp, #-104]	; 0x68
10019dec:	e51be064 	ldr	lr, [fp, #-100]	; 0x64
10019df0:	e51bc060 	ldr	ip, [fp, #-96]	; 0x60
10019df4:	e51b005c 	ldr	r0, [fp, #-92]	; 0x5c
10019df8:	e51b1058 	ldr	r1, [fp, #-88]	; 0x58
10019dfc:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
10019e00:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
10019e04:	e58de000 	str	lr, [sp]
10019e08:	e58dc004 	str	ip, [sp, #4]
10019e0c:	e58d0008 	str	r0, [sp, #8]
10019e10:	e58d100c 	str	r1, [sp, #12]
10019e14:	e58d2010 	str	r2, [sp, #16]
10019e18:	e58d3014 	str	r3, [sp, #20]
10019e1c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019e20:	e1a00007 	mov	r0, r7
10019e24:	e1a01006 	mov	r1, r6
10019e28:	e1a02005 	mov	r2, r5
10019e2c:	e1a03004 	mov	r3, r4
10019e30:	e12fff3c 	blx	ip
10019e34:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9]);
		break;
10019e38:	ea0000c2 	b	1001a148 <OP_call+0x670>

	case 11:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019e3c:	e51b8074 	ldr	r8, [fp, #-116]	; 0x74
10019e40:	e51b7070 	ldr	r7, [fp, #-112]	; 0x70
10019e44:	e51b606c 	ldr	r6, [fp, #-108]	; 0x6c
10019e48:	e51b5068 	ldr	r5, [fp, #-104]	; 0x68
10019e4c:	e51b4064 	ldr	r4, [fp, #-100]	; 0x64
10019e50:	e51be060 	ldr	lr, [fp, #-96]	; 0x60
10019e54:	e51bc05c 	ldr	ip, [fp, #-92]	; 0x5c
10019e58:	e51b0058 	ldr	r0, [fp, #-88]	; 0x58
10019e5c:	e51b1054 	ldr	r1, [fp, #-84]	; 0x54
10019e60:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
10019e64:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
10019e68:	e58d4000 	str	r4, [sp]
10019e6c:	e58de004 	str	lr, [sp, #4]
10019e70:	e58dc008 	str	ip, [sp, #8]
10019e74:	e58d000c 	str	r0, [sp, #12]
10019e78:	e58d1010 	str	r1, [sp, #16]
10019e7c:	e58d2014 	str	r2, [sp, #20]
10019e80:	e58d3018 	str	r3, [sp, #24]
10019e84:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019e88:	e1a00008 	mov	r0, r8
10019e8c:	e1a01007 	mov	r1, r7
10019e90:	e1a02006 	mov	r2, r6
10019e94:	e1a03005 	mov	r3, r5
10019e98:	e12fff3c 	blx	ip
10019e9c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10]);
		break;
10019ea0:	ea0000a8 	b	1001a148 <OP_call+0x670>

	case 12:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019ea4:	e51b9074 	ldr	r9, [fp, #-116]	; 0x74
10019ea8:	e51b8070 	ldr	r8, [fp, #-112]	; 0x70
10019eac:	e51b706c 	ldr	r7, [fp, #-108]	; 0x6c
10019eb0:	e51b6068 	ldr	r6, [fp, #-104]	; 0x68
10019eb4:	e51b5064 	ldr	r5, [fp, #-100]	; 0x64
10019eb8:	e51b4060 	ldr	r4, [fp, #-96]	; 0x60
10019ebc:	e51be05c 	ldr	lr, [fp, #-92]	; 0x5c
10019ec0:	e51bc058 	ldr	ip, [fp, #-88]	; 0x58
10019ec4:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
10019ec8:	e51b1050 	ldr	r1, [fp, #-80]	; 0x50
10019ecc:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
10019ed0:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
10019ed4:	e58d5000 	str	r5, [sp]
10019ed8:	e58d4004 	str	r4, [sp, #4]
10019edc:	e58de008 	str	lr, [sp, #8]
10019ee0:	e58dc00c 	str	ip, [sp, #12]
10019ee4:	e58d0010 	str	r0, [sp, #16]
10019ee8:	e58d1014 	str	r1, [sp, #20]
10019eec:	e58d2018 	str	r2, [sp, #24]
10019ef0:	e58d301c 	str	r3, [sp, #28]
10019ef4:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019ef8:	e1a00009 	mov	r0, r9
10019efc:	e1a01008 	mov	r1, r8
10019f00:	e1a02007 	mov	r2, r7
10019f04:	e1a03006 	mov	r3, r6
10019f08:	e12fff3c 	blx	ip
10019f0c:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11]);
		break;
10019f10:	ea00008c 	b	1001a148 <OP_call+0x670>

	case 13:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019f14:	e51ba074 	ldr	sl, [fp, #-116]	; 0x74
10019f18:	e51b9070 	ldr	r9, [fp, #-112]	; 0x70
10019f1c:	e51b806c 	ldr	r8, [fp, #-108]	; 0x6c
10019f20:	e51b7068 	ldr	r7, [fp, #-104]	; 0x68
10019f24:	e51b6064 	ldr	r6, [fp, #-100]	; 0x64
10019f28:	e51b5060 	ldr	r5, [fp, #-96]	; 0x60
10019f2c:	e51b405c 	ldr	r4, [fp, #-92]	; 0x5c
10019f30:	e51be058 	ldr	lr, [fp, #-88]	; 0x58
10019f34:	e51bc054 	ldr	ip, [fp, #-84]	; 0x54
10019f38:	e51b0050 	ldr	r0, [fp, #-80]	; 0x50
10019f3c:	e51b104c 	ldr	r1, [fp, #-76]	; 0x4c
10019f40:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
10019f44:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
10019f48:	e58d6000 	str	r6, [sp]
10019f4c:	e58d5004 	str	r5, [sp, #4]
10019f50:	e58d4008 	str	r4, [sp, #8]
10019f54:	e58de00c 	str	lr, [sp, #12]
10019f58:	e58dc010 	str	ip, [sp, #16]
10019f5c:	e58d0014 	str	r0, [sp, #20]
10019f60:	e58d1018 	str	r1, [sp, #24]
10019f64:	e58d201c 	str	r2, [sp, #28]
10019f68:	e58d3020 	str	r3, [sp, #32]
10019f6c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019f70:	e1a0000a 	mov	r0, sl
10019f74:	e1a01009 	mov	r1, r9
10019f78:	e1a02008 	mov	r2, r8
10019f7c:	e1a03007 	mov	r3, r7
10019f80:	e12fff3c 	blx	ip
10019f84:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12]);
		break;
10019f88:	ea00006e 	b	1001a148 <OP_call+0x670>

	case 14:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
10019f8c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
10019f90:	e50b3078 	str	r3, [fp, #-120]	; 0x78
10019f94:	e51ba070 	ldr	sl, [fp, #-112]	; 0x70
10019f98:	e51b906c 	ldr	r9, [fp, #-108]	; 0x6c
10019f9c:	e51b8068 	ldr	r8, [fp, #-104]	; 0x68
10019fa0:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
10019fa4:	e51b6060 	ldr	r6, [fp, #-96]	; 0x60
10019fa8:	e51b505c 	ldr	r5, [fp, #-92]	; 0x5c
10019fac:	e51b4058 	ldr	r4, [fp, #-88]	; 0x58
10019fb0:	e51be054 	ldr	lr, [fp, #-84]	; 0x54
10019fb4:	e51bc050 	ldr	ip, [fp, #-80]	; 0x50
10019fb8:	e51b004c 	ldr	r0, [fp, #-76]	; 0x4c
10019fbc:	e51b1048 	ldr	r1, [fp, #-72]	; 0x48
10019fc0:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
10019fc4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
10019fc8:	e58d7000 	str	r7, [sp]
10019fcc:	e58d6004 	str	r6, [sp, #4]
10019fd0:	e58d5008 	str	r5, [sp, #8]
10019fd4:	e58d400c 	str	r4, [sp, #12]
10019fd8:	e58de010 	str	lr, [sp, #16]
10019fdc:	e58dc014 	str	ip, [sp, #20]
10019fe0:	e58d0018 	str	r0, [sp, #24]
10019fe4:	e58d101c 	str	r1, [sp, #28]
10019fe8:	e58d2020 	str	r2, [sp, #32]
10019fec:	e58d3024 	str	r3, [sp, #36]	; 0x24
10019ff0:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
10019ff4:	e51b0078 	ldr	r0, [fp, #-120]	; 0x78
10019ff8:	e1a0100a 	mov	r1, sl
10019ffc:	e1a02009 	mov	r2, r9
1001a000:	e1a03008 	mov	r3, r8
1001a004:	e12fff3c 	blx	ip
1001a008:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13]);
		break;
1001a00c:	ea00004d 	b	1001a148 <OP_call+0x670>

	case 15:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1001a010:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
1001a014:	e50b3078 	str	r3, [fp, #-120]	; 0x78
1001a018:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
1001a01c:	e50b207c 	str	r2, [fp, #-124]	; 0x7c
1001a020:	e51ba06c 	ldr	sl, [fp, #-108]	; 0x6c
1001a024:	e51b9068 	ldr	r9, [fp, #-104]	; 0x68
1001a028:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
1001a02c:	e51b8060 	ldr	r8, [fp, #-96]	; 0x60
1001a030:	e51b705c 	ldr	r7, [fp, #-92]	; 0x5c
1001a034:	e51b6058 	ldr	r6, [fp, #-88]	; 0x58
1001a038:	e51b5054 	ldr	r5, [fp, #-84]	; 0x54
1001a03c:	e51b4050 	ldr	r4, [fp, #-80]	; 0x50
1001a040:	e51be04c 	ldr	lr, [fp, #-76]	; 0x4c
1001a044:	e51bc048 	ldr	ip, [fp, #-72]	; 0x48
1001a048:	e51b0044 	ldr	r0, [fp, #-68]	; 0x44
1001a04c:	e51b1040 	ldr	r1, [fp, #-64]	; 0x40
1001a050:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
1001a054:	e58d2000 	str	r2, [sp]
1001a058:	e58d8004 	str	r8, [sp, #4]
1001a05c:	e58d7008 	str	r7, [sp, #8]
1001a060:	e58d600c 	str	r6, [sp, #12]
1001a064:	e58d5010 	str	r5, [sp, #16]
1001a068:	e58d4014 	str	r4, [sp, #20]
1001a06c:	e58de018 	str	lr, [sp, #24]
1001a070:	e58dc01c 	str	ip, [sp, #28]
1001a074:	e58d0020 	str	r0, [sp, #32]
1001a078:	e58d1024 	str	r1, [sp, #36]	; 0x24
1001a07c:	e58d3028 	str	r3, [sp, #40]	; 0x28
1001a080:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1001a084:	e51b0078 	ldr	r0, [fp, #-120]	; 0x78
1001a088:	e51b107c 	ldr	r1, [fp, #-124]	; 0x7c
1001a08c:	e1a0200a 	mov	r2, sl
1001a090:	e1a03009 	mov	r3, r9
1001a094:	e12fff3c 	blx	ip
1001a098:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14]);
		break;
1001a09c:	ea000029 	b	1001a148 <OP_call+0x670>

	case 16:
		r = f(parameterv[0], parameterv[1], parameterv[2], parameterv[3],
1001a0a0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
1001a0a4:	e50b3078 	str	r3, [fp, #-120]	; 0x78
1001a0a8:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
1001a0ac:	e50b207c 	str	r2, [fp, #-124]	; 0x7c
1001a0b0:	e51bc06c 	ldr	ip, [fp, #-108]	; 0x6c
1001a0b4:	e50bc080 	str	ip, [fp, #-128]	; 0x80
1001a0b8:	e51ba068 	ldr	sl, [fp, #-104]	; 0x68
1001a0bc:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
1001a0c0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
1001a0c4:	e51b905c 	ldr	r9, [fp, #-92]	; 0x5c
1001a0c8:	e51b8058 	ldr	r8, [fp, #-88]	; 0x58
1001a0cc:	e51b7054 	ldr	r7, [fp, #-84]	; 0x54
1001a0d0:	e51b6050 	ldr	r6, [fp, #-80]	; 0x50
1001a0d4:	e51b504c 	ldr	r5, [fp, #-76]	; 0x4c
1001a0d8:	e51b4048 	ldr	r4, [fp, #-72]	; 0x48
1001a0dc:	e51be044 	ldr	lr, [fp, #-68]	; 0x44
1001a0e0:	e51bc040 	ldr	ip, [fp, #-64]	; 0x40
1001a0e4:	e51b103c 	ldr	r1, [fp, #-60]	; 0x3c
1001a0e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1001a0ec:	e58d2000 	str	r2, [sp]
1001a0f0:	e58d0004 	str	r0, [sp, #4]
1001a0f4:	e58d9008 	str	r9, [sp, #8]
1001a0f8:	e58d800c 	str	r8, [sp, #12]
1001a0fc:	e58d7010 	str	r7, [sp, #16]
1001a100:	e58d6014 	str	r6, [sp, #20]
1001a104:	e58d5018 	str	r5, [sp, #24]
1001a108:	e58d401c 	str	r4, [sp, #28]
1001a10c:	e58de020 	str	lr, [sp, #32]
1001a110:	e58dc024 	str	ip, [sp, #36]	; 0x24
1001a114:	e58d1028 	str	r1, [sp, #40]	; 0x28
1001a118:	e58d302c 	str	r3, [sp, #44]	; 0x2c
1001a11c:	e51bc034 	ldr	ip, [fp, #-52]	; 0x34
1001a120:	e51b0078 	ldr	r0, [fp, #-120]	; 0x78
1001a124:	e51b107c 	ldr	r1, [fp, #-124]	; 0x7c
1001a128:	e51b2080 	ldr	r2, [fp, #-128]	; 0x80
1001a12c:	e1a0300a 	mov	r3, sl
1001a130:	e12fff3c 	blx	ip
1001a134:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
				parameterv[4], parameterv[5], parameterv[6], parameterv[7],
				parameterv[8], parameterv[9], parameterv[10], parameterv[11],
				parameterv[12], parameterv[13], parameterv[14], parameterv[15]);
		break;
1001a138:	ea000002 	b	1001a148 <OP_call+0x670>

	default:
		r = 0;
1001a13c:	e3a03000 	mov	r3, #0
1001a140:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
		break;
1001a144:	e1a00000 	nop			; (mov r0, r0)
	}

	finsh_sp->long_value = r;
1001a148:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001a14c:	e3413002 	movt	r3, #4098	; 0x1002
1001a150:	e5933000 	ldr	r3, [r3]
1001a154:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
1001a158:	e5832000 	str	r2, [r3]
	finsh_sp ++;
1001a15c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001a160:	e3413002 	movt	r3, #4098	; 0x1002
1001a164:	e5933000 	ldr	r3, [r3]
1001a168:	e2832004 	add	r2, r3, #4
1001a16c:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001a170:	e3413002 	movt	r3, #4098	; 0x1002
1001a174:	e5832000 	str	r2, [r3]

	return ;
1001a178:	e1a00000 	nop			; (mov r0, r0)
}
1001a17c:	e24bd020 	sub	sp, fp, #32
1001a180:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

1001a184 <proc_variable_decl>:
	| declarator
declarator -> identifier
	| identifier ASSIGN expr_assign
*/
static struct finsh_node* proc_variable_decl(struct finsh_parser* self)
{
1001a184:	e92d4800 	push	{fp, lr}
1001a188:	e28db004 	add	fp, sp, #4
1001a18c:	e24dd040 	sub	sp, sp, #64	; 0x40
1001a190:	e50b0040 	str	r0, [fp, #-64]	; 0x40

	struct finsh_node *node;
	struct finsh_node *end;
	struct finsh_node *assign;

    node = NULL;
1001a194:	e3a03000 	mov	r3, #0
1001a198:	e50b300c 	str	r3, [fp, #-12]
	end  = NULL;
1001a19c:	e3a03000 	mov	r3, #0
1001a1a0:	e50b3010 	str	r3, [fp, #-16]

	/* get type */
	type = proc_type(self);
1001a1a4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a1a8:	eb000109 	bl	1001a5d4 <proc_type>
1001a1ac:	e1a03000 	mov	r3, r0
1001a1b0:	e54b3011 	strb	r3, [fp, #-17]

	/*process id.*/
	if (proc_identifier(self, id) == 0)
1001a1b4:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a1b8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a1bc:	e1a01003 	mov	r1, r3
1001a1c0:	eb0001ad 	bl	1001a87c <proc_identifier>
1001a1c4:	e1a03000 	mov	r3, r0
1001a1c8:	e3530000 	cmp	r3, #0
1001a1cc:	1a000009 	bne	1001a1f8 <proc_variable_decl+0x74>
	{
		/* if add variable failed */
		if (finsh_var_insert(id, type) < 0)
1001a1d0:	e55b3011 	ldrb	r3, [fp, #-17]
1001a1d4:	e24b2038 	sub	r2, fp, #56	; 0x38
1001a1d8:	e1a00002 	mov	r0, r2
1001a1dc:	e1a01003 	mov	r1, r3
1001a1e0:	eb0005c2 	bl	1001b8f0 <finsh_var_insert>
1001a1e4:	e1a03000 	mov	r3, r0
1001a1e8:	e3530000 	cmp	r3, #0
1001a1ec:	aa000001 	bge	1001a1f8 <proc_variable_decl+0x74>
		{
			finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1001a1f0:	e3a00004 	mov	r0, #4
1001a1f4:	ebfff5ae 	bl	100178b4 <finsh_error_set>
		}
	}

	next_token(token, &(self->token));
1001a1f8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a1fc:	e2833004 	add	r3, r3, #4
1001a200:	e1a00003 	mov	r0, r3
1001a204:	eb000781 	bl	1001c010 <finsh_token_token>
1001a208:	e1a03000 	mov	r3, r0
1001a20c:	e54b3005 	strb	r3, [fp, #-5]
	switch ( token )
1001a210:	e55b3005 	ldrb	r3, [fp, #-5]
1001a214:	e3530004 	cmp	r3, #4
1001a218:	0a0000e5 	beq	1001a5b4 <proc_variable_decl+0x430>
1001a21c:	e353000c 	cmp	r3, #12
1001a220:	0a00007f 	beq	1001a424 <proc_variable_decl+0x2a0>
1001a224:	e3530003 	cmp	r3, #3
1001a228:	1a0000e3 	bne	1001a5bc <proc_variable_decl+0x438>
	{
	case finsh_token_type_comma:/*',', it's a variable_list declaration.*/
		if (proc_identifier(self, id) == 0)
1001a22c:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a230:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a234:	e1a01003 	mov	r1, r3
1001a238:	eb00018f 	bl	1001a87c <proc_identifier>
1001a23c:	e1a03000 	mov	r3, r0
1001a240:	e3530000 	cmp	r3, #0
1001a244:	1a000009 	bne	1001a270 <proc_variable_decl+0xec>
		{
			/* if add variable failed */
			if (finsh_var_insert(id, type) < 0)
1001a248:	e55b3011 	ldrb	r3, [fp, #-17]
1001a24c:	e24b2038 	sub	r2, fp, #56	; 0x38
1001a250:	e1a00002 	mov	r0, r2
1001a254:	e1a01003 	mov	r1, r3
1001a258:	eb0005a4 	bl	1001b8f0 <finsh_var_insert>
1001a25c:	e1a03000 	mov	r3, r0
1001a260:	e3530000 	cmp	r3, #0
1001a264:	aa000001 	bge	1001a270 <proc_variable_decl+0xec>
			{
				finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1001a268:	e3a00004 	mov	r0, #4
1001a26c:	ebfff590 	bl	100178b4 <finsh_error_set>
			}
		}

		next_token(token, &(self->token));
1001a270:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a274:	e2833004 	add	r3, r3, #4
1001a278:	e1a00003 	mov	r0, r3
1001a27c:	eb000763 	bl	1001c010 <finsh_token_token>
1001a280:	e1a03000 	mov	r3, r0
1001a284:	e54b3005 	strb	r3, [fp, #-5]
		if ( token == finsh_token_type_assign )
1001a288:	e55b3005 	ldrb	r3, [fp, #-5]
1001a28c:	e353000c 	cmp	r3, #12
1001a290:	1a000016 	bne	1001a2f0 <proc_variable_decl+0x16c>
		{
			/* get the right side of assign expression */
			assign = proc_assign_expr(self);
1001a294:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a298:	eb0001c5 	bl	1001a9b4 <proc_assign_expr>
1001a29c:	e50b0018 	str	r0, [fp, #-24]

			if (assign != NULL)
1001a2a0:	e51b3018 	ldr	r3, [fp, #-24]
1001a2a4:	e3530000 	cmp	r3, #0
1001a2a8:	0a000010 	beq	1001a2f0 <proc_variable_decl+0x16c>
			{
				struct finsh_node* idnode;

				idnode = finsh_node_new_id(id);
1001a2ac:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a2b0:	e1a00003 	mov	r0, r3
1001a2b4:	ebfff7c0 	bl	100181bc <finsh_node_new_id>
1001a2b8:	e50b001c 	str	r0, [fp, #-28]
				end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1001a2bc:	e3a00013 	mov	r0, #19
1001a2c0:	e51b101c 	ldr	r1, [fp, #-28]
1001a2c4:	e51b2018 	ldr	r2, [fp, #-24]
1001a2c8:	eb0004b9 	bl	1001b5b4 <make_sys_node>
1001a2cc:	e50b0010 	str	r0, [fp, #-16]
				node = end;
1001a2d0:	e51b3010 	ldr	r3, [fp, #-16]
1001a2d4:	e50b300c 	str	r3, [fp, #-12]

				next_token(token, &(self->token));
1001a2d8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a2dc:	e2833004 	add	r3, r3, #4
1001a2e0:	e1a00003 	mov	r0, r3
1001a2e4:	eb000749 	bl	1001c010 <finsh_token_token>
1001a2e8:	e1a03000 	mov	r3, r0
1001a2ec:	e54b3005 	strb	r3, [fp, #-5]
			}
		}

		while ( token == finsh_token_type_comma )
1001a2f0:	ea00003e 	b	1001a3f0 <proc_variable_decl+0x26c>
		{
			if (proc_identifier(self, id) == 0)
1001a2f4:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a2f8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a2fc:	e1a01003 	mov	r1, r3
1001a300:	eb00015d 	bl	1001a87c <proc_identifier>
1001a304:	e1a03000 	mov	r3, r0
1001a308:	e3530000 	cmp	r3, #0
1001a30c:	1a000009 	bne	1001a338 <proc_variable_decl+0x1b4>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
1001a310:	e55b3011 	ldrb	r3, [fp, #-17]
1001a314:	e24b2038 	sub	r2, fp, #56	; 0x38
1001a318:	e1a00002 	mov	r0, r2
1001a31c:	e1a01003 	mov	r1, r3
1001a320:	eb000572 	bl	1001b8f0 <finsh_var_insert>
1001a324:	e1a03000 	mov	r3, r0
1001a328:	e3530000 	cmp	r3, #0
1001a32c:	aa000001 	bge	1001a338 <proc_variable_decl+0x1b4>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1001a330:	e3a00004 	mov	r0, #4
1001a334:	ebfff55e 	bl	100178b4 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
1001a338:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a33c:	e2833004 	add	r3, r3, #4
1001a340:	e1a00003 	mov	r0, r3
1001a344:	eb000731 	bl	1001c010 <finsh_token_token>
1001a348:	e1a03000 	mov	r3, r0
1001a34c:	e54b3005 	strb	r3, [fp, #-5]
			if ( token == finsh_token_type_assign )
1001a350:	e55b3005 	ldrb	r3, [fp, #-5]
1001a354:	e353000c 	cmp	r3, #12
1001a358:	1a000024 	bne	1001a3f0 <proc_variable_decl+0x26c>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
1001a35c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a360:	eb000193 	bl	1001a9b4 <proc_assign_expr>
1001a364:	e50b0018 	str	r0, [fp, #-24]

				if (assign != NULL)
1001a368:	e51b3018 	ldr	r3, [fp, #-24]
1001a36c:	e3530000 	cmp	r3, #0
1001a370:	0a00001e 	beq	1001a3f0 <proc_variable_decl+0x26c>
				{
					struct finsh_node* idnode;

					idnode = finsh_node_new_id(id);
1001a374:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a378:	e1a00003 	mov	r0, r3
1001a37c:	ebfff78e 	bl	100181bc <finsh_node_new_id>
1001a380:	e50b0020 	str	r0, [fp, #-32]

					/* make assign expression node */
					if (node != NULL)
1001a384:	e51b300c 	ldr	r3, [fp, #-12]
1001a388:	e3530000 	cmp	r3, #0
1001a38c:	0a00000a 	beq	1001a3bc <proc_variable_decl+0x238>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1001a390:	e3a00013 	mov	r0, #19
1001a394:	e51b1020 	ldr	r1, [fp, #-32]
1001a398:	e51b2018 	ldr	r2, [fp, #-24]
1001a39c:	eb000484 	bl	1001b5b4 <make_sys_node>
1001a3a0:	e1a02000 	mov	r2, r0
1001a3a4:	e51b3010 	ldr	r3, [fp, #-16]
1001a3a8:	e583200c 	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
1001a3ac:	e51b3010 	ldr	r3, [fp, #-16]
1001a3b0:	e593300c 	ldr	r3, [r3, #12]
1001a3b4:	e50b3010 	str	r3, [fp, #-16]
1001a3b8:	ea000006 	b	1001a3d8 <proc_variable_decl+0x254>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1001a3bc:	e3a00013 	mov	r0, #19
1001a3c0:	e51b1020 	ldr	r1, [fp, #-32]
1001a3c4:	e51b2018 	ldr	r2, [fp, #-24]
1001a3c8:	eb000479 	bl	1001b5b4 <make_sys_node>
1001a3cc:	e50b0010 	str	r0, [fp, #-16]
						node = end;
1001a3d0:	e51b3010 	ldr	r3, [fp, #-16]
1001a3d4:	e50b300c 	str	r3, [fp, #-12]
					}

					next_token(token, &(self->token));
1001a3d8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a3dc:	e2833004 	add	r3, r3, #4
1001a3e0:	e1a00003 	mov	r0, r3
1001a3e4:	eb000709 	bl	1001c010 <finsh_token_token>
1001a3e8:	e1a03000 	mov	r3, r0
1001a3ec:	e54b3005 	strb	r3, [fp, #-5]

				next_token(token, &(self->token));
			}
		}

		while ( token == finsh_token_type_comma )
1001a3f0:	e55b3005 	ldrb	r3, [fp, #-5]
1001a3f4:	e3530003 	cmp	r3, #3
1001a3f8:	0affffbd 	beq	1001a2f4 <proc_variable_decl+0x170>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
1001a3fc:	e55b3005 	ldrb	r3, [fp, #-5]
1001a400:	e3530004 	cmp	r3, #4
1001a404:	0a000004 	beq	1001a41c <proc_variable_decl+0x298>
1001a408:	e3a00001 	mov	r0, #1
1001a40c:	ebfff528 	bl	100178b4 <finsh_error_set>
1001a410:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a414:	e3a02001 	mov	r2, #1
1001a418:	e5c32005 	strb	r2, [r3, #5]
		return node;
1001a41c:	e51b300c 	ldr	r3, [fp, #-12]
1001a420:	ea000068 	b	1001a5c8 <proc_variable_decl+0x444>

	case finsh_token_type_assign:/*'=', it's a variable with assign declaration.*/
	{
		struct finsh_node *idnode;

		assign = proc_assign_expr(self);
1001a424:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a428:	eb000161 	bl	1001a9b4 <proc_assign_expr>
1001a42c:	e50b0018 	str	r0, [fp, #-24]
		if (assign != NULL)
1001a430:	e51b3018 	ldr	r3, [fp, #-24]
1001a434:	e3530000 	cmp	r3, #0
1001a438:	0a000010 	beq	1001a480 <proc_variable_decl+0x2fc>
		{
			idnode = finsh_node_new_id(id);
1001a43c:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a440:	e1a00003 	mov	r0, r3
1001a444:	ebfff75c 	bl	100181bc <finsh_node_new_id>
1001a448:	e50b0024 	str	r0, [fp, #-36]	; 0x24

			/* make assign expression node */
			end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1001a44c:	e3a00013 	mov	r0, #19
1001a450:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1001a454:	e51b2018 	ldr	r2, [fp, #-24]
1001a458:	eb000455 	bl	1001b5b4 <make_sys_node>
1001a45c:	e50b0010 	str	r0, [fp, #-16]
			node = end;
1001a460:	e51b3010 	ldr	r3, [fp, #-16]
1001a464:	e50b300c 	str	r3, [fp, #-12]

			next_token(token, &(self->token));
1001a468:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a46c:	e2833004 	add	r3, r3, #4
1001a470:	e1a00003 	mov	r0, r3
1001a474:	eb0006e5 	bl	1001c010 <finsh_token_token>
1001a478:	e1a03000 	mov	r3, r0
1001a47c:	e54b3005 	strb	r3, [fp, #-5]
		}

		while ( token == finsh_token_type_comma )
1001a480:	ea00003e 	b	1001a580 <proc_variable_decl+0x3fc>
		{
			if (proc_identifier(self, id) == 0)
1001a484:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a488:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a48c:	e1a01003 	mov	r1, r3
1001a490:	eb0000f9 	bl	1001a87c <proc_identifier>
1001a494:	e1a03000 	mov	r3, r0
1001a498:	e3530000 	cmp	r3, #0
1001a49c:	1a000009 	bne	1001a4c8 <proc_variable_decl+0x344>
			{
				/* if add variable failed */
				if (finsh_var_insert(id, type) < 0)
1001a4a0:	e55b3011 	ldrb	r3, [fp, #-17]
1001a4a4:	e24b2038 	sub	r2, fp, #56	; 0x38
1001a4a8:	e1a00002 	mov	r0, r2
1001a4ac:	e1a01003 	mov	r1, r3
1001a4b0:	eb00050e 	bl	1001b8f0 <finsh_var_insert>
1001a4b4:	e1a03000 	mov	r3, r0
1001a4b8:	e3530000 	cmp	r3, #0
1001a4bc:	aa000001 	bge	1001a4c8 <proc_variable_decl+0x344>
				{
					finsh_error_set(FINSH_ERROR_VARIABLE_EXIST);
1001a4c0:	e3a00004 	mov	r0, #4
1001a4c4:	ebfff4fa 	bl	100178b4 <finsh_error_set>
				}
			}

			next_token(token, &(self->token));
1001a4c8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a4cc:	e2833004 	add	r3, r3, #4
1001a4d0:	e1a00003 	mov	r0, r3
1001a4d4:	eb0006cd 	bl	1001c010 <finsh_token_token>
1001a4d8:	e1a03000 	mov	r3, r0
1001a4dc:	e54b3005 	strb	r3, [fp, #-5]
			if (token == finsh_token_type_assign)
1001a4e0:	e55b3005 	ldrb	r3, [fp, #-5]
1001a4e4:	e353000c 	cmp	r3, #12
1001a4e8:	1a000024 	bne	1001a580 <proc_variable_decl+0x3fc>
			{
				/* get the right side of assign expression */
				assign = proc_assign_expr(self);
1001a4ec:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
1001a4f0:	eb00012f 	bl	1001a9b4 <proc_assign_expr>
1001a4f4:	e50b0018 	str	r0, [fp, #-24]

				if (assign != NULL)
1001a4f8:	e51b3018 	ldr	r3, [fp, #-24]
1001a4fc:	e3530000 	cmp	r3, #0
1001a500:	0a00001e 	beq	1001a580 <proc_variable_decl+0x3fc>
				{
					idnode = finsh_node_new_id(id);
1001a504:	e24b3038 	sub	r3, fp, #56	; 0x38
1001a508:	e1a00003 	mov	r0, r3
1001a50c:	ebfff72a 	bl	100181bc <finsh_node_new_id>
1001a510:	e50b0024 	str	r0, [fp, #-36]	; 0x24

					/* make assign expression node */
					if (node != NULL)
1001a514:	e51b300c 	ldr	r3, [fp, #-12]
1001a518:	e3530000 	cmp	r3, #0
1001a51c:	0a00000a 	beq	1001a54c <proc_variable_decl+0x3c8>
					{
						finsh_node_sibling(end) = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1001a520:	e3a00013 	mov	r0, #19
1001a524:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1001a528:	e51b2018 	ldr	r2, [fp, #-24]
1001a52c:	eb000420 	bl	1001b5b4 <make_sys_node>
1001a530:	e1a02000 	mov	r2, r0
1001a534:	e51b3010 	ldr	r3, [fp, #-16]
1001a538:	e583200c 	str	r2, [r3, #12]
						end = finsh_node_sibling(end);
1001a53c:	e51b3010 	ldr	r3, [fp, #-16]
1001a540:	e593300c 	ldr	r3, [r3, #12]
1001a544:	e50b3010 	str	r3, [fp, #-16]
1001a548:	ea000006 	b	1001a568 <proc_variable_decl+0x3e4>
					}
					else
					{
						end = make_sys_node(FINSH_NODE_SYS_ASSIGN, idnode, assign);
1001a54c:	e3a00013 	mov	r0, #19
1001a550:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
1001a554:	e51b2018 	ldr	r2, [fp, #-24]
1001a558:	eb000415 	bl	1001b5b4 <make_sys_node>
1001a55c:	e50b0010 	str	r0, [fp, #-16]
						node = end;
1001a560:	e51b3010 	ldr	r3, [fp, #-16]
1001a564:	e50b300c 	str	r3, [fp, #-12]
					}

					next_token(token, &(self->token));
1001a568:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a56c:	e2833004 	add	r3, r3, #4
1001a570:	e1a00003 	mov	r0, r3
1001a574:	eb0006a5 	bl	1001c010 <finsh_token_token>
1001a578:	e1a03000 	mov	r3, r0
1001a57c:	e54b3005 	strb	r3, [fp, #-5]
			node = end;

			next_token(token, &(self->token));
		}

		while ( token == finsh_token_type_comma )
1001a580:	e55b3005 	ldrb	r3, [fp, #-5]
1001a584:	e3530003 	cmp	r3, #3
1001a588:	0affffbd 	beq	1001a484 <proc_variable_decl+0x300>
					next_token(token, &(self->token));
				}
			}
		}

		check_token(token, &(self->token), finsh_token_type_semicolon);
1001a58c:	e55b3005 	ldrb	r3, [fp, #-5]
1001a590:	e3530004 	cmp	r3, #4
1001a594:	0a000004 	beq	1001a5ac <proc_variable_decl+0x428>
1001a598:	e3a00001 	mov	r0, #1
1001a59c:	ebfff4c4 	bl	100178b4 <finsh_error_set>
1001a5a0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
1001a5a4:	e3a02001 	mov	r2, #1
1001a5a8:	e5c32005 	strb	r2, [r3, #5]
		return node;
1001a5ac:	e51b300c 	ldr	r3, [fp, #-12]
1001a5b0:	ea000004 	b	1001a5c8 <proc_variable_decl+0x444>
	}

	case finsh_token_type_semicolon:/*';', it's a variable declaration.*/
		return node;
1001a5b4:	e51b300c 	ldr	r3, [fp, #-12]
1001a5b8:	ea000002 	b	1001a5c8 <proc_variable_decl+0x444>

	default:
		finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
1001a5bc:	e3a00002 	mov	r0, #2
1001a5c0:	ebfff4bb 	bl	100178b4 <finsh_error_set>

		return NULL;
1001a5c4:	e3a03000 	mov	r3, #0
	}
}
1001a5c8:	e1a00003 	mov	r0, r3
1001a5cc:	e24bd004 	sub	sp, fp, #4
1001a5d0:	e8bd8800 	pop	{fp, pc}

1001a5d4 <proc_type>:
	| SHORT
	| INT
	| STRING
*/
static enum finsh_type proc_type(struct finsh_parser* self)
{
1001a5d4:	e92d4800 	push	{fp, lr}
1001a5d8:	e28db004 	add	fp, sp, #4
1001a5dc:	e24dd010 	sub	sp, sp, #16
1001a5e0:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_type type;
	enum finsh_token_type token;

	/* set init type */
	type = finsh_type_unknown;
1001a5e4:	e3a03000 	mov	r3, #0
1001a5e8:	e54b3005 	strb	r3, [fp, #-5]

	next_token(token, &(self->token));
1001a5ec:	e51b3010 	ldr	r3, [fp, #-16]
1001a5f0:	e2833004 	add	r3, r3, #4
1001a5f4:	e1a00003 	mov	r0, r3
1001a5f8:	eb000684 	bl	1001c010 <finsh_token_token>
1001a5fc:	e1a03000 	mov	r3, r0
1001a600:	e54b3006 	strb	r3, [fp, #-6]
	if ( is_base_type(token) ) /* base_type */
1001a604:	e55b3006 	ldrb	r3, [fp, #-6]
1001a608:	e3530014 	cmp	r3, #20
1001a60c:	0a00000b 	beq	1001a640 <proc_type+0x6c>
1001a610:	e55b3006 	ldrb	r3, [fp, #-6]
1001a614:	e3530015 	cmp	r3, #21
1001a618:	0a000008 	beq	1001a640 <proc_type+0x6c>
1001a61c:	e55b3006 	ldrb	r3, [fp, #-6]
1001a620:	e3530016 	cmp	r3, #22
1001a624:	0a000005 	beq	1001a640 <proc_type+0x6c>
1001a628:	e55b3006 	ldrb	r3, [fp, #-6]
1001a62c:	e3530017 	cmp	r3, #23
1001a630:	0a000002 	beq	1001a640 <proc_type+0x6c>
1001a634:	e55b3006 	ldrb	r3, [fp, #-6]
1001a638:	e3530018 	cmp	r3, #24
1001a63c:	1a000019 	bne	1001a6a8 <proc_type+0xd4>
	{
		switch (token)
1001a640:	e55b3006 	ldrb	r3, [fp, #-6]
1001a644:	e2433014 	sub	r3, r3, #20
1001a648:	e3530004 	cmp	r3, #4
1001a64c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001a650:	ea00007d 	b	1001a84c <proc_type+0x278>
1001a654:	1001a668 	.word	0x1001a668
1001a658:	1001a674 	.word	0x1001a674
1001a65c:	1001a680 	.word	0x1001a680
1001a660:	1001a68c 	.word	0x1001a68c
1001a664:	1001a698 	.word	0x1001a698
		{
		case finsh_token_type_void:
			type = finsh_type_void;
1001a668:	e3a03001 	mov	r3, #1
1001a66c:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a670:	ea00000b 	b	1001a6a4 <proc_type+0xd0>

		case finsh_token_type_char:
			type = finsh_type_char;
1001a674:	e3a03003 	mov	r3, #3
1001a678:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a67c:	ea000008 	b	1001a6a4 <proc_type+0xd0>

		case finsh_token_type_short:
			type = finsh_type_short;
1001a680:	e3a03006 	mov	r3, #6
1001a684:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a688:	ea000005 	b	1001a6a4 <proc_type+0xd0>

		case finsh_token_type_int:
			type = finsh_type_int;
1001a68c:	e3a03009 	mov	r3, #9
1001a690:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a694:	ea000002 	b	1001a6a4 <proc_type+0xd0>

		case finsh_token_type_long:
			type = finsh_type_long;
1001a698:	e3a0300c 	mov	r3, #12
1001a69c:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a6a0:	e1a00000 	nop			; (mov r0, r0)

		default:
			goto __return;
		}
	}
1001a6a4:	ea000035 	b	1001a780 <proc_type+0x1ac>
	else if ( token == finsh_token_type_unsigned ) /* unsigned base_type */
1001a6a8:	e55b3006 	ldrb	r3, [fp, #-6]
1001a6ac:	e3530019 	cmp	r3, #25
1001a6b0:	1a000031 	bne	1001a77c <proc_type+0x1a8>
	{
		next_token(token, &(self->token));
1001a6b4:	e51b3010 	ldr	r3, [fp, #-16]
1001a6b8:	e2833004 	add	r3, r3, #4
1001a6bc:	e1a00003 	mov	r0, r3
1001a6c0:	eb000652 	bl	1001c010 <finsh_token_token>
1001a6c4:	e1a03000 	mov	r3, r0
1001a6c8:	e54b3006 	strb	r3, [fp, #-6]
		if ( is_base_type(token) )
1001a6cc:	e55b3006 	ldrb	r3, [fp, #-6]
1001a6d0:	e3530014 	cmp	r3, #20
1001a6d4:	0a00000b 	beq	1001a708 <proc_type+0x134>
1001a6d8:	e55b3006 	ldrb	r3, [fp, #-6]
1001a6dc:	e3530015 	cmp	r3, #21
1001a6e0:	0a000008 	beq	1001a708 <proc_type+0x134>
1001a6e4:	e55b3006 	ldrb	r3, [fp, #-6]
1001a6e8:	e3530016 	cmp	r3, #22
1001a6ec:	0a000005 	beq	1001a708 <proc_type+0x134>
1001a6f0:	e55b3006 	ldrb	r3, [fp, #-6]
1001a6f4:	e3530017 	cmp	r3, #23
1001a6f8:	0a000002 	beq	1001a708 <proc_type+0x134>
1001a6fc:	e55b3006 	ldrb	r3, [fp, #-6]
1001a700:	e3530018 	cmp	r3, #24
1001a704:	1a000016 	bne	1001a764 <proc_type+0x190>
		{
			switch (token)
1001a708:	e55b3006 	ldrb	r3, [fp, #-6]
1001a70c:	e2433015 	sub	r3, r3, #21
1001a710:	e3530003 	cmp	r3, #3
1001a714:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001a718:	ea00004d 	b	1001a854 <proc_type+0x280>
1001a71c:	1001a72c 	.word	0x1001a72c
1001a720:	1001a738 	.word	0x1001a738
1001a724:	1001a744 	.word	0x1001a744
1001a728:	1001a750 	.word	0x1001a750
			{
			case finsh_token_type_char:
				type = finsh_type_uchar;
1001a72c:	e3a03004 	mov	r3, #4
1001a730:	e54b3005 	strb	r3, [fp, #-5]
				break;
1001a734:	ea000008 	b	1001a75c <proc_type+0x188>

			case finsh_token_type_short:
				type = finsh_type_ushort;
1001a738:	e3a03007 	mov	r3, #7
1001a73c:	e54b3005 	strb	r3, [fp, #-5]
				break;
1001a740:	ea000005 	b	1001a75c <proc_type+0x188>

			case finsh_token_type_int:
				type = finsh_type_uint;
1001a744:	e3a0300a 	mov	r3, #10
1001a748:	e54b3005 	strb	r3, [fp, #-5]
				break;
1001a74c:	ea000002 	b	1001a75c <proc_type+0x188>

			case finsh_token_type_long:
				type = finsh_type_ulong;
1001a750:	e3a0300d 	mov	r3, #13
1001a754:	e54b3005 	strb	r3, [fp, #-5]
				break;
1001a758:	e1a00000 	nop			; (mov r0, r0)

			default:
				goto __return;
			}
		}
1001a75c:	e1a00000 	nop			; (mov r0, r0)
1001a760:	ea000006 	b	1001a780 <proc_type+0x1ac>
		else
		{
			finsh_token_replay(&(self->token));
1001a764:	e51b3010 	ldr	r3, [fp, #-16]
1001a768:	e3a02001 	mov	r2, #1
1001a76c:	e5c32005 	strb	r2, [r3, #5]
			finsh_error_set(FINSH_ERROR_EXPECT_TYPE);
1001a770:	e3a00002 	mov	r0, #2
1001a774:	ebfff44e 	bl	100178b4 <finsh_error_set>
1001a778:	ea000000 	b	1001a780 <proc_type+0x1ac>
		}
	}
	else
	{
		goto __return;
1001a77c:	ea000035 	b	1001a858 <proc_type+0x284>
	}

	/* parse for pointer */
	next_token(token, &(self->token));
1001a780:	e51b3010 	ldr	r3, [fp, #-16]
1001a784:	e2833004 	add	r3, r3, #4
1001a788:	e1a00003 	mov	r0, r3
1001a78c:	eb00061f 	bl	1001c010 <finsh_token_token>
1001a790:	e1a03000 	mov	r3, r0
1001a794:	e54b3006 	strb	r3, [fp, #-6]
	if (token == finsh_token_type_mul)
1001a798:	e55b3006 	ldrb	r3, [fp, #-6]
1001a79c:	e3530005 	cmp	r3, #5
1001a7a0:	1a000024 	bne	1001a838 <proc_type+0x264>
	{
		switch (type)
1001a7a4:	e55b3005 	ldrb	r3, [fp, #-5]
1001a7a8:	e2433001 	sub	r3, r3, #1
1001a7ac:	e353000c 	cmp	r3, #12
1001a7b0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001a7b4:	ea00001b 	b	1001a828 <proc_type+0x254>
1001a7b8:	1001a7ec 	.word	0x1001a7ec
1001a7bc:	1001a828 	.word	0x1001a828
1001a7c0:	1001a7f8 	.word	0x1001a7f8
1001a7c4:	1001a7f8 	.word	0x1001a7f8
1001a7c8:	1001a828 	.word	0x1001a828
1001a7cc:	1001a804 	.word	0x1001a804
1001a7d0:	1001a804 	.word	0x1001a804
1001a7d4:	1001a828 	.word	0x1001a828
1001a7d8:	1001a810 	.word	0x1001a810
1001a7dc:	1001a810 	.word	0x1001a810
1001a7e0:	1001a828 	.word	0x1001a828
1001a7e4:	1001a81c 	.word	0x1001a81c
1001a7e8:	1001a81c 	.word	0x1001a81c
		{
		case finsh_type_void:
			type = finsh_type_voidp;
1001a7ec:	e3a03002 	mov	r3, #2
1001a7f0:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a7f4:	ea00000e 	b	1001a834 <proc_type+0x260>

		case finsh_type_char:
		case finsh_type_uchar:
			type = finsh_type_charp;
1001a7f8:	e3a03005 	mov	r3, #5
1001a7fc:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a800:	ea00000b 	b	1001a834 <proc_type+0x260>

		case finsh_type_short:
		case finsh_type_ushort:
			type = finsh_type_shortp;
1001a804:	e3a03008 	mov	r3, #8
1001a808:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a80c:	ea000008 	b	1001a834 <proc_type+0x260>

		case finsh_type_int:
		case finsh_type_uint:
			type = finsh_type_intp;
1001a810:	e3a0300b 	mov	r3, #11
1001a814:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a818:	ea000005 	b	1001a834 <proc_type+0x260>

		case finsh_type_long:
		case finsh_type_ulong:
			type = finsh_type_longp;
1001a81c:	e3a0300e 	mov	r3, #14
1001a820:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a824:	ea000002 	b	1001a834 <proc_type+0x260>

		default:
			type = finsh_type_voidp;
1001a828:	e3a03002 	mov	r3, #2
1001a82c:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001a830:	e1a00000 	nop			; (mov r0, r0)
1001a834:	ea000002 	b	1001a844 <proc_type+0x270>
		}
	}
	else finsh_token_replay(&(self->token));
1001a838:	e51b3010 	ldr	r3, [fp, #-16]
1001a83c:	e3a02001 	mov	r2, #1
1001a840:	e5c32005 	strb	r2, [r3, #5]

	return type;
1001a844:	e55b3005 	ldrb	r3, [fp, #-5]
1001a848:	ea000008 	b	1001a870 <proc_type+0x29c>
		case finsh_token_type_long:
			type = finsh_type_long;
			break;

		default:
			goto __return;
1001a84c:	e1a00000 	nop			; (mov r0, r0)
1001a850:	ea000000 	b	1001a858 <proc_type+0x284>
			case finsh_token_type_long:
				type = finsh_type_ulong;
				break;

			default:
				goto __return;
1001a854:	e1a00000 	nop			; (mov r0, r0)
	else finsh_token_replay(&(self->token));

	return type;

__return:
	finsh_token_replay(&(self->token));
1001a858:	e51b3010 	ldr	r3, [fp, #-16]
1001a85c:	e3a02001 	mov	r2, #1
1001a860:	e5c32005 	strb	r2, [r3, #5]
	finsh_error_set(FINSH_ERROR_UNKNOWN_TYPE);
1001a864:	e3a00003 	mov	r0, #3
1001a868:	ebfff411 	bl	100178b4 <finsh_error_set>

	return type;
1001a86c:	e55b3005 	ldrb	r3, [fp, #-5]
}
1001a870:	e1a00003 	mov	r0, r3
1001a874:	e24bd004 	sub	sp, fp, #4
1001a878:	e8bd8800 	pop	{fp, pc}

1001a87c <proc_identifier>:

/*
identifier -> IDENTIFIER
*/
static int proc_identifier(struct finsh_parser* self, char* id)
{
1001a87c:	e92d4800 	push	{fp, lr}
1001a880:	e28db004 	add	fp, sp, #4
1001a884:	e24dd010 	sub	sp, sp, #16
1001a888:	e50b0010 	str	r0, [fp, #-16]
1001a88c:	e50b1014 	str	r1, [fp, #-20]
	enum finsh_token_type token;

	match_token(token, &(self->token), finsh_token_type_identifier);
1001a890:	e51b3010 	ldr	r3, [fp, #-16]
1001a894:	e2833004 	add	r3, r3, #4
1001a898:	e1a00003 	mov	r0, r3
1001a89c:	eb0005db 	bl	1001c010 <finsh_token_token>
1001a8a0:	e1a03000 	mov	r3, r0
1001a8a4:	e54b3005 	strb	r3, [fp, #-5]
1001a8a8:	e55b3005 	ldrb	r3, [fp, #-5]
1001a8ac:	e353001f 	cmp	r3, #31
1001a8b0:	0a000004 	beq	1001a8c8 <proc_identifier+0x4c>
1001a8b4:	e3a00001 	mov	r0, #1
1001a8b8:	ebfff3fd 	bl	100178b4 <finsh_error_set>
1001a8bc:	e51b3010 	ldr	r3, [fp, #-16]
1001a8c0:	e3a02001 	mov	r2, #1
1001a8c4:	e5c32005 	strb	r2, [r3, #5]

	strncpy(id, (char*)self->token.string, FINSH_NAME_MAX);
1001a8c8:	e51b3010 	ldr	r3, [fp, #-16]
1001a8cc:	e2833014 	add	r3, r3, #20
1001a8d0:	e51b0014 	ldr	r0, [fp, #-20]
1001a8d4:	e1a01003 	mov	r1, r3
1001a8d8:	e3a02010 	mov	r2, #16
1001a8dc:	fa000d20 	blx	1001dd64 <strncpy>

	return 0;
1001a8e0:	e3a03000 	mov	r3, #0
}
1001a8e4:	e1a00003 	mov	r0, r3
1001a8e8:	e24bd004 	sub	sp, fp, #4
1001a8ec:	e8bd8800 	pop	{fp, pc}

1001a8f0 <proc_expr_statement>:
/*
statement_expr -> ';'
	| expr ';'
*/
static struct finsh_node* proc_expr_statement(struct finsh_parser* self)
{
1001a8f0:	e92d4800 	push	{fp, lr}
1001a8f4:	e28db004 	add	fp, sp, #4
1001a8f8:	e24dd010 	sub	sp, sp, #16
1001a8fc:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	struct finsh_node* expr;

	expr = NULL;
1001a900:	e3a03000 	mov	r3, #0
1001a904:	e50b3008 	str	r3, [fp, #-8]
	next_token(token, &(self->token));
1001a908:	e51b3010 	ldr	r3, [fp, #-16]
1001a90c:	e2833004 	add	r3, r3, #4
1001a910:	e1a00003 	mov	r0, r3
1001a914:	eb0005bd 	bl	1001c010 <finsh_token_token>
1001a918:	e1a03000 	mov	r3, r0
1001a91c:	e54b3009 	strb	r3, [fp, #-9]
	if ( token != finsh_token_type_semicolon )
1001a920:	e55b3009 	ldrb	r3, [fp, #-9]
1001a924:	e3530004 	cmp	r3, #4
1001a928:	0a000013 	beq	1001a97c <proc_expr_statement+0x8c>
	{
		finsh_token_replay(&(self->token));
1001a92c:	e51b3010 	ldr	r3, [fp, #-16]
1001a930:	e3a02001 	mov	r2, #1
1001a934:	e5c32005 	strb	r2, [r3, #5]
		expr = proc_expr(self);
1001a938:	e51b0010 	ldr	r0, [fp, #-16]
1001a93c:	eb000012 	bl	1001a98c <proc_expr>
1001a940:	e50b0008 	str	r0, [fp, #-8]

		match_token(token, &(self->token), finsh_token_type_semicolon);
1001a944:	e51b3010 	ldr	r3, [fp, #-16]
1001a948:	e2833004 	add	r3, r3, #4
1001a94c:	e1a00003 	mov	r0, r3
1001a950:	eb0005ae 	bl	1001c010 <finsh_token_token>
1001a954:	e1a03000 	mov	r3, r0
1001a958:	e54b3009 	strb	r3, [fp, #-9]
1001a95c:	e55b3009 	ldrb	r3, [fp, #-9]
1001a960:	e3530004 	cmp	r3, #4
1001a964:	0a000004 	beq	1001a97c <proc_expr_statement+0x8c>
1001a968:	e3a00001 	mov	r0, #1
1001a96c:	ebfff3d0 	bl	100178b4 <finsh_error_set>
1001a970:	e51b3010 	ldr	r3, [fp, #-16]
1001a974:	e3a02001 	mov	r2, #1
1001a978:	e5c32005 	strb	r2, [r3, #5]
	}

	return expr;
1001a97c:	e51b3008 	ldr	r3, [fp, #-8]
}
1001a980:	e1a00003 	mov	r0, r3
1001a984:	e24bd004 	sub	sp, fp, #4
1001a988:	e8bd8800 	pop	{fp, pc}

1001a98c <proc_expr>:

/*
expr -> expr_assign
*/
static struct finsh_node* proc_expr(struct finsh_parser* self)
{
1001a98c:	e92d4800 	push	{fp, lr}
1001a990:	e28db004 	add	fp, sp, #4
1001a994:	e24dd008 	sub	sp, sp, #8
1001a998:	e50b0008 	str	r0, [fp, #-8]
	return proc_assign_expr(self);
1001a99c:	e51b0008 	ldr	r0, [fp, #-8]
1001a9a0:	eb000003 	bl	1001a9b4 <proc_assign_expr>
1001a9a4:	e1a03000 	mov	r3, r0
}
1001a9a8:	e1a00003 	mov	r0, r3
1001a9ac:	e24bd004 	sub	sp, fp, #4
1001a9b0:	e8bd8800 	pop	{fp, pc}

1001a9b4 <proc_assign_expr>:
/*
expr_assign -> expr_inclusive_or
	| expr_unary ASSIGN expr_assign
*/
static struct finsh_node* proc_assign_expr(struct finsh_parser* self)
{
1001a9b4:	e92d4800 	push	{fp, lr}
1001a9b8:	e28db004 	add	fp, sp, #4
1001a9bc:	e24dd018 	sub	sp, sp, #24
1001a9c0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* or;
	struct finsh_node* assign;

	or = proc_inclusive_or_expr(self);
1001a9c4:	e51b0018 	ldr	r0, [fp, #-24]
1001a9c8:	eb000019 	bl	1001aa34 <proc_inclusive_or_expr>
1001a9cc:	e50b0008 	str	r0, [fp, #-8]

	next_token(token, &(self->token));
1001a9d0:	e51b3018 	ldr	r3, [fp, #-24]
1001a9d4:	e2833004 	add	r3, r3, #4
1001a9d8:	e1a00003 	mov	r0, r3
1001a9dc:	eb00058b 	bl	1001c010 <finsh_token_token>
1001a9e0:	e1a03000 	mov	r3, r0
1001a9e4:	e54b3009 	strb	r3, [fp, #-9]

	if (token == finsh_token_type_assign)
1001a9e8:	e55b3009 	ldrb	r3, [fp, #-9]
1001a9ec:	e353000c 	cmp	r3, #12
1001a9f0:	1a000008 	bne	1001aa18 <proc_assign_expr+0x64>
	{
		assign = proc_assign_expr(self);
1001a9f4:	e51b0018 	ldr	r0, [fp, #-24]
1001a9f8:	ebffffed 	bl	1001a9b4 <proc_assign_expr>
1001a9fc:	e50b0010 	str	r0, [fp, #-16]

		return make_sys_node(FINSH_NODE_SYS_ASSIGN, or, assign);
1001aa00:	e3a00013 	mov	r0, #19
1001aa04:	e51b1008 	ldr	r1, [fp, #-8]
1001aa08:	e51b2010 	ldr	r2, [fp, #-16]
1001aa0c:	eb0002e8 	bl	1001b5b4 <make_sys_node>
1001aa10:	e1a03000 	mov	r3, r0
1001aa14:	ea000003 	b	1001aa28 <proc_assign_expr+0x74>
	}
	else finsh_token_replay(&(self->token));
1001aa18:	e51b3018 	ldr	r3, [fp, #-24]
1001aa1c:	e3a02001 	mov	r2, #1
1001aa20:	e5c32005 	strb	r2, [r3, #5]

	return or;
1001aa24:	e51b3008 	ldr	r3, [fp, #-8]
}
1001aa28:	e1a00003 	mov	r0, r3
1001aa2c:	e24bd004 	sub	sp, fp, #4
1001aa30:	e8bd8800 	pop	{fp, pc}

1001aa34 <proc_inclusive_or_expr>:
/*
expr_inclusive_or -> expr_exclusive_or
	| expr_inclusive_or '|' expr_exclusive_or
*/
static struct finsh_node* proc_inclusive_or_expr(struct finsh_parser* self)
{
1001aa34:	e92d4800 	push	{fp, lr}
1001aa38:	e28db004 	add	fp, sp, #4
1001aa3c:	e24dd018 	sub	sp, sp, #24
1001aa40:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* xor;
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);
1001aa44:	e51b0018 	ldr	r0, [fp, #-24]
1001aa48:	eb000025 	bl	1001aae4 <proc_exclusive_or_expr>
1001aa4c:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1001aa50:	e51b3018 	ldr	r3, [fp, #-24]
1001aa54:	e2833004 	add	r3, r3, #4
1001aa58:	e1a00003 	mov	r0, r3
1001aa5c:	eb00056b 	bl	1001c010 <finsh_token_token>
1001aa60:	e1a03000 	mov	r3, r0
1001aa64:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_or )
1001aa68:	ea000013 	b	1001aabc <proc_inclusive_or_expr+0x88>
	{
		xor_new = proc_exclusive_or_expr(self);
1001aa6c:	e51b0018 	ldr	r0, [fp, #-24]
1001aa70:	eb00001b 	bl	1001aae4 <proc_exclusive_or_expr>
1001aa74:	e50b0010 	str	r0, [fp, #-16]

		if (xor_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001aa78:	e51b3010 	ldr	r3, [fp, #-16]
1001aa7c:	e3530000 	cmp	r3, #0
1001aa80:	1a000002 	bne	1001aa90 <proc_inclusive_or_expr+0x5c>
1001aa84:	e3a00005 	mov	r0, #5
1001aa88:	ebfff389 	bl	100178b4 <finsh_error_set>
1001aa8c:	ea000004 	b	1001aaa4 <proc_inclusive_or_expr+0x70>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);
1001aa90:	e3a0000d 	mov	r0, #13
1001aa94:	e51b100c 	ldr	r1, [fp, #-12]
1001aa98:	e51b2010 	ldr	r2, [fp, #-16]
1001aa9c:	eb0002c4 	bl	1001b5b4 <make_sys_node>
1001aaa0:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
1001aaa4:	e51b3018 	ldr	r3, [fp, #-24]
1001aaa8:	e2833004 	add	r3, r3, #4
1001aaac:	e1a00003 	mov	r0, r3
1001aab0:	eb000556 	bl	1001c010 <finsh_token_token>
1001aab4:	e1a03000 	mov	r3, r0
1001aab8:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* xor_new;

	xor = proc_exclusive_or_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_or )
1001aabc:	e55b3005 	ldrb	r3, [fp, #-5]
1001aac0:	e353000e 	cmp	r3, #14
1001aac4:	0affffe8 	beq	1001aa6c <proc_inclusive_or_expr+0x38>
		else xor = make_sys_node(FINSH_NODE_SYS_OR, xor, xor_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001aac8:	e51b3018 	ldr	r3, [fp, #-24]
1001aacc:	e3a02001 	mov	r2, #1
1001aad0:	e5c32005 	strb	r2, [r3, #5]
	return xor;
1001aad4:	e51b300c 	ldr	r3, [fp, #-12]
}
1001aad8:	e1a00003 	mov	r0, r3
1001aadc:	e24bd004 	sub	sp, fp, #4
1001aae0:	e8bd8800 	pop	{fp, pc}

1001aae4 <proc_exclusive_or_expr>:
/*
expr_exclusive_or -> expr_and
	| expr_exclusive '^' expr_and
*/
static struct finsh_node* proc_exclusive_or_expr(struct finsh_parser* self)
{
1001aae4:	e92d4800 	push	{fp, lr}
1001aae8:	e28db004 	add	fp, sp, #4
1001aaec:	e24dd018 	sub	sp, sp, #24
1001aaf0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
1001aaf4:	e51b0018 	ldr	r0, [fp, #-24]
1001aaf8:	eb000025 	bl	1001ab94 <proc_and_expr>
1001aafc:	e50b000c 	str	r0, [fp, #-12]
	next_token(token, &(self->token));
1001ab00:	e51b3018 	ldr	r3, [fp, #-24]
1001ab04:	e2833004 	add	r3, r3, #4
1001ab08:	e1a00003 	mov	r0, r3
1001ab0c:	eb00053f 	bl	1001c010 <finsh_token_token>
1001ab10:	e1a03000 	mov	r3, r0
1001ab14:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_xor )
1001ab18:	ea000013 	b	1001ab6c <proc_exclusive_or_expr+0x88>
	{
		and_new = proc_and_expr(self);
1001ab1c:	e51b0018 	ldr	r0, [fp, #-24]
1001ab20:	eb00001b 	bl	1001ab94 <proc_and_expr>
1001ab24:	e50b0010 	str	r0, [fp, #-16]
		if (and_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001ab28:	e51b3010 	ldr	r3, [fp, #-16]
1001ab2c:	e3530000 	cmp	r3, #0
1001ab30:	1a000002 	bne	1001ab40 <proc_exclusive_or_expr+0x5c>
1001ab34:	e3a00005 	mov	r0, #5
1001ab38:	ebfff35d 	bl	100178b4 <finsh_error_set>
1001ab3c:	ea000004 	b	1001ab54 <proc_exclusive_or_expr+0x70>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);
1001ab40:	e3a0000e 	mov	r0, #14
1001ab44:	e51b100c 	ldr	r1, [fp, #-12]
1001ab48:	e51b2010 	ldr	r2, [fp, #-16]
1001ab4c:	eb000298 	bl	1001b5b4 <make_sys_node>
1001ab50:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
1001ab54:	e51b3018 	ldr	r3, [fp, #-24]
1001ab58:	e2833004 	add	r3, r3, #4
1001ab5c:	e1a00003 	mov	r0, r3
1001ab60:	eb00052a 	bl	1001c010 <finsh_token_token>
1001ab64:	e1a03000 	mov	r3, r0
1001ab68:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* and;
	struct finsh_node* and_new;

	and = proc_and_expr(self);
	next_token(token, &(self->token));
	while ( token == finsh_token_type_xor )
1001ab6c:	e55b3005 	ldrb	r3, [fp, #-5]
1001ab70:	e353000f 	cmp	r3, #15
1001ab74:	0affffe8 	beq	1001ab1c <proc_exclusive_or_expr+0x38>
		else and = make_sys_node(FINSH_NODE_SYS_XOR, and, and_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001ab78:	e51b3018 	ldr	r3, [fp, #-24]
1001ab7c:	e3a02001 	mov	r2, #1
1001ab80:	e5c32005 	strb	r2, [r3, #5]
	return and;
1001ab84:	e51b300c 	ldr	r3, [fp, #-12]
}
1001ab88:	e1a00003 	mov	r0, r3
1001ab8c:	e24bd004 	sub	sp, fp, #4
1001ab90:	e8bd8800 	pop	{fp, pc}

1001ab94 <proc_and_expr>:
/*
expr_and -> expr_shift
	| expr_and '&' expr_shift
*/
static struct finsh_node* proc_and_expr(struct finsh_parser* self)
{
1001ab94:	e92d4800 	push	{fp, lr}
1001ab98:	e28db004 	add	fp, sp, #4
1001ab9c:	e24dd018 	sub	sp, sp, #24
1001aba0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* shift;
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);
1001aba4:	e51b0018 	ldr	r0, [fp, #-24]
1001aba8:	eb000025 	bl	1001ac44 <proc_shift_expr>
1001abac:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1001abb0:	e51b3018 	ldr	r3, [fp, #-24]
1001abb4:	e2833004 	add	r3, r3, #4
1001abb8:	e1a00003 	mov	r0, r3
1001abbc:	eb000513 	bl	1001c010 <finsh_token_token>
1001abc0:	e1a03000 	mov	r3, r0
1001abc4:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_and )
1001abc8:	ea000013 	b	1001ac1c <proc_and_expr+0x88>
	{
		shift_new = proc_shift_expr(self);
1001abcc:	e51b0018 	ldr	r0, [fp, #-24]
1001abd0:	eb00001b 	bl	1001ac44 <proc_shift_expr>
1001abd4:	e50b0010 	str	r0, [fp, #-16]

		if (shift_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001abd8:	e51b3010 	ldr	r3, [fp, #-16]
1001abdc:	e3530000 	cmp	r3, #0
1001abe0:	1a000002 	bne	1001abf0 <proc_and_expr+0x5c>
1001abe4:	e3a00005 	mov	r0, #5
1001abe8:	ebfff331 	bl	100178b4 <finsh_error_set>
1001abec:	ea000004 	b	1001ac04 <proc_and_expr+0x70>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);
1001abf0:	e3a0000c 	mov	r0, #12
1001abf4:	e51b100c 	ldr	r1, [fp, #-12]
1001abf8:	e51b2010 	ldr	r2, [fp, #-16]
1001abfc:	eb00026c 	bl	1001b5b4 <make_sys_node>
1001ac00:	e50b000c 	str	r0, [fp, #-12]

		next_token(token, &(self->token));
1001ac04:	e51b3018 	ldr	r3, [fp, #-24]
1001ac08:	e2833004 	add	r3, r3, #4
1001ac0c:	e1a00003 	mov	r0, r3
1001ac10:	eb0004fe 	bl	1001c010 <finsh_token_token>
1001ac14:	e1a03000 	mov	r3, r0
1001ac18:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* shift_new;

	shift = proc_shift_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_and )
1001ac1c:	e55b3005 	ldrb	r3, [fp, #-5]
1001ac20:	e353000d 	cmp	r3, #13
1001ac24:	0affffe8 	beq	1001abcc <proc_and_expr+0x38>
		else shift = make_sys_node(FINSH_NODE_SYS_AND, shift, shift_new);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001ac28:	e51b3018 	ldr	r3, [fp, #-24]
1001ac2c:	e3a02001 	mov	r2, #1
1001ac30:	e5c32005 	strb	r2, [r3, #5]
	return shift;
1001ac34:	e51b300c 	ldr	r3, [fp, #-12]
}
1001ac38:	e1a00003 	mov	r0, r3
1001ac3c:	e24bd004 	sub	sp, fp, #4
1001ac40:	e8bd8800 	pop	{fp, pc}

1001ac44 <proc_shift_expr>:
expr_shift -> expr_additive
	| expr_shift '<<' expr_additive
	| expr_shift '>>' expr_additive
*/
static struct finsh_node* proc_shift_expr(struct finsh_parser* self)
{
1001ac44:	e92d4800 	push	{fp, lr}
1001ac48:	e28db004 	add	fp, sp, #4
1001ac4c:	e24dd018 	sub	sp, sp, #24
1001ac50:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* add;
	struct finsh_node* add_new;

	add = proc_additive_expr(self);
1001ac54:	e51b0018 	ldr	r0, [fp, #-24]
1001ac58:	eb000038 	bl	1001ad40 <proc_additive_expr>
1001ac5c:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1001ac60:	e51b3018 	ldr	r3, [fp, #-24]
1001ac64:	e2833004 	add	r3, r3, #4
1001ac68:	e1a00003 	mov	r0, r3
1001ac6c:	eb0004e7 	bl	1001c010 <finsh_token_token>
1001ac70:	e1a03000 	mov	r3, r0
1001ac74:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
1001ac78:	ea000023 	b	1001ad0c <proc_shift_expr+0xc8>
	{
		add_new = proc_additive_expr(self);
1001ac7c:	e51b0018 	ldr	r0, [fp, #-24]
1001ac80:	eb00002e 	bl	1001ad40 <proc_additive_expr>
1001ac84:	e50b0010 	str	r0, [fp, #-16]
		if (add_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001ac88:	e51b3010 	ldr	r3, [fp, #-16]
1001ac8c:	e3530000 	cmp	r3, #0
1001ac90:	1a000002 	bne	1001aca0 <proc_shift_expr+0x5c>
1001ac94:	e3a00005 	mov	r0, #5
1001ac98:	ebfff305 	bl	100178b4 <finsh_error_set>
1001ac9c:	ea000014 	b	1001acf4 <proc_shift_expr+0xb0>
		else
		{
			switch (token)
1001aca0:	e55b3005 	ldrb	r3, [fp, #-5]
1001aca4:	e3530011 	cmp	r3, #17
1001aca8:	0a000002 	beq	1001acb8 <proc_shift_expr+0x74>
1001acac:	e3530012 	cmp	r3, #18
1001acb0:	0a000006 	beq	1001acd0 <proc_shift_expr+0x8c>
1001acb4:	ea00000b 	b	1001ace8 <proc_shift_expr+0xa4>
			{
			case finsh_token_type_shl:
				add = make_sys_node(FINSH_NODE_SYS_SHL, add, add_new);
1001acb8:	e3a00010 	mov	r0, #16
1001acbc:	e51b100c 	ldr	r1, [fp, #-12]
1001acc0:	e51b2010 	ldr	r2, [fp, #-16]
1001acc4:	eb00023a 	bl	1001b5b4 <make_sys_node>
1001acc8:	e50b000c 	str	r0, [fp, #-12]
				break;
1001accc:	ea000008 	b	1001acf4 <proc_shift_expr+0xb0>
			case finsh_token_type_shr:
				add = make_sys_node(FINSH_NODE_SYS_SHR, add, add_new);
1001acd0:	e3a00011 	mov	r0, #17
1001acd4:	e51b100c 	ldr	r1, [fp, #-12]
1001acd8:	e51b2010 	ldr	r2, [fp, #-16]
1001acdc:	eb000234 	bl	1001b5b4 <make_sys_node>
1001ace0:	e50b000c 	str	r0, [fp, #-12]
				break;
1001ace4:	ea000002 	b	1001acf4 <proc_shift_expr+0xb0>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001ace8:	e3a00005 	mov	r0, #5
1001acec:	ebfff2f0 	bl	100178b4 <finsh_error_set>
				break;
1001acf0:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
1001acf4:	e51b3018 	ldr	r3, [fp, #-24]
1001acf8:	e2833004 	add	r3, r3, #4
1001acfc:	e1a00003 	mov	r0, r3
1001ad00:	eb0004c2 	bl	1001c010 <finsh_token_token>
1001ad04:	e1a03000 	mov	r3, r0
1001ad08:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* add_new;

	add = proc_additive_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_shl || token == finsh_token_type_shr)
1001ad0c:	e55b3005 	ldrb	r3, [fp, #-5]
1001ad10:	e3530011 	cmp	r3, #17
1001ad14:	0affffd8 	beq	1001ac7c <proc_shift_expr+0x38>
1001ad18:	e55b3005 	ldrb	r3, [fp, #-5]
1001ad1c:	e3530012 	cmp	r3, #18
1001ad20:	0affffd5 	beq	1001ac7c <proc_shift_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001ad24:	e51b3018 	ldr	r3, [fp, #-24]
1001ad28:	e3a02001 	mov	r2, #1
1001ad2c:	e5c32005 	strb	r2, [r3, #5]
	return add;
1001ad30:	e51b300c 	ldr	r3, [fp, #-12]
}
1001ad34:	e1a00003 	mov	r0, r3
1001ad38:	e24bd004 	sub	sp, fp, #4
1001ad3c:	e8bd8800 	pop	{fp, pc}

1001ad40 <proc_additive_expr>:
expr_additive -> expr_multiplicative
	| expr_additive SUB expr_multiplicative
	| expr_additive ADD expr_multiplicative
*/
static struct finsh_node* proc_additive_expr(struct finsh_parser* self)
{
1001ad40:	e92d4800 	push	{fp, lr}
1001ad44:	e28db004 	add	fp, sp, #4
1001ad48:	e24dd018 	sub	sp, sp, #24
1001ad4c:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* mul;
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);
1001ad50:	e51b0018 	ldr	r0, [fp, #-24]
1001ad54:	eb000037 	bl	1001ae38 <proc_multiplicative_expr>
1001ad58:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1001ad5c:	e51b3018 	ldr	r3, [fp, #-24]
1001ad60:	e2833004 	add	r3, r3, #4
1001ad64:	e1a00003 	mov	r0, r3
1001ad68:	eb0004a8 	bl	1001c010 <finsh_token_token>
1001ad6c:	e1a03000 	mov	r3, r0
1001ad70:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
1001ad74:	ea000022 	b	1001ae04 <proc_additive_expr+0xc4>
	{
		mul_new = proc_multiplicative_expr(self);
1001ad78:	e51b0018 	ldr	r0, [fp, #-24]
1001ad7c:	eb00002d 	bl	1001ae38 <proc_multiplicative_expr>
1001ad80:	e50b0010 	str	r0, [fp, #-16]
		if (mul_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001ad84:	e51b3010 	ldr	r3, [fp, #-16]
1001ad88:	e3530000 	cmp	r3, #0
1001ad8c:	1a000002 	bne	1001ad9c <proc_additive_expr+0x5c>
1001ad90:	e3a00005 	mov	r0, #5
1001ad94:	ebfff2c6 	bl	100178b4 <finsh_error_set>
1001ad98:	ea000013 	b	1001adec <proc_additive_expr+0xac>
		else
		{
			switch (token)
1001ad9c:	e55b3005 	ldrb	r3, [fp, #-5]
1001ada0:	e3530006 	cmp	r3, #6
1001ada4:	0a000007 	beq	1001adc8 <proc_additive_expr+0x88>
1001ada8:	e3530008 	cmp	r3, #8
1001adac:	1a00000b 	bne	1001ade0 <proc_additive_expr+0xa0>
			{
			case finsh_token_type_sub:
				mul = make_sys_node(FINSH_NODE_SYS_SUB, mul, mul_new);
1001adb0:	e3a00008 	mov	r0, #8
1001adb4:	e51b100c 	ldr	r1, [fp, #-12]
1001adb8:	e51b2010 	ldr	r2, [fp, #-16]
1001adbc:	eb0001fc 	bl	1001b5b4 <make_sys_node>
1001adc0:	e50b000c 	str	r0, [fp, #-12]
				break;
1001adc4:	ea000008 	b	1001adec <proc_additive_expr+0xac>
			case finsh_token_type_add:
				mul = make_sys_node(FINSH_NODE_SYS_ADD, mul, mul_new);
1001adc8:	e3a00007 	mov	r0, #7
1001adcc:	e51b100c 	ldr	r1, [fp, #-12]
1001add0:	e51b2010 	ldr	r2, [fp, #-16]
1001add4:	eb0001f6 	bl	1001b5b4 <make_sys_node>
1001add8:	e50b000c 	str	r0, [fp, #-12]
				break;
1001addc:	ea000002 	b	1001adec <proc_additive_expr+0xac>
			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001ade0:	e3a00005 	mov	r0, #5
1001ade4:	ebfff2b2 	bl	100178b4 <finsh_error_set>
				break;
1001ade8:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
1001adec:	e51b3018 	ldr	r3, [fp, #-24]
1001adf0:	e2833004 	add	r3, r3, #4
1001adf4:	e1a00003 	mov	r0, r3
1001adf8:	eb000484 	bl	1001c010 <finsh_token_token>
1001adfc:	e1a03000 	mov	r3, r0
1001ae00:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* mul_new;

	mul = proc_multiplicative_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_sub || token == finsh_token_type_add )
1001ae04:	e55b3005 	ldrb	r3, [fp, #-5]
1001ae08:	e3530008 	cmp	r3, #8
1001ae0c:	0affffd9 	beq	1001ad78 <proc_additive_expr+0x38>
1001ae10:	e55b3005 	ldrb	r3, [fp, #-5]
1001ae14:	e3530006 	cmp	r3, #6
1001ae18:	0affffd6 	beq	1001ad78 <proc_additive_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001ae1c:	e51b3018 	ldr	r3, [fp, #-24]
1001ae20:	e3a02001 	mov	r2, #1
1001ae24:	e5c32005 	strb	r2, [r3, #5]
	return mul;
1001ae28:	e51b300c 	ldr	r3, [fp, #-12]
}
1001ae2c:	e1a00003 	mov	r0, r3
1001ae30:	e24bd004 	sub	sp, fp, #4
1001ae34:	e8bd8800 	pop	{fp, pc}

1001ae38 <proc_multiplicative_expr>:
	| expr_multiplicative '*' expr_cast
	| expr_multiplicative '/' expr_cast
	| expr_multiplicative '%' expr_cast
*/
static struct finsh_node* proc_multiplicative_expr(struct finsh_parser* self)
{
1001ae38:	e92d4800 	push	{fp, lr}
1001ae3c:	e28db004 	add	fp, sp, #4
1001ae40:	e24dd018 	sub	sp, sp, #24
1001ae44:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
1001ae48:	e51b0018 	ldr	r0, [fp, #-24]
1001ae4c:	eb000042 	bl	1001af5c <proc_cast_expr>
1001ae50:	e50b000c 	str	r0, [fp, #-12]
	next_token(token, &(self->token));
1001ae54:	e51b3018 	ldr	r3, [fp, #-24]
1001ae58:	e2833004 	add	r3, r3, #4
1001ae5c:	e1a00003 	mov	r0, r3
1001ae60:	eb00046a 	bl	1001c010 <finsh_token_token>
1001ae64:	e1a03000 	mov	r3, r0
1001ae68:	e54b3005 	strb	r3, [fp, #-5]
	while (token == finsh_token_type_mul ||
1001ae6c:	ea00002a 	b	1001af1c <proc_multiplicative_expr+0xe4>
		token == finsh_token_type_div ||
		token == finsh_token_type_mod )
	{
		cast_new = proc_cast_expr(self);
1001ae70:	e51b0018 	ldr	r0, [fp, #-24]
1001ae74:	eb000038 	bl	1001af5c <proc_cast_expr>
1001ae78:	e50b0010 	str	r0, [fp, #-16]
		if (cast_new == NULL) finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001ae7c:	e51b3010 	ldr	r3, [fp, #-16]
1001ae80:	e3530000 	cmp	r3, #0
1001ae84:	1a000002 	bne	1001ae94 <proc_multiplicative_expr+0x5c>
1001ae88:	e3a00005 	mov	r0, #5
1001ae8c:	ebfff288 	bl	100178b4 <finsh_error_set>
1001ae90:	ea00001b 	b	1001af04 <proc_multiplicative_expr+0xcc>
		else
		{
			switch (token)
1001ae94:	e55b3005 	ldrb	r3, [fp, #-5]
1001ae98:	e353000a 	cmp	r3, #10
1001ae9c:	0a000009 	beq	1001aec8 <proc_multiplicative_expr+0x90>
1001aea0:	e353000b 	cmp	r3, #11
1001aea4:	0a00000d 	beq	1001aee0 <proc_multiplicative_expr+0xa8>
1001aea8:	e3530005 	cmp	r3, #5
1001aeac:	1a000011 	bne	1001aef8 <proc_multiplicative_expr+0xc0>
			{
			case finsh_token_type_mul:
				cast = make_sys_node(FINSH_NODE_SYS_MUL, cast, cast_new);
1001aeb0:	e3a00009 	mov	r0, #9
1001aeb4:	e51b100c 	ldr	r1, [fp, #-12]
1001aeb8:	e51b2010 	ldr	r2, [fp, #-16]
1001aebc:	eb0001bc 	bl	1001b5b4 <make_sys_node>
1001aec0:	e50b000c 	str	r0, [fp, #-12]
				break;
1001aec4:	ea00000e 	b	1001af04 <proc_multiplicative_expr+0xcc>

			case finsh_token_type_div:
				cast = make_sys_node(FINSH_NODE_SYS_DIV, cast, cast_new);
1001aec8:	e3a0000a 	mov	r0, #10
1001aecc:	e51b100c 	ldr	r1, [fp, #-12]
1001aed0:	e51b2010 	ldr	r2, [fp, #-16]
1001aed4:	eb0001b6 	bl	1001b5b4 <make_sys_node>
1001aed8:	e50b000c 	str	r0, [fp, #-12]
				break;
1001aedc:	ea000008 	b	1001af04 <proc_multiplicative_expr+0xcc>

			case finsh_token_type_mod:
				cast = make_sys_node(FINSH_NODE_SYS_MOD, cast, cast_new);
1001aee0:	e3a0000b 	mov	r0, #11
1001aee4:	e51b100c 	ldr	r1, [fp, #-12]
1001aee8:	e51b2010 	ldr	r2, [fp, #-16]
1001aeec:	eb0001b0 	bl	1001b5b4 <make_sys_node>
1001aef0:	e50b000c 	str	r0, [fp, #-12]
				break;
1001aef4:	ea000002 	b	1001af04 <proc_multiplicative_expr+0xcc>

			default:
				finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001aef8:	e3a00005 	mov	r0, #5
1001aefc:	ebfff26c 	bl	100178b4 <finsh_error_set>
				break;
1001af00:	e1a00000 	nop			; (mov r0, r0)
			}
		}
		next_token(token, &(self->token));
1001af04:	e51b3018 	ldr	r3, [fp, #-24]
1001af08:	e2833004 	add	r3, r3, #4
1001af0c:	e1a00003 	mov	r0, r3
1001af10:	eb00043e 	bl	1001c010 <finsh_token_token>
1001af14:	e1a03000 	mov	r3, r0
1001af18:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* cast;
	struct finsh_node* cast_new;

	cast = proc_cast_expr(self);
	next_token(token, &(self->token));
	while (token == finsh_token_type_mul ||
1001af1c:	e55b3005 	ldrb	r3, [fp, #-5]
1001af20:	e3530005 	cmp	r3, #5
1001af24:	0affffd1 	beq	1001ae70 <proc_multiplicative_expr+0x38>
1001af28:	e55b3005 	ldrb	r3, [fp, #-5]
1001af2c:	e353000a 	cmp	r3, #10
1001af30:	0affffce 	beq	1001ae70 <proc_multiplicative_expr+0x38>
		token == finsh_token_type_div ||
1001af34:	e55b3005 	ldrb	r3, [fp, #-5]
1001af38:	e353000b 	cmp	r3, #11
1001af3c:	0affffcb 	beq	1001ae70 <proc_multiplicative_expr+0x38>
			}
		}
		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001af40:	e51b3018 	ldr	r3, [fp, #-24]
1001af44:	e3a02001 	mov	r2, #1
1001af48:	e5c32005 	strb	r2, [r3, #5]
	return cast;
1001af4c:	e51b300c 	ldr	r3, [fp, #-12]
}
1001af50:	e1a00003 	mov	r0, r3
1001af54:	e24bd004 	sub	sp, fp, #4
1001af58:	e8bd8800 	pop	{fp, pc}

1001af5c <proc_cast_expr>:
20060313, add recast parse
expr_cast -> expr_unary
	| '(' type ')' expr_cast
*/
static struct finsh_node* proc_cast_expr(struct finsh_parser* self)
{
1001af5c:	e92d4800 	push	{fp, lr}
1001af60:	e28db004 	add	fp, sp, #4
1001af64:	e24dd010 	sub	sp, sp, #16
1001af68:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	enum finsh_type type;
	struct finsh_node* cast;

	next_token(token, &(self->token));
1001af6c:	e51b3010 	ldr	r3, [fp, #-16]
1001af70:	e2833004 	add	r3, r3, #4
1001af74:	e1a00003 	mov	r0, r3
1001af78:	eb000424 	bl	1001c010 <finsh_token_token>
1001af7c:	e1a03000 	mov	r3, r0
1001af80:	e54b3005 	strb	r3, [fp, #-5]
	if (token == finsh_token_type_left_paren)
1001af84:	e55b3005 	ldrb	r3, [fp, #-5]
1001af88:	e3530001 	cmp	r3, #1
1001af8c:	1a00001c 	bne	1001b004 <proc_cast_expr+0xa8>
	{
		type = proc_type(self);
1001af90:	e51b0010 	ldr	r0, [fp, #-16]
1001af94:	ebfffd8e 	bl	1001a5d4 <proc_type>
1001af98:	e1a03000 	mov	r3, r0
1001af9c:	e54b3006 	strb	r3, [fp, #-6]
		match_token(token, &(self->token), finsh_token_type_right_paren);
1001afa0:	e51b3010 	ldr	r3, [fp, #-16]
1001afa4:	e2833004 	add	r3, r3, #4
1001afa8:	e1a00003 	mov	r0, r3
1001afac:	eb000417 	bl	1001c010 <finsh_token_token>
1001afb0:	e1a03000 	mov	r3, r0
1001afb4:	e54b3005 	strb	r3, [fp, #-5]
1001afb8:	e55b3005 	ldrb	r3, [fp, #-5]
1001afbc:	e3530002 	cmp	r3, #2
1001afc0:	0a000004 	beq	1001afd8 <proc_cast_expr+0x7c>
1001afc4:	e3a00001 	mov	r0, #1
1001afc8:	ebfff239 	bl	100178b4 <finsh_error_set>
1001afcc:	e51b3010 	ldr	r3, [fp, #-16]
1001afd0:	e3a02001 	mov	r2, #1
1001afd4:	e5c32005 	strb	r2, [r3, #5]

		cast = proc_cast_expr(self);
1001afd8:	e51b0010 	ldr	r0, [fp, #-16]
1001afdc:	ebffffde 	bl	1001af5c <proc_cast_expr>
1001afe0:	e50b000c 	str	r0, [fp, #-12]
		if (cast != NULL)
1001afe4:	e51b300c 	ldr	r3, [fp, #-12]
1001afe8:	e3530000 	cmp	r3, #0
1001afec:	0a000004 	beq	1001b004 <proc_cast_expr+0xa8>
		{
			cast->data_type = type;
1001aff0:	e51b300c 	ldr	r3, [fp, #-12]
1001aff4:	e55b2006 	ldrb	r2, [fp, #-6]
1001aff8:	e5c32001 	strb	r2, [r3, #1]
			return cast;
1001affc:	e51b300c 	ldr	r3, [fp, #-12]
1001b000:	ea000005 	b	1001b01c <proc_cast_expr+0xc0>
		}
	}

	finsh_token_replay(&(self->token));
1001b004:	e51b3010 	ldr	r3, [fp, #-16]
1001b008:	e3a02001 	mov	r2, #1
1001b00c:	e5c32005 	strb	r2, [r3, #5]
	return proc_unary_expr(self);
1001b010:	e51b0010 	ldr	r0, [fp, #-16]
1001b014:	eb000003 	bl	1001b028 <proc_unary_expr>
1001b018:	e1a03000 	mov	r3, r0
}
1001b01c:	e1a00003 	mov	r0, r3
1001b020:	e24bd004 	sub	sp, fp, #4
1001b024:	e8bd8800 	pop	{fp, pc}

1001b028 <proc_unary_expr>:
	| '~' expr_cast
	| '*' expr_cast
	| '&' expr_cast
*/
static struct finsh_node* proc_unary_expr(struct finsh_parser* self)
{
1001b028:	e92d4800 	push	{fp, lr}
1001b02c:	e28db004 	add	fp, sp, #4
1001b030:	e24dd010 	sub	sp, sp, #16
1001b034:	e50b0010 	str	r0, [fp, #-16]
	enum finsh_token_type token;
	struct finsh_node *cast;

	next_token(token, &(self->token));
1001b038:	e51b3010 	ldr	r3, [fp, #-16]
1001b03c:	e2833004 	add	r3, r3, #4
1001b040:	e1a00003 	mov	r0, r3
1001b044:	eb0003f1 	bl	1001c010 <finsh_token_token>
1001b048:	e1a03000 	mov	r3, r0
1001b04c:	e54b3005 	strb	r3, [fp, #-5]
	switch (token)
1001b050:	e55b3005 	ldrb	r3, [fp, #-5]
1001b054:	e2433005 	sub	r3, r3, #5
1001b058:	e353000b 	cmp	r3, #11
1001b05c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001b060:	ea000049 	b	1001b18c <proc_unary_expr+0x164>
1001b064:	1001b144 	.word	0x1001b144
1001b068:	1001b094 	.word	0x1001b094
1001b06c:	1001b0a8 	.word	0x1001b0a8
1001b070:	1001b0cc 	.word	0x1001b0cc
1001b074:	1001b0fc 	.word	0x1001b0fc
1001b078:	1001b18c 	.word	0x1001b18c
1001b07c:	1001b18c 	.word	0x1001b18c
1001b080:	1001b18c 	.word	0x1001b18c
1001b084:	1001b168 	.word	0x1001b168
1001b088:	1001b18c 	.word	0x1001b18c
1001b08c:	1001b18c 	.word	0x1001b18c
1001b090:	1001b120 	.word	0x1001b120
	{
	case finsh_token_type_add: /* + */
		cast = proc_cast_expr(self);
1001b094:	e51b0010 	ldr	r0, [fp, #-16]
1001b098:	ebffffaf 	bl	1001af5c <proc_cast_expr>
1001b09c:	e50b000c 	str	r0, [fp, #-12]
		return cast;
1001b0a0:	e51b300c 	ldr	r3, [fp, #-12]
1001b0a4:	ea00003e 	b	1001b1a4 <proc_unary_expr+0x17c>

	case finsh_token_type_inc: /* ++ */
		cast = proc_cast_expr(self);
1001b0a8:	e51b0010 	ldr	r0, [fp, #-16]
1001b0ac:	ebffffaa 	bl	1001af5c <proc_cast_expr>
1001b0b0:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_PREINC, cast, NULL);
1001b0b4:	e3a00015 	mov	r0, #21
1001b0b8:	e51b100c 	ldr	r1, [fp, #-12]
1001b0bc:	e3a02000 	mov	r2, #0
1001b0c0:	eb00013b 	bl	1001b5b4 <make_sys_node>
1001b0c4:	e1a03000 	mov	r3, r0
1001b0c8:	ea000035 	b	1001b1a4 <proc_unary_expr+0x17c>

	case finsh_token_type_sub: /* - */
		cast = proc_cast_expr(self);
1001b0cc:	e51b0010 	ldr	r0, [fp, #-16]
1001b0d0:	ebffffa1 	bl	1001af5c <proc_cast_expr>
1001b0d4:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_SUB, finsh_node_new_long(0), cast);
1001b0d8:	e3a00000 	mov	r0, #0
1001b0dc:	ebfff4af 	bl	100183a0 <finsh_node_new_long>
1001b0e0:	e1a03000 	mov	r3, r0
1001b0e4:	e3a00008 	mov	r0, #8
1001b0e8:	e1a01003 	mov	r1, r3
1001b0ec:	e51b200c 	ldr	r2, [fp, #-12]
1001b0f0:	eb00012f 	bl	1001b5b4 <make_sys_node>
1001b0f4:	e1a03000 	mov	r3, r0
1001b0f8:	ea000029 	b	1001b1a4 <proc_unary_expr+0x17c>

	case finsh_token_type_dec: /* -- */
		cast = proc_cast_expr(self);
1001b0fc:	e51b0010 	ldr	r0, [fp, #-16]
1001b100:	ebffff95 	bl	1001af5c <proc_cast_expr>
1001b104:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_PREDEC, cast, NULL);
1001b108:	e3a00016 	mov	r0, #22
1001b10c:	e51b100c 	ldr	r1, [fp, #-12]
1001b110:	e3a02000 	mov	r2, #0
1001b114:	eb000126 	bl	1001b5b4 <make_sys_node>
1001b118:	e1a03000 	mov	r3, r0
1001b11c:	ea000020 	b	1001b1a4 <proc_unary_expr+0x17c>

	case finsh_token_type_bitwise: /* ~ */
		cast = proc_cast_expr(self);
1001b120:	e51b0010 	ldr	r0, [fp, #-16]
1001b124:	ebffff8c 	bl	1001af5c <proc_cast_expr>
1001b128:	e50b000c 	str	r0, [fp, #-12]
		return make_sys_node(FINSH_NODE_SYS_BITWISE, cast, NULL);
1001b12c:	e3a0000f 	mov	r0, #15
1001b130:	e51b100c 	ldr	r1, [fp, #-12]
1001b134:	e3a02000 	mov	r2, #0
1001b138:	eb00011d 	bl	1001b5b4 <make_sys_node>
1001b13c:	e1a03000 	mov	r3, r0
1001b140:	ea000017 	b	1001b1a4 <proc_unary_expr+0x17c>

    case finsh_token_type_mul: /* * */
        cast = proc_cast_expr(self);
1001b144:	e51b0010 	ldr	r0, [fp, #-16]
1001b148:	ebffff83 	bl	1001af5c <proc_cast_expr>
1001b14c:	e50b000c 	str	r0, [fp, #-12]
        return make_sys_node(FINSH_NODE_SYS_GETVALUE, cast, NULL);
1001b150:	e3a00019 	mov	r0, #25
1001b154:	e51b100c 	ldr	r1, [fp, #-12]
1001b158:	e3a02000 	mov	r2, #0
1001b15c:	eb000114 	bl	1001b5b4 <make_sys_node>
1001b160:	e1a03000 	mov	r3, r0
1001b164:	ea00000e 	b	1001b1a4 <proc_unary_expr+0x17c>

    case finsh_token_type_and: /* & */
        cast = proc_cast_expr(self);
1001b168:	e51b0010 	ldr	r0, [fp, #-16]
1001b16c:	ebffff7a 	bl	1001af5c <proc_cast_expr>
1001b170:	e50b000c 	str	r0, [fp, #-12]
        return make_sys_node(FINSH_NODE_SYS_GETADDR, cast, NULL);
1001b174:	e3a0001a 	mov	r0, #26
1001b178:	e51b100c 	ldr	r1, [fp, #-12]
1001b17c:	e3a02000 	mov	r2, #0
1001b180:	eb00010b 	bl	1001b5b4 <make_sys_node>
1001b184:	e1a03000 	mov	r3, r0
1001b188:	ea000005 	b	1001b1a4 <proc_unary_expr+0x17c>

	default:
		finsh_token_replay(&(self->token));
1001b18c:	e51b3010 	ldr	r3, [fp, #-16]
1001b190:	e3a02001 	mov	r2, #1
1001b194:	e5c32005 	strb	r2, [r3, #5]
		return proc_postfix_expr(self);
1001b198:	e51b0010 	ldr	r0, [fp, #-16]
1001b19c:	eb000003 	bl	1001b1b0 <proc_postfix_expr>
1001b1a0:	e1a03000 	mov	r3, r0
	}
}
1001b1a4:	e1a00003 	mov	r0, r3
1001b1a8:	e24bd004 	sub	sp, fp, #4
1001b1ac:	e8bd8800 	pop	{fp, pc}

1001b1b0 <proc_postfix_expr>:
	| expr_postfix INC
	| expr_postfix DEC
	| expr_postfix '(' param_list ')'
*/
static struct finsh_node* proc_postfix_expr(struct finsh_parser* self)
{
1001b1b0:	e92d4800 	push	{fp, lr}
1001b1b4:	e28db004 	add	fp, sp, #4
1001b1b8:	e24dd018 	sub	sp, sp, #24
1001b1bc:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);
1001b1c0:	e51b0018 	ldr	r0, [fp, #-24]
1001b1c4:	eb000056 	bl	1001b324 <proc_primary_expr>
1001b1c8:	e50b000c 	str	r0, [fp, #-12]

	next_token(token, &(self->token));
1001b1cc:	e51b3018 	ldr	r3, [fp, #-24]
1001b1d0:	e2833004 	add	r3, r3, #4
1001b1d4:	e1a00003 	mov	r0, r3
1001b1d8:	eb00038c 	bl	1001c010 <finsh_token_token>
1001b1dc:	e1a03000 	mov	r3, r0
1001b1e0:	e54b3005 	strb	r3, [fp, #-5]
	while ( token == finsh_token_type_inc 	||
1001b1e4:	ea00003e 	b	1001b2e4 <proc_postfix_expr+0x134>
		token == finsh_token_type_dec 		||
		token == finsh_token_type_left_paren )
	{
		switch (token)
1001b1e8:	e55b3005 	ldrb	r3, [fp, #-5]
1001b1ec:	e3530007 	cmp	r3, #7
1001b1f0:	0a000004 	beq	1001b208 <proc_postfix_expr+0x58>
1001b1f4:	e3530009 	cmp	r3, #9
1001b1f8:	0a000008 	beq	1001b220 <proc_postfix_expr+0x70>
1001b1fc:	e3530001 	cmp	r3, #1
1001b200:	0a00000c 	beq	1001b238 <proc_postfix_expr+0x88>
				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
			}
			break;

		default:
			break;
1001b204:	ea000030 	b	1001b2cc <proc_postfix_expr+0x11c>
		token == finsh_token_type_left_paren )
	{
		switch (token)
		{
		case finsh_token_type_inc :/* '++' */
			postfix = make_sys_node(FINSH_NODE_SYS_INC, postfix, NULL);
1001b208:	e3a00017 	mov	r0, #23
1001b20c:	e51b100c 	ldr	r1, [fp, #-12]
1001b210:	e3a02000 	mov	r2, #0
1001b214:	eb0000e6 	bl	1001b5b4 <make_sys_node>
1001b218:	e50b000c 	str	r0, [fp, #-12]
			break;
1001b21c:	ea00002a 	b	1001b2cc <proc_postfix_expr+0x11c>

		case finsh_token_type_dec :/* '--' */
			postfix = make_sys_node(FINSH_NODE_SYS_DEC, postfix, NULL);
1001b220:	e3a00018 	mov	r0, #24
1001b224:	e51b100c 	ldr	r1, [fp, #-12]
1001b228:	e3a02000 	mov	r2, #0
1001b22c:	eb0000e0 	bl	1001b5b4 <make_sys_node>
1001b230:	e50b000c 	str	r0, [fp, #-12]
			break;
1001b234:	ea000024 	b	1001b2cc <proc_postfix_expr+0x11c>

		case finsh_token_type_left_paren :/* '(' */
			{
				struct finsh_node* param_list;

				param_list = NULL;
1001b238:	e3a03000 	mov	r3, #0
1001b23c:	e50b3010 	str	r3, [fp, #-16]
				next_token(token, &(self->token));
1001b240:	e51b3018 	ldr	r3, [fp, #-24]
1001b244:	e2833004 	add	r3, r3, #4
1001b248:	e1a00003 	mov	r0, r3
1001b24c:	eb00036f 	bl	1001c010 <finsh_token_token>
1001b250:	e1a03000 	mov	r3, r0
1001b254:	e54b3005 	strb	r3, [fp, #-5]
				if (token != finsh_token_type_right_paren)
1001b258:	e55b3005 	ldrb	r3, [fp, #-5]
1001b25c:	e3530002 	cmp	r3, #2
1001b260:	0a000013 	beq	1001b2b4 <proc_postfix_expr+0x104>
				{
					finsh_token_replay(&(self->token));
1001b264:	e51b3018 	ldr	r3, [fp, #-24]
1001b268:	e3a02001 	mov	r2, #1
1001b26c:	e5c32005 	strb	r2, [r3, #5]
					param_list = proc_param_list(self);
1001b270:	e51b0018 	ldr	r0, [fp, #-24]
1001b274:	eb00009a 	bl	1001b4e4 <proc_param_list>
1001b278:	e50b0010 	str	r0, [fp, #-16]

					match_token(token, &(self->token), finsh_token_type_right_paren);
1001b27c:	e51b3018 	ldr	r3, [fp, #-24]
1001b280:	e2833004 	add	r3, r3, #4
1001b284:	e1a00003 	mov	r0, r3
1001b288:	eb000360 	bl	1001c010 <finsh_token_token>
1001b28c:	e1a03000 	mov	r3, r0
1001b290:	e54b3005 	strb	r3, [fp, #-5]
1001b294:	e55b3005 	ldrb	r3, [fp, #-5]
1001b298:	e3530002 	cmp	r3, #2
1001b29c:	0a000004 	beq	1001b2b4 <proc_postfix_expr+0x104>
1001b2a0:	e3a00001 	mov	r0, #1
1001b2a4:	ebfff182 	bl	100178b4 <finsh_error_set>
1001b2a8:	e51b3018 	ldr	r3, [fp, #-24]
1001b2ac:	e3a02001 	mov	r2, #1
1001b2b0:	e5c32005 	strb	r2, [r3, #5]
				}

				postfix = make_sys_node(FINSH_NODE_SYS_FUNC, postfix, param_list);
1001b2b4:	e3a00012 	mov	r0, #18
1001b2b8:	e51b100c 	ldr	r1, [fp, #-12]
1001b2bc:	e51b2010 	ldr	r2, [fp, #-16]
1001b2c0:	eb0000bb 	bl	1001b5b4 <make_sys_node>
1001b2c4:	e50b000c 	str	r0, [fp, #-12]
			}
			break;
1001b2c8:	e1a00000 	nop			; (mov r0, r0)

		default:
			break;
		}

		next_token(token, &(self->token));
1001b2cc:	e51b3018 	ldr	r3, [fp, #-24]
1001b2d0:	e2833004 	add	r3, r3, #4
1001b2d4:	e1a00003 	mov	r0, r3
1001b2d8:	eb00034c 	bl	1001c010 <finsh_token_token>
1001b2dc:	e1a03000 	mov	r3, r0
1001b2e0:	e54b3005 	strb	r3, [fp, #-5]
	struct finsh_node* postfix;

	postfix = proc_primary_expr(self);

	next_token(token, &(self->token));
	while ( token == finsh_token_type_inc 	||
1001b2e4:	e55b3005 	ldrb	r3, [fp, #-5]
1001b2e8:	e3530007 	cmp	r3, #7
1001b2ec:	0affffbd 	beq	1001b1e8 <proc_postfix_expr+0x38>
1001b2f0:	e55b3005 	ldrb	r3, [fp, #-5]
1001b2f4:	e3530009 	cmp	r3, #9
1001b2f8:	0affffba 	beq	1001b1e8 <proc_postfix_expr+0x38>
		token == finsh_token_type_dec 		||
1001b2fc:	e55b3005 	ldrb	r3, [fp, #-5]
1001b300:	e3530001 	cmp	r3, #1
1001b304:	0affffb7 	beq	1001b1e8 <proc_postfix_expr+0x38>
		}

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001b308:	e51b3018 	ldr	r3, [fp, #-24]
1001b30c:	e3a02001 	mov	r2, #1
1001b310:	e5c32005 	strb	r2, [r3, #5]
	return postfix;
1001b314:	e51b300c 	ldr	r3, [fp, #-12]
}
1001b318:	e1a00003 	mov	r0, r3
1001b31c:	e24bd004 	sub	sp, fp, #4
1001b320:	e8bd8800 	pop	{fp, pc}

1001b324 <proc_primary_expr>:
expr_primary -> literal
	| '(' expr ')'
	| identifier
*/
static struct finsh_node* proc_primary_expr(struct finsh_parser* self)
{
1001b324:	e92d4800 	push	{fp, lr}
1001b328:	e28db004 	add	fp, sp, #4
1001b32c:	e24dd028 	sub	sp, sp, #40	; 0x28
1001b330:	e50b0028 	str	r0, [fp, #-40]	; 0x28
	enum finsh_token_type token;
	struct finsh_node* expr;

	next_token(token, &(self->token));
1001b334:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b338:	e2833004 	add	r3, r3, #4
1001b33c:	e1a00003 	mov	r0, r3
1001b340:	eb000332 	bl	1001c010 <finsh_token_token>
1001b344:	e1a03000 	mov	r3, r0
1001b348:	e54b3005 	strb	r3, [fp, #-5]
	switch ( token )
1001b34c:	e55b3005 	ldrb	r3, [fp, #-5]
1001b350:	e2433001 	sub	r3, r3, #1
1001b354:	e353001e 	cmp	r3, #30
1001b358:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001b35c:	ea000059 	b	1001b4c8 <proc_primary_expr+0x1a4>
1001b360:	1001b40c 	.word	0x1001b40c
1001b364:	1001b4c8 	.word	0x1001b4c8
1001b368:	1001b4c8 	.word	0x1001b4c8
1001b36c:	1001b4c8 	.word	0x1001b4c8
1001b370:	1001b4c8 	.word	0x1001b4c8
1001b374:	1001b4c8 	.word	0x1001b4c8
1001b378:	1001b4c8 	.word	0x1001b4c8
1001b37c:	1001b4c8 	.word	0x1001b4c8
1001b380:	1001b4c8 	.word	0x1001b4c8
1001b384:	1001b4c8 	.word	0x1001b4c8
1001b388:	1001b4c8 	.word	0x1001b4c8
1001b38c:	1001b4c8 	.word	0x1001b4c8
1001b390:	1001b4c8 	.word	0x1001b4c8
1001b394:	1001b4c8 	.word	0x1001b4c8
1001b398:	1001b4c8 	.word	0x1001b4c8
1001b39c:	1001b4c8 	.word	0x1001b4c8
1001b3a0:	1001b4c8 	.word	0x1001b4c8
1001b3a4:	1001b4c8 	.word	0x1001b4c8
1001b3a8:	1001b4c8 	.word	0x1001b4c8
1001b3ac:	1001b4c8 	.word	0x1001b4c8
1001b3b0:	1001b4c8 	.word	0x1001b4c8
1001b3b4:	1001b4c8 	.word	0x1001b4c8
1001b3b8:	1001b4c8 	.word	0x1001b4c8
1001b3bc:	1001b4c8 	.word	0x1001b4c8
1001b3c0:	1001b4c8 	.word	0x1001b4c8
1001b3c4:	1001b488 	.word	0x1001b488
1001b3c8:	1001b458 	.word	0x1001b458
1001b3cc:	1001b470 	.word	0x1001b470
1001b3d0:	1001b4a0 	.word	0x1001b4a0
1001b3d4:	1001b4b8 	.word	0x1001b4b8
1001b3d8:	1001b3dc 	.word	0x1001b3dc
	{
	case finsh_token_type_identifier:
		{
			char id[FINSH_NAME_MAX + 1];

			finsh_token_replay(&(self->token));
1001b3dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b3e0:	e3a02001 	mov	r2, #1
1001b3e4:	e5c32005 	strb	r2, [r3, #5]
			proc_identifier(self, id);
1001b3e8:	e24b3020 	sub	r3, fp, #32
1001b3ec:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
1001b3f0:	e1a01003 	mov	r1, r3
1001b3f4:	ebfffd20 	bl	1001a87c <proc_identifier>
			return finsh_node_new_id(id);
1001b3f8:	e24b3020 	sub	r3, fp, #32
1001b3fc:	e1a00003 	mov	r0, r3
1001b400:	ebfff36d 	bl	100181bc <finsh_node_new_id>
1001b404:	e1a03000 	mov	r3, r0
1001b408:	ea000032 	b	1001b4d8 <proc_primary_expr+0x1b4>
		}

	case finsh_token_type_left_paren:
		expr = proc_expr(self);
1001b40c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
1001b410:	ebfffd5d 	bl	1001a98c <proc_expr>
1001b414:	e50b000c 	str	r0, [fp, #-12]
		match_token(token, &(self->token), finsh_token_type_right_paren);
1001b418:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b41c:	e2833004 	add	r3, r3, #4
1001b420:	e1a00003 	mov	r0, r3
1001b424:	eb0002f9 	bl	1001c010 <finsh_token_token>
1001b428:	e1a03000 	mov	r3, r0
1001b42c:	e54b3005 	strb	r3, [fp, #-5]
1001b430:	e55b3005 	ldrb	r3, [fp, #-5]
1001b434:	e3530002 	cmp	r3, #2
1001b438:	0a000004 	beq	1001b450 <proc_primary_expr+0x12c>
1001b43c:	e3a00001 	mov	r0, #1
1001b440:	ebfff11b 	bl	100178b4 <finsh_error_set>
1001b444:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b448:	e3a02001 	mov	r2, #1
1001b44c:	e5c32005 	strb	r2, [r3, #5]
		return expr;
1001b450:	e51b300c 	ldr	r3, [fp, #-12]
1001b454:	ea00001f 	b	1001b4d8 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_int:
		return finsh_node_new_int(self->token.value.int_value);
1001b458:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b45c:	e5933010 	ldr	r3, [r3, #16]
1001b460:	e1a00003 	mov	r0, r3
1001b464:	ebfff3b8 	bl	1001834c <finsh_node_new_int>
1001b468:	e1a03000 	mov	r3, r0
1001b46c:	ea000019 	b	1001b4d8 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_long:
		return finsh_node_new_long(self->token.value.long_value);
1001b470:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b474:	e5933010 	ldr	r3, [r3, #16]
1001b478:	e1a00003 	mov	r0, r3
1001b47c:	ebfff3c7 	bl	100183a0 <finsh_node_new_long>
1001b480:	e1a03000 	mov	r3, r0
1001b484:	ea000013 	b	1001b4d8 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_char:
		return finsh_node_new_char(self->token.value.char_value);
1001b488:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b48c:	e5d33010 	ldrb	r3, [r3, #16]
1001b490:	e1a00003 	mov	r0, r3
1001b494:	ebfff396 	bl	100182f4 <finsh_node_new_char>
1001b498:	e1a03000 	mov	r3, r0
1001b49c:	ea00000d 	b	1001b4d8 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_string:
		return finsh_node_new_string((char*)self->token.string);
1001b4a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001b4a4:	e2833014 	add	r3, r3, #20
1001b4a8:	e1a00003 	mov	r0, r3
1001b4ac:	ebfff3d0 	bl	100183f4 <finsh_node_new_string>
1001b4b0:	e1a03000 	mov	r3, r0
1001b4b4:	ea000007 	b	1001b4d8 <proc_primary_expr+0x1b4>

	case finsh_token_type_value_null:
		return finsh_node_new_ptr(NULL);
1001b4b8:	e3a00000 	mov	r0, #0
1001b4bc:	ebfff3f8 	bl	100184a4 <finsh_node_new_ptr>
1001b4c0:	e1a03000 	mov	r3, r0
1001b4c4:	ea000003 	b	1001b4d8 <proc_primary_expr+0x1b4>

	default:
		finsh_error_set(FINSH_ERROR_INVALID_TOKEN);
1001b4c8:	e3a00001 	mov	r0, #1
1001b4cc:	ebfff0f8 	bl	100178b4 <finsh_error_set>
		break;
1001b4d0:	e1a00000 	nop			; (mov r0, r0)
	}

	return NULL;
1001b4d4:	e3a03000 	mov	r3, #0
}
1001b4d8:	e1a00003 	mov	r0, r3
1001b4dc:	e24bd004 	sub	sp, fp, #4
1001b4e0:	e8bd8800 	pop	{fp, pc}

1001b4e4 <proc_param_list>:
param_list -> empty
	| expr_assign
	| param_list ',' expr_assign
*/
static struct finsh_node* proc_param_list(struct finsh_parser* self)
{
1001b4e4:	e92d4800 	push	{fp, lr}
1001b4e8:	e28db004 	add	fp, sp, #4
1001b4ec:	e24dd018 	sub	sp, sp, #24
1001b4f0:	e50b0018 	str	r0, [fp, #-24]
	enum finsh_token_type token;
	struct finsh_node *node, *assign;

	assign = proc_assign_expr(self);
1001b4f4:	e51b0018 	ldr	r0, [fp, #-24]
1001b4f8:	ebfffd2d 	bl	1001a9b4 <proc_assign_expr>
1001b4fc:	e50b000c 	str	r0, [fp, #-12]
	if (assign == NULL) return NULL;
1001b500:	e51b300c 	ldr	r3, [fp, #-12]
1001b504:	e3530000 	cmp	r3, #0
1001b508:	1a000001 	bne	1001b514 <proc_param_list+0x30>
1001b50c:	e3a03000 	mov	r3, #0
1001b510:	ea000024 	b	1001b5a8 <proc_param_list+0xc4>
	node = assign;
1001b514:	e51b300c 	ldr	r3, [fp, #-12]
1001b518:	e50b3010 	str	r3, [fp, #-16]

	next_token(token, &(self->token));
1001b51c:	e51b3018 	ldr	r3, [fp, #-24]
1001b520:	e2833004 	add	r3, r3, #4
1001b524:	e1a00003 	mov	r0, r3
1001b528:	eb0002b8 	bl	1001c010 <finsh_token_token>
1001b52c:	e1a03000 	mov	r3, r0
1001b530:	e54b3005 	strb	r3, [fp, #-5]
	while (token == finsh_token_type_comma )
1001b534:	ea000014 	b	1001b58c <proc_param_list+0xa8>
	{
		finsh_node_sibling(assign) = proc_assign_expr(self);
1001b538:	e51b0018 	ldr	r0, [fp, #-24]
1001b53c:	ebfffd1c 	bl	1001a9b4 <proc_assign_expr>
1001b540:	e1a02000 	mov	r2, r0
1001b544:	e51b300c 	ldr	r3, [fp, #-12]
1001b548:	e583200c 	str	r2, [r3, #12]

		if (finsh_node_sibling(assign) != NULL)	assign = finsh_node_sibling(assign);
1001b54c:	e51b300c 	ldr	r3, [fp, #-12]
1001b550:	e593300c 	ldr	r3, [r3, #12]
1001b554:	e3530000 	cmp	r3, #0
1001b558:	0a000003 	beq	1001b56c <proc_param_list+0x88>
1001b55c:	e51b300c 	ldr	r3, [fp, #-12]
1001b560:	e593300c 	ldr	r3, [r3, #12]
1001b564:	e50b300c 	str	r3, [fp, #-12]
1001b568:	ea000001 	b	1001b574 <proc_param_list+0x90>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);
1001b56c:	e3a00005 	mov	r0, #5
1001b570:	ebfff0cf 	bl	100178b4 <finsh_error_set>

		next_token(token, &(self->token));
1001b574:	e51b3018 	ldr	r3, [fp, #-24]
1001b578:	e2833004 	add	r3, r3, #4
1001b57c:	e1a00003 	mov	r0, r3
1001b580:	eb0002a2 	bl	1001c010 <finsh_token_token>
1001b584:	e1a03000 	mov	r3, r0
1001b588:	e54b3005 	strb	r3, [fp, #-5]
	assign = proc_assign_expr(self);
	if (assign == NULL) return NULL;
	node = assign;

	next_token(token, &(self->token));
	while (token == finsh_token_type_comma )
1001b58c:	e55b3005 	ldrb	r3, [fp, #-5]
1001b590:	e3530003 	cmp	r3, #3
1001b594:	0affffe7 	beq	1001b538 <proc_param_list+0x54>
		else finsh_error_set(FINSH_ERROR_EXPECT_OPERATOR);

		next_token(token, &(self->token));
	}

	finsh_token_replay(&(self->token));
1001b598:	e51b3018 	ldr	r3, [fp, #-24]
1001b59c:	e3a02001 	mov	r2, #1
1001b5a0:	e5c32005 	strb	r2, [r3, #5]

	return node;
1001b5a4:	e51b3010 	ldr	r3, [fp, #-16]
}
1001b5a8:	e1a00003 	mov	r0, r3
1001b5ac:	e24bd004 	sub	sp, fp, #4
1001b5b0:	e8bd8800 	pop	{fp, pc}

1001b5b4 <make_sys_node>:
node1__
       \
       node2
*/
static struct finsh_node* make_sys_node(u_char type, struct finsh_node* node1, struct finsh_node* node2)
{
1001b5b4:	e92d4800 	push	{fp, lr}
1001b5b8:	e28db004 	add	fp, sp, #4
1001b5bc:	e24dd018 	sub	sp, sp, #24
1001b5c0:	e1a03000 	mov	r3, r0
1001b5c4:	e50b1014 	str	r1, [fp, #-20]
1001b5c8:	e50b2018 	str	r2, [fp, #-24]
1001b5cc:	e54b300d 	strb	r3, [fp, #-13]
	struct finsh_node* node;

	node = finsh_node_allocate(type);
1001b5d0:	e55b300d 	ldrb	r3, [fp, #-13]
1001b5d4:	e1a00003 	mov	r0, r3
1001b5d8:	ebfff2c5 	bl	100180f4 <finsh_node_allocate>
1001b5dc:	e50b0008 	str	r0, [fp, #-8]

	if ((node1 != NULL) && (node != NULL))
1001b5e0:	e51b3014 	ldr	r3, [fp, #-20]
1001b5e4:	e3530000 	cmp	r3, #0
1001b5e8:	0a000009 	beq	1001b614 <make_sys_node+0x60>
1001b5ec:	e51b3008 	ldr	r3, [fp, #-8]
1001b5f0:	e3530000 	cmp	r3, #0
1001b5f4:	0a000006 	beq	1001b614 <make_sys_node+0x60>
	{
		finsh_node_child(node) = node1;
1001b5f8:	e51b3008 	ldr	r3, [fp, #-8]
1001b5fc:	e51b2014 	ldr	r2, [fp, #-20]
1001b600:	e5832010 	str	r2, [r3, #16]
		finsh_node_sibling(node1) = node2;
1001b604:	e51b3014 	ldr	r3, [fp, #-20]
1001b608:	e51b2018 	ldr	r2, [fp, #-24]
1001b60c:	e583200c 	str	r2, [r3, #12]
1001b610:	ea000001 	b	1001b61c <make_sys_node+0x68>
	}
	else finsh_error_set(FINSH_ERROR_NULL_NODE);
1001b614:	e3a0000e 	mov	r0, #14
1001b618:	ebfff0a5 	bl	100178b4 <finsh_error_set>

	return node;
1001b61c:	e51b3008 	ldr	r3, [fp, #-8]
}
1001b620:	e1a00003 	mov	r0, r3
1001b624:	e24bd004 	sub	sp, fp, #4
1001b628:	e8bd8800 	pop	{fp, pc}

1001b62c <finsh_parser_run>:

/*
start -> statement_expr | decl_variable
*/
void finsh_parser_run(struct finsh_parser* self, const u_char* string)
{
1001b62c:	e92d4800 	push	{fp, lr}
1001b630:	e28db004 	add	fp, sp, #4
1001b634:	e24dd010 	sub	sp, sp, #16
1001b638:	e50b0010 	str	r0, [fp, #-16]
1001b63c:	e50b1014 	str	r1, [fp, #-20]
	enum finsh_token_type token;
	struct finsh_node *node;

    node = NULL;
1001b640:	e3a03000 	mov	r3, #0
1001b644:	e50b300c 	str	r3, [fp, #-12]

	/* init parser */
	self->parser_string = (u_char*)string;
1001b648:	e51b3010 	ldr	r3, [fp, #-16]
1001b64c:	e51b2014 	ldr	r2, [fp, #-20]
1001b650:	e5832000 	str	r2, [r3]

	/* init token */
	finsh_token_init(&(self->token), self->parser_string);
1001b654:	e51b3010 	ldr	r3, [fp, #-16]
1001b658:	e2832004 	add	r2, r3, #4
1001b65c:	e51b3010 	ldr	r3, [fp, #-16]
1001b660:	e5933000 	ldr	r3, [r3]
1001b664:	e1a00002 	mov	r0, r2
1001b668:	e1a01003 	mov	r1, r3
1001b66c:	eb000259 	bl	1001bfd8 <finsh_token_init>

	/* get next token */
	next_token(token, &(self->token));
1001b670:	e51b3010 	ldr	r3, [fp, #-16]
1001b674:	e2833004 	add	r3, r3, #4
1001b678:	e1a00003 	mov	r0, r3
1001b67c:	eb000263 	bl	1001c010 <finsh_token_token>
1001b680:	e1a03000 	mov	r3, r0
1001b684:	e54b3005 	strb	r3, [fp, #-5]
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
1001b688:	ea00007a 	b	1001b878 <finsh_parser_run+0x24c>
	{
		switch (token)
1001b68c:	e55b3005 	ldrb	r3, [fp, #-5]
1001b690:	e353001f 	cmp	r3, #31
1001b694:	1a00001b 	bne	1001b708 <finsh_parser_run+0xdc>
		{
        case finsh_token_type_identifier:
            /* process expr_statement */
            finsh_token_replay(&(self->token));
1001b698:	e51b3010 	ldr	r3, [fp, #-16]
1001b69c:	e3a02001 	mov	r2, #1
1001b6a0:	e5c32005 	strb	r2, [r3, #5]

			if (self->root != NULL)
1001b6a4:	e51b3010 	ldr	r3, [fp, #-16]
1001b6a8:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1001b6ac:	e3530000 	cmp	r3, #0
1001b6b0:	0a00000c 	beq	1001b6e8 <finsh_parser_run+0xbc>
			{
				finsh_node_sibling(node) = proc_expr_statement(self);
1001b6b4:	e51b0010 	ldr	r0, [fp, #-16]
1001b6b8:	ebfffc8c 	bl	1001a8f0 <proc_expr_statement>
1001b6bc:	e1a02000 	mov	r2, r0
1001b6c0:	e51b300c 	ldr	r3, [fp, #-12]
1001b6c4:	e583200c 	str	r2, [r3, #12]
				if (finsh_node_sibling(node) != NULL)
1001b6c8:	e51b300c 	ldr	r3, [fp, #-12]
1001b6cc:	e593300c 	ldr	r3, [r3, #12]
1001b6d0:	e3530000 	cmp	r3, #0
1001b6d4:	0a00000a 	beq	1001b704 <finsh_parser_run+0xd8>
					node = finsh_node_sibling(node);
1001b6d8:	e51b300c 	ldr	r3, [fp, #-12]
1001b6dc:	e593300c 	ldr	r3, [r3, #12]
1001b6e0:	e50b300c 	str	r3, [fp, #-12]
			else
			{
            	node = proc_expr_statement(self);
				self->root = node;
			}
            break;
1001b6e4:	ea000058 	b	1001b84c <finsh_parser_run+0x220>
				if (finsh_node_sibling(node) != NULL)
					node = finsh_node_sibling(node);
			}
			else
			{
            	node = proc_expr_statement(self);
1001b6e8:	e51b0010 	ldr	r0, [fp, #-16]
1001b6ec:	ebfffc7f 	bl	1001a8f0 <proc_expr_statement>
1001b6f0:	e50b000c 	str	r0, [fp, #-12]
				self->root = node;
1001b6f4:	e51b3010 	ldr	r3, [fp, #-16]
1001b6f8:	e51b200c 	ldr	r2, [fp, #-12]
1001b6fc:	e5832098 	str	r2, [r3, #152]	; 0x98
			}
            break;
1001b700:	ea000051 	b	1001b84c <finsh_parser_run+0x220>
1001b704:	ea000050 	b	1001b84c <finsh_parser_run+0x220>

		default:
            if (is_base_type(token) || token == finsh_token_type_unsigned)
1001b708:	e55b3005 	ldrb	r3, [fp, #-5]
1001b70c:	e3530014 	cmp	r3, #20
1001b710:	0a00000e 	beq	1001b750 <finsh_parser_run+0x124>
1001b714:	e55b3005 	ldrb	r3, [fp, #-5]
1001b718:	e3530015 	cmp	r3, #21
1001b71c:	0a00000b 	beq	1001b750 <finsh_parser_run+0x124>
1001b720:	e55b3005 	ldrb	r3, [fp, #-5]
1001b724:	e3530016 	cmp	r3, #22
1001b728:	0a000008 	beq	1001b750 <finsh_parser_run+0x124>
1001b72c:	e55b3005 	ldrb	r3, [fp, #-5]
1001b730:	e3530017 	cmp	r3, #23
1001b734:	0a000005 	beq	1001b750 <finsh_parser_run+0x124>
1001b738:	e55b3005 	ldrb	r3, [fp, #-5]
1001b73c:	e3530018 	cmp	r3, #24
1001b740:	0a000002 	beq	1001b750 <finsh_parser_run+0x124>
1001b744:	e55b3005 	ldrb	r3, [fp, #-5]
1001b748:	e3530019 	cmp	r3, #25
1001b74c:	1a00001b 	bne	1001b7c0 <finsh_parser_run+0x194>
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));
1001b750:	e51b3010 	ldr	r3, [fp, #-16]
1001b754:	e3a02001 	mov	r2, #1
1001b758:	e5c32005 	strb	r2, [r3, #5]

				if (self->root != NULL)
1001b75c:	e51b3010 	ldr	r3, [fp, #-16]
1001b760:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1001b764:	e3530000 	cmp	r3, #0
1001b768:	0a00000c 	beq	1001b7a0 <finsh_parser_run+0x174>
				{
					finsh_node_sibling(node) = proc_variable_decl(self);
1001b76c:	e51b0010 	ldr	r0, [fp, #-16]
1001b770:	ebfffa83 	bl	1001a184 <proc_variable_decl>
1001b774:	e1a02000 	mov	r2, r0
1001b778:	e51b300c 	ldr	r3, [fp, #-12]
1001b77c:	e583200c 	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
1001b780:	e51b300c 	ldr	r3, [fp, #-12]
1001b784:	e593300c 	ldr	r3, [r3, #12]
1001b788:	e3530000 	cmp	r3, #0
1001b78c:	0a00000a 	beq	1001b7bc <finsh_parser_run+0x190>
						node = finsh_node_sibling(node);
1001b790:	e51b300c 	ldr	r3, [fp, #-12]
1001b794:	e593300c 	ldr	r3, [r3, #12]
1001b798:	e50b300c 	str	r3, [fp, #-12]
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
1001b79c:	ea000029 	b	1001b848 <finsh_parser_run+0x21c>
					if (finsh_node_sibling(node) != NULL)
						node = finsh_node_sibling(node);
				}
				else
				{
					node = proc_variable_decl(self);
1001b7a0:	e51b0010 	ldr	r0, [fp, #-16]
1001b7a4:	ebfffa76 	bl	1001a184 <proc_variable_decl>
1001b7a8:	e50b000c 	str	r0, [fp, #-12]
					self->root = node;
1001b7ac:	e51b3010 	ldr	r3, [fp, #-16]
1001b7b0:	e51b200c 	ldr	r2, [fp, #-12]
1001b7b4:	e5832098 	str	r2, [r3, #152]	; 0x98
            if (is_base_type(token) || token == finsh_token_type_unsigned)
            {
            	/* variable decl */
            	finsh_token_replay(&(self->token));

				if (self->root != NULL)
1001b7b8:	ea000022 	b	1001b848 <finsh_parser_run+0x21c>
1001b7bc:	ea000021 	b	1001b848 <finsh_parser_run+0x21c>
				}
            }
            else
            {
            	/* process expr_statement */
                finsh_token_replay(&(self->token));
1001b7c0:	e51b3010 	ldr	r3, [fp, #-16]
1001b7c4:	e3a02001 	mov	r2, #1
1001b7c8:	e5c32005 	strb	r2, [r3, #5]

				if (self->root != NULL)
1001b7cc:	e51b3010 	ldr	r3, [fp, #-16]
1001b7d0:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1001b7d4:	e3530000 	cmp	r3, #0
1001b7d8:	0a000013 	beq	1001b82c <finsh_parser_run+0x200>
				{
                    finsh_node_sibling(node) = proc_expr_statement(self);
1001b7dc:	e51b0010 	ldr	r0, [fp, #-16]
1001b7e0:	ebfffc42 	bl	1001a8f0 <proc_expr_statement>
1001b7e4:	e1a02000 	mov	r2, r0
1001b7e8:	e51b300c 	ldr	r3, [fp, #-12]
1001b7ec:	e583200c 	str	r2, [r3, #12]
					if (finsh_node_sibling(node) != NULL)
1001b7f0:	e51b300c 	ldr	r3, [fp, #-12]
1001b7f4:	e593300c 	ldr	r3, [r3, #12]
1001b7f8:	e3530000 	cmp	r3, #0
1001b7fc:	0a000003 	beq	1001b810 <finsh_parser_run+0x1e4>
						node = finsh_node_sibling(node);
1001b800:	e51b300c 	ldr	r3, [fp, #-12]
1001b804:	e593300c 	ldr	r3, [r3, #12]
1001b808:	e50b300c 	str	r3, [fp, #-12]
1001b80c:	ea00000d 	b	1001b848 <finsh_parser_run+0x21c>
					else next_token(token, &(self->token));
1001b810:	e51b3010 	ldr	r3, [fp, #-16]
1001b814:	e2833004 	add	r3, r3, #4
1001b818:	e1a00003 	mov	r0, r3
1001b81c:	eb0001fb 	bl	1001c010 <finsh_token_token>
1001b820:	e1a03000 	mov	r3, r0
1001b824:	e54b3005 	strb	r3, [fp, #-5]
					node = proc_expr_statement(self);
					self->root = node;
				}
            }

			break;
1001b828:	ea000006 	b	1001b848 <finsh_parser_run+0x21c>
						node = finsh_node_sibling(node);
					else next_token(token, &(self->token));
				}
				else
				{
					node = proc_expr_statement(self);
1001b82c:	e51b0010 	ldr	r0, [fp, #-16]
1001b830:	ebfffc2e 	bl	1001a8f0 <proc_expr_statement>
1001b834:	e50b000c 	str	r0, [fp, #-12]
					self->root = node;
1001b838:	e51b3010 	ldr	r3, [fp, #-16]
1001b83c:	e51b200c 	ldr	r2, [fp, #-12]
1001b840:	e5832098 	str	r2, [r3, #152]	; 0x98
				}
            }

			break;
1001b844:	eaffffff 	b	1001b848 <finsh_parser_run+0x21c>
1001b848:	e1a00000 	nop			; (mov r0, r0)
		}

		/* no root found, break out */
		if (self->root == NULL) break;
1001b84c:	e51b3010 	ldr	r3, [fp, #-16]
1001b850:	e5933098 	ldr	r3, [r3, #152]	; 0x98
1001b854:	e3530000 	cmp	r3, #0
1001b858:	1a000000 	bne	1001b860 <finsh_parser_run+0x234>
1001b85c:	ea00000b 	b	1001b890 <finsh_parser_run+0x264>

        /* get next token */
		next_token(token, &(self->token));
1001b860:	e51b3010 	ldr	r3, [fp, #-16]
1001b864:	e2833004 	add	r3, r3, #4
1001b868:	e1a00003 	mov	r0, r3
1001b86c:	eb0001e7 	bl	1001c010 <finsh_token_token>
1001b870:	e1a03000 	mov	r3, r0
1001b874:	e54b3005 	strb	r3, [fp, #-5]
	/* init token */
	finsh_token_init(&(self->token), self->parser_string);

	/* get next token */
	next_token(token, &(self->token));
	while (token != finsh_token_type_eof && token != finsh_token_type_bad)
1001b878:	e55b3005 	ldrb	r3, [fp, #-5]
1001b87c:	e3530021 	cmp	r3, #33	; 0x21
1001b880:	0a000002 	beq	1001b890 <finsh_parser_run+0x264>
1001b884:	e55b3005 	ldrb	r3, [fp, #-5]
1001b888:	e3530020 	cmp	r3, #32
1001b88c:	1affff7e 	bne	1001b68c <finsh_parser_run+0x60>
		if (self->root == NULL) break;

        /* get next token */
		next_token(token, &(self->token));
	}
}
1001b890:	e24bd004 	sub	sp, fp, #4
1001b894:	e8bd8800 	pop	{fp, pc}

1001b898 <finsh_parser_init>:

int finsh_parser_init(struct finsh_parser* self)
{
1001b898:	e92d4800 	push	{fp, lr}
1001b89c:	e28db004 	add	fp, sp, #4
1001b8a0:	e24dd008 	sub	sp, sp, #8
1001b8a4:	e50b0008 	str	r0, [fp, #-8]
	memset(self, 0, sizeof(struct finsh_parser));
1001b8a8:	e51b0008 	ldr	r0, [fp, #-8]
1001b8ac:	e3a01000 	mov	r1, #0
1001b8b0:	e3a0209c 	mov	r2, #156	; 0x9c
1001b8b4:	fa000808 	blx	1001d8dc <memset>

	return 0;
1001b8b8:	e3a03000 	mov	r3, #0
}
1001b8bc:	e1a00003 	mov	r0, r3
1001b8c0:	e24bd004 	sub	sp, fp, #4
1001b8c4:	e8bd8800 	pop	{fp, pc}

1001b8c8 <finsh_var_init>:

struct finsh_var global_variable[FINSH_VARIABLE_MAX];
struct finsh_sysvar_item* global_sysvar_list;

int finsh_var_init()
{
1001b8c8:	e92d4800 	push	{fp, lr}
1001b8cc:	e28db004 	add	fp, sp, #4
	memset(global_variable, 0, sizeof(global_variable));
1001b8d0:	e30a0828 	movw	r0, #43048	; 0xa828
1001b8d4:	e3410002 	movt	r0, #4098	; 0x1002
1001b8d8:	e3a01000 	mov	r1, #0
1001b8dc:	e3a020c0 	mov	r2, #192	; 0xc0
1001b8e0:	fa0007fd 	blx	1001d8dc <memset>

	return 0;
1001b8e4:	e3a03000 	mov	r3, #0
}
1001b8e8:	e1a00003 	mov	r0, r3
1001b8ec:	e8bd8800 	pop	{fp, pc}

1001b8f0 <finsh_var_insert>:

int finsh_var_insert(const char* name, int type)
{
1001b8f0:	e92d4800 	push	{fp, lr}
1001b8f4:	e28db004 	add	fp, sp, #4
1001b8f8:	e24dd010 	sub	sp, sp, #16
1001b8fc:	e50b0010 	str	r0, [fp, #-16]
1001b900:	e50b1014 	str	r1, [fp, #-20]
	int i, empty;

	empty = -1;
1001b904:	e3e03000 	mvn	r3, #0
1001b908:	e50b300c 	str	r3, [fp, #-12]
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1001b90c:	e3a03000 	mov	r3, #0
1001b910:	e50b3008 	str	r3, [fp, #-8]
1001b914:	ea000026 	b	1001b9b4 <finsh_var_insert+0xc4>
	{
		/* there is a same name variable exist. */
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
1001b918:	e51b3008 	ldr	r3, [fp, #-8]
1001b91c:	e1a02003 	mov	r2, r3
1001b920:	e1a03182 	lsl	r3, r2, #3
1001b924:	e1a02003 	mov	r2, r3
1001b928:	e1a03102 	lsl	r3, r2, #2
1001b92c:	e0623003 	rsb	r3, r2, r3
1001b930:	e30a2828 	movw	r2, #43048	; 0xa828
1001b934:	e3412002 	movt	r2, #4098	; 0x1002
1001b938:	e0833002 	add	r3, r3, r2
1001b93c:	e1a00003 	mov	r0, r3
1001b940:	e51b1010 	ldr	r1, [fp, #-16]
1001b944:	e3a02010 	mov	r2, #16
1001b948:	fa0008df 	blx	1001dccc <strncmp>
1001b94c:	e1a03000 	mov	r3, r0
1001b950:	e3530000 	cmp	r3, #0
1001b954:	1a000001 	bne	1001b960 <finsh_var_insert+0x70>
			return -1;
1001b958:	e3e03000 	mvn	r3, #0
1001b95c:	ea000038 	b	1001ba44 <finsh_var_insert+0x154>

		if (global_variable[i].type == finsh_type_unknown && empty == -1)
1001b960:	e30a2828 	movw	r2, #43048	; 0xa828
1001b964:	e3412002 	movt	r2, #4098	; 0x1002
1001b968:	e51b3008 	ldr	r3, [fp, #-8]
1001b96c:	e1a01003 	mov	r1, r3
1001b970:	e1a03181 	lsl	r3, r1, #3
1001b974:	e1a01003 	mov	r1, r3
1001b978:	e1a03101 	lsl	r3, r1, #2
1001b97c:	e0613003 	rsb	r3, r1, r3
1001b980:	e0823003 	add	r3, r2, r3
1001b984:	e2833010 	add	r3, r3, #16
1001b988:	e5d33001 	ldrb	r3, [r3, #1]
1001b98c:	e3530000 	cmp	r3, #0
1001b990:	1a000004 	bne	1001b9a8 <finsh_var_insert+0xb8>
1001b994:	e51b300c 	ldr	r3, [fp, #-12]
1001b998:	e3730001 	cmn	r3, #1
1001b99c:	1a000001 	bne	1001b9a8 <finsh_var_insert+0xb8>
		{
			empty = i;
1001b9a0:	e51b3008 	ldr	r3, [fp, #-8]
1001b9a4:	e50b300c 	str	r3, [fp, #-12]
int finsh_var_insert(const char* name, int type)
{
	int i, empty;

	empty = -1;
	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1001b9a8:	e51b3008 	ldr	r3, [fp, #-8]
1001b9ac:	e2833001 	add	r3, r3, #1
1001b9b0:	e50b3008 	str	r3, [fp, #-8]
1001b9b4:	e51b3008 	ldr	r3, [fp, #-8]
1001b9b8:	e3530007 	cmp	r3, #7
1001b9bc:	daffffd5 	ble	1001b918 <finsh_var_insert+0x28>
			empty = i;
		}
	}

	/* there is no empty entry */
	if (empty == -1) return -1;
1001b9c0:	e51b300c 	ldr	r3, [fp, #-12]
1001b9c4:	e3730001 	cmn	r3, #1
1001b9c8:	1a000001 	bne	1001b9d4 <finsh_var_insert+0xe4>
1001b9cc:	e3e03000 	mvn	r3, #0
1001b9d0:	ea00001b 	b	1001ba44 <finsh_var_insert+0x154>

	/* insert entry */
	strncpy(global_variable[empty].name, name, FINSH_NAME_MAX);
1001b9d4:	e51b300c 	ldr	r3, [fp, #-12]
1001b9d8:	e1a02003 	mov	r2, r3
1001b9dc:	e1a03182 	lsl	r3, r2, #3
1001b9e0:	e1a02003 	mov	r2, r3
1001b9e4:	e1a03102 	lsl	r3, r2, #2
1001b9e8:	e0623003 	rsb	r3, r2, r3
1001b9ec:	e30a2828 	movw	r2, #43048	; 0xa828
1001b9f0:	e3412002 	movt	r2, #4098	; 0x1002
1001b9f4:	e0833002 	add	r3, r3, r2
1001b9f8:	e1a00003 	mov	r0, r3
1001b9fc:	e51b1010 	ldr	r1, [fp, #-16]
1001ba00:	e3a02010 	mov	r2, #16
1001ba04:	fa0008d6 	blx	1001dd64 <strncpy>
	global_variable[empty].type = type;
1001ba08:	e51b3014 	ldr	r3, [fp, #-20]
1001ba0c:	e6ef0073 	uxtb	r0, r3
1001ba10:	e30a2828 	movw	r2, #43048	; 0xa828
1001ba14:	e3412002 	movt	r2, #4098	; 0x1002
1001ba18:	e51b300c 	ldr	r3, [fp, #-12]
1001ba1c:	e1a01003 	mov	r1, r3
1001ba20:	e1a03181 	lsl	r3, r1, #3
1001ba24:	e1a01003 	mov	r1, r3
1001ba28:	e1a03101 	lsl	r3, r1, #2
1001ba2c:	e0613003 	rsb	r3, r1, r3
1001ba30:	e0823003 	add	r3, r2, r3
1001ba34:	e2833010 	add	r3, r3, #16
1001ba38:	e1a02000 	mov	r2, r0
1001ba3c:	e5c32001 	strb	r2, [r3, #1]

	/* return the offset */
	return empty;
1001ba40:	e51b300c 	ldr	r3, [fp, #-12]
}
1001ba44:	e1a00003 	mov	r0, r3
1001ba48:	e24bd004 	sub	sp, fp, #4
1001ba4c:	e8bd8800 	pop	{fp, pc}

1001ba50 <finsh_var_delete>:

int finsh_var_delete(const char* name)
{
1001ba50:	e92d4800 	push	{fp, lr}
1001ba54:	e28db004 	add	fp, sp, #4
1001ba58:	e24dd010 	sub	sp, sp, #16
1001ba5c:	e50b0010 	str	r0, [fp, #-16]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1001ba60:	e3a03000 	mov	r3, #0
1001ba64:	e50b3008 	str	r3, [fp, #-8]
1001ba68:	ea000013 	b	1001babc <finsh_var_delete+0x6c>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
1001ba6c:	e51b3008 	ldr	r3, [fp, #-8]
1001ba70:	e1a02003 	mov	r2, r3
1001ba74:	e1a03182 	lsl	r3, r2, #3
1001ba78:	e1a02003 	mov	r2, r3
1001ba7c:	e1a03102 	lsl	r3, r2, #2
1001ba80:	e0623003 	rsb	r3, r2, r3
1001ba84:	e30a2828 	movw	r2, #43048	; 0xa828
1001ba88:	e3412002 	movt	r2, #4098	; 0x1002
1001ba8c:	e0833002 	add	r3, r3, r2
1001ba90:	e1a00003 	mov	r0, r3
1001ba94:	e51b1010 	ldr	r1, [fp, #-16]
1001ba98:	e3a02010 	mov	r2, #16
1001ba9c:	fa00088a 	blx	1001dccc <strncmp>
1001baa0:	e1a03000 	mov	r3, r0
1001baa4:	e3530000 	cmp	r3, #0
1001baa8:	1a000000 	bne	1001bab0 <finsh_var_delete+0x60>
			break;
1001baac:	ea000005 	b	1001bac8 <finsh_var_delete+0x78>

int finsh_var_delete(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1001bab0:	e51b3008 	ldr	r3, [fp, #-8]
1001bab4:	e2833001 	add	r3, r3, #1
1001bab8:	e50b3008 	str	r3, [fp, #-8]
1001babc:	e51b3008 	ldr	r3, [fp, #-8]
1001bac0:	e3530007 	cmp	r3, #7
1001bac4:	daffffe8 	ble	1001ba6c <finsh_var_delete+0x1c>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return -1;
1001bac8:	e51b3008 	ldr	r3, [fp, #-8]
1001bacc:	e3530008 	cmp	r3, #8
1001bad0:	1a000001 	bne	1001badc <finsh_var_delete+0x8c>
1001bad4:	e3e03000 	mvn	r3, #0
1001bad8:	ea00000d 	b	1001bb14 <finsh_var_delete+0xc4>

	memset(&global_variable[i], 0, sizeof(struct finsh_var));
1001badc:	e51b3008 	ldr	r3, [fp, #-8]
1001bae0:	e1a02003 	mov	r2, r3
1001bae4:	e1a03182 	lsl	r3, r2, #3
1001bae8:	e1a02003 	mov	r2, r3
1001baec:	e1a03102 	lsl	r3, r2, #2
1001baf0:	e0623003 	rsb	r3, r2, r3
1001baf4:	e30a2828 	movw	r2, #43048	; 0xa828
1001baf8:	e3412002 	movt	r2, #4098	; 0x1002
1001bafc:	e0833002 	add	r3, r3, r2
1001bb00:	e1a00003 	mov	r0, r3
1001bb04:	e3a01000 	mov	r1, #0
1001bb08:	e3a02018 	mov	r2, #24
1001bb0c:	fa000772 	blx	1001d8dc <memset>

	return 0;
1001bb10:	e3a03000 	mov	r3, #0
}
1001bb14:	e1a00003 	mov	r0, r3
1001bb18:	e24bd004 	sub	sp, fp, #4
1001bb1c:	e8bd8800 	pop	{fp, pc}

1001bb20 <finsh_var_lookup>:

struct finsh_var* finsh_var_lookup(const char* name)
{
1001bb20:	e92d4800 	push	{fp, lr}
1001bb24:	e28db004 	add	fp, sp, #4
1001bb28:	e24dd010 	sub	sp, sp, #16
1001bb2c:	e50b0010 	str	r0, [fp, #-16]
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1001bb30:	e3a03000 	mov	r3, #0
1001bb34:	e50b3008 	str	r3, [fp, #-8]
1001bb38:	ea000013 	b	1001bb8c <finsh_var_lookup+0x6c>
	{
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
1001bb3c:	e51b3008 	ldr	r3, [fp, #-8]
1001bb40:	e1a02003 	mov	r2, r3
1001bb44:	e1a03182 	lsl	r3, r2, #3
1001bb48:	e1a02003 	mov	r2, r3
1001bb4c:	e1a03102 	lsl	r3, r2, #2
1001bb50:	e0623003 	rsb	r3, r2, r3
1001bb54:	e30a2828 	movw	r2, #43048	; 0xa828
1001bb58:	e3412002 	movt	r2, #4098	; 0x1002
1001bb5c:	e0833002 	add	r3, r3, r2
1001bb60:	e1a00003 	mov	r0, r3
1001bb64:	e51b1010 	ldr	r1, [fp, #-16]
1001bb68:	e3a02010 	mov	r2, #16
1001bb6c:	fa000856 	blx	1001dccc <strncmp>
1001bb70:	e1a03000 	mov	r3, r0
1001bb74:	e3530000 	cmp	r3, #0
1001bb78:	1a000000 	bne	1001bb80 <finsh_var_lookup+0x60>
			break;
1001bb7c:	ea000005 	b	1001bb98 <finsh_var_lookup+0x78>

struct finsh_var* finsh_var_lookup(const char* name)
{
	int i;

	for (i = 0; i < FINSH_VARIABLE_MAX; i ++)
1001bb80:	e51b3008 	ldr	r3, [fp, #-8]
1001bb84:	e2833001 	add	r3, r3, #1
1001bb88:	e50b3008 	str	r3, [fp, #-8]
1001bb8c:	e51b3008 	ldr	r3, [fp, #-8]
1001bb90:	e3530007 	cmp	r3, #7
1001bb94:	daffffe8 	ble	1001bb3c <finsh_var_lookup+0x1c>
		if (strncmp(global_variable[i].name, name, FINSH_NAME_MAX) == 0)
			break;
	}

	/* can't find variable */
	if (i == FINSH_VARIABLE_MAX) return NULL;
1001bb98:	e51b3008 	ldr	r3, [fp, #-8]
1001bb9c:	e3530008 	cmp	r3, #8
1001bba0:	1a000001 	bne	1001bbac <finsh_var_lookup+0x8c>
1001bba4:	e3a03000 	mov	r3, #0
1001bba8:	ea000008 	b	1001bbd0 <finsh_var_lookup+0xb0>

	return &global_variable[i];
1001bbac:	e51b3008 	ldr	r3, [fp, #-8]
1001bbb0:	e1a02003 	mov	r2, r3
1001bbb4:	e1a03182 	lsl	r3, r2, #3
1001bbb8:	e1a02003 	mov	r2, r3
1001bbbc:	e1a03102 	lsl	r3, r2, #2
1001bbc0:	e0623003 	rsb	r3, r2, r3
1001bbc4:	e30a2828 	movw	r2, #43048	; 0xa828
1001bbc8:	e3412002 	movt	r2, #4098	; 0x1002
1001bbcc:	e0833002 	add	r3, r3, r2
}
1001bbd0:	e1a00003 	mov	r0, r3
1001bbd4:	e24bd004 	sub	sp, fp, #4
1001bbd8:	e8bd8800 	pop	{fp, pc}

1001bbdc <finsh_sysvar_append>:

#ifdef RT_USING_HEAP
void finsh_sysvar_append(const char* name, u_char type, void* var_addr)
{
1001bbdc:	e92d4800 	push	{fp, lr}
1001bbe0:	e28db004 	add	fp, sp, #4
1001bbe4:	e24dd018 	sub	sp, sp, #24
1001bbe8:	e50b0010 	str	r0, [fp, #-16]
1001bbec:	e1a03001 	mov	r3, r1
1001bbf0:	e50b2018 	str	r2, [fp, #-24]
1001bbf4:	e54b3011 	strb	r3, [fp, #-17]
	/* create a sysvar */
	struct finsh_sysvar_item* item;

	item = (struct finsh_sysvar_item*) rt_malloc (sizeof(struct finsh_sysvar_item));
1001bbf8:	e3a00014 	mov	r0, #20
1001bbfc:	ebffaba9 	bl	10006aa8 <rt_malloc>
1001bc00:	e50b0008 	str	r0, [fp, #-8]
	if (item != NULL)
1001bc04:	e51b3008 	ldr	r3, [fp, #-8]
1001bc08:	e3530000 	cmp	r3, #0
1001bc0c:	0a000020 	beq	1001bc94 <finsh_sysvar_append+0xb8>
	{
		item->next = NULL;
1001bc10:	e51b3008 	ldr	r3, [fp, #-8]
1001bc14:	e3a02000 	mov	r2, #0
1001bc18:	e5832000 	str	r2, [r3]
		item->sysvar.name = rt_strdup(name);
1001bc1c:	e51b0010 	ldr	r0, [fp, #-16]
1001bc20:	ebffa5c6 	bl	10005340 <rt_strdup>
1001bc24:	e1a02000 	mov	r2, r0
1001bc28:	e51b3008 	ldr	r3, [fp, #-8]
1001bc2c:	e5832004 	str	r2, [r3, #4]
		item->sysvar.type = type;
1001bc30:	e51b3008 	ldr	r3, [fp, #-8]
1001bc34:	e55b2011 	ldrb	r2, [fp, #-17]
1001bc38:	e5c3200c 	strb	r2, [r3, #12]
		item->sysvar.var = var_addr;
1001bc3c:	e51b3008 	ldr	r3, [fp, #-8]
1001bc40:	e51b2018 	ldr	r2, [fp, #-24]
1001bc44:	e5832010 	str	r2, [r3, #16]

		if (global_sysvar_list == NULL)
1001bc48:	e30a3824 	movw	r3, #43044	; 0xa824
1001bc4c:	e3413002 	movt	r3, #4098	; 0x1002
1001bc50:	e5933000 	ldr	r3, [r3]
1001bc54:	e3530000 	cmp	r3, #0
1001bc58:	1a000004 	bne	1001bc70 <finsh_sysvar_append+0x94>
		{
			global_sysvar_list = item;
1001bc5c:	e30a3824 	movw	r3, #43044	; 0xa824
1001bc60:	e3413002 	movt	r3, #4098	; 0x1002
1001bc64:	e51b2008 	ldr	r2, [fp, #-8]
1001bc68:	e5832000 	str	r2, [r3]
1001bc6c:	ea000008 	b	1001bc94 <finsh_sysvar_append+0xb8>
		}
		else
		{
			item->next = global_sysvar_list;
1001bc70:	e30a3824 	movw	r3, #43044	; 0xa824
1001bc74:	e3413002 	movt	r3, #4098	; 0x1002
1001bc78:	e5932000 	ldr	r2, [r3]
1001bc7c:	e51b3008 	ldr	r3, [fp, #-8]
1001bc80:	e5832000 	str	r2, [r3]
			global_sysvar_list = item;
1001bc84:	e30a3824 	movw	r3, #43044	; 0xa824
1001bc88:	e3413002 	movt	r3, #4098	; 0x1002
1001bc8c:	e51b2008 	ldr	r2, [fp, #-8]
1001bc90:	e5832000 	str	r2, [r3]
		}
	}
}
1001bc94:	e24bd004 	sub	sp, fp, #4
1001bc98:	e8bd8800 	pop	{fp, pc}

1001bc9c <finsh_sysvar_lookup>:
#endif

struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
1001bc9c:	e92d4810 	push	{r4, fp, lr}
1001bca0:	e28db008 	add	fp, sp, #8
1001bca4:	e24dd014 	sub	sp, sp, #20
1001bca8:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
1001bcac:	e3093d60 	movw	r3, #40288	; 0x9d60
1001bcb0:	e3413002 	movt	r3, #4098	; 0x1002
1001bcb4:	e5933000 	ldr	r3, [r3]
1001bcb8:	e50b3010 	str	r3, [fp, #-16]
1001bcbc:	ea00000c 	b	1001bcf4 <finsh_sysvar_lookup+0x58>
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
	{
		if (strcmp(index->name, name) == 0)
1001bcc0:	e51b3010 	ldr	r3, [fp, #-16]
1001bcc4:	e5933000 	ldr	r3, [r3]
1001bcc8:	e1a00003 	mov	r0, r3
1001bccc:	e51b1018 	ldr	r1, [fp, #-24]
1001bcd0:	fa00051a 	blx	1001d140 <strcmp>
1001bcd4:	e1a03000 	mov	r3, r0
1001bcd8:	e3530000 	cmp	r3, #0
1001bcdc:	1a000001 	bne	1001bce8 <finsh_sysvar_lookup+0x4c>
			return index;
1001bce0:	e51b3010 	ldr	r3, [fp, #-16]
1001bce4:	ea000023 	b	1001bd78 <finsh_sysvar_lookup+0xdc>
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
	     FINSH_NEXT_SYSVAR(index))
1001bce8:	e51b3010 	ldr	r3, [fp, #-16]
1001bcec:	e2833010 	add	r3, r3, #16
1001bcf0:	e50b3010 	str	r3, [fp, #-16]
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
	     index < _sysvar_table_end;
1001bcf4:	e3093d64 	movw	r3, #40292	; 0x9d64
1001bcf8:	e3413002 	movt	r3, #4098	; 0x1002
1001bcfc:	e5933000 	ldr	r3, [r3]
struct finsh_sysvar* finsh_sysvar_lookup(const char* name)
{
	struct finsh_sysvar* index;
	struct finsh_sysvar_item* item;

	for (index = _sysvar_table_begin;
1001bd00:	e51b2010 	ldr	r2, [fp, #-16]
1001bd04:	e1520003 	cmp	r2, r3
1001bd08:	3affffec 	bcc	1001bcc0 <finsh_sysvar_lookup+0x24>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
1001bd0c:	e30a3824 	movw	r3, #43044	; 0xa824
1001bd10:	e3413002 	movt	r3, #4098	; 0x1002
1001bd14:	e5933000 	ldr	r3, [r3]
1001bd18:	e50b3014 	str	r3, [fp, #-20]
	while (item != NULL)
1001bd1c:	ea000011 	b	1001bd68 <finsh_sysvar_lookup+0xcc>
	{
		if (strncmp(item->sysvar.name, name, strlen(name)) == 0)
1001bd20:	e51b3014 	ldr	r3, [fp, #-20]
1001bd24:	e5934004 	ldr	r4, [r3, #4]
1001bd28:	e51b0018 	ldr	r0, [fp, #-24]
1001bd2c:	fa0007cf 	blx	1001dc70 <strlen>
1001bd30:	e1a03000 	mov	r3, r0
1001bd34:	e1a00004 	mov	r0, r4
1001bd38:	e51b1018 	ldr	r1, [fp, #-24]
1001bd3c:	e1a02003 	mov	r2, r3
1001bd40:	fa0007e1 	blx	1001dccc <strncmp>
1001bd44:	e1a03000 	mov	r3, r0
1001bd48:	e3530000 	cmp	r3, #0
1001bd4c:	1a000002 	bne	1001bd5c <finsh_sysvar_lookup+0xc0>
		{
			return &(item->sysvar);
1001bd50:	e51b3014 	ldr	r3, [fp, #-20]
1001bd54:	e2833004 	add	r3, r3, #4
1001bd58:	ea000006 	b	1001bd78 <finsh_sysvar_lookup+0xdc>
		}

		/* move to next item */
		item = item->next;
1001bd5c:	e51b3014 	ldr	r3, [fp, #-20]
1001bd60:	e5933000 	ldr	r3, [r3]
1001bd64:	e50b3014 	str	r3, [fp, #-20]
			return index;
	}

	/* find in sysvar list */
	item = global_sysvar_list;
	while (item != NULL)
1001bd68:	e51b3014 	ldr	r3, [fp, #-20]
1001bd6c:	e3530000 	cmp	r3, #0
1001bd70:	1affffea 	bne	1001bd20 <finsh_sysvar_lookup+0x84>
		/* move to next item */
		item = item->next;
	}

	/* can't find variable */
	return NULL;
1001bd74:	e3a03000 	mov	r3, #0
}
1001bd78:	e1a00003 	mov	r0, r3
1001bd7c:	e24bd008 	sub	sp, fp, #8
1001bd80:	e8bd8810 	pop	{r4, fp, pc}

1001bd84 <finsh_vm_run>:
/* syscall list, for dynamic system call register */
struct finsh_syscall_item* global_syscall_list = NULL;

// #define FINSH_VM_DISASSEMBLE
void finsh_vm_run()
{
1001bd84:	e92d4800 	push	{fp, lr}
1001bd88:	e28db004 	add	fp, sp, #4
1001bd8c:	e24dd008 	sub	sp, sp, #8
	void finsh_disassemble();
	finsh_disassemble();
#endif

	/* set sp(stack pointer) to the beginning of stack */
	finsh_sp = &finsh_vm_stack[0];
1001bd90:	e30a3a6c 	movw	r3, #43628	; 0xaa6c
1001bd94:	e3413002 	movt	r3, #4098	; 0x1002
1001bd98:	e30a2968 	movw	r2, #43368	; 0xa968
1001bd9c:	e3412002 	movt	r2, #4098	; 0x1002
1001bda0:	e5832000 	str	r2, [r3]

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];
1001bda4:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001bda8:	e3413002 	movt	r3, #4098	; 0x1002
1001bdac:	e30a28e8 	movw	r2, #43240	; 0xa8e8
1001bdb0:	e3412002 	movt	r2, #4098	; 0x1002
1001bdb4:	e5832000 	str	r2, [r3]

	while ((finsh_pc - &text_segment[0] >= 0) &&
1001bdb8:	ea00000d 	b	1001bdf4 <finsh_vm_run+0x70>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
	{
		/* get op */
		op = *finsh_pc++;
1001bdbc:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001bdc0:	e3413002 	movt	r3, #4098	; 0x1002
1001bdc4:	e5932000 	ldr	r2, [r3]
1001bdc8:	e2821001 	add	r1, r2, #1
1001bdcc:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001bdd0:	e3413002 	movt	r3, #4098	; 0x1002
1001bdd4:	e5831000 	str	r1, [r3]
1001bdd8:	e5d23000 	ldrb	r3, [r2]
1001bddc:	e54b3005 	strb	r3, [fp, #-5]

		/* call op function */
		op_table[op]();
1001bde0:	e55b2005 	ldrb	r2, [fp, #-5]
1001bde4:	e3003294 	movw	r3, #660	; 0x294
1001bde8:	e3413002 	movt	r3, #4098	; 0x1002
1001bdec:	e7933102 	ldr	r3, [r3, r2, lsl #2]
1001bdf0:	e12fff33 	blx	r3
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
1001bdf4:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001bdf8:	e3413002 	movt	r3, #4098	; 0x1002
1001bdfc:	e5933000 	ldr	r3, [r3]
1001be00:	e1a02003 	mov	r2, r3
1001be04:	e30a38e8 	movw	r3, #43240	; 0xa8e8
1001be08:	e3413002 	movt	r3, #4098	; 0x1002
1001be0c:	e0633002 	rsb	r3, r3, r2
1001be10:	e3530000 	cmp	r3, #0
1001be14:	ba000008 	blt	1001be3c <finsh_vm_run+0xb8>
		(finsh_pc - &text_segment[0] < FINSH_TEXT_MAX))
1001be18:	e30a3a68 	movw	r3, #43624	; 0xaa68
1001be1c:	e3413002 	movt	r3, #4098	; 0x1002
1001be20:	e5933000 	ldr	r3, [r3]
1001be24:	e1a02003 	mov	r2, r3
1001be28:	e30a38e8 	movw	r3, #43240	; 0xa8e8
1001be2c:	e3413002 	movt	r3, #4098	; 0x1002
1001be30:	e0633002 	rsb	r3, r3, r2
	finsh_sp = &finsh_vm_stack[0];

	/* set pc to the beginning of text segment */
	finsh_pc = &text_segment[0];

	while ((finsh_pc - &text_segment[0] >= 0) &&
1001be34:	e353007f 	cmp	r3, #127	; 0x7f
1001be38:	daffffdf 	ble	1001bdbc <finsh_vm_run+0x38>
		op = *finsh_pc++;

		/* call op function */
		op_table[op]();
	}
}
1001be3c:	e24bd004 	sub	sp, fp, #4
1001be40:	e8bd8800 	pop	{fp, pc}

1001be44 <finsh_syscall_append>:

#ifdef RT_USING_HEAP
void finsh_syscall_append(const char* name, syscall_func func)
{
1001be44:	e92d4800 	push	{fp, lr}
1001be48:	e28db004 	add	fp, sp, #4
1001be4c:	e24dd010 	sub	sp, sp, #16
1001be50:	e50b0010 	str	r0, [fp, #-16]
1001be54:	e50b1014 	str	r1, [fp, #-20]
	/* create the syscall */
	struct finsh_syscall_item* item;

	item = (struct finsh_syscall_item*)rt_malloc(sizeof(struct finsh_syscall_item));
1001be58:	e3a00010 	mov	r0, #16
1001be5c:	ebffab11 	bl	10006aa8 <rt_malloc>
1001be60:	e50b0008 	str	r0, [fp, #-8]
	if (item != RT_NULL)
1001be64:	e51b3008 	ldr	r3, [fp, #-8]
1001be68:	e3530000 	cmp	r3, #0
1001be6c:	0a00001d 	beq	1001bee8 <finsh_syscall_append+0xa4>
	{
		item->next = NULL;
1001be70:	e51b3008 	ldr	r3, [fp, #-8]
1001be74:	e3a02000 	mov	r2, #0
1001be78:	e5832000 	str	r2, [r3]
		item->syscall.name = rt_strdup(name);
1001be7c:	e51b0010 	ldr	r0, [fp, #-16]
1001be80:	ebffa52e 	bl	10005340 <rt_strdup>
1001be84:	e1a02000 	mov	r2, r0
1001be88:	e51b3008 	ldr	r3, [fp, #-8]
1001be8c:	e5832004 	str	r2, [r3, #4]
		item->syscall.func = func;
1001be90:	e51b3008 	ldr	r3, [fp, #-8]
1001be94:	e51b2014 	ldr	r2, [fp, #-20]
1001be98:	e583200c 	str	r2, [r3, #12]

		if (global_syscall_list == NULL)
1001be9c:	e3093d74 	movw	r3, #40308	; 0x9d74
1001bea0:	e3413002 	movt	r3, #4098	; 0x1002
1001bea4:	e5933000 	ldr	r3, [r3]
1001bea8:	e3530000 	cmp	r3, #0
1001beac:	1a000004 	bne	1001bec4 <finsh_syscall_append+0x80>
		{
			global_syscall_list = item;
1001beb0:	e3093d74 	movw	r3, #40308	; 0x9d74
1001beb4:	e3413002 	movt	r3, #4098	; 0x1002
1001beb8:	e51b2008 	ldr	r2, [fp, #-8]
1001bebc:	e5832000 	str	r2, [r3]
1001bec0:	ea000008 	b	1001bee8 <finsh_syscall_append+0xa4>
		}
		else
		{
			item->next = global_syscall_list;
1001bec4:	e3093d74 	movw	r3, #40308	; 0x9d74
1001bec8:	e3413002 	movt	r3, #4098	; 0x1002
1001becc:	e5932000 	ldr	r2, [r3]
1001bed0:	e51b3008 	ldr	r3, [fp, #-8]
1001bed4:	e5832000 	str	r2, [r3]
			global_syscall_list = item;
1001bed8:	e3093d74 	movw	r3, #40308	; 0x9d74
1001bedc:	e3413002 	movt	r3, #4098	; 0x1002
1001bee0:	e51b2008 	ldr	r2, [fp, #-8]
1001bee4:	e5832000 	str	r2, [r3]
		}
	}
}
1001bee8:	e24bd004 	sub	sp, fp, #4
1001beec:	e8bd8800 	pop	{fp, pc}

1001bef0 <finsh_syscall_lookup>:
	return (struct finsh_sysvar*)ptr;
}
#endif

struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
1001bef0:	e92d4810 	push	{r4, fp, lr}
1001bef4:	e28db008 	add	fp, sp, #8
1001bef8:	e24dd014 	sub	sp, sp, #20
1001befc:	e50b0018 	str	r0, [fp, #-24]
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
1001bf00:	e3093d58 	movw	r3, #40280	; 0x9d58
1001bf04:	e3413002 	movt	r3, #4098	; 0x1002
1001bf08:	e5933000 	ldr	r3, [r3]
1001bf0c:	e50b3010 	str	r3, [fp, #-16]
1001bf10:	ea00000c 	b	1001bf48 <finsh_syscall_lookup+0x58>
	{
		if (strcmp(index->name, name) == 0)
1001bf14:	e51b3010 	ldr	r3, [fp, #-16]
1001bf18:	e5933000 	ldr	r3, [r3]
1001bf1c:	e1a00003 	mov	r0, r3
1001bf20:	e51b1018 	ldr	r1, [fp, #-24]
1001bf24:	fa000485 	blx	1001d140 <strcmp>
1001bf28:	e1a03000 	mov	r3, r0
1001bf2c:	e3530000 	cmp	r3, #0
1001bf30:	1a000001 	bne	1001bf3c <finsh_syscall_lookup+0x4c>
			return index;
1001bf34:	e51b3010 	ldr	r3, [fp, #-16]
1001bf38:	ea000023 	b	1001bfcc <finsh_syscall_lookup+0xdc>
struct finsh_syscall* finsh_syscall_lookup(const char* name)
{
	struct finsh_syscall* index;
	struct finsh_syscall_item* item;

	for (index = _syscall_table_begin; index < _syscall_table_end; FINSH_NEXT_SYSCALL(index))
1001bf3c:	e51b3010 	ldr	r3, [fp, #-16]
1001bf40:	e283300c 	add	r3, r3, #12
1001bf44:	e50b3010 	str	r3, [fp, #-16]
1001bf48:	e3093d5c 	movw	r3, #40284	; 0x9d5c
1001bf4c:	e3413002 	movt	r3, #4098	; 0x1002
1001bf50:	e5933000 	ldr	r3, [r3]
1001bf54:	e51b2010 	ldr	r2, [fp, #-16]
1001bf58:	e1520003 	cmp	r2, r3
1001bf5c:	3affffec 	bcc	1001bf14 <finsh_syscall_lookup+0x24>
		if (strcmp(index->name, name) == 0)
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
1001bf60:	e3093d74 	movw	r3, #40308	; 0x9d74
1001bf64:	e3413002 	movt	r3, #4098	; 0x1002
1001bf68:	e5933000 	ldr	r3, [r3]
1001bf6c:	e50b3014 	str	r3, [fp, #-20]
	while (item != NULL)
1001bf70:	ea000011 	b	1001bfbc <finsh_syscall_lookup+0xcc>
	{
		if (strncmp(item->syscall.name, name, strlen(name)) == 0)
1001bf74:	e51b3014 	ldr	r3, [fp, #-20]
1001bf78:	e5934004 	ldr	r4, [r3, #4]
1001bf7c:	e51b0018 	ldr	r0, [fp, #-24]
1001bf80:	fa00073a 	blx	1001dc70 <strlen>
1001bf84:	e1a03000 	mov	r3, r0
1001bf88:	e1a00004 	mov	r0, r4
1001bf8c:	e51b1018 	ldr	r1, [fp, #-24]
1001bf90:	e1a02003 	mov	r2, r3
1001bf94:	fa00074c 	blx	1001dccc <strncmp>
1001bf98:	e1a03000 	mov	r3, r0
1001bf9c:	e3530000 	cmp	r3, #0
1001bfa0:	1a000002 	bne	1001bfb0 <finsh_syscall_lookup+0xc0>
		{
			return &(item->syscall);
1001bfa4:	e51b3014 	ldr	r3, [fp, #-20]
1001bfa8:	e2833004 	add	r3, r3, #4
1001bfac:	ea000006 	b	1001bfcc <finsh_syscall_lookup+0xdc>
		}

		item = item->next;
1001bfb0:	e51b3014 	ldr	r3, [fp, #-20]
1001bfb4:	e5933000 	ldr	r3, [r3]
1001bfb8:	e50b3014 	str	r3, [fp, #-20]
			return index;
	}

	/* find on syscall list */
	item = global_syscall_list;
	while (item != NULL)
1001bfbc:	e51b3014 	ldr	r3, [fp, #-20]
1001bfc0:	e3530000 	cmp	r3, #0
1001bfc4:	1affffea 	bne	1001bf74 <finsh_syscall_lookup+0x84>
		}

		item = item->next;
	}

	return NULL;
1001bfc8:	e3a03000 	mov	r3, #0
}
1001bfcc:	e1a00003 	mov	r0, r3
1001bfd0:	e24bd008 	sub	sp, fp, #8
1001bfd4:	e8bd8810 	pop	{r4, fp, pc}

1001bfd8 <finsh_token_init>:
static void token_trim_space(struct finsh_token* self);
static char token_proc_char(struct finsh_token* self);
static int token_proc_escape(struct finsh_token* self);

void finsh_token_init(struct finsh_token* self, u_char* line)
{
1001bfd8:	e92d4800 	push	{fp, lr}
1001bfdc:	e28db004 	add	fp, sp, #4
1001bfe0:	e24dd008 	sub	sp, sp, #8
1001bfe4:	e50b0008 	str	r0, [fp, #-8]
1001bfe8:	e50b100c 	str	r1, [fp, #-12]
	memset(self, 0, sizeof(struct finsh_token));
1001bfec:	e51b0008 	ldr	r0, [fp, #-8]
1001bff0:	e3a01000 	mov	r1, #0
1001bff4:	e3a02094 	mov	r2, #148	; 0x94
1001bff8:	fa000637 	blx	1001d8dc <memset>

	self->line = line;
1001bffc:	e51b3008 	ldr	r3, [fp, #-8]
1001c000:	e51b200c 	ldr	r2, [fp, #-12]
1001c004:	e5832090 	str	r2, [r3, #144]	; 0x90
}
1001c008:	e24bd004 	sub	sp, fp, #4
1001c00c:	e8bd8800 	pop	{fp, pc}

1001c010 <finsh_token_token>:

enum finsh_token_type finsh_token_token(struct finsh_token* self)
{
1001c010:	e92d4800 	push	{fp, lr}
1001c014:	e28db004 	add	fp, sp, #4
1001c018:	e24dd008 	sub	sp, sp, #8
1001c01c:	e50b0008 	str	r0, [fp, #-8]
	if ( self->replay )	self->replay = 0;
1001c020:	e51b3008 	ldr	r3, [fp, #-8]
1001c024:	e5d33001 	ldrb	r3, [r3, #1]
1001c028:	e3530000 	cmp	r3, #0
1001c02c:	0a000003 	beq	1001c040 <finsh_token_token+0x30>
1001c030:	e51b3008 	ldr	r3, [fp, #-8]
1001c034:	e3a02000 	mov	r2, #0
1001c038:	e5c32001 	strb	r2, [r3, #1]
1001c03c:	ea000001 	b	1001c048 <finsh_token_token+0x38>
	else token_run(self);
1001c040:	e51b0008 	ldr	r0, [fp, #-8]
1001c044:	eb0000a3 	bl	1001c2d8 <token_run>

	return (enum finsh_token_type)self->current_token;
1001c048:	e51b3008 	ldr	r3, [fp, #-8]
1001c04c:	e5d33008 	ldrb	r3, [r3, #8]
}
1001c050:	e1a00003 	mov	r0, r3
1001c054:	e24bd004 	sub	sp, fp, #4
1001c058:	e8bd8800 	pop	{fp, pc}

1001c05c <finsh_token_get_token>:

void finsh_token_get_token(struct finsh_token* self, u_char* token)
{
1001c05c:	e92d4800 	push	{fp, lr}
1001c060:	e28db004 	add	fp, sp, #4
1001c064:	e24dd008 	sub	sp, sp, #8
1001c068:	e50b0008 	str	r0, [fp, #-8]
1001c06c:	e50b100c 	str	r1, [fp, #-12]
	strncpy((char*)token, (char*)self->string, FINSH_NAME_MAX);
1001c070:	e51b3008 	ldr	r3, [fp, #-8]
1001c074:	e2833010 	add	r3, r3, #16
1001c078:	e51b000c 	ldr	r0, [fp, #-12]
1001c07c:	e1a01003 	mov	r1, r3
1001c080:	e3a02010 	mov	r2, #16
1001c084:	fa000736 	blx	1001dd64 <strncpy>
}
1001c088:	e24bd004 	sub	sp, fp, #4
1001c08c:	e8bd8800 	pop	{fp, pc}

1001c090 <token_get_string>:

int token_get_string(struct finsh_token* self, u_char* str)
{
1001c090:	e92d4800 	push	{fp, lr}
1001c094:	e28db004 	add	fp, sp, #4
1001c098:	e24dd010 	sub	sp, sp, #16
1001c09c:	e50b0010 	str	r0, [fp, #-16]
1001c0a0:	e50b1014 	str	r1, [fp, #-20]
	unsigned char *p=str;
1001c0a4:	e51b3014 	ldr	r3, [fp, #-20]
1001c0a8:	e50b3008 	str	r3, [fp, #-8]
	char ch;

	ch = token_next_char(self);
1001c0ac:	e51b0010 	ldr	r0, [fp, #-16]
1001c0b0:	eb000043 	bl	1001c1c4 <token_next_char>
1001c0b4:	e1a03000 	mov	r3, r0
1001c0b8:	e54b3009 	strb	r3, [fp, #-9]
	if (is_eof(self)) return -1;
1001c0bc:	e51b3010 	ldr	r3, [fp, #-16]
1001c0c0:	e5d33000 	ldrb	r3, [r3]
1001c0c4:	e3530000 	cmp	r3, #0
1001c0c8:	0a000001 	beq	1001c0d4 <token_get_string+0x44>
1001c0cc:	e3e03000 	mvn	r3, #0
1001c0d0:	ea000038 	b	1001c1b8 <token_get_string+0x128>

	str[0] = '\0';
1001c0d4:	e51b3014 	ldr	r3, [fp, #-20]
1001c0d8:	e3a02000 	mov	r2, #0
1001c0dc:	e5c32000 	strb	r2, [r3]

	if ( is_digit(ch) )/*the first character of identifier is not a digit.*/
1001c0e0:	e55b3009 	ldrb	r3, [fp, #-9]
1001c0e4:	e353002f 	cmp	r3, #47	; 0x2f
1001c0e8:	9a000006 	bls	1001c108 <token_get_string+0x78>
1001c0ec:	e55b3009 	ldrb	r3, [fp, #-9]
1001c0f0:	e3530039 	cmp	r3, #57	; 0x39
1001c0f4:	8a000003 	bhi	1001c108 <token_get_string+0x78>
	{
		token_prev_char(self);
1001c0f8:	e51b0010 	ldr	r0, [fp, #-16]
1001c0fc:	eb00005f 	bl	1001c280 <token_prev_char>
		return -1;
1001c100:	e3e03000 	mvn	r3, #0
1001c104:	ea00002b 	b	1001c1b8 <token_get_string+0x128>
	}

	while (!is_separator(ch) && !is_eof(self))
1001c108:	ea000008 	b	1001c130 <token_get_string+0xa0>
	{
		*p++ = ch;
1001c10c:	e51b3008 	ldr	r3, [fp, #-8]
1001c110:	e2832001 	add	r2, r3, #1
1001c114:	e50b2008 	str	r2, [fp, #-8]
1001c118:	e55b2009 	ldrb	r2, [fp, #-9]
1001c11c:	e5c32000 	strb	r2, [r3]

		ch = token_next_char(self);
1001c120:	e51b0010 	ldr	r0, [fp, #-16]
1001c124:	eb000026 	bl	1001c1c4 <token_next_char>
1001c128:	e1a03000 	mov	r3, r0
1001c12c:	e54b3009 	strb	r3, [fp, #-9]
	{
		token_prev_char(self);
		return -1;
	}

	while (!is_separator(ch) && !is_eof(self))
1001c130:	e55b3009 	ldrb	r3, [fp, #-9]
1001c134:	e3530060 	cmp	r3, #96	; 0x60
1001c138:	9a000002 	bls	1001c148 <token_get_string+0xb8>
1001c13c:	e55b3009 	ldrb	r3, [fp, #-9]
1001c140:	e353007a 	cmp	r3, #122	; 0x7a
1001c144:	9a00000e 	bls	1001c184 <token_get_string+0xf4>
1001c148:	e55b3009 	ldrb	r3, [fp, #-9]
1001c14c:	e3530040 	cmp	r3, #64	; 0x40
1001c150:	9a000002 	bls	1001c160 <token_get_string+0xd0>
1001c154:	e55b3009 	ldrb	r3, [fp, #-9]
1001c158:	e353005a 	cmp	r3, #90	; 0x5a
1001c15c:	9a000008 	bls	1001c184 <token_get_string+0xf4>
1001c160:	e55b3009 	ldrb	r3, [fp, #-9]
1001c164:	e353002f 	cmp	r3, #47	; 0x2f
1001c168:	9a000002 	bls	1001c178 <token_get_string+0xe8>
1001c16c:	e55b3009 	ldrb	r3, [fp, #-9]
1001c170:	e3530039 	cmp	r3, #57	; 0x39
1001c174:	9a000002 	bls	1001c184 <token_get_string+0xf4>
1001c178:	e55b3009 	ldrb	r3, [fp, #-9]
1001c17c:	e353005f 	cmp	r3, #95	; 0x5f
1001c180:	1a000003 	bne	1001c194 <token_get_string+0x104>
1001c184:	e51b3010 	ldr	r3, [fp, #-16]
1001c188:	e5d33000 	ldrb	r3, [r3]
1001c18c:	e3530000 	cmp	r3, #0
1001c190:	0affffdd 	beq	1001c10c <token_get_string+0x7c>
	{
		*p++ = ch;

		ch = token_next_char(self);
	}
	self->eof = 0;
1001c194:	e51b3010 	ldr	r3, [fp, #-16]
1001c198:	e3a02000 	mov	r2, #0
1001c19c:	e5c32000 	strb	r2, [r3]

	token_prev_char(self);
1001c1a0:	e51b0010 	ldr	r0, [fp, #-16]
1001c1a4:	eb000035 	bl	1001c280 <token_prev_char>
	*p = '\0';
1001c1a8:	e51b3008 	ldr	r3, [fp, #-8]
1001c1ac:	e3a02000 	mov	r2, #0
1001c1b0:	e5c32000 	strb	r2, [r3]

	return 0;
1001c1b4:	e3a03000 	mov	r3, #0
}
1001c1b8:	e1a00003 	mov	r0, r3
1001c1bc:	e24bd004 	sub	sp, fp, #4
1001c1c0:	e8bd8800 	pop	{fp, pc}

1001c1c4 <token_next_char>:

/*
get next character.
*/
static char token_next_char(struct finsh_token* self)
{
1001c1c4:	e92d4810 	push	{r4, fp, lr}
1001c1c8:	e28db008 	add	fp, sp, #8
1001c1cc:	e24dd00c 	sub	sp, sp, #12
1001c1d0:	e50b0010 	str	r0, [fp, #-16]
	if (self->eof) return '\0';
1001c1d4:	e51b3010 	ldr	r3, [fp, #-16]
1001c1d8:	e5d33000 	ldrb	r3, [r3]
1001c1dc:	e3530000 	cmp	r3, #0
1001c1e0:	0a000001 	beq	1001c1ec <token_next_char+0x28>
1001c1e4:	e3a03000 	mov	r3, #0
1001c1e8:	ea000021 	b	1001c274 <token_next_char+0xb0>

	if (self->position == (int)strlen((char*)self->line) || self->line[self->position] =='\n')
1001c1ec:	e51b3010 	ldr	r3, [fp, #-16]
1001c1f0:	e5934004 	ldr	r4, [r3, #4]
1001c1f4:	e51b3010 	ldr	r3, [fp, #-16]
1001c1f8:	e5933090 	ldr	r3, [r3, #144]	; 0x90
1001c1fc:	e1a00003 	mov	r0, r3
1001c200:	fa00069a 	blx	1001dc70 <strlen>
1001c204:	e1a03000 	mov	r3, r0
1001c208:	e1540003 	cmp	r4, r3
1001c20c:	0a000007 	beq	1001c230 <token_next_char+0x6c>
1001c210:	e51b3010 	ldr	r3, [fp, #-16]
1001c214:	e5933090 	ldr	r3, [r3, #144]	; 0x90
1001c218:	e51b2010 	ldr	r2, [fp, #-16]
1001c21c:	e5922004 	ldr	r2, [r2, #4]
1001c220:	e0833002 	add	r3, r3, r2
1001c224:	e5d33000 	ldrb	r3, [r3]
1001c228:	e353000a 	cmp	r3, #10
1001c22c:	1a000007 	bne	1001c250 <token_next_char+0x8c>
	{
			self->eof = 1;
1001c230:	e51b3010 	ldr	r3, [fp, #-16]
1001c234:	e3a02001 	mov	r2, #1
1001c238:	e5c32000 	strb	r2, [r3]
			self->position = 0;
1001c23c:	e51b3010 	ldr	r3, [fp, #-16]
1001c240:	e3a02000 	mov	r2, #0
1001c244:	e5832004 	str	r2, [r3, #4]
			return '\0';
1001c248:	e3a03000 	mov	r3, #0
1001c24c:	ea000008 	b	1001c274 <token_next_char+0xb0>
	}

	return self->line[self->position++];
1001c250:	e51b3010 	ldr	r3, [fp, #-16]
1001c254:	e5932090 	ldr	r2, [r3, #144]	; 0x90
1001c258:	e51b3010 	ldr	r3, [fp, #-16]
1001c25c:	e5933004 	ldr	r3, [r3, #4]
1001c260:	e2830001 	add	r0, r3, #1
1001c264:	e51b1010 	ldr	r1, [fp, #-16]
1001c268:	e5810004 	str	r0, [r1, #4]
1001c26c:	e0823003 	add	r3, r2, r3
1001c270:	e5d33000 	ldrb	r3, [r3]
}
1001c274:	e1a00003 	mov	r0, r3
1001c278:	e24bd008 	sub	sp, fp, #8
1001c27c:	e8bd8810 	pop	{r4, fp, pc}

1001c280 <token_prev_char>:

static void token_prev_char(struct finsh_token* self)
{
1001c280:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001c284:	e28db000 	add	fp, sp, #0
1001c288:	e24dd00c 	sub	sp, sp, #12
1001c28c:	e50b0008 	str	r0, [fp, #-8]
	if ( self->eof ) return;
1001c290:	e51b3008 	ldr	r3, [fp, #-8]
1001c294:	e5d33000 	ldrb	r3, [r3]
1001c298:	e3530000 	cmp	r3, #0
1001c29c:	0a000000 	beq	1001c2a4 <token_prev_char+0x24>
1001c2a0:	ea000009 	b	1001c2cc <token_prev_char+0x4c>

	if ( self->position == 0 ) return;
1001c2a4:	e51b3008 	ldr	r3, [fp, #-8]
1001c2a8:	e5933004 	ldr	r3, [r3, #4]
1001c2ac:	e3530000 	cmp	r3, #0
1001c2b0:	1a000000 	bne	1001c2b8 <token_prev_char+0x38>
1001c2b4:	ea000004 	b	1001c2cc <token_prev_char+0x4c>
    else self->position--;
1001c2b8:	e51b3008 	ldr	r3, [fp, #-8]
1001c2bc:	e5933004 	ldr	r3, [r3, #4]
1001c2c0:	e2432001 	sub	r2, r3, #1
1001c2c4:	e51b3008 	ldr	r3, [fp, #-8]
1001c2c8:	e5832004 	str	r2, [r3, #4]
}
1001c2cc:	e24bd000 	sub	sp, fp, #0
1001c2d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001c2d4:	e12fff1e 	bx	lr

1001c2d8 <token_run>:

static void token_run(struct finsh_token* self)
{
1001c2d8:	e92d4800 	push	{fp, lr}
1001c2dc:	e28db004 	add	fp, sp, #4
1001c2e0:	e24dd010 	sub	sp, sp, #16
1001c2e4:	e50b0010 	str	r0, [fp, #-16]
	char ch;

	token_trim_space(self); /* first trim space and tab. */
1001c2e8:	e51b0010 	ldr	r0, [fp, #-16]
1001c2ec:	eb00014c 	bl	1001c824 <token_trim_space>
	token_get_string(self, &(self->string[0]));
1001c2f0:	e51b3010 	ldr	r3, [fp, #-16]
1001c2f4:	e2833010 	add	r3, r3, #16
1001c2f8:	e51b0010 	ldr	r0, [fp, #-16]
1001c2fc:	e1a01003 	mov	r1, r3
1001c300:	ebffff62 	bl	1001c090 <token_get_string>

	if ( is_eof(self) ) /*if it is eof, break;*/
1001c304:	e51b3010 	ldr	r3, [fp, #-16]
1001c308:	e5d33000 	ldrb	r3, [r3]
1001c30c:	e3530000 	cmp	r3, #0
1001c310:	0a000003 	beq	1001c324 <token_run+0x4c>
	{
		self->current_token = finsh_token_type_eof;
1001c314:	e51b3010 	ldr	r3, [fp, #-16]
1001c318:	e3a02021 	mov	r2, #33	; 0x21
1001c31c:	e5c32008 	strb	r2, [r3, #8]
		return ;
1001c320:	ea000117 	b	1001c784 <token_run+0x4ac>
	}

	if (self->string[0] != '\0') /*It is a key word or a identifier.*/
1001c324:	e51b3010 	ldr	r3, [fp, #-16]
1001c328:	e5d33010 	ldrb	r3, [r3, #16]
1001c32c:	e3530000 	cmp	r3, #0
1001c330:	0a00000b 	beq	1001c364 <token_run+0x8c>
	{
		if ( !token_match_name(self, (char*)self->string) )
1001c334:	e51b3010 	ldr	r3, [fp, #-16]
1001c338:	e2833010 	add	r3, r3, #16
1001c33c:	e51b0010 	ldr	r0, [fp, #-16]
1001c340:	e1a01003 	mov	r1, r3
1001c344:	eb000110 	bl	1001c78c <token_match_name>
1001c348:	e1a03000 	mov	r3, r0
1001c34c:	e3530000 	cmp	r3, #0
1001c350:	1a00010b 	bne	1001c784 <token_run+0x4ac>
		{
			self->current_token = finsh_token_type_identifier;
1001c354:	e51b3010 	ldr	r3, [fp, #-16]
1001c358:	e3a0201f 	mov	r2, #31
1001c35c:	e5c32008 	strb	r2, [r3, #8]
1001c360:	ea000107 	b	1001c784 <token_run+0x4ac>
		}
	}
	else/*It is a operator character.*/
	{
		ch = token_next_char(self);
1001c364:	e51b0010 	ldr	r0, [fp, #-16]
1001c368:	ebffff95 	bl	1001c1c4 <token_next_char>
1001c36c:	e1a03000 	mov	r3, r0
1001c370:	e54b3005 	strb	r3, [fp, #-5]

		switch ( ch )
1001c374:	e55b3005 	ldrb	r3, [fp, #-5]
1001c378:	e2433022 	sub	r3, r3, #34	; 0x22
1001c37c:	e353005c 	cmp	r3, #92	; 0x5c
1001c380:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001c384:	ea0000ed 	b	1001c740 <token_run+0x468>
1001c388:	1001c728 	.word	0x1001c728
1001c38c:	1001c740 	.word	0x1001c740
1001c390:	1001c740 	.word	0x1001c740
1001c394:	1001c6c0 	.word	0x1001c6c0
1001c398:	1001c53c 	.word	0x1001c53c
1001c39c:	1001c700 	.word	0x1001c700
1001c3a0:	1001c4fc 	.word	0x1001c4fc
1001c3a4:	1001c50c 	.word	0x1001c50c
1001c3a8:	1001c54c 	.word	0x1001c54c
1001c3ac:	1001c55c 	.word	0x1001c55c
1001c3b0:	1001c51c 	.word	0x1001c51c
1001c3b4:	1001c5a0 	.word	0x1001c5a0
1001c3b8:	1001c740 	.word	0x1001c740
1001c3bc:	1001c5e4 	.word	0x1001c5e4
1001c3c0:	1001c740 	.word	0x1001c740
1001c3c4:	1001c740 	.word	0x1001c740
1001c3c8:	1001c740 	.word	0x1001c740
1001c3cc:	1001c740 	.word	0x1001c740
1001c3d0:	1001c740 	.word	0x1001c740
1001c3d4:	1001c740 	.word	0x1001c740
1001c3d8:	1001c740 	.word	0x1001c740
1001c3dc:	1001c740 	.word	0x1001c740
1001c3e0:	1001c740 	.word	0x1001c740
1001c3e4:	1001c740 	.word	0x1001c740
1001c3e8:	1001c740 	.word	0x1001c740
1001c3ec:	1001c52c 	.word	0x1001c52c
1001c3f0:	1001c628 	.word	0x1001c628
1001c3f4:	1001c6f0 	.word	0x1001c6f0
1001c3f8:	1001c66c 	.word	0x1001c66c
1001c3fc:	1001c740 	.word	0x1001c740
1001c400:	1001c740 	.word	0x1001c740
1001c404:	1001c740 	.word	0x1001c740
1001c408:	1001c740 	.word	0x1001c740
1001c40c:	1001c740 	.word	0x1001c740
1001c410:	1001c740 	.word	0x1001c740
1001c414:	1001c740 	.word	0x1001c740
1001c418:	1001c740 	.word	0x1001c740
1001c41c:	1001c740 	.word	0x1001c740
1001c420:	1001c740 	.word	0x1001c740
1001c424:	1001c740 	.word	0x1001c740
1001c428:	1001c740 	.word	0x1001c740
1001c42c:	1001c740 	.word	0x1001c740
1001c430:	1001c740 	.word	0x1001c740
1001c434:	1001c740 	.word	0x1001c740
1001c438:	1001c740 	.word	0x1001c740
1001c43c:	1001c740 	.word	0x1001c740
1001c440:	1001c740 	.word	0x1001c740
1001c444:	1001c740 	.word	0x1001c740
1001c448:	1001c740 	.word	0x1001c740
1001c44c:	1001c740 	.word	0x1001c740
1001c450:	1001c740 	.word	0x1001c740
1001c454:	1001c740 	.word	0x1001c740
1001c458:	1001c740 	.word	0x1001c740
1001c45c:	1001c740 	.word	0x1001c740
1001c460:	1001c740 	.word	0x1001c740
1001c464:	1001c740 	.word	0x1001c740
1001c468:	1001c740 	.word	0x1001c740
1001c46c:	1001c740 	.word	0x1001c740
1001c470:	1001c740 	.word	0x1001c740
1001c474:	1001c740 	.word	0x1001c740
1001c478:	1001c6e0 	.word	0x1001c6e0
1001c47c:	1001c740 	.word	0x1001c740
1001c480:	1001c740 	.word	0x1001c740
1001c484:	1001c740 	.word	0x1001c740
1001c488:	1001c740 	.word	0x1001c740
1001c48c:	1001c740 	.word	0x1001c740
1001c490:	1001c740 	.word	0x1001c740
1001c494:	1001c740 	.word	0x1001c740
1001c498:	1001c740 	.word	0x1001c740
1001c49c:	1001c740 	.word	0x1001c740
1001c4a0:	1001c740 	.word	0x1001c740
1001c4a4:	1001c740 	.word	0x1001c740
1001c4a8:	1001c740 	.word	0x1001c740
1001c4ac:	1001c740 	.word	0x1001c740
1001c4b0:	1001c740 	.word	0x1001c740
1001c4b4:	1001c740 	.word	0x1001c740
1001c4b8:	1001c740 	.word	0x1001c740
1001c4bc:	1001c740 	.word	0x1001c740
1001c4c0:	1001c740 	.word	0x1001c740
1001c4c4:	1001c740 	.word	0x1001c740
1001c4c8:	1001c740 	.word	0x1001c740
1001c4cc:	1001c740 	.word	0x1001c740
1001c4d0:	1001c740 	.word	0x1001c740
1001c4d4:	1001c740 	.word	0x1001c740
1001c4d8:	1001c740 	.word	0x1001c740
1001c4dc:	1001c740 	.word	0x1001c740
1001c4e0:	1001c740 	.word	0x1001c740
1001c4e4:	1001c740 	.word	0x1001c740
1001c4e8:	1001c740 	.word	0x1001c740
1001c4ec:	1001c740 	.word	0x1001c740
1001c4f0:	1001c6b0 	.word	0x1001c6b0
1001c4f4:	1001c740 	.word	0x1001c740
1001c4f8:	1001c6d0 	.word	0x1001c6d0
		{
		case '(':
			self->current_token = finsh_token_type_left_paren;
1001c4fc:	e51b3010 	ldr	r3, [fp, #-16]
1001c500:	e3a02001 	mov	r2, #1
1001c504:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c508:	ea00009d 	b	1001c784 <token_run+0x4ac>

		case ')':
			self->current_token = finsh_token_type_right_paren;
1001c50c:	e51b3010 	ldr	r3, [fp, #-16]
1001c510:	e3a02002 	mov	r2, #2
1001c514:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c518:	ea000099 	b	1001c784 <token_run+0x4ac>

		case ',':
			self->current_token = finsh_token_type_comma;
1001c51c:	e51b3010 	ldr	r3, [fp, #-16]
1001c520:	e3a02003 	mov	r2, #3
1001c524:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c528:	ea000095 	b	1001c784 <token_run+0x4ac>

		case ';':
			self->current_token = finsh_token_type_semicolon;
1001c52c:	e51b3010 	ldr	r3, [fp, #-16]
1001c530:	e3a02004 	mov	r2, #4
1001c534:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c538:	ea000091 	b	1001c784 <token_run+0x4ac>

		case '&':
			self->current_token = finsh_token_type_and;
1001c53c:	e51b3010 	ldr	r3, [fp, #-16]
1001c540:	e3a0200d 	mov	r2, #13
1001c544:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c548:	ea00008d 	b	1001c784 <token_run+0x4ac>

		case '*':
			self->current_token = finsh_token_type_mul;
1001c54c:	e51b3010 	ldr	r3, [fp, #-16]
1001c550:	e3a02005 	mov	r2, #5
1001c554:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c558:	ea000089 	b	1001c784 <token_run+0x4ac>

		case '+':
			ch = token_next_char(self);
1001c55c:	e51b0010 	ldr	r0, [fp, #-16]
1001c560:	ebffff17 	bl	1001c1c4 <token_next_char>
1001c564:	e1a03000 	mov	r3, r0
1001c568:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '+' )
1001c56c:	e55b3005 	ldrb	r3, [fp, #-5]
1001c570:	e353002b 	cmp	r3, #43	; 0x2b
1001c574:	1a000003 	bne	1001c588 <token_run+0x2b0>
			{
				self->current_token = finsh_token_type_inc;
1001c578:	e51b3010 	ldr	r3, [fp, #-16]
1001c57c:	e3a02007 	mov	r2, #7
1001c580:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_add;
			}
			break;
1001c584:	ea00007e 	b	1001c784 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_inc;
			}
			else
			{
				token_prev_char(self);
1001c588:	e51b0010 	ldr	r0, [fp, #-16]
1001c58c:	ebffff3b 	bl	1001c280 <token_prev_char>
				self->current_token = finsh_token_type_add;
1001c590:	e51b3010 	ldr	r3, [fp, #-16]
1001c594:	e3a02006 	mov	r2, #6
1001c598:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1001c59c:	ea000078 	b	1001c784 <token_run+0x4ac>

		case '-':
			ch = token_next_char(self);
1001c5a0:	e51b0010 	ldr	r0, [fp, #-16]
1001c5a4:	ebffff06 	bl	1001c1c4 <token_next_char>
1001c5a8:	e1a03000 	mov	r3, r0
1001c5ac:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '-' )
1001c5b0:	e55b3005 	ldrb	r3, [fp, #-5]
1001c5b4:	e353002d 	cmp	r3, #45	; 0x2d
1001c5b8:	1a000003 	bne	1001c5cc <token_run+0x2f4>
			{
				self->current_token = finsh_token_type_dec;
1001c5bc:	e51b3010 	ldr	r3, [fp, #-16]
1001c5c0:	e3a02009 	mov	r2, #9
1001c5c4:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_sub;
			}
			break;
1001c5c8:	ea00006d 	b	1001c784 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_dec;
			}
			else
			{
				token_prev_char(self);
1001c5cc:	e51b0010 	ldr	r0, [fp, #-16]
1001c5d0:	ebffff2a 	bl	1001c280 <token_prev_char>
				self->current_token = finsh_token_type_sub;
1001c5d4:	e51b3010 	ldr	r3, [fp, #-16]
1001c5d8:	e3a02008 	mov	r2, #8
1001c5dc:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1001c5e0:	ea000067 	b	1001c784 <token_run+0x4ac>

		case '/':
			ch = token_next_char(self);
1001c5e4:	e51b0010 	ldr	r0, [fp, #-16]
1001c5e8:	ebfffef5 	bl	1001c1c4 <token_next_char>
1001c5ec:	e1a03000 	mov	r3, r0
1001c5f0:	e54b3005 	strb	r3, [fp, #-5]
			if (ch == '/')
1001c5f4:	e55b3005 	ldrb	r3, [fp, #-5]
1001c5f8:	e353002f 	cmp	r3, #47	; 0x2f
1001c5fc:	1a000003 	bne	1001c610 <token_run+0x338>
			{
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
1001c600:	e51b3010 	ldr	r3, [fp, #-16]
1001c604:	e3a02021 	mov	r2, #33	; 0x21
1001c608:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_div;
			}
			break;
1001c60c:	ea00005c 	b	1001c784 <token_run+0x4ac>
				/* line comments, set to end of file */
				self->current_token = finsh_token_type_eof;
			}
			else
			{
				token_prev_char(self);
1001c610:	e51b0010 	ldr	r0, [fp, #-16]
1001c614:	ebffff19 	bl	1001c280 <token_prev_char>
				self->current_token = finsh_token_type_div;
1001c618:	e51b3010 	ldr	r3, [fp, #-16]
1001c61c:	e3a0200a 	mov	r2, #10
1001c620:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1001c624:	ea000056 	b	1001c784 <token_run+0x4ac>

		case '<':
			ch = token_next_char(self);
1001c628:	e51b0010 	ldr	r0, [fp, #-16]
1001c62c:	ebfffee4 	bl	1001c1c4 <token_next_char>
1001c630:	e1a03000 	mov	r3, r0
1001c634:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '<' )
1001c638:	e55b3005 	ldrb	r3, [fp, #-5]
1001c63c:	e353003c 	cmp	r3, #60	; 0x3c
1001c640:	1a000003 	bne	1001c654 <token_run+0x37c>
			{
				self->current_token = finsh_token_type_shl;
1001c644:	e51b3010 	ldr	r3, [fp, #-16]
1001c648:	e3a02011 	mov	r2, #17
1001c64c:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
1001c650:	ea00004b 	b	1001c784 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_shl;
			}
			else
			{
				token_prev_char(self);
1001c654:	e51b0010 	ldr	r0, [fp, #-16]
1001c658:	ebffff08 	bl	1001c280 <token_prev_char>
				self->current_token = finsh_token_type_bad;
1001c65c:	e51b3010 	ldr	r3, [fp, #-16]
1001c660:	e3a02020 	mov	r2, #32
1001c664:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1001c668:	ea000045 	b	1001c784 <token_run+0x4ac>

		case '>':
			ch = token_next_char(self);
1001c66c:	e51b0010 	ldr	r0, [fp, #-16]
1001c670:	ebfffed3 	bl	1001c1c4 <token_next_char>
1001c674:	e1a03000 	mov	r3, r0
1001c678:	e54b3005 	strb	r3, [fp, #-5]

			if ( ch == '>' )
1001c67c:	e55b3005 	ldrb	r3, [fp, #-5]
1001c680:	e353003e 	cmp	r3, #62	; 0x3e
1001c684:	1a000003 	bne	1001c698 <token_run+0x3c0>
			{
				self->current_token = finsh_token_type_shr;
1001c688:	e51b3010 	ldr	r3, [fp, #-16]
1001c68c:	e3a02012 	mov	r2, #18
1001c690:	e5c32008 	strb	r2, [r3, #8]
			else
			{
				token_prev_char(self);
				self->current_token = finsh_token_type_bad;
			}
			break;
1001c694:	ea00003a 	b	1001c784 <token_run+0x4ac>
			{
				self->current_token = finsh_token_type_shr;
			}
			else
			{
				token_prev_char(self);
1001c698:	e51b0010 	ldr	r0, [fp, #-16]
1001c69c:	ebfffef7 	bl	1001c280 <token_prev_char>
				self->current_token = finsh_token_type_bad;
1001c6a0:	e51b3010 	ldr	r3, [fp, #-16]
1001c6a4:	e3a02020 	mov	r2, #32
1001c6a8:	e5c32008 	strb	r2, [r3, #8]
			}
			break;
1001c6ac:	ea000034 	b	1001c784 <token_run+0x4ac>

		case '|':
			self->current_token = finsh_token_type_or;
1001c6b0:	e51b3010 	ldr	r3, [fp, #-16]
1001c6b4:	e3a0200e 	mov	r2, #14
1001c6b8:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c6bc:	ea000030 	b	1001c784 <token_run+0x4ac>

		case '%':
			self->current_token = finsh_token_type_mod;
1001c6c0:	e51b3010 	ldr	r3, [fp, #-16]
1001c6c4:	e3a0200b 	mov	r2, #11
1001c6c8:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c6cc:	ea00002c 	b	1001c784 <token_run+0x4ac>

		case '~':
			self->current_token = finsh_token_type_bitwise;
1001c6d0:	e51b3010 	ldr	r3, [fp, #-16]
1001c6d4:	e3a02010 	mov	r2, #16
1001c6d8:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c6dc:	ea000028 	b	1001c784 <token_run+0x4ac>

		case '^':
			self->current_token = finsh_token_type_xor;
1001c6e0:	e51b3010 	ldr	r3, [fp, #-16]
1001c6e4:	e3a0200f 	mov	r2, #15
1001c6e8:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c6ec:	ea000024 	b	1001c784 <token_run+0x4ac>

		case '=':
			self->current_token = finsh_token_type_assign;
1001c6f0:	e51b3010 	ldr	r3, [fp, #-16]
1001c6f4:	e3a0200c 	mov	r2, #12
1001c6f8:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c6fc:	ea000020 	b	1001c784 <token_run+0x4ac>

		case '\'':
			self->value.char_value = token_proc_char(self);
1001c700:	e51b0010 	ldr	r0, [fp, #-16]
1001c704:	eb00005b 	bl	1001c878 <token_proc_char>
1001c708:	e1a03000 	mov	r3, r0
1001c70c:	e1a02003 	mov	r2, r3
1001c710:	e51b3010 	ldr	r3, [fp, #-16]
1001c714:	e5c3200c 	strb	r2, [r3, #12]
			self->current_token = finsh_token_type_value_char;
1001c718:	e51b3010 	ldr	r3, [fp, #-16]
1001c71c:	e3a0201a 	mov	r2, #26
1001c720:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c724:	ea000016 	b	1001c784 <token_run+0x4ac>

		case '"':
			token_proc_string(self);
1001c728:	e51b0010 	ldr	r0, [fp, #-16]
1001c72c:	eb0000b3 	bl	1001ca00 <token_proc_string>
			self->current_token = finsh_token_type_value_string;
1001c730:	e51b3010 	ldr	r3, [fp, #-16]
1001c734:	e3a0201d 	mov	r2, #29
1001c738:	e5c32008 	strb	r2, [r3, #8]
			break;
1001c73c:	ea000010 	b	1001c784 <token_run+0x4ac>

		default:
			if ( is_digit(ch) )
1001c740:	e55b3005 	ldrb	r3, [fp, #-5]
1001c744:	e353002f 	cmp	r3, #47	; 0x2f
1001c748:	9a000007 	bls	1001c76c <token_run+0x494>
1001c74c:	e55b3005 	ldrb	r3, [fp, #-5]
1001c750:	e3530039 	cmp	r3, #57	; 0x39
1001c754:	8a000004 	bhi	1001c76c <token_run+0x494>
			{
				token_prev_char(self);
1001c758:	e51b0010 	ldr	r0, [fp, #-16]
1001c75c:	ebfffec7 	bl	1001c280 <token_prev_char>
				token_proc_number(self);
1001c760:	e51b0010 	ldr	r0, [fp, #-16]
1001c764:	eb00014a 	bl	1001cc94 <token_proc_number>
				break;
1001c768:	ea000005 	b	1001c784 <token_run+0x4ac>
			}

			finsh_error_set(FINSH_ERROR_UNKNOWN_TOKEN);
1001c76c:	e3a0000b 	mov	r0, #11
1001c770:	ebffec4f 	bl	100178b4 <finsh_error_set>
			self->current_token = finsh_token_type_bad;
1001c774:	e51b3010 	ldr	r3, [fp, #-16]
1001c778:	e3a02020 	mov	r2, #32
1001c77c:	e5c32008 	strb	r2, [r3, #8]

			break;
1001c780:	e1a00000 	nop			; (mov r0, r0)
		}
	}
}
1001c784:	e24bd004 	sub	sp, fp, #4
1001c788:	e8bd8800 	pop	{fp, pc}

1001c78c <token_match_name>:

static int token_match_name(struct finsh_token* self, const char* str)
{
1001c78c:	e92d4800 	push	{fp, lr}
1001c790:	e28db004 	add	fp, sp, #4
1001c794:	e24dd010 	sub	sp, sp, #16
1001c798:	e50b0010 	str	r0, [fp, #-16]
1001c79c:	e50b1014 	str	r1, [fp, #-20]
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
1001c7a0:	e3a03000 	mov	r3, #0
1001c7a4:	e50b3008 	str	r3, [fp, #-8]
1001c7a8:	ea000016 	b	1001c808 <token_match_name+0x7c>
	{
		if ( strcmp(finsh_name_table[i].name, str)==0 )
1001c7ac:	e3003398 	movw	r3, #920	; 0x398
1001c7b0:	e3413002 	movt	r3, #4098	; 0x1002
1001c7b4:	e51b2008 	ldr	r2, [fp, #-8]
1001c7b8:	e7933182 	ldr	r3, [r3, r2, lsl #3]
1001c7bc:	e1a00003 	mov	r0, r3
1001c7c0:	e51b1014 	ldr	r1, [fp, #-20]
1001c7c4:	fa00025d 	blx	1001d140 <strcmp>
1001c7c8:	e1a03000 	mov	r3, r0
1001c7cc:	e3530000 	cmp	r3, #0
1001c7d0:	1a000009 	bne	1001c7fc <token_match_name+0x70>
		{
			self->current_token = finsh_name_table[i].type;
1001c7d4:	e3002398 	movw	r2, #920	; 0x398
1001c7d8:	e3412002 	movt	r2, #4098	; 0x1002
1001c7dc:	e51b3008 	ldr	r3, [fp, #-8]
1001c7e0:	e1a03183 	lsl	r3, r3, #3
1001c7e4:	e0823003 	add	r3, r2, r3
1001c7e8:	e5d32004 	ldrb	r2, [r3, #4]
1001c7ec:	e51b3010 	ldr	r3, [fp, #-16]
1001c7f0:	e5c32008 	strb	r2, [r3, #8]
			return 1;
1001c7f4:	e3a03001 	mov	r3, #1
1001c7f8:	ea000006 	b	1001c818 <token_match_name+0x8c>

static int token_match_name(struct finsh_token* self, const char* str)
{
	int i;

	for (i = 0; i < sizeof(finsh_name_table)/sizeof(struct name_table); i++)
1001c7fc:	e51b3008 	ldr	r3, [fp, #-8]
1001c800:	e2833001 	add	r3, r3, #1
1001c804:	e50b3008 	str	r3, [fp, #-8]
1001c808:	e51b3008 	ldr	r3, [fp, #-8]
1001c80c:	e3530007 	cmp	r3, #7
1001c810:	9affffe5 	bls	1001c7ac <token_match_name+0x20>
			self->current_token = finsh_name_table[i].type;
			return 1;
		}
	}

	return 0;
1001c814:	e3a03000 	mov	r3, #0
}
1001c818:	e1a00003 	mov	r0, r3
1001c81c:	e24bd004 	sub	sp, fp, #4
1001c820:	e8bd8800 	pop	{fp, pc}

1001c824 <token_trim_space>:

static void token_trim_space(struct finsh_token* self)
{
1001c824:	e92d4800 	push	{fp, lr}
1001c828:	e28db004 	add	fp, sp, #4
1001c82c:	e24dd010 	sub	sp, sp, #16
1001c830:	e50b0010 	str	r0, [fp, #-16]
	char ch;
	while ( (ch = token_next_char(self)) ==' ' || 
1001c834:	e51b0010 	ldr	r0, [fp, #-16]
1001c838:	ebfffe61 	bl	1001c1c4 <token_next_char>
1001c83c:	e1a03000 	mov	r3, r0
1001c840:	e54b3005 	strb	r3, [fp, #-5]
1001c844:	e55b3005 	ldrb	r3, [fp, #-5]
1001c848:	e3530020 	cmp	r3, #32
1001c84c:	0afffff8 	beq	1001c834 <token_trim_space+0x10>
1001c850:	e55b3005 	ldrb	r3, [fp, #-5]
1001c854:	e3530009 	cmp	r3, #9
1001c858:	0afffff5 	beq	1001c834 <token_trim_space+0x10>
        ch == '\t' || 
1001c85c:	e55b3005 	ldrb	r3, [fp, #-5]
1001c860:	e353000d 	cmp	r3, #13
1001c864:	0afffff2 	beq	1001c834 <token_trim_space+0x10>
        ch == '\r');

	token_prev_char(self);
1001c868:	e51b0010 	ldr	r0, [fp, #-16]
1001c86c:	ebfffe83 	bl	1001c280 <token_prev_char>
}
1001c870:	e24bd004 	sub	sp, fp, #4
1001c874:	e8bd8800 	pop	{fp, pc}

1001c878 <token_proc_char>:

static char token_proc_char(struct finsh_token* self)
{
1001c878:	e92d4800 	push	{fp, lr}
1001c87c:	e28db004 	add	fp, sp, #4
1001c880:	e24dd018 	sub	sp, sp, #24
1001c884:	e50b0018 	str	r0, [fp, #-24]
	char ch;
	char buf[4], *p;

	p = buf;
1001c888:	e24b3010 	sub	r3, fp, #16
1001c88c:	e50b300c 	str	r3, [fp, #-12]
	ch = token_next_char(self);
1001c890:	e51b0018 	ldr	r0, [fp, #-24]
1001c894:	ebfffe4a 	bl	1001c1c4 <token_next_char>
1001c898:	e1a03000 	mov	r3, r0
1001c89c:	e54b3005 	strb	r3, [fp, #-5]

	if ( ch == '\\' )
1001c8a0:	e55b3005 	ldrb	r3, [fp, #-5]
1001c8a4:	e353005c 	cmp	r3, #92	; 0x5c
1001c8a8:	1a000045 	bne	1001c9c4 <token_proc_char+0x14c>
	{
		ch = token_next_char(self);
1001c8ac:	e51b0018 	ldr	r0, [fp, #-24]
1001c8b0:	ebfffe43 	bl	1001c1c4 <token_next_char>
1001c8b4:	e1a03000 	mov	r3, r0
1001c8b8:	e54b3005 	strb	r3, [fp, #-5]
		switch ( ch )
1001c8bc:	e55b3005 	ldrb	r3, [fp, #-5]
1001c8c0:	e353006e 	cmp	r3, #110	; 0x6e
1001c8c4:	0a00000f 	beq	1001c908 <token_proc_char+0x90>
1001c8c8:	e353006e 	cmp	r3, #110	; 0x6e
1001c8cc:	ca000006 	bgt	1001c8ec <token_proc_char+0x74>
1001c8d0:	e353005c 	cmp	r3, #92	; 0x5c
1001c8d4:	0a00001a 	beq	1001c944 <token_proc_char+0xcc>
1001c8d8:	e3530062 	cmp	r3, #98	; 0x62
1001c8dc:	0a000012 	beq	1001c92c <token_proc_char+0xb4>
1001c8e0:	e3530027 	cmp	r3, #39	; 0x27
1001c8e4:	0a000019 	beq	1001c950 <token_proc_char+0xd8>
1001c8e8:	ea00001b 	b	1001c95c <token_proc_char+0xe4>
1001c8ec:	e3530074 	cmp	r3, #116	; 0x74
1001c8f0:	0a000007 	beq	1001c914 <token_proc_char+0x9c>
1001c8f4:	e3530076 	cmp	r3, #118	; 0x76
1001c8f8:	0a000008 	beq	1001c920 <token_proc_char+0xa8>
1001c8fc:	e3530072 	cmp	r3, #114	; 0x72
1001c900:	0a00000c 	beq	1001c938 <token_proc_char+0xc0>
1001c904:	ea000014 	b	1001c95c <token_proc_char+0xe4>
		{
		case 'n': ch = '\n'; break;
1001c908:	e3a0300a 	mov	r3, #10
1001c90c:	e54b3005 	strb	r3, [fp, #-5]
1001c910:	ea00002b 	b	1001c9c4 <token_proc_char+0x14c>
		case 't': ch = '\t'; break;
1001c914:	e3a03009 	mov	r3, #9
1001c918:	e54b3005 	strb	r3, [fp, #-5]
1001c91c:	ea000028 	b	1001c9c4 <token_proc_char+0x14c>
		case 'v': ch = '\v'; break;
1001c920:	e3a0300b 	mov	r3, #11
1001c924:	e54b3005 	strb	r3, [fp, #-5]
1001c928:	ea000025 	b	1001c9c4 <token_proc_char+0x14c>
		case 'b': ch = '\b'; break;
1001c92c:	e3a03008 	mov	r3, #8
1001c930:	e54b3005 	strb	r3, [fp, #-5]
1001c934:	ea000022 	b	1001c9c4 <token_proc_char+0x14c>
		case 'r': ch = '\r'; break;
1001c938:	e3a0300d 	mov	r3, #13
1001c93c:	e54b3005 	strb	r3, [fp, #-5]
1001c940:	ea00001f 	b	1001c9c4 <token_proc_char+0x14c>
		case '\\': ch = '\\';  break;
1001c944:	e3a0305c 	mov	r3, #92	; 0x5c
1001c948:	e54b3005 	strb	r3, [fp, #-5]
1001c94c:	ea00001c 	b	1001c9c4 <token_proc_char+0x14c>
		case '\'': ch = '\'';  break;
1001c950:	e3a03027 	mov	r3, #39	; 0x27
1001c954:	e54b3005 	strb	r3, [fp, #-5]
1001c958:	ea000019 	b	1001c9c4 <token_proc_char+0x14c>
		default :
			while ( is_digit(ch) )/*for '\113' char*/
1001c95c:	ea000008 	b	1001c984 <token_proc_char+0x10c>
			{
				ch = token_next_char(self);
1001c960:	e51b0018 	ldr	r0, [fp, #-24]
1001c964:	ebfffe16 	bl	1001c1c4 <token_next_char>
1001c968:	e1a03000 	mov	r3, r0
1001c96c:	e54b3005 	strb	r3, [fp, #-5]
				*p++ = ch;
1001c970:	e51b300c 	ldr	r3, [fp, #-12]
1001c974:	e2832001 	add	r2, r3, #1
1001c978:	e50b200c 	str	r2, [fp, #-12]
1001c97c:	e55b2005 	ldrb	r2, [fp, #-5]
1001c980:	e5c32000 	strb	r2, [r3]
		case 'b': ch = '\b'; break;
		case 'r': ch = '\r'; break;
		case '\\': ch = '\\';  break;
		case '\'': ch = '\'';  break;
		default :
			while ( is_digit(ch) )/*for '\113' char*/
1001c984:	e55b3005 	ldrb	r3, [fp, #-5]
1001c988:	e353002f 	cmp	r3, #47	; 0x2f
1001c98c:	9a000002 	bls	1001c99c <token_proc_char+0x124>
1001c990:	e55b3005 	ldrb	r3, [fp, #-5]
1001c994:	e3530039 	cmp	r3, #57	; 0x39
1001c998:	9afffff0 	bls	1001c960 <token_proc_char+0xe8>
			{
				ch = token_next_char(self);
				*p++ = ch;
			}

			token_prev_char(self);
1001c99c:	e51b0018 	ldr	r0, [fp, #-24]
1001c9a0:	ebfffe36 	bl	1001c280 <token_prev_char>
			*p = '\0';
1001c9a4:	e51b300c 	ldr	r3, [fp, #-12]
1001c9a8:	e3a02000 	mov	r2, #0
1001c9ac:	e5c32000 	strb	r2, [r3]
			ch = atoi(p);
1001c9b0:	e51b000c 	ldr	r0, [fp, #-12]
1001c9b4:	fa00039c 	blx	1001d82c <atoi>
1001c9b8:	e1a03000 	mov	r3, r0
1001c9bc:	e54b3005 	strb	r3, [fp, #-5]
			break;
1001c9c0:	e1a00000 	nop			; (mov r0, r0)
		}
	}

	if ( token_next_char(self) != '\'' )
1001c9c4:	e51b0018 	ldr	r0, [fp, #-24]
1001c9c8:	ebfffdfd 	bl	1001c1c4 <token_next_char>
1001c9cc:	e1a03000 	mov	r3, r0
1001c9d0:	e3530027 	cmp	r3, #39	; 0x27
1001c9d4:	0a000005 	beq	1001c9f0 <token_proc_char+0x178>
	{
		token_prev_char(self);
1001c9d8:	e51b0018 	ldr	r0, [fp, #-24]
1001c9dc:	ebfffe27 	bl	1001c280 <token_prev_char>
		finsh_error_set(FINSH_ERROR_EXPECT_CHAR);
1001c9e0:	e3a00009 	mov	r0, #9
1001c9e4:	ebffebb2 	bl	100178b4 <finsh_error_set>
		return ch;
1001c9e8:	e55b3005 	ldrb	r3, [fp, #-5]
1001c9ec:	ea000000 	b	1001c9f4 <token_proc_char+0x17c>
	}

	return ch;
1001c9f0:	e55b3005 	ldrb	r3, [fp, #-5]
}
1001c9f4:	e1a00003 	mov	r0, r3
1001c9f8:	e24bd004 	sub	sp, fp, #4
1001c9fc:	e8bd8800 	pop	{fp, pc}

1001ca00 <token_proc_string>:

static u_char* token_proc_string(struct finsh_token* self)
{
1001ca00:	e92d4800 	push	{fp, lr}
1001ca04:	e28db004 	add	fp, sp, #4
1001ca08:	e24dd010 	sub	sp, sp, #16
1001ca0c:	e50b0010 	str	r0, [fp, #-16]
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
1001ca10:	e51b3010 	ldr	r3, [fp, #-16]
1001ca14:	e2833010 	add	r3, r3, #16
1001ca18:	e50b3008 	str	r3, [fp, #-8]
1001ca1c:	ea000021 	b	1001caa8 <token_proc_string+0xa8>
	{
		char ch = token_next_char(self);
1001ca20:	e51b0010 	ldr	r0, [fp, #-16]
1001ca24:	ebfffde6 	bl	1001c1c4 <token_next_char>
1001ca28:	e1a03000 	mov	r3, r0
1001ca2c:	e54b3009 	strb	r3, [fp, #-9]

		if ( is_eof(self) )
1001ca30:	e51b3010 	ldr	r3, [fp, #-16]
1001ca34:	e5d33000 	ldrb	r3, [r3]
1001ca38:	e3530000 	cmp	r3, #0
1001ca3c:	0a000003 	beq	1001ca50 <token_proc_string+0x50>
		{
			finsh_error_set(FINSH_ERROR_UNEXPECT_END);
1001ca40:	e3a0000a 	mov	r0, #10
1001ca44:	ebffeb9a 	bl	100178b4 <finsh_error_set>
			return NULL;;
1001ca48:	e3a03000 	mov	r3, #0
1001ca4c:	ea00001c 	b	1001cac4 <token_proc_string+0xc4>
		}
		if ( ch == '\\' )
1001ca50:	e55b3009 	ldrb	r3, [fp, #-9]
1001ca54:	e353005c 	cmp	r3, #92	; 0x5c
1001ca58:	1a000004 	bne	1001ca70 <token_proc_string+0x70>
		{
			ch = token_proc_escape(self);
1001ca5c:	e51b0010 	ldr	r0, [fp, #-16]
1001ca60:	eb00001a 	bl	1001cad0 <token_proc_escape>
1001ca64:	e1a03000 	mov	r3, r0
1001ca68:	e54b3009 	strb	r3, [fp, #-9]
1001ca6c:	ea000008 	b	1001ca94 <token_proc_string+0x94>
		}
		else if ( ch == '"' )/*end of string.*/
1001ca70:	e55b3009 	ldrb	r3, [fp, #-9]
1001ca74:	e3530022 	cmp	r3, #34	; 0x22
1001ca78:	1a000005 	bne	1001ca94 <token_proc_string+0x94>
		{
			*p = '\0';
1001ca7c:	e51b3008 	ldr	r3, [fp, #-8]
1001ca80:	e3a02000 	mov	r2, #0
1001ca84:	e5c32000 	strb	r2, [r3]
			return self->string;
1001ca88:	e51b3010 	ldr	r3, [fp, #-16]
1001ca8c:	e2833010 	add	r3, r3, #16
1001ca90:	ea00000b 	b	1001cac4 <token_proc_string+0xc4>
		}

		*p++ = ch;
1001ca94:	e51b3008 	ldr	r3, [fp, #-8]
1001ca98:	e2832001 	add	r2, r3, #1
1001ca9c:	e50b2008 	str	r2, [fp, #-8]
1001caa0:	e55b2009 	ldrb	r2, [fp, #-9]
1001caa4:	e5c32000 	strb	r2, [r3]

static u_char* token_proc_string(struct finsh_token* self)
{
	u_char* p;

	for ( p = &self->string[0]; p - &(self->string[0]) < FINSH_STRING_MAX; )
1001caa8:	e51b3008 	ldr	r3, [fp, #-8]
1001caac:	e51b2010 	ldr	r2, [fp, #-16]
1001cab0:	e2822010 	add	r2, r2, #16
1001cab4:	e0623003 	rsb	r3, r2, r3
1001cab8:	e353007f 	cmp	r3, #127	; 0x7f
1001cabc:	daffffd7 	ble	1001ca20 <token_proc_string+0x20>
		}

		*p++ = ch;
	}

	return NULL;
1001cac0:	e3a03000 	mov	r3, #0
}
1001cac4:	e1a00003 	mov	r0, r3
1001cac8:	e24bd004 	sub	sp, fp, #4
1001cacc:	e8bd8800 	pop	{fp, pc}

1001cad0 <token_proc_escape>:

static int token_proc_escape(struct finsh_token* self)
{
1001cad0:	e92d4800 	push	{fp, lr}
1001cad4:	e28db004 	add	fp, sp, #4
1001cad8:	e24dd010 	sub	sp, sp, #16
1001cadc:	e50b0010 	str	r0, [fp, #-16]
	char ch;
	int result=0;
1001cae0:	e3a03000 	mov	r3, #0
1001cae4:	e50b300c 	str	r3, [fp, #-12]

	ch = token_next_char(self);
1001cae8:	e51b0010 	ldr	r0, [fp, #-16]
1001caec:	ebfffdb4 	bl	1001c1c4 <token_next_char>
1001caf0:	e1a03000 	mov	r3, r0
1001caf4:	e54b3005 	strb	r3, [fp, #-5]
	switch (ch)
1001caf8:	e55b3005 	ldrb	r3, [fp, #-5]
1001cafc:	e2433061 	sub	r3, r3, #97	; 0x61
1001cb00:	e3530017 	cmp	r3, #23
1001cb04:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
1001cb08:	ea000044 	b	1001cc20 <token_proc_escape+0x150>
1001cb0c:	1001cbb4 	.word	0x1001cbb4
1001cb10:	1001cb90 	.word	0x1001cb90
1001cb14:	1001cc20 	.word	0x1001cc20
1001cb18:	1001cc20 	.word	0x1001cc20
1001cb1c:	1001cc20 	.word	0x1001cc20
1001cb20:	1001cba8 	.word	0x1001cba8
1001cb24:	1001cc20 	.word	0x1001cc20
1001cb28:	1001cc20 	.word	0x1001cc20
1001cb2c:	1001cc20 	.word	0x1001cc20
1001cb30:	1001cc20 	.word	0x1001cc20
1001cb34:	1001cc20 	.word	0x1001cc20
1001cb38:	1001cc20 	.word	0x1001cc20
1001cb3c:	1001cc20 	.word	0x1001cc20
1001cb40:	1001cb6c 	.word	0x1001cb6c
1001cb44:	1001cc20 	.word	0x1001cc20
1001cb48:	1001cc20 	.word	0x1001cc20
1001cb4c:	1001cc20 	.word	0x1001cc20
1001cb50:	1001cb9c 	.word	0x1001cb9c
1001cb54:	1001cc20 	.word	0x1001cc20
1001cb58:	1001cb78 	.word	0x1001cb78
1001cb5c:	1001cc20 	.word	0x1001cc20
1001cb60:	1001cb84 	.word	0x1001cb84
1001cb64:	1001cc20 	.word	0x1001cc20
1001cb68:	1001cbc0 	.word	0x1001cbc0
	{
	case 'n':
		result = '\n';
1001cb6c:	e3a0300a 	mov	r3, #10
1001cb70:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cb74:	ea000042 	b	1001cc84 <token_proc_escape+0x1b4>
	case 't':
		result = '\t';
1001cb78:	e3a03009 	mov	r3, #9
1001cb7c:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cb80:	ea00003f 	b	1001cc84 <token_proc_escape+0x1b4>
	case 'v':
		result = '\v';
1001cb84:	e3a0300b 	mov	r3, #11
1001cb88:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cb8c:	ea00003c 	b	1001cc84 <token_proc_escape+0x1b4>
	case 'b':
		result = '\b';
1001cb90:	e3a03008 	mov	r3, #8
1001cb94:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cb98:	ea000039 	b	1001cc84 <token_proc_escape+0x1b4>
	case 'r':
		result = '\r';
1001cb9c:	e3a0300d 	mov	r3, #13
1001cba0:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cba4:	ea000036 	b	1001cc84 <token_proc_escape+0x1b4>
	case 'f':
		result = '\f';
1001cba8:	e3a0300c 	mov	r3, #12
1001cbac:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cbb0:	ea000033 	b	1001cc84 <token_proc_escape+0x1b4>
	case 'a':
		result = '\007';
1001cbb4:	e3a03007 	mov	r3, #7
1001cbb8:	e50b300c 	str	r3, [fp, #-12]
		break;
1001cbbc:	ea000030 	b	1001cc84 <token_proc_escape+0x1b4>
	case 'x':
		result = 0;
1001cbc0:	e3a03000 	mov	r3, #0
1001cbc4:	e50b300c 	str	r3, [fp, #-12]
		ch  = token_next_char(self);
1001cbc8:	e51b0010 	ldr	r0, [fp, #-16]
1001cbcc:	ebfffd7c 	bl	1001c1c4 <token_next_char>
1001cbd0:	e1a03000 	mov	r3, r0
1001cbd4:	e54b3005 	strb	r3, [fp, #-5]
		while ( (ch - '0')<16u )
1001cbd8:	ea000009 	b	1001cc04 <token_proc_escape+0x134>
		{
			result = result*16 + ch - '0';
1001cbdc:	e51b300c 	ldr	r3, [fp, #-12]
1001cbe0:	e1a02203 	lsl	r2, r3, #4
1001cbe4:	e55b3005 	ldrb	r3, [fp, #-5]
1001cbe8:	e0823003 	add	r3, r2, r3
1001cbec:	e2433030 	sub	r3, r3, #48	; 0x30
1001cbf0:	e50b300c 	str	r3, [fp, #-12]
			ch = token_next_char(self);
1001cbf4:	e51b0010 	ldr	r0, [fp, #-16]
1001cbf8:	ebfffd71 	bl	1001c1c4 <token_next_char>
1001cbfc:	e1a03000 	mov	r3, r0
1001cc00:	e54b3005 	strb	r3, [fp, #-5]
		result = '\007';
		break;
	case 'x':
		result = 0;
		ch  = token_next_char(self);
		while ( (ch - '0')<16u )
1001cc04:	e55b3005 	ldrb	r3, [fp, #-5]
1001cc08:	e2433030 	sub	r3, r3, #48	; 0x30
1001cc0c:	e353000f 	cmp	r3, #15
1001cc10:	9afffff1 	bls	1001cbdc <token_proc_escape+0x10c>
		{
			result = result*16 + ch - '0';
			ch = token_next_char(self);
		}
		token_prev_char(self);
1001cc14:	e51b0010 	ldr	r0, [fp, #-16]
1001cc18:	ebfffd98 	bl	1001c280 <token_prev_char>
		break;
1001cc1c:	ea000018 	b	1001cc84 <token_proc_escape+0x1b4>
	default:
		if ( (ch - '0') < 8u)
1001cc20:	e55b3005 	ldrb	r3, [fp, #-5]
1001cc24:	e2433030 	sub	r3, r3, #48	; 0x30
1001cc28:	e3530007 	cmp	r3, #7
1001cc2c:	8a000013 	bhi	1001cc80 <token_proc_escape+0x1b0>
		{
			result = 0;
1001cc30:	e3a03000 	mov	r3, #0
1001cc34:	e50b300c 	str	r3, [fp, #-12]
			while ( (ch - '0') < 8u )
1001cc38:	ea000009 	b	1001cc64 <token_proc_escape+0x194>
			{
				result = result*8 + ch - '0';
1001cc3c:	e51b300c 	ldr	r3, [fp, #-12]
1001cc40:	e1a02183 	lsl	r2, r3, #3
1001cc44:	e55b3005 	ldrb	r3, [fp, #-5]
1001cc48:	e0823003 	add	r3, r2, r3
1001cc4c:	e2433030 	sub	r3, r3, #48	; 0x30
1001cc50:	e50b300c 	str	r3, [fp, #-12]
				ch = token_next_char(self);
1001cc54:	e51b0010 	ldr	r0, [fp, #-16]
1001cc58:	ebfffd59 	bl	1001c1c4 <token_next_char>
1001cc5c:	e1a03000 	mov	r3, r0
1001cc60:	e54b3005 	strb	r3, [fp, #-5]
		break;
	default:
		if ( (ch - '0') < 8u)
		{
			result = 0;
			while ( (ch - '0') < 8u )
1001cc64:	e55b3005 	ldrb	r3, [fp, #-5]
1001cc68:	e2433030 	sub	r3, r3, #48	; 0x30
1001cc6c:	e3530007 	cmp	r3, #7
1001cc70:	9afffff1 	bls	1001cc3c <token_proc_escape+0x16c>
			{
				result = result*8 + ch - '0';
				ch = token_next_char(self);
			}

			token_prev_char(self);
1001cc74:	e51b0010 	ldr	r0, [fp, #-16]
1001cc78:	ebfffd80 	bl	1001c280 <token_prev_char>
		}
		break;
1001cc7c:	eaffffff 	b	1001cc80 <token_proc_escape+0x1b0>
1001cc80:	e1a00000 	nop			; (mov r0, r0)
	}

	return result;
1001cc84:	e51b300c 	ldr	r3, [fp, #-12]
}
1001cc88:	e1a00003 	mov	r0, r3
1001cc8c:	e24bd004 	sub	sp, fp, #4
1001cc90:	e8bd8800 	pop	{fp, pc}

1001cc94 <token_proc_number>:

/*
(0|0x|0X|0b|0B)number+(l|L)
*/
static void token_proc_number(struct finsh_token* self)
{
1001cc94:	e92d4800 	push	{fp, lr}
1001cc98:	e28db004 	add	fp, sp, #4
1001cc9c:	e24dd098 	sub	sp, sp, #152	; 0x98
1001cca0:	e50b0098 	str	r0, [fp, #-152]	; 0x98
	char ch;
	char *p, buf[128];
	long value;

	value = 0;
1001cca4:	e3a03000 	mov	r3, #0
1001cca8:	e50b3010 	str	r3, [fp, #-16]
	p = buf;
1001ccac:	e24b3094 	sub	r3, fp, #148	; 0x94
1001ccb0:	e50b300c 	str	r3, [fp, #-12]

	ch  = token_next_char(self);
1001ccb4:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001ccb8:	ebfffd41 	bl	1001c1c4 <token_next_char>
1001ccbc:	e1a03000 	mov	r3, r0
1001ccc0:	e54b3005 	strb	r3, [fp, #-5]
	if ( ch == '0' )
1001ccc4:	e55b3005 	ldrb	r3, [fp, #-5]
1001ccc8:	e3530030 	cmp	r3, #48	; 0x30
1001cccc:	1a00007f 	bne	1001ced0 <token_proc_number+0x23c>
	{
		int b;
		ch = token_next_char(self);
1001ccd0:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001ccd4:	ebfffd3a 	bl	1001c1c4 <token_next_char>
1001ccd8:	e1a03000 	mov	r3, r0
1001ccdc:	e54b3005 	strb	r3, [fp, #-5]
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
1001cce0:	e55b3005 	ldrb	r3, [fp, #-5]
1001cce4:	e3530078 	cmp	r3, #120	; 0x78
1001cce8:	0a000002 	beq	1001ccf8 <token_proc_number+0x64>
1001ccec:	e55b3005 	ldrb	r3, [fp, #-5]
1001ccf0:	e3530058 	cmp	r3, #88	; 0x58
1001ccf4:	1a00001f 	bne	1001cd78 <token_proc_number+0xe4>
		{
			b = 16;
1001ccf8:	e3a03010 	mov	r3, #16
1001ccfc:	e50b3014 	str	r3, [fp, #-20]
			ch = token_next_char(self);
1001cd00:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001cd04:	ebfffd2e 	bl	1001c1c4 <token_next_char>
1001cd08:	e1a03000 	mov	r3, r0
1001cd0c:	e54b3005 	strb	r3, [fp, #-5]
			while ( is_digit(ch) || is_alpha(ch) )
1001cd10:	ea000008 	b	1001cd38 <token_proc_number+0xa4>
			{
				*p++ = ch;
1001cd14:	e51b300c 	ldr	r3, [fp, #-12]
1001cd18:	e2832001 	add	r2, r3, #1
1001cd1c:	e50b200c 	str	r2, [fp, #-12]
1001cd20:	e55b2005 	ldrb	r2, [fp, #-5]
1001cd24:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
1001cd28:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001cd2c:	ebfffd24 	bl	1001c1c4 <token_next_char>
1001cd30:	e1a03000 	mov	r3, r0
1001cd34:	e54b3005 	strb	r3, [fp, #-5]
		ch = token_next_char(self);
		if ( ch == 'x' || ch == 'X' )/*it's a hex number*/
		{
			b = 16;
			ch = token_next_char(self);
			while ( is_digit(ch) || is_alpha(ch) )
1001cd38:	e55b3005 	ldrb	r3, [fp, #-5]
1001cd3c:	e353002f 	cmp	r3, #47	; 0x2f
1001cd40:	9a000002 	bls	1001cd50 <token_proc_number+0xbc>
1001cd44:	e55b3005 	ldrb	r3, [fp, #-5]
1001cd48:	e3530039 	cmp	r3, #57	; 0x39
1001cd4c:	9afffff0 	bls	1001cd14 <token_proc_number+0x80>
1001cd50:	e55b3005 	ldrb	r3, [fp, #-5]
1001cd54:	e3833020 	orr	r3, r3, #32
1001cd58:	e6ef3073 	uxtb	r3, r3
1001cd5c:	e2433061 	sub	r3, r3, #97	; 0x61
1001cd60:	e3530019 	cmp	r3, #25
1001cd64:	9affffea 	bls	1001cd14 <token_proc_number+0x80>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
1001cd68:	e51b300c 	ldr	r3, [fp, #-12]
1001cd6c:	e3a02000 	mov	r2, #0
1001cd70:	e5c32000 	strb	r2, [r3]
1001cd74:	ea000044 	b	1001ce8c <token_proc_number+0x1f8>
		}
		else if ( ch == 'b' || ch == 'B' )
1001cd78:	e55b3005 	ldrb	r3, [fp, #-5]
1001cd7c:	e3530062 	cmp	r3, #98	; 0x62
1001cd80:	0a000002 	beq	1001cd90 <token_proc_number+0xfc>
1001cd84:	e55b3005 	ldrb	r3, [fp, #-5]
1001cd88:	e3530042 	cmp	r3, #66	; 0x42
1001cd8c:	1a000019 	bne	1001cdf8 <token_proc_number+0x164>
		{
			b = 2;
1001cd90:	e3a03002 	mov	r3, #2
1001cd94:	e50b3014 	str	r3, [fp, #-20]
			ch = token_next_char(self);
1001cd98:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001cd9c:	ebfffd08 	bl	1001c1c4 <token_next_char>
1001cda0:	e1a03000 	mov	r3, r0
1001cda4:	e54b3005 	strb	r3, [fp, #-5]
			while ( (ch=='0')||(ch=='1') )
1001cda8:	ea000008 	b	1001cdd0 <token_proc_number+0x13c>
			{
				*p++ = ch;
1001cdac:	e51b300c 	ldr	r3, [fp, #-12]
1001cdb0:	e2832001 	add	r2, r3, #1
1001cdb4:	e50b200c 	str	r2, [fp, #-12]
1001cdb8:	e55b2005 	ldrb	r2, [fp, #-5]
1001cdbc:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
1001cdc0:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001cdc4:	ebfffcfe 	bl	1001c1c4 <token_next_char>
1001cdc8:	e1a03000 	mov	r3, r0
1001cdcc:	e54b3005 	strb	r3, [fp, #-5]
		}
		else if ( ch == 'b' || ch == 'B' )
		{
			b = 2;
			ch = token_next_char(self);
			while ( (ch=='0')||(ch=='1') )
1001cdd0:	e55b3005 	ldrb	r3, [fp, #-5]
1001cdd4:	e3530030 	cmp	r3, #48	; 0x30
1001cdd8:	0afffff3 	beq	1001cdac <token_proc_number+0x118>
1001cddc:	e55b3005 	ldrb	r3, [fp, #-5]
1001cde0:	e3530031 	cmp	r3, #49	; 0x31
1001cde4:	0afffff0 	beq	1001cdac <token_proc_number+0x118>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
1001cde8:	e51b300c 	ldr	r3, [fp, #-12]
1001cdec:	e3a02000 	mov	r2, #0
1001cdf0:	e5c32000 	strb	r2, [r3]
1001cdf4:	ea000024 	b	1001ce8c <token_proc_number+0x1f8>
		}
		else if ( '0' <= ch && ch <= '7' )
1001cdf8:	e55b3005 	ldrb	r3, [fp, #-5]
1001cdfc:	e353002f 	cmp	r3, #47	; 0x2f
1001ce00:	9a000018 	bls	1001ce68 <token_proc_number+0x1d4>
1001ce04:	e55b3005 	ldrb	r3, [fp, #-5]
1001ce08:	e3530037 	cmp	r3, #55	; 0x37
1001ce0c:	8a000015 	bhi	1001ce68 <token_proc_number+0x1d4>
		{
			b = 8;
1001ce10:	e3a03008 	mov	r3, #8
1001ce14:	e50b3014 	str	r3, [fp, #-20]
			while ( '0' <= ch && ch <= '7' )
1001ce18:	ea000008 	b	1001ce40 <token_proc_number+0x1ac>
			{
				*p++ = ch;
1001ce1c:	e51b300c 	ldr	r3, [fp, #-12]
1001ce20:	e2832001 	add	r2, r3, #1
1001ce24:	e50b200c 	str	r2, [fp, #-12]
1001ce28:	e55b2005 	ldrb	r2, [fp, #-5]
1001ce2c:	e5c32000 	strb	r2, [r3]
				ch = token_next_char(self);
1001ce30:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001ce34:	ebfffce2 	bl	1001c1c4 <token_next_char>
1001ce38:	e1a03000 	mov	r3, r0
1001ce3c:	e54b3005 	strb	r3, [fp, #-5]
			*p = '\0';
		}
		else if ( '0' <= ch && ch <= '7' )
		{
			b = 8;
			while ( '0' <= ch && ch <= '7' )
1001ce40:	e55b3005 	ldrb	r3, [fp, #-5]
1001ce44:	e353002f 	cmp	r3, #47	; 0x2f
1001ce48:	9a000002 	bls	1001ce58 <token_proc_number+0x1c4>
1001ce4c:	e55b3005 	ldrb	r3, [fp, #-5]
1001ce50:	e3530037 	cmp	r3, #55	; 0x37
1001ce54:	9afffff0 	bls	1001ce1c <token_proc_number+0x188>
			{
				*p++ = ch;
				ch = token_next_char(self);
			}

			*p = '\0';
1001ce58:	e51b300c 	ldr	r3, [fp, #-12]
1001ce5c:	e3a02000 	mov	r2, #0
1001ce60:	e5c32000 	strb	r2, [r3]
1001ce64:	ea000008 	b	1001ce8c <token_proc_number+0x1f8>
		}
		else
		{
			token_prev_char(self);
1001ce68:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001ce6c:	ebfffd03 	bl	1001c280 <token_prev_char>

			/* made as 0 value */
			self->value.int_value = 0;
1001ce70:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001ce74:	e3a02000 	mov	r2, #0
1001ce78:	e583200c 	str	r2, [r3, #12]
			self->current_token = finsh_token_type_value_int;
1001ce7c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001ce80:	e3a0201b 	mov	r2, #27
1001ce84:	e5c32008 	strb	r2, [r3, #8]
			return;
1001ce88:	ea000035 	b	1001cf64 <token_proc_number+0x2d0>
		}

		self->value.int_value = token_spec_number(buf, strlen(buf), b);
1001ce8c:	e24b3094 	sub	r3, fp, #148	; 0x94
1001ce90:	e1a00003 	mov	r0, r3
1001ce94:	fa000375 	blx	1001dc70 <strlen>
1001ce98:	e1a03000 	mov	r3, r0
1001ce9c:	e1a02003 	mov	r2, r3
1001cea0:	e24b3094 	sub	r3, fp, #148	; 0x94
1001cea4:	e1a00003 	mov	r0, r3
1001cea8:	e1a01002 	mov	r1, r2
1001ceac:	e51b2014 	ldr	r2, [fp, #-20]
1001ceb0:	eb00002d 	bl	1001cf6c <token_spec_number>
1001ceb4:	e1a02000 	mov	r2, r0
1001ceb8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001cebc:	e583200c 	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
1001cec0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001cec4:	e3a0201b 	mov	r2, #27
1001cec8:	e5c32008 	strb	r2, [r3, #8]
1001cecc:	ea000018 	b	1001cf34 <token_proc_number+0x2a0>
	}
	else
	{
		while ( is_digit(ch) )
1001ced0:	ea00000b 	b	1001cf04 <token_proc_number+0x270>
		{
			value = value*10 + ( ch - '0' );
1001ced4:	e51b3010 	ldr	r3, [fp, #-16]
1001ced8:	e1a03083 	lsl	r3, r3, #1
1001cedc:	e1a02103 	lsl	r2, r3, #2
1001cee0:	e0832002 	add	r2, r3, r2
1001cee4:	e55b3005 	ldrb	r3, [fp, #-5]
1001cee8:	e2433030 	sub	r3, r3, #48	; 0x30
1001ceec:	e0823003 	add	r3, r2, r3
1001cef0:	e50b3010 	str	r3, [fp, #-16]
			ch = token_next_char(self);
1001cef4:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001cef8:	ebfffcb1 	bl	1001c1c4 <token_next_char>
1001cefc:	e1a03000 	mov	r3, r0
1001cf00:	e54b3005 	strb	r3, [fp, #-5]
		self->value.int_value = token_spec_number(buf, strlen(buf), b);
		self->current_token = finsh_token_type_value_int;
	}
	else
	{
		while ( is_digit(ch) )
1001cf04:	e55b3005 	ldrb	r3, [fp, #-5]
1001cf08:	e353002f 	cmp	r3, #47	; 0x2f
1001cf0c:	9a000002 	bls	1001cf1c <token_proc_number+0x288>
1001cf10:	e55b3005 	ldrb	r3, [fp, #-5]
1001cf14:	e3530039 	cmp	r3, #57	; 0x39
1001cf18:	9affffed 	bls	1001ced4 <token_proc_number+0x240>
		{
			value = value*10 + ( ch - '0' );
			ch = token_next_char(self);
		}

		self->value.int_value = value;
1001cf1c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001cf20:	e51b2010 	ldr	r2, [fp, #-16]
1001cf24:	e583200c 	str	r2, [r3, #12]
		self->current_token = finsh_token_type_value_int;
1001cf28:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001cf2c:	e3a0201b 	mov	r2, #27
1001cf30:	e5c32008 	strb	r2, [r3, #8]
	}

	switch ( ch )
1001cf34:	e55b3005 	ldrb	r3, [fp, #-5]
1001cf38:	e353004c 	cmp	r3, #76	; 0x4c
1001cf3c:	0a000001 	beq	1001cf48 <token_proc_number+0x2b4>
1001cf40:	e353006c 	cmp	r3, #108	; 0x6c
1001cf44:	1a000003 	bne	1001cf58 <token_proc_number+0x2c4>
	{
	case 'l':
	case 'L':
		self->current_token = finsh_token_type_value_long;
1001cf48:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
1001cf4c:	e3a0201c 	mov	r2, #28
1001cf50:	e5c32008 	strb	r2, [r3, #8]
		break;
1001cf54:	ea000002 	b	1001cf64 <token_proc_number+0x2d0>

	default:
		token_prev_char(self);
1001cf58:	e51b0098 	ldr	r0, [fp, #-152]	; 0x98
1001cf5c:	ebfffcc7 	bl	1001c280 <token_prev_char>
		break;
1001cf60:	e1a00000 	nop			; (mov r0, r0)
	}
}
1001cf64:	e24bd004 	sub	sp, fp, #4
1001cf68:	e8bd8800 	pop	{fp, pc}

1001cf6c <token_spec_number>:

/*use 64 bit number*/
#define BN_SIZE 2

static long token_spec_number(char* string, int length, int b)
{
1001cf6c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
1001cf70:	e28db000 	add	fp, sp, #0
1001cf74:	e24dd03c 	sub	sp, sp, #60	; 0x3c
1001cf78:	e50b0030 	str	r0, [fp, #-48]	; 0x30
1001cf7c:	e50b1034 	str	r1, [fp, #-52]	; 0x34
1001cf80:	e50b2038 	str	r2, [fp, #-56]	; 0x38
	char* p;
	int t;
	int i, j, shift=1;
1001cf84:	e3a03001 	mov	r3, #1
1001cf88:	e50b3018 	str	r3, [fp, #-24]
	unsigned int bn[BN_SIZE], v;
	long d;

	p = string;
1001cf8c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
1001cf90:	e50b3008 	str	r3, [fp, #-8]
	i = 0;
1001cf94:	e3a03000 	mov	r3, #0
1001cf98:	e50b3010 	str	r3, [fp, #-16]

	switch ( b )
1001cf9c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
1001cfa0:	e3530008 	cmp	r3, #8
1001cfa4:	0a000007 	beq	1001cfc8 <token_spec_number+0x5c>
1001cfa8:	e3530010 	cmp	r3, #16
1001cfac:	0a000002 	beq	1001cfbc <token_spec_number+0x50>
1001cfb0:	e3530002 	cmp	r3, #2
1001cfb4:	0a000006 	beq	1001cfd4 <token_spec_number+0x68>
		break;
	case 8:  shift = 3;
		break;
	case 2:  shift = 1;
		break;
	default: break;
1001cfb8:	ea000008 	b	1001cfe0 <token_spec_number+0x74>
	p = string;
	i = 0;

	switch ( b )
	{
	case 16: shift = 4;
1001cfbc:	e3a03004 	mov	r3, #4
1001cfc0:	e50b3018 	str	r3, [fp, #-24]
		break;
1001cfc4:	ea000005 	b	1001cfe0 <token_spec_number+0x74>
	case 8:  shift = 3;
1001cfc8:	e3a03003 	mov	r3, #3
1001cfcc:	e50b3018 	str	r3, [fp, #-24]
		break;
1001cfd0:	ea000002 	b	1001cfe0 <token_spec_number+0x74>
	case 2:  shift = 1;
1001cfd4:	e3a03001 	mov	r3, #1
1001cfd8:	e50b3018 	str	r3, [fp, #-24]
		break;
1001cfdc:	e1a00000 	nop			; (mov r0, r0)
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;
1001cfe0:	e3a03000 	mov	r3, #0
1001cfe4:	e50b3014 	str	r3, [fp, #-20]
1001cfe8:	ea000008 	b	1001d010 <token_spec_number+0xa4>
1001cfec:	e51b3014 	ldr	r3, [fp, #-20]
1001cff0:	e1a03103 	lsl	r3, r3, #2
1001cff4:	e24b2004 	sub	r2, fp, #4
1001cff8:	e0823003 	add	r3, r2, r3
1001cffc:	e3a02000 	mov	r2, #0
1001d000:	e5032024 	str	r2, [r3, #-36]	; 0x24
1001d004:	e51b3014 	ldr	r3, [fp, #-20]
1001d008:	e2833001 	add	r3, r3, #1
1001d00c:	e50b3014 	str	r3, [fp, #-20]
1001d010:	e51b3014 	ldr	r3, [fp, #-20]
1001d014:	e3530001 	cmp	r3, #1
1001d018:	dafffff3 	ble	1001cfec <token_spec_number+0x80>

	while ( i<length )
1001d01c:	ea00003c 	b	1001d114 <token_spec_number+0x1a8>
	{
		t = *p++;
1001d020:	e51b3008 	ldr	r3, [fp, #-8]
1001d024:	e2832001 	add	r2, r3, #1
1001d028:	e50b2008 	str	r2, [fp, #-8]
1001d02c:	e5d33000 	ldrb	r3, [r3]
1001d030:	e50b300c 	str	r3, [fp, #-12]
		if ( t>='a' && t <='f' )
1001d034:	e51b300c 	ldr	r3, [fp, #-12]
1001d038:	e3530060 	cmp	r3, #96	; 0x60
1001d03c:	da000006 	ble	1001d05c <token_spec_number+0xf0>
1001d040:	e51b300c 	ldr	r3, [fp, #-12]
1001d044:	e3530066 	cmp	r3, #102	; 0x66
1001d048:	ca000003 	bgt	1001d05c <token_spec_number+0xf0>
		{
			t = t - 'a' +10;
1001d04c:	e51b300c 	ldr	r3, [fp, #-12]
1001d050:	e2433057 	sub	r3, r3, #87	; 0x57
1001d054:	e50b300c 	str	r3, [fp, #-12]
1001d058:	ea00000c 	b	1001d090 <token_spec_number+0x124>
		}
		else if ( t >='A' && t <='F' )
1001d05c:	e51b300c 	ldr	r3, [fp, #-12]
1001d060:	e3530040 	cmp	r3, #64	; 0x40
1001d064:	da000006 	ble	1001d084 <token_spec_number+0x118>
1001d068:	e51b300c 	ldr	r3, [fp, #-12]
1001d06c:	e3530046 	cmp	r3, #70	; 0x46
1001d070:	ca000003 	bgt	1001d084 <token_spec_number+0x118>
		{
			t = t - 'A' +10;
1001d074:	e51b300c 	ldr	r3, [fp, #-12]
1001d078:	e2433037 	sub	r3, r3, #55	; 0x37
1001d07c:	e50b300c 	str	r3, [fp, #-12]
1001d080:	ea000002 	b	1001d090 <token_spec_number+0x124>
		}
		else t = t - '0';
1001d084:	e51b300c 	ldr	r3, [fp, #-12]
1001d088:	e2433030 	sub	r3, r3, #48	; 0x30
1001d08c:	e50b300c 	str	r3, [fp, #-12]

		for ( j=0; j<BN_SIZE ; j++)
1001d090:	e3a03000 	mov	r3, #0
1001d094:	e50b3014 	str	r3, [fp, #-20]
1001d098:	ea000017 	b	1001d0fc <token_spec_number+0x190>
		{
			v = bn[j];
1001d09c:	e51b3014 	ldr	r3, [fp, #-20]
1001d0a0:	e1a03103 	lsl	r3, r3, #2
1001d0a4:	e24b2004 	sub	r2, fp, #4
1001d0a8:	e0823003 	add	r3, r2, r3
1001d0ac:	e5133024 	ldr	r3, [r3, #-36]	; 0x24
1001d0b0:	e50b301c 	str	r3, [fp, #-28]
			bn[j] = (v<<shift) | t;
1001d0b4:	e51b201c 	ldr	r2, [fp, #-28]
1001d0b8:	e51b3018 	ldr	r3, [fp, #-24]
1001d0bc:	e1a02312 	lsl	r2, r2, r3
1001d0c0:	e51b300c 	ldr	r3, [fp, #-12]
1001d0c4:	e1822003 	orr	r2, r2, r3
1001d0c8:	e51b3014 	ldr	r3, [fp, #-20]
1001d0cc:	e1a03103 	lsl	r3, r3, #2
1001d0d0:	e24b1004 	sub	r1, fp, #4
1001d0d4:	e0813003 	add	r3, r1, r3
1001d0d8:	e5032024 	str	r2, [r3, #-36]	; 0x24
			t = v >> (32 - shift);
1001d0dc:	e51b3018 	ldr	r3, [fp, #-24]
1001d0e0:	e2633020 	rsb	r3, r3, #32
1001d0e4:	e51b201c 	ldr	r2, [fp, #-28]
1001d0e8:	e1a03332 	lsr	r3, r2, r3
1001d0ec:	e50b300c 	str	r3, [fp, #-12]
		{
			t = t - 'A' +10;
		}
		else t = t - '0';

		for ( j=0; j<BN_SIZE ; j++)
1001d0f0:	e51b3014 	ldr	r3, [fp, #-20]
1001d0f4:	e2833001 	add	r3, r3, #1
1001d0f8:	e50b3014 	str	r3, [fp, #-20]
1001d0fc:	e51b3014 	ldr	r3, [fp, #-20]
1001d100:	e3530001 	cmp	r3, #1
1001d104:	daffffe4 	ble	1001d09c <token_spec_number+0x130>
		{
			v = bn[j];
			bn[j] = (v<<shift) | t;
			t = v >> (32 - shift);
		}
		i++;
1001d108:	e51b3010 	ldr	r3, [fp, #-16]
1001d10c:	e2833001 	add	r3, r3, #1
1001d110:	e50b3010 	str	r3, [fp, #-16]
	default: break;
	}

	for ( j=0; j<BN_SIZE ; j++) bn[j] = 0;

	while ( i<length )
1001d114:	e51b2010 	ldr	r2, [fp, #-16]
1001d118:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
1001d11c:	e1520003 	cmp	r2, r3
1001d120:	baffffbe 	blt	1001d020 <token_spec_number+0xb4>
			t = v >> (32 - shift);
		}
		i++;
	}

	d = (long)bn[0];
1001d124:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
1001d128:	e50b3020 	str	r3, [fp, #-32]

	return d;
1001d12c:	e51b3020 	ldr	r3, [fp, #-32]
}
1001d130:	e1a00003 	mov	r0, r3
1001d134:	e24bd000 	sub	sp, fp, #0
1001d138:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
1001d13c:	e12fff1e 	bx	lr

1001d140 <strcmp>:
1001d140:	ea80 0c01 	eor.w	ip, r0, r1
1001d144:	f01c 0f03 	tst.w	ip, #3
1001d148:	d137      	bne.n	1001d1ba <strcmp+0x7a>
1001d14a:	f010 0c03 	ands.w	ip, r0, #3
1001d14e:	f020 0003 	bic.w	r0, r0, #3
1001d152:	f021 0103 	bic.w	r1, r1, #3
1001d156:	f850 2b04 	ldr.w	r2, [r0], #4
1001d15a:	bf08      	it	eq
1001d15c:	f851 3b04 	ldreq.w	r3, [r1], #4
1001d160:	d00e      	beq.n	1001d180 <strcmp+0x40>
1001d162:	f08c 0c03 	eor.w	ip, ip, #3
1001d166:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
1001d16a:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
1001d16e:	fa23 fc0c 	lsr.w	ip, r3, ip
1001d172:	f851 3b04 	ldr.w	r3, [r1], #4
1001d176:	ea42 020c 	orr.w	r2, r2, ip
1001d17a:	ea43 030c 	orr.w	r3, r3, ip
1001d17e:	bf00      	nop
1001d180:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1001d184:	429a      	cmp	r2, r3
1001d186:	bf01      	itttt	eq
1001d188:	ea2c 0c02 	biceq.w	ip, ip, r2
1001d18c:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
1001d190:	f850 2b04 	ldreq.w	r2, [r0], #4
1001d194:	f851 3b04 	ldreq.w	r3, [r1], #4
1001d198:	d0f2      	beq.n	1001d180 <strcmp+0x40>
1001d19a:	ea4f 6002 	mov.w	r0, r2, lsl #24
1001d19e:	ea4f 2212 	mov.w	r2, r2, lsr #8
1001d1a2:	2801      	cmp	r0, #1
1001d1a4:	bf28      	it	cs
1001d1a6:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
1001d1aa:	bf08      	it	eq
1001d1ac:	0a1b      	lsreq	r3, r3, #8
1001d1ae:	d0f4      	beq.n	1001d19a <strcmp+0x5a>
1001d1b0:	f003 03ff 	and.w	r3, r3, #255	; 0xff
1001d1b4:	0e00      	lsrs	r0, r0, #24
1001d1b6:	1ac0      	subs	r0, r0, r3
1001d1b8:	4770      	bx	lr
1001d1ba:	f010 0f03 	tst.w	r0, #3
1001d1be:	d00a      	beq.n	1001d1d6 <strcmp+0x96>
1001d1c0:	f810 2b01 	ldrb.w	r2, [r0], #1
1001d1c4:	f811 3b01 	ldrb.w	r3, [r1], #1
1001d1c8:	2a01      	cmp	r2, #1
1001d1ca:	bf28      	it	cs
1001d1cc:	429a      	cmpcs	r2, r3
1001d1ce:	d0f4      	beq.n	1001d1ba <strcmp+0x7a>
1001d1d0:	eba2 0003 	sub.w	r0, r2, r3
1001d1d4:	4770      	bx	lr
1001d1d6:	f84d 5d04 	str.w	r5, [sp, #-4]!
1001d1da:	f850 2b04 	ldr.w	r2, [r0], #4
1001d1de:	f001 0503 	and.w	r5, r1, #3
1001d1e2:	f021 0103 	bic.w	r1, r1, #3
1001d1e6:	f851 3b04 	ldr.w	r3, [r1], #4
1001d1ea:	2d02      	cmp	r5, #2
1001d1ec:	d026      	beq.n	1001d23c <strcmp+0xfc>
1001d1ee:	d84d      	bhi.n	1001d28c <strcmp+0x14c>
1001d1f0:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
1001d1f4:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
1001d1f8:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1001d1fc:	ea2c 0c02 	bic.w	ip, ip, r2
1001d200:	d10d      	bne.n	1001d21e <strcmp+0xde>
1001d202:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
1001d206:	bf08      	it	eq
1001d208:	f851 3b04 	ldreq.w	r3, [r1], #4
1001d20c:	d10a      	bne.n	1001d224 <strcmp+0xe4>
1001d20e:	ea85 0502 	eor.w	r5, r5, r2
1001d212:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
1001d216:	d10c      	bne.n	1001d232 <strcmp+0xf2>
1001d218:	f850 2b04 	ldr.w	r2, [r0], #4
1001d21c:	e7e8      	b.n	1001d1f0 <strcmp+0xb0>
1001d21e:	ea4f 2313 	mov.w	r3, r3, lsr #8
1001d222:	e05b      	b.n	1001d2dc <strcmp+0x19c>
1001d224:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
1001d228:	d154      	bne.n	1001d2d4 <strcmp+0x194>
1001d22a:	780b      	ldrb	r3, [r1, #0]
1001d22c:	ea4f 6512 	mov.w	r5, r2, lsr #24
1001d230:	e054      	b.n	1001d2dc <strcmp+0x19c>
1001d232:	ea4f 6512 	mov.w	r5, r2, lsr #24
1001d236:	f003 03ff 	and.w	r3, r3, #255	; 0xff
1001d23a:	e04f      	b.n	1001d2dc <strcmp+0x19c>
1001d23c:	ea4f 4502 	mov.w	r5, r2, lsl #16
1001d240:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1001d244:	ea4f 4515 	mov.w	r5, r5, lsr #16
1001d248:	ea2c 0c02 	bic.w	ip, ip, r2
1001d24c:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
1001d250:	d118      	bne.n	1001d284 <strcmp+0x144>
1001d252:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
1001d256:	bf08      	it	eq
1001d258:	f851 3b04 	ldreq.w	r3, [r1], #4
1001d25c:	d107      	bne.n	1001d26e <strcmp+0x12e>
1001d25e:	ea85 0502 	eor.w	r5, r5, r2
1001d262:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
1001d266:	d109      	bne.n	1001d27c <strcmp+0x13c>
1001d268:	f850 2b04 	ldr.w	r2, [r0], #4
1001d26c:	e7e6      	b.n	1001d23c <strcmp+0xfc>
1001d26e:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
1001d272:	d12f      	bne.n	1001d2d4 <strcmp+0x194>
1001d274:	880b      	ldrh	r3, [r1, #0]
1001d276:	ea4f 4512 	mov.w	r5, r2, lsr #16
1001d27a:	e02f      	b.n	1001d2dc <strcmp+0x19c>
1001d27c:	ea4f 4303 	mov.w	r3, r3, lsl #16
1001d280:	ea4f 4512 	mov.w	r5, r2, lsr #16
1001d284:	ea4f 4313 	mov.w	r3, r3, lsr #16
1001d288:	e028      	b.n	1001d2dc <strcmp+0x19c>
1001d28a:	bf00      	nop
1001d28c:	f002 05ff 	and.w	r5, r2, #255	; 0xff
1001d290:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
1001d294:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
1001d298:	ea2c 0c02 	bic.w	ip, ip, r2
1001d29c:	d10d      	bne.n	1001d2ba <strcmp+0x17a>
1001d29e:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
1001d2a2:	bf08      	it	eq
1001d2a4:	f851 3b04 	ldreq.w	r3, [r1], #4
1001d2a8:	d10a      	bne.n	1001d2c0 <strcmp+0x180>
1001d2aa:	ea85 0502 	eor.w	r5, r5, r2
1001d2ae:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
1001d2b2:	d10a      	bne.n	1001d2ca <strcmp+0x18a>
1001d2b4:	f850 2b04 	ldr.w	r2, [r0], #4
1001d2b8:	e7e8      	b.n	1001d28c <strcmp+0x14c>
1001d2ba:	ea4f 6313 	mov.w	r3, r3, lsr #24
1001d2be:	e00d      	b.n	1001d2dc <strcmp+0x19c>
1001d2c0:	f012 0fff 	tst.w	r2, #255	; 0xff
1001d2c4:	d006      	beq.n	1001d2d4 <strcmp+0x194>
1001d2c6:	f851 3b04 	ldr.w	r3, [r1], #4
1001d2ca:	ea4f 2512 	mov.w	r5, r2, lsr #8
1001d2ce:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
1001d2d2:	e003      	b.n	1001d2dc <strcmp+0x19c>
1001d2d4:	f04f 0000 	mov.w	r0, #0
1001d2d8:	bc20      	pop	{r5}
1001d2da:	4770      	bx	lr
1001d2dc:	f005 02ff 	and.w	r2, r5, #255	; 0xff
1001d2e0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
1001d2e4:	2801      	cmp	r0, #1
1001d2e6:	bf28      	it	cs
1001d2e8:	4290      	cmpcs	r0, r2
1001d2ea:	bf04      	itt	eq
1001d2ec:	0a2d      	lsreq	r5, r5, #8
1001d2ee:	0a1b      	lsreq	r3, r3, #8
1001d2f0:	d0f4      	beq.n	1001d2dc <strcmp+0x19c>
1001d2f2:	eba2 0000 	sub.w	r0, r2, r0
1001d2f6:	bc20      	pop	{r5}
1001d2f8:	4770      	bx	lr
1001d2fa:	bf00      	nop
1001d2fc:	0000      	movs	r0, r0
	...

1001d300 <__aeabi_uidiv>:
1001d300:	1e4a      	subs	r2, r1, #1
1001d302:	bf08      	it	eq
1001d304:	4770      	bxeq	lr
1001d306:	f0c0 8124 	bcc.w	1001d552 <__aeabi_uidiv+0x252>
1001d30a:	4288      	cmp	r0, r1
1001d30c:	f240 8116 	bls.w	1001d53c <__aeabi_uidiv+0x23c>
1001d310:	4211      	tst	r1, r2
1001d312:	f000 8117 	beq.w	1001d544 <__aeabi_uidiv+0x244>
1001d316:	fab0 f380 	clz	r3, r0
1001d31a:	fab1 f281 	clz	r2, r1
1001d31e:	eba2 0303 	sub.w	r3, r2, r3
1001d322:	f1c3 031f 	rsb	r3, r3, #31
1001d326:	a204      	add	r2, pc, #16	; (adr r2, 1001d338 <__aeabi_uidiv+0x38>)
1001d328:	eb02 1303 	add.w	r3, r2, r3, lsl #4
1001d32c:	f04f 0200 	mov.w	r2, #0
1001d330:	469f      	mov	pc, r3
1001d332:	bf00      	nop
1001d334:	f3af 8000 	nop.w
1001d338:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
1001d33c:	bf00      	nop
1001d33e:	eb42 0202 	adc.w	r2, r2, r2
1001d342:	bf28      	it	cs
1001d344:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
1001d348:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
1001d34c:	bf00      	nop
1001d34e:	eb42 0202 	adc.w	r2, r2, r2
1001d352:	bf28      	it	cs
1001d354:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
1001d358:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
1001d35c:	bf00      	nop
1001d35e:	eb42 0202 	adc.w	r2, r2, r2
1001d362:	bf28      	it	cs
1001d364:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
1001d368:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
1001d36c:	bf00      	nop
1001d36e:	eb42 0202 	adc.w	r2, r2, r2
1001d372:	bf28      	it	cs
1001d374:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
1001d378:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
1001d37c:	bf00      	nop
1001d37e:	eb42 0202 	adc.w	r2, r2, r2
1001d382:	bf28      	it	cs
1001d384:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
1001d388:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
1001d38c:	bf00      	nop
1001d38e:	eb42 0202 	adc.w	r2, r2, r2
1001d392:	bf28      	it	cs
1001d394:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
1001d398:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
1001d39c:	bf00      	nop
1001d39e:	eb42 0202 	adc.w	r2, r2, r2
1001d3a2:	bf28      	it	cs
1001d3a4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
1001d3a8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
1001d3ac:	bf00      	nop
1001d3ae:	eb42 0202 	adc.w	r2, r2, r2
1001d3b2:	bf28      	it	cs
1001d3b4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
1001d3b8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
1001d3bc:	bf00      	nop
1001d3be:	eb42 0202 	adc.w	r2, r2, r2
1001d3c2:	bf28      	it	cs
1001d3c4:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
1001d3c8:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
1001d3cc:	bf00      	nop
1001d3ce:	eb42 0202 	adc.w	r2, r2, r2
1001d3d2:	bf28      	it	cs
1001d3d4:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
1001d3d8:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
1001d3dc:	bf00      	nop
1001d3de:	eb42 0202 	adc.w	r2, r2, r2
1001d3e2:	bf28      	it	cs
1001d3e4:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
1001d3e8:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
1001d3ec:	bf00      	nop
1001d3ee:	eb42 0202 	adc.w	r2, r2, r2
1001d3f2:	bf28      	it	cs
1001d3f4:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
1001d3f8:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
1001d3fc:	bf00      	nop
1001d3fe:	eb42 0202 	adc.w	r2, r2, r2
1001d402:	bf28      	it	cs
1001d404:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
1001d408:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
1001d40c:	bf00      	nop
1001d40e:	eb42 0202 	adc.w	r2, r2, r2
1001d412:	bf28      	it	cs
1001d414:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
1001d418:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
1001d41c:	bf00      	nop
1001d41e:	eb42 0202 	adc.w	r2, r2, r2
1001d422:	bf28      	it	cs
1001d424:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
1001d428:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
1001d42c:	bf00      	nop
1001d42e:	eb42 0202 	adc.w	r2, r2, r2
1001d432:	bf28      	it	cs
1001d434:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
1001d438:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
1001d43c:	bf00      	nop
1001d43e:	eb42 0202 	adc.w	r2, r2, r2
1001d442:	bf28      	it	cs
1001d444:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
1001d448:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
1001d44c:	bf00      	nop
1001d44e:	eb42 0202 	adc.w	r2, r2, r2
1001d452:	bf28      	it	cs
1001d454:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
1001d458:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
1001d45c:	bf00      	nop
1001d45e:	eb42 0202 	adc.w	r2, r2, r2
1001d462:	bf28      	it	cs
1001d464:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
1001d468:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
1001d46c:	bf00      	nop
1001d46e:	eb42 0202 	adc.w	r2, r2, r2
1001d472:	bf28      	it	cs
1001d474:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
1001d478:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
1001d47c:	bf00      	nop
1001d47e:	eb42 0202 	adc.w	r2, r2, r2
1001d482:	bf28      	it	cs
1001d484:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
1001d488:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
1001d48c:	bf00      	nop
1001d48e:	eb42 0202 	adc.w	r2, r2, r2
1001d492:	bf28      	it	cs
1001d494:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
1001d498:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
1001d49c:	bf00      	nop
1001d49e:	eb42 0202 	adc.w	r2, r2, r2
1001d4a2:	bf28      	it	cs
1001d4a4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
1001d4a8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
1001d4ac:	bf00      	nop
1001d4ae:	eb42 0202 	adc.w	r2, r2, r2
1001d4b2:	bf28      	it	cs
1001d4b4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
1001d4b8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
1001d4bc:	bf00      	nop
1001d4be:	eb42 0202 	adc.w	r2, r2, r2
1001d4c2:	bf28      	it	cs
1001d4c4:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
1001d4c8:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
1001d4cc:	bf00      	nop
1001d4ce:	eb42 0202 	adc.w	r2, r2, r2
1001d4d2:	bf28      	it	cs
1001d4d4:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
1001d4d8:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
1001d4dc:	bf00      	nop
1001d4de:	eb42 0202 	adc.w	r2, r2, r2
1001d4e2:	bf28      	it	cs
1001d4e4:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
1001d4e8:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
1001d4ec:	bf00      	nop
1001d4ee:	eb42 0202 	adc.w	r2, r2, r2
1001d4f2:	bf28      	it	cs
1001d4f4:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
1001d4f8:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
1001d4fc:	bf00      	nop
1001d4fe:	eb42 0202 	adc.w	r2, r2, r2
1001d502:	bf28      	it	cs
1001d504:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
1001d508:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
1001d50c:	bf00      	nop
1001d50e:	eb42 0202 	adc.w	r2, r2, r2
1001d512:	bf28      	it	cs
1001d514:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
1001d518:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
1001d51c:	bf00      	nop
1001d51e:	eb42 0202 	adc.w	r2, r2, r2
1001d522:	bf28      	it	cs
1001d524:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
1001d528:	ebb0 0f01 	cmp.w	r0, r1
1001d52c:	bf00      	nop
1001d52e:	eb42 0202 	adc.w	r2, r2, r2
1001d532:	bf28      	it	cs
1001d534:	eba0 0001 	subcs.w	r0, r0, r1
1001d538:	4610      	mov	r0, r2
1001d53a:	4770      	bx	lr
1001d53c:	bf0c      	ite	eq
1001d53e:	2001      	moveq	r0, #1
1001d540:	2000      	movne	r0, #0
1001d542:	4770      	bx	lr
1001d544:	fab1 f281 	clz	r2, r1
1001d548:	f1c2 021f 	rsb	r2, r2, #31
1001d54c:	fa20 f002 	lsr.w	r0, r0, r2
1001d550:	4770      	bx	lr
1001d552:	b108      	cbz	r0, 1001d558 <__aeabi_uidiv+0x258>
1001d554:	f04f 30ff 	mov.w	r0, #4294967295
1001d558:	f000 b966 	b.w	1001d828 <__aeabi_idiv0>

1001d55c <__aeabi_uidivmod>:
1001d55c:	2900      	cmp	r1, #0
1001d55e:	d0f8      	beq.n	1001d552 <__aeabi_uidiv+0x252>
1001d560:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
1001d564:	f7ff fecc 	bl	1001d300 <__aeabi_uidiv>
1001d568:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
1001d56c:	fb02 f300 	mul.w	r3, r2, r0
1001d570:	eba1 0103 	sub.w	r1, r1, r3
1001d574:	4770      	bx	lr
1001d576:	bf00      	nop

1001d578 <__aeabi_idiv>:
1001d578:	2900      	cmp	r1, #0
1001d57a:	f000 813e 	beq.w	1001d7fa <.divsi3_skip_div0_test+0x27c>

1001d57e <.divsi3_skip_div0_test>:
1001d57e:	ea80 0c01 	eor.w	ip, r0, r1
1001d582:	bf48      	it	mi
1001d584:	4249      	negmi	r1, r1
1001d586:	1e4a      	subs	r2, r1, #1
1001d588:	f000 811f 	beq.w	1001d7ca <.divsi3_skip_div0_test+0x24c>
1001d58c:	0003      	movs	r3, r0
1001d58e:	bf48      	it	mi
1001d590:	4243      	negmi	r3, r0
1001d592:	428b      	cmp	r3, r1
1001d594:	f240 811e 	bls.w	1001d7d4 <.divsi3_skip_div0_test+0x256>
1001d598:	4211      	tst	r1, r2
1001d59a:	f000 8123 	beq.w	1001d7e4 <.divsi3_skip_div0_test+0x266>
1001d59e:	fab3 f283 	clz	r2, r3
1001d5a2:	fab1 f081 	clz	r0, r1
1001d5a6:	eba0 0202 	sub.w	r2, r0, r2
1001d5aa:	f1c2 021f 	rsb	r2, r2, #31
1001d5ae:	a004      	add	r0, pc, #16	; (adr r0, 1001d5c0 <.divsi3_skip_div0_test+0x42>)
1001d5b0:	eb00 1202 	add.w	r2, r0, r2, lsl #4
1001d5b4:	f04f 0000 	mov.w	r0, #0
1001d5b8:	4697      	mov	pc, r2
1001d5ba:	bf00      	nop
1001d5bc:	f3af 8000 	nop.w
1001d5c0:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
1001d5c4:	bf00      	nop
1001d5c6:	eb40 0000 	adc.w	r0, r0, r0
1001d5ca:	bf28      	it	cs
1001d5cc:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
1001d5d0:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
1001d5d4:	bf00      	nop
1001d5d6:	eb40 0000 	adc.w	r0, r0, r0
1001d5da:	bf28      	it	cs
1001d5dc:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
1001d5e0:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
1001d5e4:	bf00      	nop
1001d5e6:	eb40 0000 	adc.w	r0, r0, r0
1001d5ea:	bf28      	it	cs
1001d5ec:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
1001d5f0:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
1001d5f4:	bf00      	nop
1001d5f6:	eb40 0000 	adc.w	r0, r0, r0
1001d5fa:	bf28      	it	cs
1001d5fc:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
1001d600:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
1001d604:	bf00      	nop
1001d606:	eb40 0000 	adc.w	r0, r0, r0
1001d60a:	bf28      	it	cs
1001d60c:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
1001d610:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
1001d614:	bf00      	nop
1001d616:	eb40 0000 	adc.w	r0, r0, r0
1001d61a:	bf28      	it	cs
1001d61c:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
1001d620:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
1001d624:	bf00      	nop
1001d626:	eb40 0000 	adc.w	r0, r0, r0
1001d62a:	bf28      	it	cs
1001d62c:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
1001d630:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
1001d634:	bf00      	nop
1001d636:	eb40 0000 	adc.w	r0, r0, r0
1001d63a:	bf28      	it	cs
1001d63c:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
1001d640:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
1001d644:	bf00      	nop
1001d646:	eb40 0000 	adc.w	r0, r0, r0
1001d64a:	bf28      	it	cs
1001d64c:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
1001d650:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
1001d654:	bf00      	nop
1001d656:	eb40 0000 	adc.w	r0, r0, r0
1001d65a:	bf28      	it	cs
1001d65c:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
1001d660:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
1001d664:	bf00      	nop
1001d666:	eb40 0000 	adc.w	r0, r0, r0
1001d66a:	bf28      	it	cs
1001d66c:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
1001d670:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
1001d674:	bf00      	nop
1001d676:	eb40 0000 	adc.w	r0, r0, r0
1001d67a:	bf28      	it	cs
1001d67c:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
1001d680:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
1001d684:	bf00      	nop
1001d686:	eb40 0000 	adc.w	r0, r0, r0
1001d68a:	bf28      	it	cs
1001d68c:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
1001d690:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
1001d694:	bf00      	nop
1001d696:	eb40 0000 	adc.w	r0, r0, r0
1001d69a:	bf28      	it	cs
1001d69c:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
1001d6a0:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
1001d6a4:	bf00      	nop
1001d6a6:	eb40 0000 	adc.w	r0, r0, r0
1001d6aa:	bf28      	it	cs
1001d6ac:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
1001d6b0:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
1001d6b4:	bf00      	nop
1001d6b6:	eb40 0000 	adc.w	r0, r0, r0
1001d6ba:	bf28      	it	cs
1001d6bc:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
1001d6c0:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
1001d6c4:	bf00      	nop
1001d6c6:	eb40 0000 	adc.w	r0, r0, r0
1001d6ca:	bf28      	it	cs
1001d6cc:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
1001d6d0:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
1001d6d4:	bf00      	nop
1001d6d6:	eb40 0000 	adc.w	r0, r0, r0
1001d6da:	bf28      	it	cs
1001d6dc:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
1001d6e0:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
1001d6e4:	bf00      	nop
1001d6e6:	eb40 0000 	adc.w	r0, r0, r0
1001d6ea:	bf28      	it	cs
1001d6ec:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
1001d6f0:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
1001d6f4:	bf00      	nop
1001d6f6:	eb40 0000 	adc.w	r0, r0, r0
1001d6fa:	bf28      	it	cs
1001d6fc:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
1001d700:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
1001d704:	bf00      	nop
1001d706:	eb40 0000 	adc.w	r0, r0, r0
1001d70a:	bf28      	it	cs
1001d70c:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
1001d710:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
1001d714:	bf00      	nop
1001d716:	eb40 0000 	adc.w	r0, r0, r0
1001d71a:	bf28      	it	cs
1001d71c:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
1001d720:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
1001d724:	bf00      	nop
1001d726:	eb40 0000 	adc.w	r0, r0, r0
1001d72a:	bf28      	it	cs
1001d72c:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
1001d730:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
1001d734:	bf00      	nop
1001d736:	eb40 0000 	adc.w	r0, r0, r0
1001d73a:	bf28      	it	cs
1001d73c:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
1001d740:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
1001d744:	bf00      	nop
1001d746:	eb40 0000 	adc.w	r0, r0, r0
1001d74a:	bf28      	it	cs
1001d74c:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
1001d750:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
1001d754:	bf00      	nop
1001d756:	eb40 0000 	adc.w	r0, r0, r0
1001d75a:	bf28      	it	cs
1001d75c:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
1001d760:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
1001d764:	bf00      	nop
1001d766:	eb40 0000 	adc.w	r0, r0, r0
1001d76a:	bf28      	it	cs
1001d76c:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
1001d770:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
1001d774:	bf00      	nop
1001d776:	eb40 0000 	adc.w	r0, r0, r0
1001d77a:	bf28      	it	cs
1001d77c:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
1001d780:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
1001d784:	bf00      	nop
1001d786:	eb40 0000 	adc.w	r0, r0, r0
1001d78a:	bf28      	it	cs
1001d78c:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
1001d790:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
1001d794:	bf00      	nop
1001d796:	eb40 0000 	adc.w	r0, r0, r0
1001d79a:	bf28      	it	cs
1001d79c:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
1001d7a0:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
1001d7a4:	bf00      	nop
1001d7a6:	eb40 0000 	adc.w	r0, r0, r0
1001d7aa:	bf28      	it	cs
1001d7ac:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
1001d7b0:	ebb3 0f01 	cmp.w	r3, r1
1001d7b4:	bf00      	nop
1001d7b6:	eb40 0000 	adc.w	r0, r0, r0
1001d7ba:	bf28      	it	cs
1001d7bc:	eba3 0301 	subcs.w	r3, r3, r1
1001d7c0:	f1bc 0f00 	cmp.w	ip, #0
1001d7c4:	bf48      	it	mi
1001d7c6:	4240      	negmi	r0, r0
1001d7c8:	4770      	bx	lr
1001d7ca:	ea9c 0f00 	teq	ip, r0
1001d7ce:	bf48      	it	mi
1001d7d0:	4240      	negmi	r0, r0
1001d7d2:	4770      	bx	lr
1001d7d4:	bf38      	it	cc
1001d7d6:	2000      	movcc	r0, #0
1001d7d8:	bf04      	itt	eq
1001d7da:	ea4f 70ec 	moveq.w	r0, ip, asr #31
1001d7de:	f040 0001 	orreq.w	r0, r0, #1
1001d7e2:	4770      	bx	lr
1001d7e4:	fab1 f281 	clz	r2, r1
1001d7e8:	f1c2 021f 	rsb	r2, r2, #31
1001d7ec:	f1bc 0f00 	cmp.w	ip, #0
1001d7f0:	fa23 f002 	lsr.w	r0, r3, r2
1001d7f4:	bf48      	it	mi
1001d7f6:	4240      	negmi	r0, r0
1001d7f8:	4770      	bx	lr
1001d7fa:	2800      	cmp	r0, #0
1001d7fc:	bfc8      	it	gt
1001d7fe:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
1001d802:	bfb8      	it	lt
1001d804:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
1001d808:	f000 b80e 	b.w	1001d828 <__aeabi_idiv0>

1001d80c <__aeabi_idivmod>:
1001d80c:	2900      	cmp	r1, #0
1001d80e:	d0f4      	beq.n	1001d7fa <.divsi3_skip_div0_test+0x27c>
1001d810:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
1001d814:	f7ff feb3 	bl	1001d57e <.divsi3_skip_div0_test>
1001d818:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
1001d81c:	fb02 f300 	mul.w	r3, r2, r0
1001d820:	eba1 0103 	sub.w	r1, r1, r3
1001d824:	4770      	bx	lr
1001d826:	bf00      	nop

1001d828 <__aeabi_idiv0>:
1001d828:	4770      	bx	lr
1001d82a:	bf00      	nop

1001d82c <atoi>:
1001d82c:	2100      	movs	r1, #0
1001d82e:	220a      	movs	r2, #10
1001d830:	f000 bb6e 	b.w	1001df10 <strtol>

1001d834 <memcpy>:
1001d834:	2a0f      	cmp	r2, #15
1001d836:	b5f0      	push	{r4, r5, r6, r7, lr}
1001d838:	d949      	bls.n	1001d8ce <memcpy+0x9a>
1001d83a:	ea40 0301 	orr.w	r3, r0, r1
1001d83e:	079b      	lsls	r3, r3, #30
1001d840:	d148      	bne.n	1001d8d4 <memcpy+0xa0>
1001d842:	f100 0410 	add.w	r4, r0, #16
1001d846:	f101 0310 	add.w	r3, r1, #16
1001d84a:	4615      	mov	r5, r2
1001d84c:	f853 6c10 	ldr.w	r6, [r3, #-16]
1001d850:	3d10      	subs	r5, #16
1001d852:	2d0f      	cmp	r5, #15
1001d854:	f103 0310 	add.w	r3, r3, #16
1001d858:	f104 0410 	add.w	r4, r4, #16
1001d85c:	f844 6c20 	str.w	r6, [r4, #-32]
1001d860:	f853 6c1c 	ldr.w	r6, [r3, #-28]
1001d864:	f844 6c1c 	str.w	r6, [r4, #-28]
1001d868:	f853 6c18 	ldr.w	r6, [r3, #-24]
1001d86c:	f844 6c18 	str.w	r6, [r4, #-24]
1001d870:	f853 6c14 	ldr.w	r6, [r3, #-20]
1001d874:	f844 6c14 	str.w	r6, [r4, #-20]
1001d878:	d8e8      	bhi.n	1001d84c <memcpy+0x18>
1001d87a:	f1a2 0310 	sub.w	r3, r2, #16
1001d87e:	f002 0e0f 	and.w	lr, r2, #15
1001d882:	f023 030f 	bic.w	r3, r3, #15
1001d886:	f1be 0f03 	cmp.w	lr, #3
1001d88a:	f103 0310 	add.w	r3, r3, #16
1001d88e:	4419      	add	r1, r3
1001d890:	4403      	add	r3, r0
1001d892:	d921      	bls.n	1001d8d8 <memcpy+0xa4>
1001d894:	1f1e      	subs	r6, r3, #4
1001d896:	460d      	mov	r5, r1
1001d898:	4674      	mov	r4, lr
1001d89a:	f855 7b04 	ldr.w	r7, [r5], #4
1001d89e:	3c04      	subs	r4, #4
1001d8a0:	2c03      	cmp	r4, #3
1001d8a2:	f846 7f04 	str.w	r7, [r6, #4]!
1001d8a6:	d8f8      	bhi.n	1001d89a <memcpy+0x66>
1001d8a8:	f1ae 0404 	sub.w	r4, lr, #4
1001d8ac:	f002 0203 	and.w	r2, r2, #3
1001d8b0:	f024 0403 	bic.w	r4, r4, #3
1001d8b4:	3404      	adds	r4, #4
1001d8b6:	4423      	add	r3, r4
1001d8b8:	4421      	add	r1, r4
1001d8ba:	b152      	cbz	r2, 1001d8d2 <memcpy+0x9e>
1001d8bc:	3b01      	subs	r3, #1
1001d8be:	440a      	add	r2, r1
1001d8c0:	f811 4b01 	ldrb.w	r4, [r1], #1
1001d8c4:	4291      	cmp	r1, r2
1001d8c6:	f803 4f01 	strb.w	r4, [r3, #1]!
1001d8ca:	d1f9      	bne.n	1001d8c0 <memcpy+0x8c>
1001d8cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
1001d8ce:	4603      	mov	r3, r0
1001d8d0:	e7f3      	b.n	1001d8ba <memcpy+0x86>
1001d8d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
1001d8d4:	4603      	mov	r3, r0
1001d8d6:	e7f1      	b.n	1001d8bc <memcpy+0x88>
1001d8d8:	4672      	mov	r2, lr
1001d8da:	e7ee      	b.n	1001d8ba <memcpy+0x86>

1001d8dc <memset>:
1001d8dc:	0783      	lsls	r3, r0, #30
1001d8de:	b470      	push	{r4, r5, r6}
1001d8e0:	d04a      	beq.n	1001d978 <memset+0x9c>
1001d8e2:	1e54      	subs	r4, r2, #1
1001d8e4:	2a00      	cmp	r2, #0
1001d8e6:	d045      	beq.n	1001d974 <memset+0x98>
1001d8e8:	b2cd      	uxtb	r5, r1
1001d8ea:	4603      	mov	r3, r0
1001d8ec:	e002      	b.n	1001d8f4 <memset+0x18>
1001d8ee:	2c00      	cmp	r4, #0
1001d8f0:	d040      	beq.n	1001d974 <memset+0x98>
1001d8f2:	4614      	mov	r4, r2
1001d8f4:	f803 5b01 	strb.w	r5, [r3], #1
1001d8f8:	f013 0f03 	tst.w	r3, #3
1001d8fc:	f104 32ff 	add.w	r2, r4, #4294967295
1001d900:	d1f5      	bne.n	1001d8ee <memset+0x12>
1001d902:	2c03      	cmp	r4, #3
1001d904:	d92f      	bls.n	1001d966 <memset+0x8a>
1001d906:	b2cd      	uxtb	r5, r1
1001d908:	2c0f      	cmp	r4, #15
1001d90a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
1001d90e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
1001d912:	d91a      	bls.n	1001d94a <memset+0x6e>
1001d914:	f103 0210 	add.w	r2, r3, #16
1001d918:	4626      	mov	r6, r4
1001d91a:	3e10      	subs	r6, #16
1001d91c:	f842 5c10 	str.w	r5, [r2, #-16]
1001d920:	2e0f      	cmp	r6, #15
1001d922:	f842 5c0c 	str.w	r5, [r2, #-12]
1001d926:	f842 5c08 	str.w	r5, [r2, #-8]
1001d92a:	f102 0210 	add.w	r2, r2, #16
1001d92e:	f842 5c14 	str.w	r5, [r2, #-20]
1001d932:	d8f2      	bhi.n	1001d91a <memset+0x3e>
1001d934:	f1a4 0210 	sub.w	r2, r4, #16
1001d938:	f004 040f 	and.w	r4, r4, #15
1001d93c:	f022 020f 	bic.w	r2, r2, #15
1001d940:	2c03      	cmp	r4, #3
1001d942:	f102 0210 	add.w	r2, r2, #16
1001d946:	4413      	add	r3, r2
1001d948:	d90d      	bls.n	1001d966 <memset+0x8a>
1001d94a:	461e      	mov	r6, r3
1001d94c:	4622      	mov	r2, r4
1001d94e:	3a04      	subs	r2, #4
1001d950:	f846 5b04 	str.w	r5, [r6], #4
1001d954:	2a03      	cmp	r2, #3
1001d956:	d8fa      	bhi.n	1001d94e <memset+0x72>
1001d958:	1f22      	subs	r2, r4, #4
1001d95a:	f004 0403 	and.w	r4, r4, #3
1001d95e:	f022 0203 	bic.w	r2, r2, #3
1001d962:	3204      	adds	r2, #4
1001d964:	4413      	add	r3, r2
1001d966:	b12c      	cbz	r4, 1001d974 <memset+0x98>
1001d968:	b2c9      	uxtb	r1, r1
1001d96a:	441c      	add	r4, r3
1001d96c:	f803 1b01 	strb.w	r1, [r3], #1
1001d970:	42a3      	cmp	r3, r4
1001d972:	d1fb      	bne.n	1001d96c <memset+0x90>
1001d974:	bc70      	pop	{r4, r5, r6}
1001d976:	4770      	bx	lr
1001d978:	4614      	mov	r4, r2
1001d97a:	4603      	mov	r3, r0
1001d97c:	e7c1      	b.n	1001d902 <memset+0x26>
1001d97e:	bf00      	nop

1001d980 <putenv>:
1001d980:	f640 63b0 	movw	r3, #3760	; 0xeb0
1001d984:	4601      	mov	r1, r0
1001d986:	f2c1 0302 	movt	r3, #4098	; 0x1002
1001d98a:	6818      	ldr	r0, [r3, #0]
1001d98c:	f000 b800 	b.w	1001d990 <_putenv_r>

1001d990 <_putenv_r>:
1001d990:	b570      	push	{r4, r5, r6, lr}
1001d992:	4606      	mov	r6, r0
1001d994:	f000 f958 	bl	1001dc48 <_strdup_r>
1001d998:	b1a0      	cbz	r0, 1001d9c4 <_putenv_r+0x34>
1001d99a:	213d      	movs	r1, #61	; 0x3d
1001d99c:	4605      	mov	r5, r0
1001d99e:	f000 f8dd 	bl	1001db5c <strchr>
1001d9a2:	b188      	cbz	r0, 1001d9c8 <_putenv_r+0x38>
1001d9a4:	4602      	mov	r2, r0
1001d9a6:	4629      	mov	r1, r5
1001d9a8:	2300      	movs	r3, #0
1001d9aa:	4630      	mov	r0, r6
1001d9ac:	f802 3b01 	strb.w	r3, [r2], #1
1001d9b0:	2301      	movs	r3, #1
1001d9b2:	f000 f80f 	bl	1001d9d4 <_setenv_r>
1001d9b6:	4629      	mov	r1, r5
1001d9b8:	4604      	mov	r4, r0
1001d9ba:	4630      	mov	r0, r6
1001d9bc:	f7f0 efe4 	blx	1000e988 <_free_r>
1001d9c0:	4620      	mov	r0, r4
1001d9c2:	bd70      	pop	{r4, r5, r6, pc}
1001d9c4:	2001      	movs	r0, #1
1001d9c6:	bd70      	pop	{r4, r5, r6, pc}
1001d9c8:	4630      	mov	r0, r6
1001d9ca:	4629      	mov	r1, r5
1001d9cc:	f7f0 efdc 	blx	1000e988 <_free_r>
1001d9d0:	2001      	movs	r0, #1
1001d9d2:	bd70      	pop	{r4, r5, r6, pc}

1001d9d4 <_setenv_r>:
1001d9d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1001d9d8:	460e      	mov	r6, r1
1001d9da:	b083      	sub	sp, #12
1001d9dc:	4605      	mov	r5, r0
1001d9de:	213d      	movs	r1, #61	; 0x3d
1001d9e0:	4630      	mov	r0, r6
1001d9e2:	4614      	mov	r4, r2
1001d9e4:	461f      	mov	r7, r3
1001d9e6:	f000 f8b9 	bl	1001db5c <strchr>
1001d9ea:	2800      	cmp	r0, #0
1001d9ec:	d168      	bne.n	1001dac0 <_setenv_r+0xec>
1001d9ee:	4628      	mov	r0, r5
1001d9f0:	f000 fa9c 	bl	1001df2c <__env_lock>
1001d9f4:	4620      	mov	r0, r4
1001d9f6:	f000 f93b 	bl	1001dc70 <strlen>
1001d9fa:	4631      	mov	r1, r6
1001d9fc:	aa01      	add	r2, sp, #4
1001d9fe:	4680      	mov	r8, r0
1001da00:	4628      	mov	r0, r5
1001da02:	f000 fa9d 	bl	1001df40 <_findenv_r>
1001da06:	4682      	mov	sl, r0
1001da08:	2800      	cmp	r0, #0
1001da0a:	d063      	beq.n	1001dad4 <_setenv_r+0x100>
1001da0c:	2f00      	cmp	r7, #0
1001da0e:	d046      	beq.n	1001da9e <_setenv_r+0xca>
1001da10:	f000 f92e 	bl	1001dc70 <strlen>
1001da14:	4580      	cmp	r8, r0
1001da16:	d94a      	bls.n	1001daae <_setenv_r+0xda>
1001da18:	9f01      	ldr	r7, [sp, #4]
1001da1a:	f640 69b8 	movw	r9, #3768	; 0xeb8
1001da1e:	f2c1 0902 	movt	r9, #4098	; 0x1002
1001da22:	00bf      	lsls	r7, r7, #2
1001da24:	7831      	ldrb	r1, [r6, #0]
1001da26:	293d      	cmp	r1, #61	; 0x3d
1001da28:	bf18      	it	ne
1001da2a:	2900      	cmpne	r1, #0
1001da2c:	bf14      	ite	ne
1001da2e:	2101      	movne	r1, #1
1001da30:	2100      	moveq	r1, #0
1001da32:	d007      	beq.n	1001da44 <_setenv_r+0x70>
1001da34:	4631      	mov	r1, r6
1001da36:	f811 3f01 	ldrb.w	r3, [r1, #1]!
1001da3a:	2b3d      	cmp	r3, #61	; 0x3d
1001da3c:	bf18      	it	ne
1001da3e:	2b00      	cmpne	r3, #0
1001da40:	d1f9      	bne.n	1001da36 <_setenv_r+0x62>
1001da42:	1b89      	subs	r1, r1, r6
1001da44:	4441      	add	r1, r8
1001da46:	4628      	mov	r0, r5
1001da48:	3102      	adds	r1, #2
1001da4a:	f8d9 8000 	ldr.w	r8, [r9]
1001da4e:	f7f0 ef28 	blx	1000e8a0 <_malloc_r>
1001da52:	f640 63b8 	movw	r3, #3768	; 0xeb8
1001da56:	f2c1 0302 	movt	r3, #4098	; 0x1002
1001da5a:	f848 0007 	str.w	r0, [r8, r7]
1001da5e:	2800      	cmp	r0, #0
1001da60:	d076      	beq.n	1001db50 <_setenv_r+0x17c>
1001da62:	681a      	ldr	r2, [r3, #0]
1001da64:	1c71      	adds	r1, r6, #1
1001da66:	9801      	ldr	r0, [sp, #4]
1001da68:	7833      	ldrb	r3, [r6, #0]
1001da6a:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
1001da6e:	2b00      	cmp	r3, #0
1001da70:	bf18      	it	ne
1001da72:	2b3d      	cmpne	r3, #61	; 0x3d
1001da74:	7003      	strb	r3, [r0, #0]
1001da76:	d009      	beq.n	1001da8c <_setenv_r+0xb8>
1001da78:	1c42      	adds	r2, r0, #1
1001da7a:	f811 3b01 	ldrb.w	r3, [r1], #1
1001da7e:	4610      	mov	r0, r2
1001da80:	2b00      	cmp	r3, #0
1001da82:	bf18      	it	ne
1001da84:	2b3d      	cmpne	r3, #61	; 0x3d
1001da86:	f802 3b01 	strb.w	r3, [r2], #1
1001da8a:	d1f6      	bne.n	1001da7a <_setenv_r+0xa6>
1001da8c:	4602      	mov	r2, r0
1001da8e:	233d      	movs	r3, #61	; 0x3d
1001da90:	7003      	strb	r3, [r0, #0]
1001da92:	f814 3b01 	ldrb.w	r3, [r4], #1
1001da96:	f802 3f01 	strb.w	r3, [r2, #1]!
1001da9a:	2b00      	cmp	r3, #0
1001da9c:	d1f9      	bne.n	1001da92 <_setenv_r+0xbe>
1001da9e:	4628      	mov	r0, r5
1001daa0:	f000 fa46 	bl	1001df30 <__env_unlock>
1001daa4:	2300      	movs	r3, #0
1001daa6:	4618      	mov	r0, r3
1001daa8:	b003      	add	sp, #12
1001daaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1001daae:	f10a 30ff 	add.w	r0, sl, #4294967295
1001dab2:	f814 3b01 	ldrb.w	r3, [r4], #1
1001dab6:	f800 3f01 	strb.w	r3, [r0, #1]!
1001daba:	2b00      	cmp	r3, #0
1001dabc:	d1f9      	bne.n	1001dab2 <_setenv_r+0xde>
1001dabe:	e7ee      	b.n	1001da9e <_setenv_r+0xca>
1001dac0:	f000 fa38 	bl	1001df34 <__errno>
1001dac4:	f04f 33ff 	mov.w	r3, #4294967295
1001dac8:	2216      	movs	r2, #22
1001daca:	6002      	str	r2, [r0, #0]
1001dacc:	4618      	mov	r0, r3
1001dace:	b003      	add	sp, #12
1001dad0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1001dad4:	f640 69b8 	movw	r9, #3768	; 0xeb8
1001dad8:	f2c1 0902 	movt	r9, #4098	; 0x1002
1001dadc:	f8d9 1000 	ldr.w	r1, [r9]
1001dae0:	6808      	ldr	r0, [r1, #0]
1001dae2:	b390      	cbz	r0, 1001db4a <_setenv_r+0x176>
1001dae4:	460b      	mov	r3, r1
1001dae6:	f853 2f04 	ldr.w	r2, [r3, #4]!
1001daea:	f10a 0a01 	add.w	sl, sl, #1
1001daee:	2a00      	cmp	r2, #0
1001daf0:	d1f9      	bne.n	1001dae6 <_setenv_r+0x112>
1001daf2:	f10a 0202 	add.w	r2, sl, #2
1001daf6:	0092      	lsls	r2, r2, #2
1001daf8:	f649 5378 	movw	r3, #40312	; 0x9d78
1001dafc:	f2c1 0302 	movt	r3, #4098	; 0x1002
1001db00:	6818      	ldr	r0, [r3, #0]
1001db02:	b178      	cbz	r0, 1001db24 <_setenv_r+0x150>
1001db04:	4628      	mov	r0, r5
1001db06:	f7f0 eef0 	blx	1000e8e8 <_realloc_r>
1001db0a:	f8c9 0000 	str.w	r0, [r9]
1001db0e:	b1f8      	cbz	r0, 1001db50 <_setenv_r+0x17c>
1001db10:	ea4f 078a 	mov.w	r7, sl, lsl #2
1001db14:	f10a 0301 	add.w	r3, sl, #1
1001db18:	2200      	movs	r2, #0
1001db1a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
1001db1e:	f8cd a004 	str.w	sl, [sp, #4]
1001db22:	e77f      	b.n	1001da24 <_setenv_r+0x50>
1001db24:	4611      	mov	r1, r2
1001db26:	4628      	mov	r0, r5
1001db28:	2201      	movs	r2, #1
1001db2a:	601a      	str	r2, [r3, #0]
1001db2c:	f7f0 eeb8 	blx	1000e8a0 <_malloc_r>
1001db30:	4683      	mov	fp, r0
1001db32:	b168      	cbz	r0, 1001db50 <_setenv_r+0x17c>
1001db34:	ea4f 078a 	mov.w	r7, sl, lsl #2
1001db38:	f8d9 1000 	ldr.w	r1, [r9]
1001db3c:	463a      	mov	r2, r7
1001db3e:	f7ff fe79 	bl	1001d834 <memcpy>
1001db42:	4658      	mov	r0, fp
1001db44:	f8c9 b000 	str.w	fp, [r9]
1001db48:	e7e4      	b.n	1001db14 <_setenv_r+0x140>
1001db4a:	4682      	mov	sl, r0
1001db4c:	2208      	movs	r2, #8
1001db4e:	e7d3      	b.n	1001daf8 <_setenv_r+0x124>
1001db50:	4628      	mov	r0, r5
1001db52:	f000 f9ed 	bl	1001df30 <__env_unlock>
1001db56:	f04f 33ff 	mov.w	r3, #4294967295
1001db5a:	e7a4      	b.n	1001daa6 <_setenv_r+0xd2>

1001db5c <strchr>:
1001db5c:	b2c9      	uxtb	r1, r1
1001db5e:	b470      	push	{r4, r5, r6}
1001db60:	2900      	cmp	r1, #0
1001db62:	d040      	beq.n	1001dbe6 <strchr+0x8a>
1001db64:	0784      	lsls	r4, r0, #30
1001db66:	d010      	beq.n	1001db8a <strchr+0x2e>
1001db68:	7803      	ldrb	r3, [r0, #0]
1001db6a:	2b00      	cmp	r3, #0
1001db6c:	d068      	beq.n	1001dc40 <strchr+0xe4>
1001db6e:	4299      	cmp	r1, r3
1001db70:	bf18      	it	ne
1001db72:	1c43      	addne	r3, r0, #1
1001db74:	d106      	bne.n	1001db84 <strchr+0x28>
1001db76:	e034      	b.n	1001dbe2 <strchr+0x86>
1001db78:	f813 2b01 	ldrb.w	r2, [r3], #1
1001db7c:	2a00      	cmp	r2, #0
1001db7e:	d05c      	beq.n	1001dc3a <strchr+0xde>
1001db80:	4291      	cmp	r1, r2
1001db82:	d02e      	beq.n	1001dbe2 <strchr+0x86>
1001db84:	079a      	lsls	r2, r3, #30
1001db86:	4618      	mov	r0, r3
1001db88:	d1f6      	bne.n	1001db78 <strchr+0x1c>
1001db8a:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
1001db8e:	6804      	ldr	r4, [r0, #0]
1001db90:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
1001db94:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
1001db98:	ea84 0506 	eor.w	r5, r4, r6
1001db9c:	ea22 0204 	bic.w	r2, r2, r4
1001dba0:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
1001dba4:	ea23 0305 	bic.w	r3, r3, r5
1001dba8:	4313      	orrs	r3, r2
1001dbaa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1001dbae:	d10f      	bne.n	1001dbd0 <strchr+0x74>
1001dbb0:	f850 5f04 	ldr.w	r5, [r0, #4]!
1001dbb4:	ea86 0305 	eor.w	r3, r6, r5
1001dbb8:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
1001dbbc:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
1001dbc0:	ea22 0205 	bic.w	r2, r2, r5
1001dbc4:	ea24 0303 	bic.w	r3, r4, r3
1001dbc8:	4313      	orrs	r3, r2
1001dbca:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1001dbce:	d0ef      	beq.n	1001dbb0 <strchr+0x54>
1001dbd0:	7803      	ldrb	r3, [r0, #0]
1001dbd2:	b923      	cbnz	r3, 1001dbde <strchr+0x82>
1001dbd4:	e034      	b.n	1001dc40 <strchr+0xe4>
1001dbd6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
1001dbda:	2b00      	cmp	r3, #0
1001dbdc:	d030      	beq.n	1001dc40 <strchr+0xe4>
1001dbde:	4299      	cmp	r1, r3
1001dbe0:	d1f9      	bne.n	1001dbd6 <strchr+0x7a>
1001dbe2:	bc70      	pop	{r4, r5, r6}
1001dbe4:	4770      	bx	lr
1001dbe6:	0781      	lsls	r1, r0, #30
1001dbe8:	d00d      	beq.n	1001dc06 <strchr+0xaa>
1001dbea:	7803      	ldrb	r3, [r0, #0]
1001dbec:	2b00      	cmp	r3, #0
1001dbee:	d0f8      	beq.n	1001dbe2 <strchr+0x86>
1001dbf0:	1c43      	adds	r3, r0, #1
1001dbf2:	e002      	b.n	1001dbfa <strchr+0x9e>
1001dbf4:	7802      	ldrb	r2, [r0, #0]
1001dbf6:	2a00      	cmp	r2, #0
1001dbf8:	d0f3      	beq.n	1001dbe2 <strchr+0x86>
1001dbfa:	f013 0f03 	tst.w	r3, #3
1001dbfe:	4618      	mov	r0, r3
1001dc00:	f103 0301 	add.w	r3, r3, #1
1001dc04:	d1f6      	bne.n	1001dbf4 <strchr+0x98>
1001dc06:	6802      	ldr	r2, [r0, #0]
1001dc08:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
1001dc0c:	ea23 0302 	bic.w	r3, r3, r2
1001dc10:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1001dc14:	d108      	bne.n	1001dc28 <strchr+0xcc>
1001dc16:	f850 2f04 	ldr.w	r2, [r0, #4]!
1001dc1a:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
1001dc1e:	ea23 0302 	bic.w	r3, r3, r2
1001dc22:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
1001dc26:	d0f6      	beq.n	1001dc16 <strchr+0xba>
1001dc28:	7803      	ldrb	r3, [r0, #0]
1001dc2a:	2b00      	cmp	r3, #0
1001dc2c:	d0d9      	beq.n	1001dbe2 <strchr+0x86>
1001dc2e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
1001dc32:	2b00      	cmp	r3, #0
1001dc34:	d1fb      	bne.n	1001dc2e <strchr+0xd2>
1001dc36:	bc70      	pop	{r4, r5, r6}
1001dc38:	4770      	bx	lr
1001dc3a:	4610      	mov	r0, r2
1001dc3c:	bc70      	pop	{r4, r5, r6}
1001dc3e:	4770      	bx	lr
1001dc40:	4618      	mov	r0, r3
1001dc42:	bc70      	pop	{r4, r5, r6}
1001dc44:	4770      	bx	lr
1001dc46:	bf00      	nop

1001dc48 <_strdup_r>:
1001dc48:	b570      	push	{r4, r5, r6, lr}
1001dc4a:	4606      	mov	r6, r0
1001dc4c:	4608      	mov	r0, r1
1001dc4e:	460d      	mov	r5, r1
1001dc50:	f000 f80e 	bl	1001dc70 <strlen>
1001dc54:	1c44      	adds	r4, r0, #1
1001dc56:	4630      	mov	r0, r6
1001dc58:	4621      	mov	r1, r4
1001dc5a:	f7f0 ee22 	blx	1000e8a0 <_malloc_r>
1001dc5e:	4606      	mov	r6, r0
1001dc60:	b118      	cbz	r0, 1001dc6a <_strdup_r+0x22>
1001dc62:	4629      	mov	r1, r5
1001dc64:	4622      	mov	r2, r4
1001dc66:	f7ff fde5 	bl	1001d834 <memcpy>
1001dc6a:	4630      	mov	r0, r6
1001dc6c:	bd70      	pop	{r4, r5, r6, pc}
1001dc6e:	bf00      	nop

1001dc70 <strlen>:
1001dc70:	f020 0103 	bic.w	r1, r0, #3
1001dc74:	f010 0003 	ands.w	r0, r0, #3
1001dc78:	f1c0 0000 	rsb	r0, r0, #0
1001dc7c:	f851 3b04 	ldr.w	r3, [r1], #4
1001dc80:	f100 0c04 	add.w	ip, r0, #4
1001dc84:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
1001dc88:	f06f 0200 	mvn.w	r2, #0
1001dc8c:	bf1c      	itt	ne
1001dc8e:	fa22 f20c 	lsrne.w	r2, r2, ip
1001dc92:	4313      	orrne	r3, r2
1001dc94:	f04f 0c01 	mov.w	ip, #1
1001dc98:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
1001dc9c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
1001dca0:	eba3 020c 	sub.w	r2, r3, ip
1001dca4:	ea22 0203 	bic.w	r2, r2, r3
1001dca8:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
1001dcac:	bf04      	itt	eq
1001dcae:	f851 3b04 	ldreq.w	r3, [r1], #4
1001dcb2:	3004      	addeq	r0, #4
1001dcb4:	d0f4      	beq.n	1001dca0 <strlen+0x30>
1001dcb6:	f1c2 0100 	rsb	r1, r2, #0
1001dcba:	ea02 0201 	and.w	r2, r2, r1
1001dcbe:	fab2 f282 	clz	r2, r2
1001dcc2:	f1c2 021f 	rsb	r2, r2, #31
1001dcc6:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
1001dcca:	4770      	bx	lr

1001dccc <strncmp>:
1001dccc:	2a00      	cmp	r2, #0
1001dcce:	d03f      	beq.n	1001dd50 <strncmp+0x84>
1001dcd0:	ea40 0301 	orr.w	r3, r0, r1
1001dcd4:	f013 0303 	ands.w	r3, r3, #3
1001dcd8:	b4f0      	push	{r4, r5, r6, r7}
1001dcda:	d125      	bne.n	1001dd28 <strncmp+0x5c>
1001dcdc:	2a03      	cmp	r2, #3
1001dcde:	d923      	bls.n	1001dd28 <strncmp+0x5c>
1001dce0:	6804      	ldr	r4, [r0, #0]
1001dce2:	680d      	ldr	r5, [r1, #0]
1001dce4:	42ac      	cmp	r4, r5
1001dce6:	d11f      	bne.n	1001dd28 <strncmp+0x5c>
1001dce8:	3a04      	subs	r2, #4
1001dcea:	d036      	beq.n	1001dd5a <strncmp+0x8e>
1001dcec:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
1001dcf0:	ea25 0404 	bic.w	r4, r5, r4
1001dcf4:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
1001dcf8:	d131      	bne.n	1001dd5e <strncmp+0x92>
1001dcfa:	1d07      	adds	r7, r0, #4
1001dcfc:	1d0d      	adds	r5, r1, #4
1001dcfe:	e00d      	b.n	1001dd1c <strncmp+0x50>
1001dd00:	f857 3b04 	ldr.w	r3, [r7], #4
1001dd04:	680e      	ldr	r6, [r1, #0]
1001dd06:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
1001dd0a:	42b3      	cmp	r3, r6
1001dd0c:	ea24 0403 	bic.w	r4, r4, r3
1001dd10:	d10a      	bne.n	1001dd28 <strncmp+0x5c>
1001dd12:	3a04      	subs	r2, #4
1001dd14:	d021      	beq.n	1001dd5a <strncmp+0x8e>
1001dd16:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
1001dd1a:	d116      	bne.n	1001dd4a <strncmp+0x7e>
1001dd1c:	2a03      	cmp	r2, #3
1001dd1e:	4629      	mov	r1, r5
1001dd20:	4638      	mov	r0, r7
1001dd22:	f105 0504 	add.w	r5, r5, #4
1001dd26:	d8eb      	bhi.n	1001dd00 <strncmp+0x34>
1001dd28:	7803      	ldrb	r3, [r0, #0]
1001dd2a:	3a01      	subs	r2, #1
1001dd2c:	780c      	ldrb	r4, [r1, #0]
1001dd2e:	42a3      	cmp	r3, r4
1001dd30:	d007      	beq.n	1001dd42 <strncmp+0x76>
1001dd32:	e00f      	b.n	1001dd54 <strncmp+0x88>
1001dd34:	f810 3f01 	ldrb.w	r3, [r0, #1]!
1001dd38:	3a01      	subs	r2, #1
1001dd3a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
1001dd3e:	42a3      	cmp	r3, r4
1001dd40:	d108      	bne.n	1001dd54 <strncmp+0x88>
1001dd42:	2a00      	cmp	r2, #0
1001dd44:	bf18      	it	ne
1001dd46:	2b00      	cmpne	r3, #0
1001dd48:	d1f4      	bne.n	1001dd34 <strncmp+0x68>
1001dd4a:	2000      	movs	r0, #0
1001dd4c:	bcf0      	pop	{r4, r5, r6, r7}
1001dd4e:	4770      	bx	lr
1001dd50:	4610      	mov	r0, r2
1001dd52:	4770      	bx	lr
1001dd54:	1b18      	subs	r0, r3, r4
1001dd56:	bcf0      	pop	{r4, r5, r6, r7}
1001dd58:	4770      	bx	lr
1001dd5a:	4610      	mov	r0, r2
1001dd5c:	e7fb      	b.n	1001dd56 <strncmp+0x8a>
1001dd5e:	4618      	mov	r0, r3
1001dd60:	e7f9      	b.n	1001dd56 <strncmp+0x8a>
1001dd62:	bf00      	nop

1001dd64 <strncpy>:
1001dd64:	ea40 0301 	orr.w	r3, r0, r1
1001dd68:	f013 0f03 	tst.w	r3, #3
1001dd6c:	b470      	push	{r4, r5, r6}
1001dd6e:	bf0c      	ite	eq
1001dd70:	2301      	moveq	r3, #1
1001dd72:	2300      	movne	r3, #0
1001dd74:	2a03      	cmp	r2, #3
1001dd76:	bf94      	ite	ls
1001dd78:	2300      	movls	r3, #0
1001dd7a:	f003 0301 	andhi.w	r3, r3, #1
1001dd7e:	4606      	mov	r6, r0
1001dd80:	b18b      	cbz	r3, 1001dda6 <strncpy+0x42>
1001dd82:	460b      	mov	r3, r1
1001dd84:	4606      	mov	r6, r0
1001dd86:	4619      	mov	r1, r3
1001dd88:	f853 5b04 	ldr.w	r5, [r3], #4
1001dd8c:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
1001dd90:	ea24 0405 	bic.w	r4, r4, r5
1001dd94:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
1001dd98:	d105      	bne.n	1001dda6 <strncpy+0x42>
1001dd9a:	3a04      	subs	r2, #4
1001dd9c:	f846 5b04 	str.w	r5, [r6], #4
1001dda0:	2a03      	cmp	r2, #3
1001dda2:	4619      	mov	r1, r3
1001dda4:	d8ef      	bhi.n	1001dd86 <strncpy+0x22>
1001dda6:	b1a2      	cbz	r2, 1001ddd2 <strncpy+0x6e>
1001dda8:	780c      	ldrb	r4, [r1, #0]
1001ddaa:	3a01      	subs	r2, #1
1001ddac:	1c73      	adds	r3, r6, #1
1001ddae:	3101      	adds	r1, #1
1001ddb0:	7034      	strb	r4, [r6, #0]
1001ddb2:	b13c      	cbz	r4, 1001ddc4 <strncpy+0x60>
1001ddb4:	b16a      	cbz	r2, 1001ddd2 <strncpy+0x6e>
1001ddb6:	f811 4b01 	ldrb.w	r4, [r1], #1
1001ddba:	3a01      	subs	r2, #1
1001ddbc:	f803 4b01 	strb.w	r4, [r3], #1
1001ddc0:	2c00      	cmp	r4, #0
1001ddc2:	d1f7      	bne.n	1001ddb4 <strncpy+0x50>
1001ddc4:	b12a      	cbz	r2, 1001ddd2 <strncpy+0x6e>
1001ddc6:	441a      	add	r2, r3
1001ddc8:	2100      	movs	r1, #0
1001ddca:	f803 1b01 	strb.w	r1, [r3], #1
1001ddce:	4293      	cmp	r3, r2
1001ddd0:	d1fb      	bne.n	1001ddca <strncpy+0x66>
1001ddd2:	bc70      	pop	{r4, r5, r6}
1001ddd4:	4770      	bx	lr
1001ddd6:	bf00      	nop

1001ddd8 <_strtol_r>:
1001ddd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1001dddc:	f640 64b4 	movw	r4, #3764	; 0xeb4
1001dde0:	b085      	sub	sp, #20
1001dde2:	f2c1 0402 	movt	r4, #4098	; 0x1002
1001dde6:	468b      	mov	fp, r1
1001dde8:	461f      	mov	r7, r3
1001ddea:	9003      	str	r0, [sp, #12]
1001ddec:	6826      	ldr	r6, [r4, #0]
1001ddee:	e000      	b.n	1001ddf2 <_strtol_r+0x1a>
1001ddf0:	4621      	mov	r1, r4
1001ddf2:	460c      	mov	r4, r1
1001ddf4:	f814 5b01 	ldrb.w	r5, [r4], #1
1001ddf8:	1973      	adds	r3, r6, r5
1001ddfa:	785b      	ldrb	r3, [r3, #1]
1001ddfc:	f003 0308 	and.w	r3, r3, #8
1001de00:	f003 08ff 	and.w	r8, r3, #255	; 0xff
1001de04:	2b00      	cmp	r3, #0
1001de06:	d1f3      	bne.n	1001ddf0 <_strtol_r+0x18>
1001de08:	2d2d      	cmp	r5, #45	; 0x2d
1001de0a:	d071      	beq.n	1001def0 <_strtol_r+0x118>
1001de0c:	2d2b      	cmp	r5, #43	; 0x2b
1001de0e:	bf04      	itt	eq
1001de10:	1c8c      	addeq	r4, r1, #2
1001de12:	784d      	ldrbeq	r5, [r1, #1]
1001de14:	f037 0310 	bics.w	r3, r7, #16
1001de18:	d10b      	bne.n	1001de32 <_strtol_r+0x5a>
1001de1a:	fab7 f387 	clz	r3, r7
1001de1e:	2d30      	cmp	r5, #48	; 0x30
1001de20:	ea4f 1353 	mov.w	r3, r3, lsr #5
1001de24:	d069      	beq.n	1001defa <_strtol_r+0x122>
1001de26:	b123      	cbz	r3, 1001de32 <_strtol_r+0x5a>
1001de28:	270a      	movs	r7, #10
1001de2a:	46ba      	mov	sl, r7
1001de2c:	e002      	b.n	1001de34 <_strtol_r+0x5c>
1001de2e:	b103      	cbz	r3, 1001de32 <_strtol_r+0x5a>
1001de30:	2708      	movs	r7, #8
1001de32:	46ba      	mov	sl, r7
1001de34:	f1b8 0f00 	cmp.w	r8, #0
1001de38:	4651      	mov	r1, sl
1001de3a:	9202      	str	r2, [sp, #8]
1001de3c:	bf14      	ite	ne
1001de3e:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
1001de42:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
1001de46:	4660      	mov	r0, ip
1001de48:	f8cd c004 	str.w	ip, [sp, #4]
1001de4c:	f7ff fb86 	bl	1001d55c <__aeabi_uidivmod>
1001de50:	f8dd c004 	ldr.w	ip, [sp, #4]
1001de54:	4660      	mov	r0, ip
1001de56:	4689      	mov	r9, r1
1001de58:	4651      	mov	r1, sl
1001de5a:	f7ff fa51 	bl	1001d300 <__aeabi_uidiv>
1001de5e:	2300      	movs	r3, #0
1001de60:	469c      	mov	ip, r3
1001de62:	9a02      	ldr	r2, [sp, #8]
1001de64:	e00c      	b.n	1001de80 <_strtol_r+0xa8>
1001de66:	454d      	cmp	r5, r9
1001de68:	bfd4      	ite	le
1001de6a:	2100      	movle	r1, #0
1001de6c:	2101      	movgt	r1, #1
1001de6e:	4584      	cmp	ip, r0
1001de70:	bf18      	it	ne
1001de72:	2100      	movne	r1, #0
1001de74:	b9e1      	cbnz	r1, 1001deb0 <_strtol_r+0xd8>
1001de76:	fb0a 5c0c 	mla	ip, sl, ip, r5
1001de7a:	2301      	movs	r3, #1
1001de7c:	f814 5b01 	ldrb.w	r5, [r4], #1
1001de80:	1971      	adds	r1, r6, r5
1001de82:	7849      	ldrb	r1, [r1, #1]
1001de84:	f011 0f04 	tst.w	r1, #4
1001de88:	bf18      	it	ne
1001de8a:	3d30      	subne	r5, #48	; 0x30
1001de8c:	d107      	bne.n	1001de9e <_strtol_r+0xc6>
1001de8e:	f011 0103 	ands.w	r1, r1, #3
1001de92:	d010      	beq.n	1001deb6 <_strtol_r+0xde>
1001de94:	2901      	cmp	r1, #1
1001de96:	bf0c      	ite	eq
1001de98:	2137      	moveq	r1, #55	; 0x37
1001de9a:	2157      	movne	r1, #87	; 0x57
1001de9c:	1a6d      	subs	r5, r5, r1
1001de9e:	42af      	cmp	r7, r5
1001dea0:	dd09      	ble.n	1001deb6 <_strtol_r+0xde>
1001dea2:	4584      	cmp	ip, r0
1001dea4:	bf94      	ite	ls
1001dea6:	2100      	movls	r1, #0
1001dea8:	2101      	movhi	r1, #1
1001deaa:	ea51 73d3 	orrs.w	r3, r1, r3, lsr #31
1001deae:	d0da      	beq.n	1001de66 <_strtol_r+0x8e>
1001deb0:	f04f 33ff 	mov.w	r3, #4294967295
1001deb4:	e7e2      	b.n	1001de7c <_strtol_r+0xa4>
1001deb6:	1c59      	adds	r1, r3, #1
1001deb8:	d00b      	beq.n	1001ded2 <_strtol_r+0xfa>
1001deba:	f1c8 0000 	rsb	r0, r8, #0
1001debe:	ea8c 0000 	eor.w	r0, ip, r0
1001dec2:	4440      	add	r0, r8
1001dec4:	b112      	cbz	r2, 1001decc <_strtol_r+0xf4>
1001dec6:	b98b      	cbnz	r3, 1001deec <_strtol_r+0x114>
1001dec8:	465c      	mov	r4, fp
1001deca:	6014      	str	r4, [r2, #0]
1001decc:	b005      	add	sp, #20
1001dece:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
1001ded2:	9903      	ldr	r1, [sp, #12]
1001ded4:	f1b8 0f00 	cmp.w	r8, #0
1001ded8:	f04f 0322 	mov.w	r3, #34	; 0x22
1001dedc:	bf14      	ite	ne
1001dede:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
1001dee2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
1001dee6:	600b      	str	r3, [r1, #0]
1001dee8:	2a00      	cmp	r2, #0
1001deea:	d0ef      	beq.n	1001decc <_strtol_r+0xf4>
1001deec:	3c01      	subs	r4, #1
1001deee:	e7ec      	b.n	1001deca <_strtol_r+0xf2>
1001def0:	1c8c      	adds	r4, r1, #2
1001def2:	784d      	ldrb	r5, [r1, #1]
1001def4:	f04f 0801 	mov.w	r8, #1
1001def8:	e78c      	b.n	1001de14 <_strtol_r+0x3c>
1001defa:	7821      	ldrb	r1, [r4, #0]
1001defc:	f001 01df 	and.w	r1, r1, #223	; 0xdf
1001df00:	2958      	cmp	r1, #88	; 0x58
1001df02:	d194      	bne.n	1001de2e <_strtol_r+0x56>
1001df04:	2710      	movs	r7, #16
1001df06:	7865      	ldrb	r5, [r4, #1]
1001df08:	46ba      	mov	sl, r7
1001df0a:	3402      	adds	r4, #2
1001df0c:	e792      	b.n	1001de34 <_strtol_r+0x5c>
1001df0e:	bf00      	nop

1001df10 <strtol>:
1001df10:	b430      	push	{r4, r5}
1001df12:	f640 64b0 	movw	r4, #3760	; 0xeb0
1001df16:	460d      	mov	r5, r1
1001df18:	f2c1 0402 	movt	r4, #4098	; 0x1002
1001df1c:	4613      	mov	r3, r2
1001df1e:	4601      	mov	r1, r0
1001df20:	462a      	mov	r2, r5
1001df22:	6820      	ldr	r0, [r4, #0]
1001df24:	bc30      	pop	{r4, r5}
1001df26:	f7ff bf57 	b.w	1001ddd8 <_strtol_r>
1001df2a:	bf00      	nop

1001df2c <__env_lock>:
1001df2c:	4770      	bx	lr
1001df2e:	bf00      	nop

1001df30 <__env_unlock>:
1001df30:	4770      	bx	lr
1001df32:	bf00      	nop

1001df34 <__errno>:
1001df34:	f640 63b0 	movw	r3, #3760	; 0xeb0
1001df38:	f2c1 0302 	movt	r3, #4098	; 0x1002
1001df3c:	6818      	ldr	r0, [r3, #0]
1001df3e:	4770      	bx	lr

1001df40 <_findenv_r>:
1001df40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
1001df44:	f640 68b8 	movw	r8, #3768	; 0xeb8
1001df48:	f2c1 0802 	movt	r8, #4098	; 0x1002
1001df4c:	460e      	mov	r6, r1
1001df4e:	4617      	mov	r7, r2
1001df50:	4681      	mov	r9, r0
1001df52:	f7ff ffeb 	bl	1001df2c <__env_lock>
1001df56:	f8d8 5000 	ldr.w	r5, [r8]
1001df5a:	b1fd      	cbz	r5, 1001df9c <_findenv_r+0x5c>
1001df5c:	7833      	ldrb	r3, [r6, #0]
1001df5e:	4634      	mov	r4, r6
1001df60:	2b3d      	cmp	r3, #61	; 0x3d
1001df62:	bf18      	it	ne
1001df64:	2b00      	cmpne	r3, #0
1001df66:	d005      	beq.n	1001df74 <_findenv_r+0x34>
1001df68:	f814 3f01 	ldrb.w	r3, [r4, #1]!
1001df6c:	2b3d      	cmp	r3, #61	; 0x3d
1001df6e:	bf18      	it	ne
1001df70:	2b00      	cmpne	r3, #0
1001df72:	d1f9      	bne.n	1001df68 <_findenv_r+0x28>
1001df74:	2b3d      	cmp	r3, #61	; 0x3d
1001df76:	d011      	beq.n	1001df9c <_findenv_r+0x5c>
1001df78:	6828      	ldr	r0, [r5, #0]
1001df7a:	1ba4      	subs	r4, r4, r6
1001df7c:	b170      	cbz	r0, 1001df9c <_findenv_r+0x5c>
1001df7e:	4631      	mov	r1, r6
1001df80:	4622      	mov	r2, r4
1001df82:	f7ff fea3 	bl	1001dccc <strncmp>
1001df86:	b928      	cbnz	r0, 1001df94 <_findenv_r+0x54>
1001df88:	682b      	ldr	r3, [r5, #0]
1001df8a:	eb03 0a04 	add.w	sl, r3, r4
1001df8e:	5d1b      	ldrb	r3, [r3, r4]
1001df90:	2b3d      	cmp	r3, #61	; 0x3d
1001df92:	d009      	beq.n	1001dfa8 <_findenv_r+0x68>
1001df94:	f855 0f04 	ldr.w	r0, [r5, #4]!
1001df98:	2800      	cmp	r0, #0
1001df9a:	d1f0      	bne.n	1001df7e <_findenv_r+0x3e>
1001df9c:	4648      	mov	r0, r9
1001df9e:	f7ff ffc7 	bl	1001df30 <__env_unlock>
1001dfa2:	2000      	movs	r0, #0
1001dfa4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
1001dfa8:	f8d8 3000 	ldr.w	r3, [r8]
1001dfac:	4648      	mov	r0, r9
1001dfae:	1aed      	subs	r5, r5, r3
1001dfb0:	10ad      	asrs	r5, r5, #2
1001dfb2:	603d      	str	r5, [r7, #0]
1001dfb4:	f7ff ffbc 	bl	1001df30 <__env_unlock>
1001dfb8:	f10a 0001 	add.w	r0, sl, #1
1001dfbc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

1001dfc0 <__fsym_list_mem>:
1001dfc0:	03d8 1002 03e4 1002 75dc 1000               .........u..

1001dfcc <__fsym_hello>:
1001dfcc:	0404 1002 040c 1002 2094 1001               ......... ..

1001dfd8 <__fsym_version>:
1001dfd8:	041c 1002 0424 1002 20b4 1001               ....$.... ..

1001dfe4 <__fsym___cmd_version>:
1001dfe4:	0448 1002 0458 1002 20b4 1001               H...X.... ..

1001dff0 <__fsym_list_thread>:
1001dff0:	047c 1002 0488 1002 2284 1001               |........"..

1001dffc <__fsym___cmd_list_thread>:
1001dffc:	0494 1002 04a8 1002 2284 1001               ........."..

1001e008 <__fsym_list_sem>:
1001e008:	04b4 1002 04c0 1002 2454 1001               ........T$..

1001e014 <__fsym___cmd_list_sem>:
1001e014:	04dc 1002 04ec 1002 2454 1001               ........T$..

1001e020 <__fsym_list_event>:
1001e020:	0508 1002 0514 1002 2578 1001               ........x%..

1001e02c <__fsym___cmd_list_event>:
1001e02c:	052c 1002 0540 1002 2578 1001               ,...@...x%..

1001e038 <__fsym_list_mutex>:
1001e038:	0558 1002 0564 1002 265c 1001               X...d...\&..

1001e044 <__fsym___cmd_list_mutex>:
1001e044:	057c 1002 0590 1002 265c 1001               |.......\&..

1001e050 <__fsym_list_mailbox>:
1001e050:	05a8 1002 05b8 1002 27c8 1001               .........'..

1001e05c <__fsym___cmd_list_mailbox>:
1001e05c:	05d0 1002 05e4 1002 27c8 1001               .........'..

1001e068 <__fsym_list_msgqueue>:
1001e068:	05fc 1002 060c 1002 2914 1001               .........)..

1001e074 <__fsym___cmd_list_msgqueue>:
1001e074:	062c 1002 0640 1002 2914 1001               ,...@....)..

1001e080 <__fsym_list_mempool>:
1001e080:	0660 1002 0670 1002 2a64 1001               `...p...d*..

1001e08c <__fsym___cmd_list_mempool>:
1001e08c:	068c 1002 06a0 1002 2a64 1001               ........d*..

1001e098 <__fsym_list_timer>:
1001e098:	06bc 1002 06c8 1002 2b68 1001               ........h+..

1001e0a4 <__fsym___cmd_list_timer>:
1001e0a4:	06e0 1002 06f4 1002 2b68 1001               ........h+..

1001e0b0 <__fsym_list_device>:
1001e0b0:	070c 1002 0718 1002 2c6c 1001               ........l,..

1001e0bc <__fsym___cmd_list_device>:
1001e0bc:	0730 1002 0744 1002 2c6c 1001               0...D...l,..

1001e0c8 <__fsym_list>:
1001e0c8:	075c 1002 0764 1002 2c8c 1001               \...d....,..

1001e0d4 <__fsym___cmd_ps>:
1001e0d4:	07a4 1002 07b0 1002 33e0 1001               .........3..

1001e0e0 <__fsym___cmd_time>:
1001e0e0:	07cc 1002 07d8 1002 3408 1001               .........4..

1001e0ec <__fsym___cmd_free>:
1001e0ec:	07f4 1002 0800 1002 3430 1001               ........04..

1001e0f8 <__fsym___cmd_exit>:
1001e0f8:	0828 1002 0834 1002 347c 1001               (...4...|4..

1001e104 <__fsym_msh>:
1001e104:	0854 1002 0858 1002 34b4 1001               T...X....4..

1001e110 <__fsym___cmd_help>:
1001e110:	086c 1002 0878 1002 34e0 1001               l...x....4..

1001e11c <__fsymtab_end>:
1001e11c:	10020780 	.word	0x10020780
1001e120:	10020788 	.word	0x10020788
1001e124:	00000009 	.word	0x00000009
1001e128:	10029d68 	.word	0x10029d68

1001e12c <__rt_init_rti_start>:
1001e12c:	10000d2c                                ,...

1001e130 <__rt_init_rt_hw_timer_init>:
1001e130:	10000248                                H...

1001e134 <__rt_init_rt_hw_uart_init>:
1001e134:	100009e4                                ....

1001e138 <__rt_init_rti_board_end>:
1001e138:	10000d48                                H...

1001e13c <__rt_init_finsh_system_init>:
1001e13c:	10011ed0                                ....

1001e140 <__rt_init_libc_system_init>:
1001e140:	1000e3ac                                ....

1001e144 <__rt_init_rti_end>:
1001e144:	10000d64                                d...
